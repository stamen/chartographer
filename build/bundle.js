
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$4() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$4;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$3() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$4,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$4;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.48.0' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function ascending$3(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function bisector(f) {
      let compare1, compare2, delta;

      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We can’t do this
      // for a comparator (except for specific, known comparators) because we can’t
      // tell if the comparator is symmetric, and an asymmetric comparator can’t be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending$3;
        compare2 = (d, x) => ascending$3(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending$3 || f === descending$2 ? f : zero$1;
        compare2 = f;
        delta = f;
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function zero$1() {
      return 0;
    }

    function number$4(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector(ascending$3);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number$4).center;
    var bisect = bisectRight;

    function blur(values, r) {
      if (!((r = +r) >= 0)) throw new RangeError("invalid r");
      let length = values.length;
      if (!((length = Math.floor(length)) >= 0)) throw new RangeError("invalid length");
      if (!length || !r) return values;
      const blur = blurf(r);
      const temp = values.slice();
      blur(values, temp, 0, length, 1);
      blur(temp, values, 0, length, 1);
      blur(values, temp, 0, length, 1);
      return values;
    }

    const blur2 = Blur2(blurf);

    const blurImage = Blur2(blurfImage);

    function Blur2(blur) {
      return function(data, rx, ry = rx) {
        if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
        if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
        let {data: values, width, height} = data;
        if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
        if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
        if (!width || !height || (!rx && !ry)) return data;
        const blurx = rx && blur(rx);
        const blury = ry && blur(ry);
        const temp = values.slice();
        if (blurx && blury) {
          blurh(blurx, temp, values, width, height);
          blurh(blurx, values, temp, width, height);
          blurh(blurx, temp, values, width, height);
          blurv(blury, values, temp, width, height);
          blurv(blury, temp, values, width, height);
          blurv(blury, values, temp, width, height);
        } else if (blurx) {
          blurh(blurx, values, temp, width, height);
          blurh(blurx, temp, values, width, height);
          blurh(blurx, values, temp, width, height);
        } else if (blury) {
          blurv(blury, values, temp, width, height);
          blurv(blury, temp, values, width, height);
          blurv(blury, values, temp, width, height);
        }
        return data;
      };
    }

    function blurh(blur, T, S, w, h) {
      for (let y = 0, n = w * h; y < n;) {
        blur(T, S, y, y += w, 1);
      }
    }

    function blurv(blur, T, S, w, h) {
      for (let x = 0, n = w * h; x < w; ++x) {
        blur(T, S, x, x + n, w);
      }
    }

    function blurfImage(radius) {
      const blur = blurf(radius);
      return (T, S, start, stop, step) => {
        start <<= 2, stop <<= 2, step <<= 2;
        blur(T, S, start + 0, stop + 0, step);
        blur(T, S, start + 1, stop + 1, step);
        blur(T, S, start + 2, stop + 2, step);
        blur(T, S, start + 3, stop + 3, step);
      };
    }

    // Given a target array T, a source array S, sets each value T[i] to the average
    // of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,
    // for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between
    // S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an
    // integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted
    // according to r - ⌊radius⌋.
    function blurf(radius) {
      const radius0 = Math.floor(radius);
      if (radius0 === radius) return bluri(radius);
      const t = radius - radius0;
      const w = 2 * radius + 1;
      return (T, S, start, stop, step) => { // stop must be aligned!
        if (!((stop -= step) >= start)) return; // inclusive stop
        let sum = radius0 * S[start];
        const s0 = step * radius0;
        const s1 = s0 + step;
        for (let i = start, j = start + s0; i < j; i += step) {
          sum += S[Math.min(stop, i)];
        }
        for (let i = start, j = stop; i <= j; i += step) {
          sum += S[Math.min(stop, i + s0)];
          T[i] = (sum + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
          sum -= S[Math.max(start, i - s0)];
        }
      };
    }

    // Like blurf, but optimized for integer radius.
    function bluri(radius) {
      const w = 2 * radius + 1;
      return (T, S, start, stop, step) => { // stop must be aligned!
        if (!((stop -= step) >= start)) return; // inclusive stop
        let sum = radius * S[start];
        const s = step * radius;
        for (let i = start, j = start + s; i < j; i += step) {
          sum += S[Math.min(stop, i)];
        }
        for (let i = start, j = stop; i <= j; i += step) {
          sum += S[Math.min(stop, i + s)];
          T[i] = sum / w;
          sum -= S[Math.max(start, i - s)];
        }
      };
    }

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$3(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$2(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$3);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function variance(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$9(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$9, identity$9, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$9, keys);
    }

    function flatten$1(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$1(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$1(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$9, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$4(values, ...keys) {
      return nest(values, identity$9, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f] = F;
      if ((f && f.length !== 2) || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascendingDefined(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascendingDefined(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(compareDefined(f));
    }

    function compareDefined(compare = ascending$3) {
      if (compare === ascending$3) return ascendingDefined;
      if (typeof compare !== "function") throw new TypeError("compare is not a function");
      return (a, b) => {
        const x = compare(a, b);
        if (x || x === 0) return x;
        return (compare(b, b) === 0) - (compare(a, a) === 0);
      };
    }

    function ascendingDefined(a, b) {
      return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length !== 2
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk))))
        .map(([key]) => key);
    }

    var array$7 = Array.prototype;

    var slice$3 = array$7.slice;

    function constant$b(x) {
      return () => x;
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
    }

    function bin() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            step,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the domain is aligned with the first tick (which it will by
          // default), then we can use quantization rather than bisection to bin
          // values, which is substantially faster.
          if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);

          // If the last threshold is coincident with the domain’s upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we don’t
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        if (isFinite(step)) {
          if (step > 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
              }
            }
          } else if (step < 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                const j = Math.floor((x0 - x) * step);
                bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
              }
            }
          }
        } else {
          for (i = 0; i < n; ++i) {
            if ((x = values[i]) != null && x0 <= x && x <= x1) {
              bins[bisect(tz, x, 0, m)].push(data[i]);
            }
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$b([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$b(slice$3.call(_)) : constant$b(_), histogram) : threshold;
      };

      return histogram;
    }

    function max$3(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function min$2(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = array.length - 1, compare) {
      compare = compare === undefined ? ascendingDefined : compareDefined(compare);

      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }

      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function greatest(values, compare = ascending$3) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, maxValue) > 0
              : ascending$3(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return min$2(values);
      if (p >= 1) return max$3(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)),
          value1 = min$2(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$4) {
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileIndex(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return minIndex(values);
      if (p >= 1) return maxIndex(values);
      var n,
          i = Math.floor((n - 1) * p),
          order = (i, j) => ascendingDefined(values[i], values[j]),
          index = quickselect(Uint32Array.from(values, (_, i) => i), i, 0, n - 1, order);
      return greatest(index.subarray(0, i + 1), i => values[i]);
    }

    function thresholdFreedmanDiaconis(values, min, max) {
      return Math.ceil((max - min) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * Math.pow(count$1(values), -1 / 3)));
    }

    function thresholdScott(values, min, max) {
      return Math.ceil((max - min) * Math.cbrt(count$1(values)) / (3.49 * deviation(values)));
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function medianIndex(values, valueof) {
      return quantileIndex(values, 0.5, valueof);
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge(arrays) {
      return Array.from(flatten(arrays));
    }

    function mode(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$2(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function rank(values, valueof = ascending$3) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      let V = Array.from(values);
      const R = new Float64Array(V.length);
      if (valueof.length !== 2) V = V.map(valueof), valueof = ascending$3;
      const compareIndex = (i, j) => valueof(V[i], V[j]);
      let k, r;
      Uint32Array
        .from(V, (_, i) => i)
        .sort(valueof === ascending$3 ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex))
        .forEach((j, i) => {
          const c = compareIndex(j, k === undefined ? j : k);
          if (c >= 0) {
            if (k === undefined || c > 0) k = j, r = i;
            R[j] = r;
          } else {
            R[j] = NaN;
          }
        });
      return R;
    }

    function least(values, compare = ascending$3) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, minValue) < 0
              : ascending$3(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$3) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatestIndex(values, compare = ascending$3) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$1 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$2(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$2(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$2(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$1(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$1(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference(values, ...others) {
      values = new InternSet(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint(values, other) {
      const iterator = other[Symbol.iterator](), set = new InternSet();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function intersection(values, ...others) {
      values = new InternSet(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function set$2(values) {
      return values instanceof InternSet ? values : new InternSet(values);
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        const io = intern(o);
        if (set.has(io)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          const ivalue = intern(value);
          set.add(ivalue);
          if (Object.is(io, ivalue)) break;
        }
      }
      return true;
    }

    function intern(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union(...others) {
      const set = new InternSet();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$6 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$3(scale) {
      return d => +scale(d);
    }

    function center$1(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$1 : number$3)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$3 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$2(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$3, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we don’t ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$6(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$6(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter$1 = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter$1.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$a(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isn’t worried about “live” collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // don’t; we’d rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$6(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$9 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$9(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$9(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color$3() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
        reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
        reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
        reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
        reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
        reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color$3, color$2, {
      copy(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHex8() {
      return this.rgb().formatHex8();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color$2(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba$1(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba$1((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba$1(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color$3)) o = color$2(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color$3, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }

    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }

    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }

    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }

    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }

    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color$3)) o = color$2(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend(Color$3, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));

    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }

    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn$1 = 0.96422,
        Yn$1 = 1,
        Zn$1 = 0.82521,
        t0$2 = 4 / 29,
        t1$2 = 6 / 29,
        t2$1 = 3 * t1$2 * t1$2,
        t3$1 = t1$2 * t1$2 * t1$2;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab$1((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn$1), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab$1((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn$1);
        z = xyz2lab$1((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn$1);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$2(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$2, extend(Color$3, {
      brighter(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn$1 * lab2xyz$1(x);
        y = Yn$1 * lab2xyz$1(y);
        z = Zn$1 * lab2xyz$1(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab$1(t) {
      return t > t3$1 ? Math.pow(t, 1 / 3) : t / t2$1 + t0$2;
    }

    function lab2xyz$1(t) {
      return t > t1$2 ? t * t * t : t2$1 * (t - t0$2);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$3(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$3, extend(Color$3, {
      brighter(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B$1 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$1,
        BC_DA = B$1 * C - D$1 * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend(Color$3, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B$1 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$8 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$8(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$8(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$5(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$3(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$3(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$3(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$8(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color$2(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color$2 ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$7 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$1 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0 ≅ u1.
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab$1(start, end) {
      var l = nogamma((start = lab$2(start)).l, (end = lab$2(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl$1(hue) {
      return function(start, end) {
        var h = hue((start = hcl$3(start)).h, (end = hcl$3(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$2 = hcl$1(hue$1);
    var hclLong = hcl$1(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$3;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get$1(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get$1(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get$1(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get$1(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get$1(node, id).value[name];
      };
    }

    function interpolate$2(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color$2 ? interpolateRgb
          : (c = color$2(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$2;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get$1(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get$1(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get$1(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get$1(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$2;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get$1(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition$1(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition$1.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$1 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$5 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$7 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$3, max: max$2, min: min$1} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name “__brush” rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$3(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$2(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$2(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$3(point.cur[0] - point[0]) > abs$3(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$2(W - w0, min$1(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$2(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$2(W, min$1(E, points[0][0])), e1 = max$2(W, min$1(E, points[1][0])), signX = 1;
                if (signY) n1 = max$2(N, min$1(S, points[0][1])), s1 = max$2(N, min$1(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$2(W - w0, min$1(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$2(W - e0, min$1(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$2(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$2(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$2(W, min$1(E, w0 - dx * signX)), e1 = max$2(W, min$1(E, e0 + dx * signX));
              if (signY) n1 = max$2(N, min$1(S, n0 - dy * signY)), s1 = max$2(N, min$1(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$7(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$2 = Math.abs;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$4 = pi$3 * 2;
    var max$1 = Math.max;
    var epsilon$5 = 1e-12;

    function range$1(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$1(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$1(0, tau$4 - padAngle * n) / k;
        dx = k ? padAngle : tau$4 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$1(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$1(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$2 = Math.PI,
        tau$3 = 2 * pi$2,
        epsilon$4 = 1e-6,
        tauEpsilon = tau$3 - epsilon$4;

    function Path$1() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path$1;
    }

    Path$1.prototype = path.prototype = {
      constructor: Path$1,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$4));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$4) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$3 + tau$3;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$4) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    var slice$2 = Array.prototype.slice;

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$2.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        if (ap > epsilon$5) {
          if (abs$2(sa1 - sa0) > ap * 2 + epsilon$5) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$2(ta1 - ta0) > ap * 2 + epsilon$5) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$2(sa0), sr * sin$2(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$2(ta0), tr2 * sin$2(ta0));
            context.lineTo(tr * cos$2(ta2), tr * sin$2(ta2));
            context.lineTo(tr2 * cos$2(ta1), tr2 * sin$2(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$2(sa0), sr * sin$2(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$4 = Array.prototype;

    var slice$1 = array$4.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$5 = x => () => x;

    function contains$2(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$2() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function Contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values), ts = tickStep(e[0], e[1], tz);
          tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        var polygons = [],
            holes = [];

        isorings(values, value, function(ring) {
          smooth(ring, values, value);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          t2 = values[y * dx] >= value;
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v0,
              v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          if (y > 0 && y < dy && yt === y) {
            v0 = values[(yt - 1) * dx + xt];
            point[1] = y + (value - v0) / (v1 - v0) - 0.5;
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$2, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$5(20);

      function grid(data) {
        var values = new Float32Array(n * m),
            pow2k = Math.pow(2, -k),
            i = -1;

        for (const d of data) {
          var xi = (x(d, ++i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        }

        blur2({data: values, width: n, height: m}, r * pow2k);
        return values;
      }

      function density(data) {
        var values = grid(data),
            tz = threshold(values),
            pow4k = Math.pow(2, 2 * k);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          tz = ticks(Number.MIN_VALUE, max$3(values) / pow4k, tz);
        }

        return Contours()
            .size([n, m])
            .thresholds(tz.map(d => d * pow4k))
          (values)
            .map((c, i) => (c.value = +tz[i], transform(c)));
      }

      density.contours = function(data) {
        var values = grid(data),
            contours = Contours().size([n, m]),
            pow4k = Math.pow(2, 2 * k),
            contour = value => {
              value = +value;
              var c = transform(contours.contour(values, value * pow4k));
              c.value = value; // preserve exact threshold value
              return c;
            };
        Object.defineProperty(contour, "max", {get: () => max$3(values) / pow4k});
        return contour;
      };

      function transform(geometry) {
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$5(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();
      };

      return density;
    }

    const epsilon$3 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$1(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
    const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
    const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$1(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$1(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$1(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let minDist = Infinity;
            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0; i < n; i++) {
                const d = dist$1(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            minDist = Infinity;

            // find the point closest to the seed
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist$1(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) {
                        hull[j++] = id;
                        d0 = this._dists[id];
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist$1(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist$1(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$2 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // degenerate case (collinear diagram)
            // almost equal points (degenerate triangle)
            // the circumcenter is at the infinity, in a
            // direction that is:
            // 1. orthogonal to the halfedge.
            let a = 1e9;
            // 2. points away from the center; since the list of triangles starts
            // in the center, the first point of the first triangle
            // will be our reference
            const r = triangles[0] * 2;
            a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] == cj[aj]
              && ci[ai + 1] == cj[aj + 1]
              && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
              && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
              ) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points);
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k]
            || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
              P.splice(j, 2), i -= 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
    }

    const tau$2 = 2 * Math.PI, pow$2 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$2(x - points[i * 2], 2) + pow$2(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$2(x - points[t * 2], 2) + pow$2(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$2(x - points[e * 2], 2) + pow$2(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$2);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries don’t change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isn’t necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$4(d) {
      return d.x + d.vx;
    }

    function y$3(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$4, y$3).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$3(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$4(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$2 = 1664525;
    const c$4 = 1013904223;
    const m$1 = 4294967296; // 2^32

    function lcg$2() {
      let s = 1;
      return () => (s = (a$2 * s + c$4) % m$1) / m$1;
    }

    function x$3(d) {
      return d.x;
    }

    function y$2(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$2();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$4(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$3, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$4(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$4(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$2(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$1(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$6(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "−" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format$1;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format$1 = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot = Math.hypot;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$1() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = new Adder();

    // hello?

    var areaSum$1 = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$1;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnoli’s
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1 = new Adder();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range;

    var boundsStream$2 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$2.point = boundsRingPoint;
        boundsStream$2.lineStart = boundsRingStart;
        boundsStream$2.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$2.point = boundsPoint$1;
        boundsStream$2.lineStart = boundsLineStart;
        boundsStream$2.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$1) phi1 = 90;
        else if (deltaSum < -epsilon$1) phi0 = -90;
        range[0] = lambda0$1, range[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$2.point = linePoint;
    }

    function boundsLineEnd() {
      range[0] = lambda0$1, range[1] = lambda1;
      boundsStream$2.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$1) lambda0$1 = -(lambda1 = 180);
      range[0] = lambda0$1, range[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$2);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$1,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder();
      Y2$1 = new Adder();
      Z2$1 = new Adder();
      geoStream(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$1) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / m) * degrees];
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
    }

    function circle$2() {
      var center = constant$3([0, 0]),
          radius = constant$3(90),
          precision = constant$3(6),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$3([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$3(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$3(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$1,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$1 && abs$1(a[1] - b[1]) < epsilon$1;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$1;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$2(subject);
      link$2(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$2(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$1(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$1;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$1;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the point’s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$1 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$1) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$1
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$1) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$1; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$1,
            meridian = polar || delta < epsilon$1;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$1,
      point: noop$1,
      lineStart: lengthLineStart,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1 = new Adder();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$1(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$2(y0, y1 - epsilon$1, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$2(x0, x1 - epsilon$1, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$2(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$2(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$2(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$1; }).map(x))
            .concat(range$2(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$1; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
          .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate$1(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$5 = x => x;

    var areaSum = new Adder(),
        areaRingSum = new Adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var pathArea = areaStream;

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    var boundsStream$1 = boundsStream;

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    var pathCentroid = centroidStream;

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$1
    };

    var lengthSum = new Adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$1,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$1;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    var pathMeasure = lengthStream;

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function index$2(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(pathArea));
        return pathArea.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(pathMeasure));
        return pathMeasure.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(pathCentroid));
        return pathCentroid.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$1 || abs$1(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection$1(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$1) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960×500. The projection also works quite well at 960×600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$1, y + 0.120 * k + epsilon$1], [x - 0.214 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$1, y + 0.166 * k + epsilon$1], [x - 0.115 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$1(x),
            cy = cos$1(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$1(x),
          k * sin$1(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection$1(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$1(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection$1(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$1);
    }

    function mercatorProjection(project) {
      var m = projection$1(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$1) y = -halfPi$1 + epsilon$1; }
        else { if (y > halfPi$1 - epsilon$1) y = halfPi$1 - epsilon$1; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$1(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection$1(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$1) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin$1(sin$1(l) / M)
      ];
    };

    function equalEarth() {
      return projection$1(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k = cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection$1(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$1 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection$1(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection$1(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$1);
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection$1(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Don’t include the root’s parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$1(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$1(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$1.prototype = hierarchy.prototype = {
      constructor: Node$1,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function array$3(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle(array, random) {
      let m = array.length,
          t,
          i;

      while (m) {
        i = random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      return packEncloseRandom(circles, lcg$1());
    }

    function packEncloseRandom(circles, random) {
      var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packSiblingsRandom(circles, random) {
      if (!(n = (circles = array$3(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node(a), b = new Node(b), c = new Node(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle…
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // “Closeness” is determined by linear distance along the front-chain.
        // “Ahead” or “behind” is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = packEncloseRandom(a, random);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packSiblingsRandom(circles, lcg$1());
      return circles;
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        const random = lcg$1();
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildrenRandom(padding, 0.5, random))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildrenRandom(constantZero, 1, random))
              .eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$2(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildrenRandom(padding, k, random) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packSiblingsRandom(children, random);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {},
        imputed = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId,
          path;

      function stratify(data) {
        var nodes = Array.from(data),
            currentId = id,
            currentParentId = parentId,
            n,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        if (path != null) {
          const I = nodes.map((d, i) => normalize$1(path(d, i, data)));
          const P = I.map(parentof);
          const S = new Set(I).add("");
          for (const i of P) {
            if (!S.has(i)) {
              S.add(i);
              I.push(i);
              P.push(parentof(i));
              nodes.push(imputed);
            }
          }
          currentId = (_, i) => I[i];
          currentParentId = (_, i) => P[i];
        }

        for (i = 0, n = nodes.length; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$1(d);
          if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");

        // When imputing internal nodes, only introduce roots if needed.
        // Then replace the imputed marker data with null.
        if (path != null) {
          while (root.data === imputed && root.children.length === 1) {
            root = root.children[0], --n;
          }
          for (let i = nodes.length - 1; i >= 0; --i) {
            node = nodes[i];
            if (node.data !== imputed) break;
            node.data = null;
          }
        }

        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = optional(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = optional(x), stratify) : parentId;
      };

      stratify.path = function(x) {
        return arguments.length ? (path = optional(x), stratify) : path;
      };

      return stratify;
    }

    // To normalize a path, we coerce to a string, strip the trailing slash if any
    // (as long as the trailing slash is not immediately preceded by another slash),
    // and add leading slash if missing.
    function normalize$1(path) {
      path = `${path}`;
      let i = path.length;
      if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);
      return path[0] === "/" ? path : `/${path}`;
    }

    // Walk backwards to find the first slash that is not the leading slash, e.g.:
    // "/foo/bar" ⇥ "/foo", "/foo" ⇥ "/", "/" ↦ "". (The root is special-cased
    // because the id of the root must be a truthy value.)
    function parentof(path) {
      let i = path.length;
      if (i < 2) return "";
      while (--i > 1) if (slash(path, i)) break;
      return path.slice(0, i);
    }

    // Slashes can be escaped; to determine whether a slash is a path delimiter, we
    // count the number of preceding backslashes escaping the forward slash: an odd
    // number indicates an escaped forward slash.
    function slash(path, i) {
      if (path[i] === "/") {
        let k = 0;
        while (i > 0 && path[--i] === "\\") ++k;
        if ((k & 1) === 0) return true;
      }
      return false;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$1.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.’s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$2(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$2(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$2(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$2(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$2(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$2(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$4() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$2(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$3,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$2), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format$1(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$2), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$2) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : x => Math.pow(base, x);
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), x => Math.log(x) / base);
    }

    function reflect(f) {
      return (x, k) => -f(-x, k);
    }

    function loggish(transform) {
      const scale = transform(transformLog, transformExp);
      const domain = scale.domain;
      let base = 10;
      let logs;
      let pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = count => {
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;

        if (r) ([u, v] = [v, u]);

        let i = logs(u);
        let j = logs(v);
        let k;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1; k < base; ++k) {
              t = i < 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1; k >= 1; --k) {
              t = i > 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
      };

      scale.tickFormat = (count, specifier) => {
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
          specifier = format$1(specifier);
        }
        if (count === Infinity) return specifier;
        const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return d => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = () => {
        return domain(nice(domain(), {
          floor: x => pows(Math.floor(logs(x))),
          ceil: x => pows(Math.ceil(logs(x)))
        }));
      };

      return scale;
    }

    function log() {
      const scale = loggish(transformer$2()).domain([1, 10]);
      scale.copy = () => copy$1(scale, log()).base(scale.base());
      initRange.apply(scale, arguments);
      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function square$1(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$1(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$2)).map(square$1)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    var t0$1 = new Date,
        t1$1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0$1.setTime(+start), t1$1.setTime(+end);
          floori(t0$1), floori(t1$1);
          return Math.floor(count(t0$1, t1$1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var millisecond$1 = millisecond;
    var milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var utcSecond = second;
    var seconds = second.range;

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });

    var timeMinute = minute;
    var minutes = minute.range;

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });

    var timeHour = hour;
    var hours = hour.range;

    var day = newInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );

    var timeDay = day;
    var days = day.range;

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var timeMonth = month;
    var months = month.range;

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var timeYear = year;
    var years = year.range;

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcMinute$1 = utcMinute;
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcHour$1 = utcHour;
    var utcHours = utcHour.range;

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    var utcDay$1 = utcDay;
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcMonth$1 = utcMonth;
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    var utcYear$1 = utcYear;
    var utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [utcSecond,  1,      durationSecond],
        [utcSecond,  5,  5 * durationSecond],
        [utcSecond, 15, 15 * durationSecond],
        [utcSecond, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond$1.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay$1.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + timeDay.count(timeYear(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(timeYear(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(timeYear(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    var formatIso$1 = formatIso;

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var parseIso$1 = parseIso;

    function date(t) {
      return new Date(t);
    }

    function number$1(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number$1)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$3);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$3);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$1(x) {
      return function constant() {
        return x;
      };
    }

    const abs = Math.abs;
    const atan2 = Math.atan2;
    const cos = Math.cos;
    const max = Math.max;
    const min = Math.min;
    const sin = Math.sin;
    const sqrt = Math.sqrt;

    const epsilon = 1e-12;
    const pi = Math.PI;
    const halfPi = pi / 2;
    const tau = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$1(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau - epsilon) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice = Array.prototype.slice;

    function array$2(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x$1(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function line(x, y$1) {
      var defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x = typeof x === "function" ? x : (x === undefined) ? x$1 : constant$1(x);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant$1(y$1);

      function line(data) {
        var i,
            n = (data = array$2(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$1(+_), line) : x;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area(x0, y0, y1) {
      var x1 = null,
          defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x$1 : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array$2(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$1(0),
          endAngle = constant$1(tau),
          padAngle = constant$1(0);

      function pie(data) {
        var i,
            n = (data = array$2(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    class BumpRadial {
      constructor(context) {
        this._context = context;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {}
      point(x, y) {
        x = +x, y = +y;
        if (this._point++ === 0) {
          this._x0 = x, this._y0 = y;
        } else {
          const p0 = pointRadial(this._x0, this._y0);
          const p1 = pointRadial(this._x0, this._y0 = (this._y0 + y) / 2);
          const p2 = pointRadial(x, this._y0);
          const p3 = pointRadial(x, y);
          this._context.moveTo(...p0);
          this._context.bezierCurveTo(...p1, ...p2, ...p3);
        }
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function bumpRadial(context) {
      return new BumpRadial(context);
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link$1(curve) {
      let source = linkSource;
      let target = linkTarget;
      let x = x$1;
      let y$1 = y;
      let context = null;
      let output = null;

      function link() {
        let buffer;
        const argv = slice.call(arguments);
        const s = source.apply(this, argv);
        const t = target.apply(this, argv);
        if (context == null) output = curve(buffer = path());
        output.lineStart();
        argv[0] = s, output.point(+x.apply(this, argv), +y$1.apply(this, argv));
        argv[0] = t, output.point(+x.apply(this, argv), +y$1.apply(this, argv));
        output.lineEnd();
        if (buffer) return output = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$1(+_), link) : x;
      };

      link.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link) : y$1;
      };

      link.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
      };

      return link;
    }

    function linkHorizontal() {
      return link$1(bumpX);
    }

    function linkVertical() {
      return link$1(bumpY);
    }

    function linkRadial() {
      const l = link$1(bumpRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    const sqrt3$2 = sqrt(3);

    var asterisk = {
      draw(context, size) {
        const r = sqrt(size + min(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3$2;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };

    var circle = {
      draw(context, size) {
        const r = sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };

    var cross = {
      draw(context, size) {
        const r = sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    const tan30 = sqrt(1 / 3);
    const tan30_2 = tan30 * 2;

    var diamond = {
      draw(context, size) {
        const y = sqrt(size / tan30_2);
        const x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var diamond2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };

    var plus = {
      draw(context, size) {
        const r = sqrt(size - min(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };

    var square = {
      draw(context, size) {
        const w = sqrt(size);
        const x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var square2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };

    const ka = 0.89081309152928522810;
    const kr = sin(pi / 10) / sin(7 * pi / 10);
    const kx = sin(tau / 10) * kr;
    const ky = -cos(tau / 10) * kr;

    var star = {
      draw(context, size) {
        const r = sqrt(size * ka);
        const x = kx * r;
        const y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (let i = 1; i < 5; ++i) {
          const a = tau * i / 5;
          const c = cos(a);
          const s = sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    const sqrt3$1 = sqrt(3);

    var triangle = {
      draw(context, size) {
        const y = -sqrt(size / (sqrt3$1 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3$1 * y, -y);
        context.lineTo(sqrt3$1 * y, -y);
        context.closePath();
      }
    };

    const sqrt3 = sqrt(3);

    var triangle2 = {
      draw(context, size) {
        const s = sqrt(size) * 0.6824;
        const t = s  / 2;
        const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
        context.moveTo(0, -s);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };

    const c = -0.5;
    const s = sqrt(3) / 2;
    const k = 1 / sqrt(12);
    const a = (k / 2 + 1) * 3;

    var wye = {
      draw(context, size) {
        const r = sqrt(size / a);
        const x0 = r / 2, y0 = r * k;
        const x1 = x0, y1 = r * k + r;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var x = {
      draw(context, size) {
        const r = sqrt(size - min(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };

    // These symbols are designed to be filled.
    const symbolsFill = [
      circle,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    // These symbols are designed to be stroked (with a width of 1.5px and round caps).
    const symbolsStroke = [
      circle,
      plus,
      x,
      triangle2,
      asterisk,
      square2,
      diamond2
    ];

    function Symbol$1(type, size) {
      let context = null;

      type = typeof type === "function" ? type : constant$1(type || circle);
      size = typeof size === "function" ? size : constant$1(size === undefined ? 64 : +size);

      function symbol() {
        let buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop() {}

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$3(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$2(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$1(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step$2(context, t) {
      this._context = context;
      this._t = t;
    }

    Step$2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step$2(context, 0.5);
    }

    function stepBefore(context) {
      return new Step$2(context, 0);
    }

    function stepAfter(context) {
      return new Step$2(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$1([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array$2(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    var constant = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event won’t trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bisect: bisect,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        bisectCenter: bisectCenter,
        ascending: ascending$3,
        bisector: bisector,
        blur: blur,
        blur2: blur2,
        blurImage: blurImage,
        count: count$1,
        cross: cross$2,
        cumsum: cumsum,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        Adder: Adder,
        fsum: fsum,
        fcumsum: fcumsum,
        group: group,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        groups: groups,
        index: index$4,
        indexes: indexes,
        rollup: rollup,
        rollups: rollups,
        groupSort: groupSort,
        bin: bin,
        histogram: bin,
        thresholdFreedmanDiaconis: thresholdFreedmanDiaconis,
        thresholdScott: thresholdScott,
        thresholdSturges: thresholdSturges,
        max: max$3,
        maxIndex: maxIndex,
        mean: mean,
        median: median,
        medianIndex: medianIndex,
        merge: merge,
        min: min$2,
        minIndex: minIndex,
        mode: mode,
        nice: nice$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile$1,
        quantileIndex: quantileIndex,
        quantileSorted: quantileSorted,
        quickselect: quickselect,
        range: range$2,
        rank: rank,
        least: least,
        leastIndex: leastIndex,
        greatest: greatest,
        greatestIndex: greatestIndex,
        scan: scan,
        shuffle: shuffle$1,
        shuffler: shuffler,
        sum: sum$2,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance,
        zip: zip,
        every: every,
        some: some,
        filter: filter$2,
        map: map$1,
        reduce: reduce,
        reverse: reverse$1,
        sort: sort,
        difference: difference,
        disjoint: disjoint,
        intersection: intersection,
        subset: subset,
        superset: superset,
        union: union,
        InternMap: InternMap,
        InternSet: InternSet,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        chordTranspose: chordTranspose,
        chordDirected: chordDirected,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        color: color$2,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$2,
        hcl: hcl$3,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: Contours,
        contourDensity: density,
        Delaunay: Delaunay,
        Voronoi: Voronoi,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$3,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$2,
        forceY: y$1,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format$1; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$2,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$1,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate$1,
        geoLength: length$1,
        geoPath: index$2,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$4,
        geoProjection: projection$1,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        Node: Node$1,
        pack: index$1,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolate$3,
        interpolateArray: array$5,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab$1,
        interpolateHcl: hcl$2,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        path: path,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonHull: hull,
        polygonContains: contains,
        polygonLength: length,
        quadtree: quadtree,
        randomUniform: uniform,
        randomInt: int,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        randomPareto: pareto,
        randomBernoulli: bernoulli,
        randomGeometric: geometric,
        randomBinomial: binomial,
        randomGamma: gamma,
        randomBeta: beta,
        randomWeibull: weibull,
        randomCauchy: cauchy,
        randomLogistic: logistic,
        randomPoisson: poisson,
        randomLcg: lcg,
        scaleBand: band,
        scalePoint: point$4,
        scaleIdentity: identity$2,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$1,
        scaleRadial: radial,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        namespace: namespace,
        namespaces: namespaces,
        pointer: pointer,
        pointers: pointers,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        window: defaultView,
        arc: arc,
        area: area,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        link: link$1,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: Symbol$1,
        symbolsStroke: symbolsStroke,
        symbolsFill: symbolsFill,
        symbols: symbolsFill,
        symbolAsterisk: asterisk,
        symbolCircle: circle,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolDiamond2: diamond2,
        symbolPlus: plus,
        symbolSquare: square,
        symbolSquare2: square2,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolTriangle2: triangle2,
        symbolWye: wye,
        symbolX: x,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        timeInterval: newInterval,
        timeMillisecond: millisecond$1,
        timeMilliseconds: milliseconds,
        utcMillisecond: millisecond$1,
        utcMilliseconds: milliseconds,
        timeSecond: utcSecond,
        timeSeconds: seconds,
        utcSecond: utcSecond,
        utcSeconds: seconds,
        timeMinute: timeMinute,
        timeMinutes: minutes,
        timeHour: timeHour,
        timeHours: hours,
        timeDay: timeDay,
        timeDays: days,
        timeWeek: sunday,
        timeWeeks: sundays,
        timeSunday: sunday,
        timeSundays: sundays,
        timeMonday: monday,
        timeMondays: mondays,
        timeTuesday: tuesday,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday,
        timeWednesdays: wednesdays,
        timeThursday: thursday,
        timeThursdays: thursdays,
        timeFriday: friday,
        timeFridays: fridays,
        timeSaturday: saturday,
        timeSaturdays: saturdays,
        timeMonth: timeMonth,
        timeMonths: months,
        timeYear: timeYear,
        timeYears: years,
        utcMinute: utcMinute$1,
        utcMinutes: utcMinutes,
        utcHour: utcHour$1,
        utcHours: utcHours,
        utcDay: utcDay$1,
        utcDays: utcDays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth$1,
        utcMonths: utcMonths,
        utcYear: utcYear$1,
        utcYears: utcYears,
        utcTicks: utcTicks,
        utcTickInterval: utcTickInterval,
        timeTicks: timeTicks,
        timeTickInterval: timeTickInterval,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso$1,
        isoParse: parseIso$1,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition$1,
        active: active,
        interrupt: interrupt,
        zoom: zoom,
        zoomTransform: transform,
        zoomIdentity: identity,
        ZoomTransform: Transform
    });

    var $version = 8;
    var $root = {
    	version: {
    		required: true,
    		type: "enum",
    		values: [
    			8
    		],
    		doc: "Style specification version number. Must be 8.",
    		example: 8
    	},
    	name: {
    		type: "string",
    		doc: "A human-readable name for the style.",
    		example: "Bright"
    	},
    	metadata: {
    		type: "*",
    		doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    	},
    	center: {
    		type: "array",
    		value: "number",
    		doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    		example: [
    			-73.9749,
    			40.7736
    		]
    	},
    	zoom: {
    		type: "number",
    		doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    		example: 12.5
    	},
    	bearing: {
    		type: "number",
    		"default": 0,
    		period: 360,
    		units: "degrees",
    		doc: "Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    		example: 29
    	},
    	pitch: {
    		type: "number",
    		"default": 0,
    		units: "degrees",
    		doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    		example: 50
    	},
    	light: {
    		type: "light",
    		doc: "The global light source.",
    		example: {
    			anchor: "viewport",
    			color: "white",
    			intensity: 0.4
    		}
    	},
    	terrain: {
    		type: "terrain",
    		doc: "A global modifier that elevates layers and markers based on a DEM data source."
    	},
    	fog: {
    		type: "fog",
    		doc: "A global effect that fades layers and markers based on their distance to the camera. The fog can be used to approximate the effect of atmosphere on distant objects and enhance the depth perception of the map when used with terrain or 3D features. Note: fog is renamed to atmosphere in the Android and iOS SDKs and planned to be changed in GL-JS v.3.0.0."
    	},
    	sources: {
    		required: true,
    		type: "sources",
    		doc: "Data source specifications.",
    		example: {
    			"mapbox-streets": {
    				type: "vector",
    				url: "mapbox://mapbox.mapbox-streets-v6"
    			}
    		}
    	},
    	sprite: {
    		type: "string",
    		doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
    		example: "mapbox://sprites/mapbox/bright-v8"
    	},
    	glyphs: {
    		type: "string",
    		doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
    		example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    	},
    	transition: {
    		type: "transition",
    		doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
    		example: {
    			duration: 300,
    			delay: 0
    		}
    	},
    	projection: {
    		type: "projection",
    		doc: "The projection the map should be rendered in. Supported projections are Mercator, Globe, Albers, Equal Earth, Equirectangular (WGS84), Lambert conformal conic, Natural Earth, and Winkel Tripel. Terrain, sky and fog are supported by only Mercator and globe. CustomLayerInterface is not supported outside of Mercator.",
    		example: {
    			name: "albers",
    			center: [
    				-154,
    				50
    			],
    			parallels: [
    				55,
    				65
    			]
    		}
    	},
    	layers: {
    		required: true,
    		type: "array",
    		value: "layer",
    		doc: "Layers will be drawn in the order of this array.",
    		example: [
    			{
    				id: "water",
    				source: "mapbox-streets",
    				"source-layer": "water",
    				type: "fill",
    				paint: {
    					"fill-color": "#00ffff"
    				}
    			}
    		]
    	}
    };
    var sources = {
    	"*": {
    		type: "source",
    		doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
    	}
    };
    var source = [
    	"source_vector",
    	"source_raster",
    	"source_raster_dem",
    	"source_geojson",
    	"source_video",
    	"source_image"
    ];
    var source_vector = {
    	type: {
    		required: true,
    		type: "enum",
    		values: {
    			vector: {
    				doc: "A vector tile source."
    			}
    		},
    		doc: "The type of the source."
    	},
    	url: {
    		type: "string",
    		doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    	},
    	tiles: {
    		type: "array",
    		value: "string",
    		doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    	},
    	bounds: {
    		type: "array",
    		value: "number",
    		length: 4,
    		"default": [
    			-180,
    			-85.051129,
    			180,
    			85.051129
    		],
    		doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    	},
    	scheme: {
    		type: "enum",
    		values: {
    			xyz: {
    				doc: "Slippy map tilenames scheme."
    			},
    			tms: {
    				doc: "OSGeo spec scheme."
    			}
    		},
    		"default": "xyz",
    		doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    	},
    	minzoom: {
    		type: "number",
    		"default": 0,
    		doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    	},
    	maxzoom: {
    		type: "number",
    		"default": 22,
    		doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    	},
    	attribution: {
    		type: "string",
    		doc: "Contains an attribution to be displayed when the map is shown to a user."
    	},
    	promoteId: {
    		type: "promoteId",
    		doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."
    	},
    	volatile: {
    		type: "boolean",
    		"default": false,
    		doc: "A setting to determine whether a source's tiles are cached locally.",
    		"sdk-support": {
    			"basic functionality": {
    				android: "9.3.0",
    				ios: "5.10.0"
    			}
    		}
    	},
    	"*": {
    		type: "*",
    		doc: "Other keys to configure the data source."
    	}
    };
    var source_raster = {
    	type: {
    		required: true,
    		type: "enum",
    		values: {
    			raster: {
    				doc: "A raster tile source."
    			}
    		},
    		doc: "The type of the source."
    	},
    	url: {
    		type: "string",
    		doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    	},
    	tiles: {
    		type: "array",
    		value: "string",
    		doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    	},
    	bounds: {
    		type: "array",
    		value: "number",
    		length: 4,
    		"default": [
    			-180,
    			-85.051129,
    			180,
    			85.051129
    		],
    		doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    	},
    	minzoom: {
    		type: "number",
    		"default": 0,
    		doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    	},
    	maxzoom: {
    		type: "number",
    		"default": 22,
    		doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    	},
    	tileSize: {
    		type: "number",
    		"default": 512,
    		units: "pixels",
    		doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    	},
    	scheme: {
    		type: "enum",
    		values: {
    			xyz: {
    				doc: "Slippy map tilenames scheme."
    			},
    			tms: {
    				doc: "OSGeo spec scheme."
    			}
    		},
    		"default": "xyz",
    		doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    	},
    	attribution: {
    		type: "string",
    		doc: "Contains an attribution to be displayed when the map is shown to a user."
    	},
    	volatile: {
    		type: "boolean",
    		"default": false,
    		doc: "A setting to determine whether a source's tiles are cached locally.",
    		"sdk-support": {
    			"basic functionality": {
    				android: "9.3.0",
    				ios: "5.10.0"
    			}
    		}
    	},
    	"*": {
    		type: "*",
    		doc: "Other keys to configure the data source."
    	}
    };
    var source_raster_dem = {
    	type: {
    		required: true,
    		type: "enum",
    		values: {
    			"raster-dem": {
    				doc: "A RGB-encoded raster DEM source"
    			}
    		},
    		doc: "The type of the source."
    	},
    	url: {
    		type: "string",
    		doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    	},
    	tiles: {
    		type: "array",
    		value: "string",
    		doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    	},
    	bounds: {
    		type: "array",
    		value: "number",
    		length: 4,
    		"default": [
    			-180,
    			-85.051129,
    			180,
    			85.051129
    		],
    		doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    	},
    	minzoom: {
    		type: "number",
    		"default": 0,
    		doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    	},
    	maxzoom: {
    		type: "number",
    		"default": 22,
    		doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    	},
    	tileSize: {
    		type: "number",
    		"default": 512,
    		units: "pixels",
    		doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    	},
    	attribution: {
    		type: "string",
    		doc: "Contains an attribution to be displayed when the map is shown to a user."
    	},
    	encoding: {
    		type: "enum",
    		values: {
    			terrarium: {
    				doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
    			},
    			mapbox: {
    				doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
    			}
    		},
    		"default": "mapbox",
    		doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
    	},
    	volatile: {
    		type: "boolean",
    		"default": false,
    		doc: "A setting to determine whether a source's tiles are cached locally.",
    		"sdk-support": {
    			"basic functionality": {
    				android: "9.3.0",
    				ios: "5.10.0"
    			}
    		}
    	},
    	"*": {
    		type: "*",
    		doc: "Other keys to configure the data source."
    	}
    };
    var source_geojson = {
    	type: {
    		required: true,
    		type: "enum",
    		values: {
    			geojson: {
    				doc: "A GeoJSON data source."
    			}
    		},
    		doc: "The data type of the GeoJSON source."
    	},
    	data: {
    		type: "*",
    		doc: "A URL to a GeoJSON file, or inline GeoJSON."
    	},
    	maxzoom: {
    		type: "number",
    		"default": 18,
    		doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    	},
    	attribution: {
    		type: "string",
    		doc: "Contains an attribution to be displayed when the map is shown to a user."
    	},
    	buffer: {
    		type: "number",
    		"default": 128,
    		maximum: 512,
    		minimum: 0,
    		doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
    	},
    	filter: {
    		type: "*",
    		doc: "An expression for filtering features prior to processing them for rendering."
    	},
    	tolerance: {
    		type: "number",
    		"default": 0.375,
    		doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    	},
    	cluster: {
    		type: "boolean",
    		"default": false,
    		doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
    	},
    	clusterRadius: {
    		type: "number",
    		"default": 50,
    		minimum: 0,
    		doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
    	},
    	clusterMaxZoom: {
    		type: "number",
    		doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15."
    	},
    	clusterMinPoints: {
    		type: "number",
    		doc: "Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`."
    	},
    	clusterProperties: {
    		type: "*",
    		doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\"property_name\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\"+\"` or `\"max\"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{\"sum\": [\"+\", [\"get\", \"scalerank\"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\"accumulated\"]` value, e.g.:\n`{\"sum\": [[\"+\", [\"accumulated\"], [\"get\", \"sum\"]], [\"get\", \"scalerank\"]]}`"
    	},
    	lineMetrics: {
    		type: "boolean",
    		"default": false,
    		doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
    	},
    	generateId: {
    		type: "boolean",
    		"default": false,
    		doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
    	},
    	promoteId: {
    		type: "promoteId",
    		doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
    	}
    };
    var source_video = {
    	type: {
    		required: true,
    		type: "enum",
    		values: {
    			video: {
    				doc: "A video data source."
    			}
    		},
    		doc: "The data type of the video source."
    	},
    	urls: {
    		required: true,
    		type: "array",
    		value: "string",
    		doc: "URLs to video content in order of preferred format."
    	},
    	coordinates: {
    		required: true,
    		doc: "Corners of video specified in longitude, latitude pairs.",
    		type: "array",
    		length: 4,
    		value: {
    			type: "array",
    			length: 2,
    			value: "number",
    			doc: "A single longitude, latitude pair."
    		}
    	}
    };
    var source_image = {
    	type: {
    		required: true,
    		type: "enum",
    		values: {
    			image: {
    				doc: "An image data source."
    			}
    		},
    		doc: "The data type of the image source."
    	},
    	url: {
    		required: true,
    		type: "string",
    		doc: "URL that points to an image."
    	},
    	coordinates: {
    		required: true,
    		doc: "Corners of image specified in longitude, latitude pairs.",
    		type: "array",
    		length: 4,
    		value: {
    			type: "array",
    			length: 2,
    			value: "number",
    			doc: "A single longitude, latitude pair."
    		}
    	}
    };
    var layer = {
    	id: {
    		type: "string",
    		doc: "Unique layer name.",
    		required: true
    	},
    	type: {
    		type: "enum",
    		values: {
    			fill: {
    				doc: "A filled polygon with an optional stroked border.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.10.0",
    						android: "2.0.1",
    						ios: "2.0.0",
    						macos: "0.1.0"
    					}
    				}
    			},
    			line: {
    				doc: "A stroked line.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.10.0",
    						android: "2.0.1",
    						ios: "2.0.0",
    						macos: "0.1.0"
    					}
    				}
    			},
    			symbol: {
    				doc: "An icon or a text label.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.10.0",
    						android: "2.0.1",
    						ios: "2.0.0",
    						macos: "0.1.0"
    					}
    				}
    			},
    			circle: {
    				doc: "A filled circle.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.10.0",
    						android: "2.0.1",
    						ios: "2.0.0",
    						macos: "0.1.0"
    					}
    				}
    			},
    			heatmap: {
    				doc: "A heatmap.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.41.0",
    						android: "6.0.0",
    						ios: "4.0.0",
    						macos: "0.7.0"
    					}
    				}
    			},
    			"fill-extrusion": {
    				doc: "An extruded (3D) polygon.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.27.0",
    						android: "5.1.0",
    						ios: "3.6.0",
    						macos: "0.5.0"
    					}
    				}
    			},
    			raster: {
    				doc: "Raster map textures such as satellite imagery.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.10.0",
    						android: "2.0.1",
    						ios: "2.0.0",
    						macos: "0.1.0"
    					}
    				}
    			},
    			hillshade: {
    				doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.43.0",
    						android: "6.0.0",
    						ios: "4.0.0",
    						macos: "0.7.0"
    					}
    				}
    			},
    			background: {
    				doc: "The background color or pattern of the map.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "0.10.0",
    						android: "2.0.1",
    						ios: "2.0.0",
    						macos: "0.1.0"
    					}
    				}
    			},
    			sky: {
    				doc: "A spherical dome around the map that is always rendered behind all other layers.",
    				"sdk-support": {
    					"basic functionality": {
    						js: "2.0.0",
    						ios: "10.0.0",
    						android: "10.0.0"
    					}
    				}
    			}
    		},
    		doc: "Rendering type of this layer.",
    		required: true
    	},
    	metadata: {
    		type: "*",
    		doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    	},
    	source: {
    		type: "string",
    		doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
    	},
    	"source-layer": {
    		type: "string",
    		doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
    	},
    	minzoom: {
    		type: "number",
    		minimum: 0,
    		maximum: 24,
    		doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
    	},
    	maxzoom: {
    		type: "number",
    		minimum: 0,
    		maximum: 24,
    		doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
    	},
    	filter: {
    		type: "filter",
    		doc: "An expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `[\"feature-state\", ...]` expression is not supported in filter expressions.  The `[\"pitch\"]` and `[\"distance-from-center\"]` expressions are supported only for filter expressions on the symbol layer."
    	},
    	layout: {
    		type: "layout",
    		doc: "Layout properties for the layer."
    	},
    	paint: {
    		type: "paint",
    		doc: "Default paint properties for this layer."
    	}
    };
    var layout = [
    	"layout_fill",
    	"layout_line",
    	"layout_circle",
    	"layout_heatmap",
    	"layout_fill-extrusion",
    	"layout_symbol",
    	"layout_raster",
    	"layout_hillshade",
    	"layout_background",
    	"layout_sky"
    ];
    var layout_background = {
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_sky = {
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_fill = {
    	"fill-sort-key": {
    		type: "number",
    		doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "1.2.0",
    				android: "9.1.0",
    				ios: "5.8.0",
    				macos: "0.15.0"
    			},
    			"data-driven styling": {
    				js: "1.2.0",
    				android: "9.1.0",
    				ios: "5.8.0",
    				macos: "0.15.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_circle = {
    	"circle-sort-key": {
    		type: "number",
    		doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "1.2.0",
    				android: "9.2.0",
    				ios: "5.9.0",
    				macos: "0.16.0"
    			},
    			"data-driven styling": {
    				js: "1.2.0",
    				android: "9.2.0",
    				ios: "5.9.0",
    				macos: "0.16.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_heatmap = {
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.41.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_line = {
    	"line-cap": {
    		type: "enum",
    		values: {
    			butt: {
    				doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
    			},
    			round: {
    				doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
    			},
    			square: {
    				doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
    			}
    		},
    		"default": "butt",
    		doc: "The display of line endings.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "2.3.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-join": {
    		type: "enum",
    		values: {
    			bevel: {
    				doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
    			},
    			round: {
    				doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
    			},
    			miter: {
    				doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
    			}
    		},
    		"default": "miter",
    		doc: "The display of lines when joining.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.40.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-miter-limit": {
    		type: "number",
    		"default": 2,
    		doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
    		requires: [
    			{
    				"line-join": "miter"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"line-round-limit": {
    		type: "number",
    		"default": 1.05,
    		doc: "Used to automatically convert round joins to miter joins for shallow angles.",
    		requires: [
    			{
    				"line-join": "round"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"line-sort-key": {
    		type: "number",
    		doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "1.2.0",
    				android: "9.1.0",
    				ios: "5.8.0",
    				macos: "0.15.0"
    			},
    			"data-driven styling": {
    				js: "1.2.0",
    				android: "9.1.0",
    				ios: "5.8.0",
    				macos: "0.15.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_symbol = {
    	"symbol-placement": {
    		type: "enum",
    		values: {
    			point: {
    				doc: "The label is placed at the point where the geometry is located."
    			},
    			line: {
    				doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
    			},
    			"line-center": {
    				doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
    			}
    		},
    		"default": "point",
    		doc: "Label placement relative to its geometry.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"`line-center` value": {
    				js: "0.47.0",
    				android: "6.4.0",
    				ios: "4.3.0",
    				macos: "0.10.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"symbol-spacing": {
    		type: "number",
    		"default": 250,
    		minimum: 1,
    		units: "pixels",
    		doc: "Distance between two symbol anchors.",
    		requires: [
    			{
    				"symbol-placement": "line"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"symbol-avoid-edges": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"symbol-sort-key": {
    		type: "number",
    		doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.53.0",
    				android: "7.4.0",
    				ios: "4.11.0",
    				macos: "0.14.0"
    			},
    			"data-driven styling": {
    				js: "0.53.0",
    				android: "7.4.0",
    				ios: "4.11.0",
    				macos: "0.14.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"symbol-z-order": {
    		type: "enum",
    		values: {
    			auto: {
    				doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
    			},
    			"viewport-y": {
    				doc: "Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
    			},
    			source: {
    				doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data."
    			}
    		},
    		"default": "auto",
    		doc: "Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.49.0",
    				android: "6.6.0",
    				ios: "4.5.0",
    				macos: "0.12.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-allow-overlap": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-ignore-placement": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, other symbols can be visible even if they collide with the icon.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-optional": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
    		requires: [
    			"icon-image",
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-rotation-alignment": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
    			},
    			viewport: {
    				doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
    			},
    			auto: {
    				doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
    			}
    		},
    		"default": "auto",
    		doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"`auto` value": {
    				js: "0.25.0",
    				android: "4.2.0",
    				ios: "3.4.0",
    				macos: "0.3.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-size": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		units: "factor of the original icon size",
    		doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.35.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-text-fit": {
    		type: "enum",
    		values: {
    			none: {
    				doc: "The icon is displayed at its intrinsic aspect ratio."
    			},
    			width: {
    				doc: "The icon is scaled in the x-dimension to fit the width of the text."
    			},
    			height: {
    				doc: "The icon is scaled in the y-dimension to fit the height of the text."
    			},
    			both: {
    				doc: "The icon is scaled in both x- and y-dimensions."
    			}
    		},
    		"default": "none",
    		doc: "Scales the icon to fit around the associated text.",
    		requires: [
    			"icon-image",
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.21.0",
    				android: "4.2.0",
    				ios: "3.4.0",
    				macos: "0.2.1"
    			},
    			"stretchable icons": {
    				js: "1.6.0",
    				android: "9.2.0",
    				ios: "5.8.0",
    				macos: "0.15.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-text-fit-padding": {
    		type: "array",
    		value: "number",
    		length: 4,
    		"default": [
    			0,
    			0,
    			0,
    			0
    		],
    		units: "pixels",
    		doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
    		requires: [
    			"icon-image",
    			"text-field",
    			{
    				"icon-text-fit": [
    					"both",
    					"width",
    					"height"
    				]
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.21.0",
    				android: "4.2.0",
    				ios: "3.4.0",
    				macos: "0.2.1"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-image": {
    		type: "resolvedImage",
    		doc: "Name of image in sprite to use for drawing an image background.",
    		tokens: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.35.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-rotate": {
    		type: "number",
    		"default": 0,
    		period: 360,
    		units: "degrees",
    		doc: "Rotates the icon clockwise.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.21.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-padding": {
    		type: "number",
    		"default": 2,
    		minimum: 0,
    		units: "pixels",
    		doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-keep-upright": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
    		requires: [
    			"icon-image",
    			{
    				"icon-rotation-alignment": "map"
    			},
    			{
    				"symbol-placement": [
    					"line",
    					"line-center"
    				]
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-offset": {
    		type: "array",
    		value: "number",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-anchor": {
    		type: "enum",
    		values: {
    			center: {
    				doc: "The center of the icon is placed closest to the anchor."
    			},
    			left: {
    				doc: "The left side of the icon is placed closest to the anchor."
    			},
    			right: {
    				doc: "The right side of the icon is placed closest to the anchor."
    			},
    			top: {
    				doc: "The top of the icon is placed closest to the anchor."
    			},
    			bottom: {
    				doc: "The bottom of the icon is placed closest to the anchor."
    			},
    			"top-left": {
    				doc: "The top left corner of the icon is placed closest to the anchor."
    			},
    			"top-right": {
    				doc: "The top right corner of the icon is placed closest to the anchor."
    			},
    			"bottom-left": {
    				doc: "The bottom left corner of the icon is placed closest to the anchor."
    			},
    			"bottom-right": {
    				doc: "The bottom right corner of the icon is placed closest to the anchor."
    			}
    		},
    		"default": "center",
    		doc: "Part of the icon placed closest to the anchor.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.40.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			},
    			"data-driven styling": {
    				js: "0.40.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-pitch-alignment": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The icon is aligned to the plane of the map."
    			},
    			viewport: {
    				doc: "The icon is aligned to the plane of the viewport."
    			},
    			auto: {
    				doc: "Automatically matches the value of `icon-rotation-alignment`."
    			}
    		},
    		"default": "auto",
    		doc: "Orientation of icon when map is pitched.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.39.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-pitch-alignment": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The text is aligned to the plane of the map."
    			},
    			viewport: {
    				doc: "The text is aligned to the plane of the viewport."
    			},
    			auto: {
    				doc: "Automatically matches the value of `text-rotation-alignment`."
    			}
    		},
    		"default": "auto",
    		doc: "Orientation of text when map is pitched.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.21.0",
    				android: "4.2.0",
    				ios: "3.4.0",
    				macos: "0.2.1"
    			},
    			"`auto` value": {
    				js: "0.25.0",
    				android: "4.2.0",
    				ios: "3.4.0",
    				macos: "0.3.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-rotation-alignment": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
    			},
    			viewport: {
    				doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
    			},
    			auto: {
    				doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
    			}
    		},
    		"default": "auto",
    		doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"`auto` value": {
    				js: "0.25.0",
    				android: "4.2.0",
    				ios: "3.4.0",
    				macos: "0.3.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-field": {
    		type: "formatted",
    		"default": "",
    		tokens: true,
    		doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-font": {
    		type: "array",
    		value: "string",
    		"default": [
    			"Open Sans Regular",
    			"Arial Unicode MS Regular"
    		],
    		doc: "Font stack to use for displaying text.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-size": {
    		type: "number",
    		"default": 16,
    		minimum: 0,
    		units: "pixels",
    		doc: "Font size.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.35.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-max-width": {
    		type: "number",
    		"default": 10,
    		minimum: 0,
    		units: "ems",
    		doc: "The maximum line width for text wrapping.",
    		requires: [
    			"text-field",
    			{
    				"symbol-placement": [
    					"point"
    				]
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.40.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-line-height": {
    		type: "number",
    		"default": 1.2,
    		units: "ems",
    		doc: "Text leading value for multi-line text.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "2.3.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-letter-spacing": {
    		type: "number",
    		"default": 0,
    		units: "ems",
    		doc: "Text tracking amount.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.40.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-justify": {
    		type: "enum",
    		values: {
    			auto: {
    				doc: "The text is aligned towards the anchor position."
    			},
    			left: {
    				doc: "The text is aligned to the left."
    			},
    			center: {
    				doc: "The text is centered."
    			},
    			right: {
    				doc: "The text is aligned to the right."
    			}
    		},
    		"default": "center",
    		doc: "Text justification options.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.39.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			},
    			auto: {
    				js: "0.54.0",
    				android: "7.4.0",
    				ios: "4.10.0",
    				macos: "0.14.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-radial-offset": {
    		type: "number",
    		units: "ems",
    		"default": 0,
    		doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.54.0",
    				android: "7.4.0",
    				ios: "4.10.0",
    				macos: "0.14.0"
    			},
    			"data-driven styling": {
    				js: "0.54.0",
    				android: "7.4.0",
    				ios: "4.10.0",
    				macos: "0.14.0"
    			}
    		},
    		requires: [
    			"text-field"
    		],
    		"property-type": "data-driven",
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		}
    	},
    	"text-variable-anchor": {
    		type: "array",
    		value: "enum",
    		values: {
    			center: {
    				doc: "The center of the text is placed closest to the anchor."
    			},
    			left: {
    				doc: "The left side of the text is placed closest to the anchor."
    			},
    			right: {
    				doc: "The right side of the text is placed closest to the anchor."
    			},
    			top: {
    				doc: "The top of the text is placed closest to the anchor."
    			},
    			bottom: {
    				doc: "The bottom of the text is placed closest to the anchor."
    			},
    			"top-left": {
    				doc: "The top left corner of the text is placed closest to the anchor."
    			},
    			"top-right": {
    				doc: "The top right corner of the text is placed closest to the anchor."
    			},
    			"bottom-left": {
    				doc: "The bottom left corner of the text is placed closest to the anchor."
    			},
    			"bottom-right": {
    				doc: "The bottom right corner of the text is placed closest to the anchor."
    			}
    		},
    		requires: [
    			"text-field",
    			{
    				"symbol-placement": [
    					"point"
    				]
    			}
    		],
    		doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.54.0",
    				android: "7.4.0",
    				ios: "4.10.0",
    				macos: "0.14.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-anchor": {
    		type: "enum",
    		values: {
    			center: {
    				doc: "The center of the text is placed closest to the anchor."
    			},
    			left: {
    				doc: "The left side of the text is placed closest to the anchor."
    			},
    			right: {
    				doc: "The right side of the text is placed closest to the anchor."
    			},
    			top: {
    				doc: "The top of the text is placed closest to the anchor."
    			},
    			bottom: {
    				doc: "The bottom of the text is placed closest to the anchor."
    			},
    			"top-left": {
    				doc: "The top left corner of the text is placed closest to the anchor."
    			},
    			"top-right": {
    				doc: "The top right corner of the text is placed closest to the anchor."
    			},
    			"bottom-left": {
    				doc: "The bottom left corner of the text is placed closest to the anchor."
    			},
    			"bottom-right": {
    				doc: "The bottom right corner of the text is placed closest to the anchor."
    			}
    		},
    		"default": "center",
    		doc: "Part of the text placed closest to the anchor.",
    		requires: [
    			"text-field",
    			{
    				"!": "text-variable-anchor"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.39.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-max-angle": {
    		type: "number",
    		"default": 45,
    		units: "degrees",
    		doc: "Maximum angle change between adjacent characters.",
    		requires: [
    			"text-field",
    			{
    				"symbol-placement": [
    					"line",
    					"line-center"
    				]
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-writing-mode": {
    		type: "array",
    		value: "enum",
    		values: {
    			horizontal: {
    				doc: "If a text's language supports horizontal writing mode, symbols would be laid out horizontally."
    			},
    			vertical: {
    				doc: "If a text's language supports vertical writing mode, symbols would be laid out vertically."
    			}
    		},
    		doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "1.3.0",
    				android: "8.3.0",
    				ios: "5.3.0",
    				macos: "0.15.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-rotate": {
    		type: "number",
    		"default": 0,
    		period: 360,
    		units: "degrees",
    		doc: "Rotates the text clockwise.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.35.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-padding": {
    		type: "number",
    		"default": 2,
    		minimum: 0,
    		units: "pixels",
    		doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-keep-upright": {
    		type: "boolean",
    		"default": true,
    		doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
    		requires: [
    			"text-field",
    			{
    				"text-rotation-alignment": "map"
    			},
    			{
    				"symbol-placement": [
    					"line",
    					"line-center"
    				]
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-transform": {
    		type: "enum",
    		values: {
    			none: {
    				doc: "The text is not altered."
    			},
    			uppercase: {
    				doc: "Forces all letters to be displayed in uppercase."
    			},
    			lowercase: {
    				doc: "Forces all letters to be displayed in lowercase."
    			}
    		},
    		"default": "none",
    		doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-offset": {
    		type: "array",
    		doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
    		value: "number",
    		units: "ems",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		requires: [
    			"text-field",
    			{
    				"!": "text-radial-offset"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.35.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-allow-overlap": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-ignore-placement": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, other symbols can be visible even if they collide with the text.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-optional": {
    		type: "boolean",
    		"default": false,
    		doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
    		requires: [
    			"text-field",
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_raster = {
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var layout_hillshade = {
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var filter = {
    	type: "array",
    	value: "*",
    	doc: "A filter selects specific features from a layer."
    };
    var filter_symbol = {
    	type: "boolean",
    	doc: "Expression which determines whether or not to display a symbol. Symbols support dynamic filtering, meaning this expression can use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    	"default": false,
    	transition: false,
    	"property-type": "data-driven",
    	expression: {
    		interpolated: false,
    		parameters: [
    			"zoom",
    			"feature",
    			"pitch",
    			"distance-from-center"
    		]
    	}
    };
    var filter_fill = {
    	type: "boolean",
    	doc: "Expression which determines whether or not to display a polygon. Fill layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    	"default": false,
    	transition: false,
    	"property-type": "data-driven",
    	expression: {
    		interpolated: false,
    		parameters: [
    			"zoom",
    			"feature"
    		]
    	}
    };
    var filter_line = {
    	type: "boolean",
    	doc: "Expression which determines whether or not to display a Polygon or LineString. Line layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    	"default": false,
    	transition: false,
    	"property-type": "data-driven",
    	expression: {
    		interpolated: false,
    		parameters: [
    			"zoom",
    			"feature"
    		]
    	}
    };
    var filter_circle = {
    	type: "boolean",
    	doc: "Expression which determines whether or not to display a circle. Circle layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    	"default": false,
    	transition: false,
    	"property-type": "data-driven",
    	expression: {
    		interpolated: false,
    		parameters: [
    			"zoom",
    			"feature"
    		]
    	}
    };
    var filter_heatmap = {
    	type: "boolean",
    	doc: "Expression used to determine whether a point is being displayed or not. Heatmap layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    	"default": false,
    	transition: false,
    	"property-type": "data-driven",
    	expression: {
    		interpolated: false,
    		parameters: [
    			"zoom",
    			"feature"
    		]
    	}
    };
    var filter_operator = {
    	type: "enum",
    	values: {
    		"==": {
    			doc: "`[\"==\", key, value]` equality: `feature[key] = value`"
    		},
    		"!=": {
    			doc: "`[\"!=\", key, value]` inequality: `feature[key] ≠ value`"
    		},
    		">": {
    			doc: "`[\">\", key, value]` greater than: `feature[key] > value`"
    		},
    		">=": {
    			doc: "`[\">=\", key, value]` greater than or equal: `feature[key] ≥ value`"
    		},
    		"<": {
    			doc: "`[\"<\", key, value]` less than: `feature[key] < value`"
    		},
    		"<=": {
    			doc: "`[\"<=\", key, value]` less than or equal: `feature[key] ≤ value`"
    		},
    		"in": {
    			doc: "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`"
    		},
    		"!in": {
    			doc: "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`"
    		},
    		all: {
    			doc: "`[\"all\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`"
    		},
    		any: {
    			doc: "`[\"any\", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`"
    		},
    		none: {
    			doc: "`[\"none\", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`"
    		},
    		has: {
    			doc: "`[\"has\", key]` `feature[key]` exists"
    		},
    		"!has": {
    			doc: "`[\"!has\", key]` `feature[key]` does not exist"
    		},
    		within: {
    			doc: "`[\"within\", object]` feature geometry is within object geometry"
    		}
    	},
    	doc: "The filter operator."
    };
    var geometry_type = {
    	type: "enum",
    	values: {
    		Point: {
    			doc: "Filter to point geometries."
    		},
    		LineString: {
    			doc: "Filter to line geometries."
    		},
    		Polygon: {
    			doc: "Filter to polygon geometries."
    		}
    	},
    	doc: "The geometry type for the filter to select."
    };
    var function_stop = {
    	type: "array",
    	minimum: 0,
    	maximum: 24,
    	value: [
    		"number",
    		"color"
    	],
    	length: 2,
    	doc: "Zoom level and value pair."
    };
    var expression$1 = {
    	type: "array",
    	value: "*",
    	minimum: 1,
    	doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
    };
    var expression_name = {
    	doc: "",
    	type: "enum",
    	values: {
    		"let": {
    			doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
    			group: "Variable binding",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"var": {
    			doc: "References variable bound using \"let\".",
    			group: "Variable binding",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		literal: {
    			doc: "Provides a literal array or object value.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		array: {
    			doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		at: {
    			doc: "Retrieves an item from an array.",
    			group: "Lookup",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"in": {
    			doc: "Determines whether an item exists in an array or a substring exists in a string. In the specific case when the second and third arguments are string literals, you must wrap at least one of them in a [`literal`](#types-literal) expression to hint correct interpretation to the [type system](#type-system).",
    			group: "Lookup",
    			"sdk-support": {
    				"basic functionality": {
    					js: "1.6.0",
    					android: "9.1.0",
    					ios: "5.8.0",
    					macos: "0.15.0"
    				}
    			}
    		},
    		"index-of": {
    			doc: "Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.",
    			group: "Lookup",
    			"sdk-support": {
    				"basic functionality": {
    					js: "1.10.0"
    				}
    			}
    		},
    		slice: {
    			doc: "Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.",
    			group: "Lookup",
    			"sdk-support": {
    				"basic functionality": {
    					js: "1.10.0"
    				}
    			}
    		},
    		"case": {
    			doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		match: {
    			doc: "Selects the output for which the label value matches the input value, or the fallback value if no match is found. The input can be any expression (for example, `[\"get\", \"building_type\"]`). Each label must be unique, and must be either:\n - a single literal value; or\n - an array of literal values, the values of which must be all strings or all numbers (for example `[100, 101]` or `[\"c\", \"b\"]`).\n\nThe input matches if any of the values in the array matches using strict equality, similar to the `\"in\"` operator.\nIf the input type does not match the type of the labels, the result will be the fallback value.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		coalesce: {
    			doc: "Evaluates each expression in turn until the first valid value is obtained. Invalid values are `null` and [`'image'`](#types-image) expressions that are unavailable in the style. If all values are invalid, `coalesce` returns the first value listed.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		step: {
    			doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",
    			group: "Ramps, scales, curves",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.42.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		interpolate: {
    			doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `[\"linear\"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\n- `[\"exponential\", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.",
    			group: "Ramps, scales, curves",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.42.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"interpolate-hcl": {
    			doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",
    			group: "Ramps, scales, curves",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.49.0"
    				}
    			}
    		},
    		"interpolate-lab": {
    			doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",
    			group: "Ramps, scales, curves",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.49.0"
    				}
    			}
    		},
    		ln2: {
    			doc: "Returns mathematical constant ln(2).",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		pi: {
    			doc: "Returns the mathematical constant pi.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		e: {
    			doc: "Returns the mathematical constant e.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"typeof": {
    			doc: "Returns a string describing the type of the given value.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		string: {
    			doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		number: {
    			doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		boolean: {
    			doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		object: {
    			doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		collator: {
    			doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		},
    		format: {
    			doc: "Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`'image'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\n- `\"text-font\"`: Overrides the font stack specified by the root layout property.\n- `\"text-color\"`: Overrides the color specified by the root paint property.\n- `\"font-scale\"`: Applies a scaling factor on `text-size` as specified by the root layout property.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.48.0",
    					android: "6.7.0",
    					ios: "4.6.0",
    					macos: "0.12.0"
    				},
    				"text-font": {
    					js: "0.48.0",
    					android: "6.7.0",
    					ios: "4.6.0",
    					macos: "0.12.0"
    				},
    				"font-scale": {
    					js: "0.48.0",
    					android: "6.7.0",
    					ios: "4.6.0",
    					macos: "0.12.0"
    				},
    				"text-color": {
    					js: "1.3.0",
    					android: "7.3.0",
    					ios: "4.10.0",
    					macos: "0.14.0"
    				},
    				image: {
    					js: "1.6.0",
    					android: "8.6.0",
    					ios: "5.7.0",
    					macos: "0.15.0"
    				}
    			}
    		},
    		image: {
    			doc: "Returns a [`ResolvedImage`](/mapbox-gl-js/style-spec/types/#resolvedimage) for use in [`icon-image`](/mapbox-gl-js/style-spec/layers/#layout-symbol-icon-image), `*-pattern` entries, and as a section in the [`'format'`](#types-format) expression. A [`'coalesce'`](#coalesce) expression containing `image` expressions will evaluate to the first listed image that is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `'image'` argument.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "1.4.0",
    					android: "8.6.0",
    					ios: "5.7.0",
    					macos: "0.15.0"
    				}
    			}
    		},
    		"number-format": {
    			doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.54.0",
    					android: "8.4.0",
    					ios: "5.4.0",
    					macos: "0.15.0"
    				}
    			}
    		},
    		"to-string": {
    			doc: "Converts the input value to a string. If the input is `null`, the result is `\"\"`. If the input is a [`boolean`](#types-boolean), the result is `\"true\"` or `\"false\"`. If the input is a number, it is converted to a string as specified by the [\"NumberToString\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a [`color`](#color), it is converted to a string of the form `\"rgba(r,g,b,a)\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. If the input is an [`'image'`](#types-image) expression, `'to-string'` returns the image name. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"to-number": {
    			doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\"ToNumber Applied to the String Type\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"to-boolean": {
    			doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"to-rgba": {
    			doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
    			group: "Color",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"to-color": {
    			doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
    			group: "Types",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		rgb: {
    			doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
    			group: "Color",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		rgba: {
    			doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
    			group: "Color",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		get: {
    			doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns `null` if the requested property is missing.",
    			group: "Lookup",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		has: {
    			doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
    			group: "Lookup",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		length: {
    			doc: "Returns the length of an array or string.",
    			group: "Lookup",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		properties: {
    			doc: "Returns the feature properties object.  Note that in some cases, it may be more efficient to use `[\"get\", \"property_name\"]` directly.",
    			group: "Feature data",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"feature-state": {
    			doc: "Retrieves a property value from the current feature's state. Returns `null` if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
    			group: "Feature data",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.46.0"
    				}
    			}
    		},
    		"geometry-type": {
    			doc: "Returns the feature's geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`. `Multi*` feature types are only returned in GeoJSON sources. When working with vector tile sources, use the singular forms.",
    			group: "Feature data",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		id: {
    			doc: "Returns the feature's id, if it has one.",
    			group: "Feature data",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		zoom: {
    			doc: "Returns the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level \"step\" or \"interpolate\" expression.",
    			group: "Camera",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		pitch: {
    			doc: "Returns the current pitch in degrees. `[\"pitch\"]` may only be used in the `filter` expression for a `symbol` layer.",
    			group: "Camera",
    			"sdk-support": {
    				"basic functionality": {
    					js: "2.6.0"
    				}
    			}
    		},
    		"distance-from-center": {
    			doc: "Returns the distance of a `symbol` instance from the center of the map. The distance is measured in pixels divided by the height of the map container. It measures 0 at the center, decreases towards the camera and increase away from the camera. For example, if the height of the map is 1000px, a value of -1 means 1000px away from the center towards the camera, and a value of 1 means a distance of 1000px away from the camera from the center. `[\"distance-from-center\"]` may only be used in the `filter` expression for a `symbol` layer.",
    			group: "Camera",
    			"sdk-support": {
    				"basic functionality": {
    					js: "2.6.0"
    				}
    			}
    		},
    		"heatmap-density": {
    			doc: "Returns the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
    			group: "Heatmap",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"line-progress": {
    			doc: "Returns the progress along a gradient line. Can only be used in the `line-gradient` property.",
    			group: "Feature data",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.6.0",
    					macos: "0.12.0"
    				}
    			}
    		},
    		"sky-radial-progress": {
    			doc: "Returns the distance of a point on the sky from the sun position. Returns 0 at sun position and 1 when the distance reaches `sky-gradient-radius`. Can only be used in the `sky-gradient` property.",
    			group: "sky",
    			"sdk-support": {
    				"basic functionality": {
    					js: "2.0.0",
    					ios: "10.0.0",
    					android: "10.0.0"
    				}
    			}
    		},
    		accumulated: {
    			doc: "Returns the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
    			group: "Feature data",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.53.0",
    					android: "8.4.0",
    					ios: "5.5.0",
    					macos: "0.15.0"
    				}
    			}
    		},
    		"+": {
    			doc: "Returns the sum of the inputs.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"*": {
    			doc: "Returns the product of the inputs.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"-": {
    			doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"/": {
    			doc: "Returns the result of floating point division of the first input by the second.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"%": {
    			doc: "Returns the remainder after integer division of the first input by the second.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"^": {
    			doc: "Returns the result of raising the first input to the power specified by the second.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		sqrt: {
    			doc: "Returns the square root of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.42.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		log10: {
    			doc: "Returns the base-ten logarithm of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		ln: {
    			doc: "Returns the natural logarithm of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		log2: {
    			doc: "Returns the base-two logarithm of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		sin: {
    			doc: "Returns the sine of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		cos: {
    			doc: "Returns the cosine of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		tan: {
    			doc: "Returns the tangent of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		asin: {
    			doc: "Returns the arcsine of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		acos: {
    			doc: "Returns the arccosine of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		atan: {
    			doc: "Returns the arctangent of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		min: {
    			doc: "Returns the minimum value of the inputs.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		max: {
    			doc: "Returns the maximum value of the inputs.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		round: {
    			doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\"round\", -1.5]` evaluates to -2.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		abs: {
    			doc: "Returns the absolute value of the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		ceil: {
    			doc: "Returns the smallest integer that is greater than or equal to the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		floor: {
    			doc: "Returns the largest integer that is less than or equal to the input.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		distance: {
    			doc: "Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.",
    			group: "Math",
    			"sdk-support": {
    				"basic functionality": {
    					android: "9.2.0",
    					ios: "5.9.0",
    					macos: "0.16.0"
    				}
    			}
    		},
    		"==": {
    			doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				},
    				collator: {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		},
    		"!=": {
    			doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				},
    				collator: {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		},
    		">": {
    			doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				},
    				collator: {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		},
    		"<": {
    			doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				},
    				collator: {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		},
    		">=": {
    			doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				},
    				collator: {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		},
    		"<=": {
    			doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				},
    				collator: {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		},
    		all: {
    			doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		any: {
    			doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"!": {
    			doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		within: {
    			doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line's endpoint is on the boundary.",
    			group: "Decision",
    			"sdk-support": {
    				"basic functionality": {
    					js: "1.9.0",
    					android: "9.1.0",
    					ios: "5.8.0",
    					macos: "0.15.0"
    				}
    			}
    		},
    		"is-supported-script": {
    			doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
    			group: "String",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.6.0"
    				}
    			}
    		},
    		upcase: {
    			doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
    			group: "String",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		downcase: {
    			doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
    			group: "String",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		concat: {
    			doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
    			group: "String",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.41.0",
    					android: "6.0.0",
    					ios: "4.0.0",
    					macos: "0.7.0"
    				}
    			}
    		},
    		"resolved-locale": {
    			doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
    			group: "String",
    			"sdk-support": {
    				"basic functionality": {
    					js: "0.45.0",
    					android: "6.5.0",
    					ios: "4.2.0",
    					macos: "0.9.0"
    				}
    			}
    		}
    	}
    };
    var fog = {
    	range: {
    		type: "array",
    		"default": [
    			0.5,
    			10
    		],
    		minimum: -20,
    		maximum: 20,
    		length: 2,
    		value: "number",
    		"property-type": "data-constant",
    		transition: true,
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		doc: "The start and end distance range in which fog fades from fully transparent to fully opaque. The distance to the point at the center of the map is defined as zero, so that negative range values are closer to the camera, and positive values are farther away.",
    		example: [
    			0.5,
    			10
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.3.0",
    				android: "10.6.0",
    				ios: "10.6.0"
    			}
    		}
    	},
    	color: {
    		type: "color",
    		"property-type": "data-constant",
    		"default": "#ffffff",
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "The color of the atmosphere region immediately below the horizon and within the `range` and above the horizon and within `horizon-blend`. Using opacity is recommended only for smoothly transitioning fog on/off as anything less than 100% opacity results in more tiles loaded and drawn.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.3.0",
    				android: "10.6.0",
    				ios: "10.6.0"
    			}
    		}
    	},
    	"high-color": {
    		type: "color",
    		"property-type": "data-constant",
    		"default": "#245cdf",
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "The color of the atmosphere region above the horizon, `high-color` extends further above the horizon than the `color` property and its spread can be controlled with `horizon-blend`. The opacity can be set to `0` to remove the high atmosphere color contribution.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.9.0",
    				android: "10.6.0",
    				ios: "10.6.0"
    			}
    		}
    	},
    	"space-color": {
    		type: "color",
    		"property-type": "data-constant",
    		"default": [
    			"interpolate",
    			[
    				"linear"
    			],
    			[
    				"zoom"
    			],
    			4,
    			"#010b19",
    			7,
    			"#367ab9"
    		],
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "The color of the region above the horizon and after the end of the `horizon-blend` contribution. The opacity can be set to `0` to have a transparent background.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.9.0",
    				android: "10.6.0",
    				ios: "10.6.0"
    			}
    		}
    	},
    	"horizon-blend": {
    		type: "number",
    		"property-type": "data-constant",
    		"default": [
    			"interpolate",
    			[
    				"linear"
    			],
    			[
    				"zoom"
    			],
    			4,
    			0.2,
    			7,
    			0.1
    		],
    		minimum: 0,
    		maximum: 1,
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "Horizon blend applies a smooth fade from the color of the atmosphere to the color of space. A value of zero leaves a sharp transition from atmosphere to space. Increasing the value blends the color of atmosphere into increasingly high angles of the sky.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.3.0",
    				android: "10.6.0",
    				ios: "10.6.0"
    			}
    		}
    	},
    	"star-intensity": {
    		type: "number",
    		"property-type": "data-constant",
    		"default": [
    			"interpolate",
    			[
    				"linear"
    			],
    			[
    				"zoom"
    			],
    			5,
    			0.35,
    			6,
    			0
    		],
    		minimum: 0,
    		maximum: 1,
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "A value controlling the star intensity where `0` will show no stars and `1` will show stars at their maximum intensity.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.9.0",
    				android: "10.6.0",
    				ios: "10.6.0"
    			}
    		}
    	}
    };
    var light = {
    	anchor: {
    		type: "enum",
    		"default": "viewport",
    		values: {
    			map: {
    				doc: "The position of the light source is aligned to the rotation of the map."
    			},
    			viewport: {
    				doc: "The position of the light source is aligned to the rotation of the viewport."
    			}
    		},
    		"property-type": "data-constant",
    		transition: false,
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		doc: "Whether extruded geometries are lit relative to the map or viewport.",
    		example: "map",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		}
    	},
    	position: {
    		type: "array",
    		"default": [
    			1.15,
    			210,
    			30
    		],
    		length: 3,
    		value: "number",
    		"property-type": "data-constant",
    		transition: true,
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).",
    		example: [
    			1.5,
    			90,
    			80
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		}
    	},
    	color: {
    		type: "color",
    		"property-type": "data-constant",
    		"default": "#ffffff",
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "Color tint for lighting extruded geometries.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		}
    	},
    	intensity: {
    		type: "number",
    		"property-type": "data-constant",
    		"default": 0.5,
    		minimum: 0,
    		maximum: 1,
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		}
    	}
    };
    var projection = {
    	name: {
    		type: "enum",
    		values: {
    			albers: {
    				doc: "An Albers equal-area projection centered on the continental United States. You can configure the projection for a different region by setting `center` and `parallels` properties. You may want to set max bounds to constrain the map to the relevant region."
    			},
    			equalEarth: {
    				doc: "An Equal Earth projection."
    			},
    			equirectangular: {
    				doc: "An Equirectangular projection. This projection is very similar to the Plate Carrée projection."
    			},
    			lambertConformalConic: {
    				doc: "A Lambert conformal conic projection. You can configure the projection for a region by setting `center` and `parallels` properties. You may want to set max bounds to constrain the map to the relevant region."
    			},
    			mercator: {
    				doc: "The Mercator projection is the default projection."
    			},
    			naturalEarth: {
    				doc: "A Natural Earth projection."
    			},
    			winkelTripel: {
    				doc: "A Winkel Tripel projection."
    			},
    			globe: {
    				doc: "A globe projection."
    			}
    		},
    		"default": "mercator",
    		doc: "The name of the projection to be used for rendering the map.",
    		required: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.6.0"
    			}
    		}
    	},
    	center: {
    		type: "array",
    		length: 2,
    		value: "number",
    		"property-type": "data-constant",
    		minimum: [
    			-180,
    			-90
    		],
    		maximum: [
    			180,
    			90
    		],
    		transition: false,
    		doc: "The reference longitude and latitude of the projection. `center` takes the form of [lng, lat]. This property is only configurable for conic projections (Albers and Lambert Conformal Conic). All other projections are centered on [0, 0].",
    		example: [
    			-96,
    			37.5
    		],
    		requires: [
    			{
    				name: [
    					"albers",
    					"lambertConformalConic"
    				]
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.6.0"
    			}
    		}
    	},
    	parallels: {
    		type: "array",
    		length: 2,
    		value: "number",
    		"property-type": "data-constant",
    		minimum: [
    			-90,
    			-90
    		],
    		maximum: [
    			90,
    			90
    		],
    		transition: false,
    		doc: "The standard parallels of the projection, denoting the desired latitude range with minimal distortion. `parallels` takes the form of [lat0, lat1]. This property is only configurable for conic projections (Albers and Lambert Conformal Conic).",
    		example: [
    			29.5,
    			45.5
    		],
    		requires: [
    			{
    				name: [
    					"albers",
    					"lambertConformalConic"
    				]
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.6.0"
    			}
    		}
    	}
    };
    var terrain = {
    	source: {
    		type: "string",
    		doc: "Name of a source of `raster_dem` type to be used for terrain elevation.",
    		required: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		}
    	},
    	exaggeration: {
    		type: "number",
    		"property-type": "data-constant",
    		"default": 1,
    		minimum: 0,
    		maximum: 1000,
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		transition: true,
    		doc: "Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.",
    		requires: [
    			"source"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		}
    	}
    };
    var paint = [
    	"paint_fill",
    	"paint_line",
    	"paint_circle",
    	"paint_heatmap",
    	"paint_fill-extrusion",
    	"paint_symbol",
    	"paint_raster",
    	"paint_hillshade",
    	"paint_background",
    	"paint_sky"
    ];
    var paint_fill = {
    	"fill-antialias": {
    		type: "boolean",
    		"default": true,
    		doc: "Whether or not the fill should be antialiased.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"fill-opacity": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.21.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"fill-color": {
    		type: "color",
    		"default": "#000000",
    		doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
    		transition: true,
    		requires: [
    			{
    				"!": "fill-pattern"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.19.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"fill-outline-color": {
    		type: "color",
    		doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
    		transition: true,
    		requires: [
    			{
    				"!": "fill-pattern"
    			},
    			{
    				"fill-antialias": true
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.19.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"fill-translate": {
    		type: "array",
    		value: "number",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		transition: true,
    		units: "pixels",
    		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"fill-translate-anchor": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The fill is translated relative to the map."
    			},
    			viewport: {
    				doc: "The fill is translated relative to the viewport."
    			}
    		},
    		doc: "Controls the frame of reference for `fill-translate`.",
    		"default": "map",
    		requires: [
    			"fill-translate"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"fill-pattern": {
    		type: "resolvedImage",
    		transition: true,
    		doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.49.0",
    				android: "6.5.0",
    				macos: "0.11.0",
    				ios: "4.4.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "cross-faded-data-driven"
    	}
    };
    var paint_line = {
    	"line-opacity": {
    		type: "number",
    		doc: "The opacity at which the line will be drawn.",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-color": {
    		type: "color",
    		doc: "The color with which the line will be drawn.",
    		"default": "#000000",
    		transition: true,
    		requires: [
    			{
    				"!": "line-pattern"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.23.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-translate": {
    		type: "array",
    		value: "number",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		transition: true,
    		units: "pixels",
    		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"line-translate-anchor": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The line is translated relative to the map."
    			},
    			viewport: {
    				doc: "The line is translated relative to the viewport."
    			}
    		},
    		doc: "Controls the frame of reference for `line-translate`.",
    		"default": "map",
    		requires: [
    			"line-translate"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"line-width": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "Stroke thickness.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.39.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-gap-width": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
    		transition: true,
    		units: "pixels",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-offset": {
    		type: "number",
    		"default": 0,
    		doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
    		transition: true,
    		units: "pixels",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.12.1",
    				android: "3.0.0",
    				ios: "3.1.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-blur": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "Blur applied to the line, in pixels.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"line-dasharray": {
    		type: "array",
    		value: "number",
    		doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    		minimum: 0,
    		transition: true,
    		units: "line widths",
    		requires: [
    			{
    				"!": "line-pattern"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "2.3.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "cross-faded-data-driven"
    	},
    	"line-pattern": {
    		type: "resolvedImage",
    		transition: true,
    		doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.49.0",
    				android: "6.5.0",
    				macos: "0.11.0",
    				ios: "4.4.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "cross-faded-data-driven"
    	},
    	"line-gradient": {
    		type: "color",
    		doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\"lineMetrics\": true`.",
    		transition: false,
    		requires: [
    			{
    				"!": "line-pattern"
    			},
    			{
    				source: "geojson",
    				has: {
    					lineMetrics: true
    				}
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.45.0",
    				android: "6.5.0",
    				ios: "4.4.0",
    				macos: "0.11.0"
    			},
    			"data-driven styling": {
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"line-progress"
    			]
    		},
    		"property-type": "color-ramp"
    	},
    	"line-trim-offset": {
    		type: "array",
    		value: "number",
    		doc: "The line part between [trim-start, trim-end] will be marked as transparent to make a route vanishing effect. The line trim-off offset is based on the whole line range [0.0, 1.0].",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		minimum: [
    			0,
    			0
    		],
    		maximum: [
    			1,
    			1
    		],
    		transition: false,
    		requires: [
    			{
    				source: "geojson",
    				has: {
    					lineMetrics: true
    				}
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.9.0",
    				android: "10.5.0",
    				ios: "10.5.0",
    				macos: "10.5.0"
    			}
    		},
    		"property-type": "constant"
    	}
    };
    var paint_circle = {
    	"circle-radius": {
    		type: "number",
    		"default": 5,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "Circle radius.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.18.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"circle-color": {
    		type: "color",
    		"default": "#000000",
    		doc: "The fill color of the circle.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.18.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"circle-blur": {
    		type: "number",
    		"default": 0,
    		doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.20.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"circle-opacity": {
    		type: "number",
    		doc: "The opacity at which the circle will be drawn.",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.20.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"circle-translate": {
    		type: "array",
    		value: "number",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		transition: true,
    		units: "pixels",
    		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"circle-translate-anchor": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The circle is translated relative to the map."
    			},
    			viewport: {
    				doc: "The circle is translated relative to the viewport."
    			}
    		},
    		doc: "Controls the frame of reference for `circle-translate`.",
    		"default": "map",
    		requires: [
    			"circle-translate"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"circle-pitch-scale": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "Circles are scaled according to their apparent distance to the camera."
    			},
    			viewport: {
    				doc: "Circles are not scaled."
    			}
    		},
    		"default": "map",
    		doc: "Controls the scaling behavior of the circle when the map is pitched.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.21.0",
    				android: "4.2.0",
    				ios: "3.4.0",
    				macos: "0.2.1"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"circle-pitch-alignment": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The circle is aligned to the plane of the map."
    			},
    			viewport: {
    				doc: "The circle is aligned to the plane of the viewport."
    			}
    		},
    		"default": "viewport",
    		doc: "Orientation of circle when map is pitched.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.39.0",
    				android: "5.2.0",
    				ios: "3.7.0",
    				macos: "0.6.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"circle-stroke-width": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"circle-stroke-color": {
    		type: "color",
    		"default": "#000000",
    		doc: "The stroke color of the circle.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"circle-stroke-opacity": {
    		type: "number",
    		doc: "The opacity of the circle's stroke.",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			},
    			"data-driven styling": {
    				js: "0.29.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	}
    };
    var paint_heatmap = {
    	"heatmap-radius": {
    		type: "number",
    		"default": 30,
    		minimum: 1,
    		transition: true,
    		units: "pixels",
    		doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed. `queryRenderedFeatures` on heatmap layers will return points within this radius.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.41.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			},
    			"data-driven styling": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"heatmap-weight": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		transition: false,
    		doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.41.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			},
    			"data-driven styling": {
    				js: "0.41.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"heatmap-intensity": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		transition: true,
    		doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.41.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"heatmap-color": {
    		type: "color",
    		"default": [
    			"interpolate",
    			[
    				"linear"
    			],
    			[
    				"heatmap-density"
    			],
    			0,
    			"rgba(0, 0, 255, 0)",
    			0.1,
    			"royalblue",
    			0.3,
    			"cyan",
    			0.5,
    			"lime",
    			0.7,
    			"yellow",
    			1,
    			"red"
    		],
    		doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\"heatmap-density\"]` as input.",
    		transition: false,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.41.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			},
    			"data-driven styling": {
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"heatmap-density"
    			]
    		},
    		"property-type": "color-ramp"
    	},
    	"heatmap-opacity": {
    		type: "number",
    		doc: "The global opacity at which the heatmap layer will be drawn.",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.41.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	}
    };
    var paint_symbol = {
    	"icon-opacity": {
    		doc: "The opacity at which the icon will be drawn.",
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-color": {
    		type: "color",
    		"default": "#000000",
    		transition: true,
    		doc: "The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-halo-color": {
    		type: "color",
    		"default": "rgba(0, 0, 0, 0)",
    		transition: true,
    		doc: "The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-halo-width": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "Distance of halo to the icon outline.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-halo-blur": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "Fade out the halo towards the outside.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"icon-translate": {
    		type: "array",
    		value: "number",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		transition: true,
    		units: "pixels",
    		doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
    		requires: [
    			"icon-image"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"icon-translate-anchor": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "Icons are translated relative to the map."
    			},
    			viewport: {
    				doc: "Icons are translated relative to the viewport."
    			}
    		},
    		doc: "Controls the frame of reference for `icon-translate`.",
    		"default": "map",
    		requires: [
    			"icon-image",
    			"icon-translate"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-opacity": {
    		type: "number",
    		doc: "The opacity at which the text will be drawn.",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-color": {
    		type: "color",
    		doc: "The color with which the text will be drawn.",
    		"default": "#000000",
    		transition: true,
    		overridable: true,
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-halo-color": {
    		type: "color",
    		"default": "rgba(0, 0, 0, 0)",
    		transition: true,
    		doc: "The color of the text's halo, which helps it stand out from backgrounds.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-halo-width": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-halo-blur": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		transition: true,
    		units: "pixels",
    		doc: "The halo's fadeout distance towards the outside.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    				js: "0.33.0",
    				android: "5.0.0",
    				ios: "3.5.0",
    				macos: "0.4.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"text-translate": {
    		type: "array",
    		value: "number",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		transition: true,
    		units: "pixels",
    		doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
    		requires: [
    			"text-field"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"text-translate-anchor": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The text is translated relative to the map."
    			},
    			viewport: {
    				doc: "The text is translated relative to the viewport."
    			}
    		},
    		doc: "Controls the frame of reference for `text-translate`.",
    		"default": "map",
    		requires: [
    			"text-field",
    			"text-translate"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	}
    };
    var paint_raster = {
    	"raster-opacity": {
    		type: "number",
    		doc: "The opacity at which the image will be drawn.",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"raster-hue-rotate": {
    		type: "number",
    		"default": 0,
    		period: 360,
    		transition: true,
    		units: "degrees",
    		doc: "Rotates hues around the color wheel.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"raster-brightness-min": {
    		type: "number",
    		doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
    		"default": 0,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"raster-brightness-max": {
    		type: "number",
    		doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"raster-saturation": {
    		type: "number",
    		doc: "Increase or reduce the saturation of the image.",
    		"default": 0,
    		minimum: -1,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"raster-contrast": {
    		type: "number",
    		doc: "Increase or reduce the contrast of the image.",
    		"default": 0,
    		minimum: -1,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"raster-resampling": {
    		type: "enum",
    		doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
    		values: {
    			linear: {
    				doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
    			},
    			nearest: {
    				doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
    			}
    		},
    		"default": "linear",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.47.0",
    				android: "6.3.0",
    				ios: "4.2.0",
    				macos: "0.9.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"raster-fade-duration": {
    		type: "number",
    		"default": 300,
    		minimum: 0,
    		transition: false,
    		units: "milliseconds",
    		doc: "Fade duration when a new tile is added.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	}
    };
    var paint_hillshade = {
    	"hillshade-illumination-direction": {
    		type: "number",
    		"default": 335,
    		minimum: 0,
    		maximum: 359,
    		doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
    		transition: false,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"hillshade-illumination-anchor": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The hillshade illumination is relative to the north direction."
    			},
    			viewport: {
    				doc: "The hillshade illumination is relative to the top of the viewport."
    			}
    		},
    		"default": "viewport",
    		doc: "Direction of light source when map is rotated.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"hillshade-exaggeration": {
    		type: "number",
    		doc: "Intensity of the hillshade",
    		"default": 0.5,
    		minimum: 0,
    		maximum: 1,
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"hillshade-shadow-color": {
    		type: "color",
    		"default": "#000000",
    		doc: "The shading color of areas that face away from the light source.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"hillshade-highlight-color": {
    		type: "color",
    		"default": "#FFFFFF",
    		doc: "The shading color of areas that faces towards the light source.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"hillshade-accent-color": {
    		type: "color",
    		"default": "#000000",
    		doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.43.0",
    				android: "6.0.0",
    				ios: "4.0.0",
    				macos: "0.7.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	}
    };
    var paint_background = {
    	"background-color": {
    		type: "color",
    		"default": "#000000",
    		doc: "The color with which the background will be drawn.",
    		transition: true,
    		requires: [
    			{
    				"!": "background-pattern"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"background-pattern": {
    		type: "resolvedImage",
    		transition: true,
    		doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			},
    			"data-driven styling": {
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "cross-faded"
    	},
    	"background-opacity": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		doc: "The opacity at which the background will be drawn.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.10.0",
    				android: "2.0.1",
    				ios: "2.0.0",
    				macos: "0.1.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	}
    };
    var paint_sky = {
    	"sky-type": {
    		type: "enum",
    		values: {
    			gradient: {
    				doc: "Renders the sky with a gradient that can be configured with `sky-gradient-radius` and `sky-gradient`."
    			},
    			atmosphere: {
    				doc: "Renders the sky with a simulated atmospheric scattering algorithm, the sun direction can be attached to the light position or explicitly set through `sky-atmosphere-sun`."
    			}
    		},
    		"default": "atmosphere",
    		doc: "The type of the sky",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"sky-atmosphere-sun": {
    		type: "array",
    		value: "number",
    		length: 2,
    		units: "degrees",
    		minimum: [
    			0,
    			0
    		],
    		maximum: [
    			360,
    			180
    		],
    		transition: false,
    		doc: "Position of the sun center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the sun relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the sun, where 0° is directly above, at zenith, and 90° at the horizon. When this property is ommitted, the sun center is directly inherited from the light position.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		requires: [
    			{
    				"sky-type": "atmosphere"
    			}
    		],
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"sky-atmosphere-sun-intensity": {
    		type: "number",
    		requires: [
    			{
    				"sky-type": "atmosphere"
    			}
    		],
    		"default": 10,
    		minimum: 0,
    		maximum: 100,
    		transition: false,
    		doc: "Intensity of the sun as a light source in the atmosphere (on a scale from 0 to a 100). Setting higher values will brighten up the sky.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		"property-type": "data-constant"
    	},
    	"sky-gradient-center": {
    		type: "array",
    		requires: [
    			{
    				"sky-type": "gradient"
    			}
    		],
    		value: "number",
    		"default": [
    			0,
    			0
    		],
    		length: 2,
    		units: "degrees",
    		minimum: [
    			0,
    			0
    		],
    		maximum: [
    			360,
    			180
    		],
    		transition: false,
    		doc: "Position of the gradient center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the gradient center relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the gradient center, where 0° is directly above, at zenith, and 90° at the horizon.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"sky-gradient-radius": {
    		type: "number",
    		requires: [
    			{
    				"sky-type": "gradient"
    			}
    		],
    		"default": 90,
    		minimum: 0,
    		maximum: 180,
    		transition: false,
    		doc: "The angular distance (measured in degrees) from `sky-gradient-center` up to which the gradient extends. A value of 180 causes the gradient to wrap around to the opposite direction from `sky-gradient-center`.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"sky-gradient": {
    		type: "color",
    		"default": [
    			"interpolate",
    			[
    				"linear"
    			],
    			[
    				"sky-radial-progress"
    			],
    			0.8,
    			"#87ceeb",
    			1,
    			"white"
    		],
    		doc: "Defines a radial color gradient with which to color the sky. The color values can be interpolated with an expression using `sky-radial-progress`. The range [0, 1] for the interpolant covers a radial distance (in degrees) of [0, `sky-gradient-radius`] centered at the position specified by `sky-gradient-center`.",
    		transition: false,
    		requires: [
    			{
    				"sky-type": "gradient"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			},
    			"data-driven styling": {
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"sky-radial-progress"
    			]
    		},
    		"property-type": "color-ramp"
    	},
    	"sky-atmosphere-halo-color": {
    		type: "color",
    		"default": "white",
    		doc: "A color applied to the atmosphere sun halo. The alpha channel describes how strongly the sun halo is represented in an atmosphere sky layer.",
    		transition: false,
    		requires: [
    			{
    				"sky-type": "atmosphere"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		"property-type": "data-constant"
    	},
    	"sky-atmosphere-color": {
    		type: "color",
    		"default": "white",
    		doc: "A color used to tweak the main atmospheric scattering coefficients. Using white applies the default coefficients giving the natural blue color to the atmosphere. This color affects how heavily the corresponding wavelength is represented during scattering. The alpha channel describes the density of the atmosphere, with 1 maximum density and 0 no density.",
    		transition: false,
    		requires: [
    			{
    				"sky-type": "atmosphere"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		"property-type": "data-constant"
    	},
    	"sky-opacity": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		doc: "The opacity of the entire sky layer.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "2.0.0",
    				ios: "10.0.0",
    				android: "10.0.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	}
    };
    var transition = {
    	duration: {
    		type: "number",
    		"default": 300,
    		minimum: 0,
    		units: "milliseconds",
    		doc: "Time allotted for transitions to complete."
    	},
    	delay: {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		units: "milliseconds",
    		doc: "Length of time before a transition begins."
    	}
    };
    var promoteId = {
    	"*": {
    		type: "string",
    		doc: "A name of a feature property to use as ID for feature state."
    	}
    };
    var v8 = {
    	$version: $version,
    	$root: $root,
    	sources: sources,
    	source: source,
    	source_vector: source_vector,
    	source_raster: source_raster,
    	source_raster_dem: source_raster_dem,
    	source_geojson: source_geojson,
    	source_video: source_video,
    	source_image: source_image,
    	layer: layer,
    	layout: layout,
    	layout_background: layout_background,
    	layout_sky: layout_sky,
    	layout_fill: layout_fill,
    	layout_circle: layout_circle,
    	layout_heatmap: layout_heatmap,
    	"layout_fill-extrusion": {
    	visibility: {
    		type: "enum",
    		values: {
    			visible: {
    				doc: "The layer is shown."
    			},
    			none: {
    				doc: "The layer is not shown."
    			}
    		},
    		"default": "visible",
    		doc: "Whether this layer is displayed.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		"property-type": "constant"
    	}
    },
    	layout_line: layout_line,
    	layout_symbol: layout_symbol,
    	layout_raster: layout_raster,
    	layout_hillshade: layout_hillshade,
    	filter: filter,
    	filter_symbol: filter_symbol,
    	filter_fill: filter_fill,
    	filter_line: filter_line,
    	filter_circle: filter_circle,
    	"filter_fill-extrusion": {
    	type: "boolean",
    	doc: "Expression which determines whether or not to display a Polygon. Fill-extrusion layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    	"default": false,
    	transition: false,
    	"property-type": "data-driven",
    	expression: {
    		interpolated: false,
    		parameters: [
    			"zoom",
    			"feature"
    		]
    	}
    },
    	filter_heatmap: filter_heatmap,
    	filter_operator: filter_operator,
    	geometry_type: geometry_type,
    	"function": {
    	expression: {
    		type: "expression",
    		doc: "An expression."
    	},
    	stops: {
    		type: "array",
    		doc: "An array of stops.",
    		value: "function_stop"
    	},
    	base: {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    	},
    	property: {
    		type: "string",
    		doc: "The name of a feature property to use as the function input.",
    		"default": "$zoom"
    	},
    	type: {
    		type: "enum",
    		values: {
    			identity: {
    				doc: "Return the input value as the output value."
    			},
    			exponential: {
    				doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
    			},
    			interval: {
    				doc: "Return the output value of the stop just less than the function input."
    			},
    			categorical: {
    				doc: "Return the output value of the stop equal to the function input."
    			}
    		},
    		doc: "The interpolation strategy to use in function evaluation.",
    		"default": "exponential"
    	},
    	colorSpace: {
    		type: "enum",
    		values: {
    			rgb: {
    				doc: "Use the RGB color space to interpolate color values"
    			},
    			lab: {
    				doc: "Use the LAB color space to interpolate color values."
    			},
    			hcl: {
    				doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
    			}
    		},
    		doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
    		"default": "rgb"
    	},
    	"default": {
    		type: "*",
    		required: false,
    		doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
    	}
    },
    	function_stop: function_stop,
    	expression: expression$1,
    	expression_name: expression_name,
    	fog: fog,
    	light: light,
    	projection: projection,
    	terrain: terrain,
    	paint: paint,
    	paint_fill: paint_fill,
    	"paint_fill-extrusion": {
    	"fill-extrusion-opacity": {
    		type: "number",
    		"default": 1,
    		minimum: 0,
    		maximum: 1,
    		doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"fill-extrusion-color": {
    		type: "color",
    		"default": "#000000",
    		doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
    		transition: true,
    		requires: [
    			{
    				"!": "fill-extrusion-pattern"
    			}
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			},
    			"data-driven styling": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"fill-extrusion-translate": {
    		type: "array",
    		value: "number",
    		length: 2,
    		"default": [
    			0,
    			0
    		],
    		transition: true,
    		units: "pixels",
    		doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"fill-extrusion-translate-anchor": {
    		type: "enum",
    		values: {
    			map: {
    				doc: "The fill extrusion is translated relative to the map."
    			},
    			viewport: {
    				doc: "The fill extrusion is translated relative to the viewport."
    			}
    		},
    		doc: "Controls the frame of reference for `fill-extrusion-translate`.",
    		"default": "map",
    		requires: [
    			"fill-extrusion-translate"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	},
    	"fill-extrusion-pattern": {
    		type: "resolvedImage",
    		transition: true,
    		doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			},
    			"data-driven styling": {
    				js: "0.49.0",
    				android: "6.5.0",
    				macos: "0.11.0",
    				ios: "4.4.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom",
    				"feature"
    			]
    		},
    		"property-type": "cross-faded-data-driven"
    	},
    	"fill-extrusion-height": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		units: "meters",
    		doc: "The height with which to extrude this layer.",
    		transition: true,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			},
    			"data-driven styling": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"fill-extrusion-base": {
    		type: "number",
    		"default": 0,
    		minimum: 0,
    		units: "meters",
    		doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
    		transition: true,
    		requires: [
    			"fill-extrusion-height"
    		],
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			},
    			"data-driven styling": {
    				js: "0.27.0",
    				android: "5.1.0",
    				ios: "3.6.0",
    				macos: "0.5.0"
    			}
    		},
    		expression: {
    			interpolated: true,
    			parameters: [
    				"zoom",
    				"feature",
    				"feature-state"
    			]
    		},
    		"property-type": "data-driven"
    	},
    	"fill-extrusion-vertical-gradient": {
    		type: "boolean",
    		"default": true,
    		doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
    		transition: false,
    		"sdk-support": {
    			"basic functionality": {
    				js: "0.50.0",
    				android: "7.0.0",
    				ios: "4.7.0",
    				macos: "0.13.0"
    			}
    		},
    		expression: {
    			interpolated: false,
    			parameters: [
    				"zoom"
    			]
    		},
    		"property-type": "data-constant"
    	}
    },
    	paint_line: paint_line,
    	paint_circle: paint_circle,
    	paint_heatmap: paint_heatmap,
    	paint_symbol: paint_symbol,
    	paint_raster: paint_raster,
    	paint_hillshade: paint_hillshade,
    	paint_background: paint_background,
    	paint_sky: paint_sky,
    	transition: transition,
    	"property-type": {
    	"data-driven": {
    		type: "property-type",
    		doc: "Property is interpolable and can be represented using a property expression."
    	},
    	"cross-faded": {
    		type: "property-type",
    		doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."
    	},
    	"cross-faded-data-driven": {
    		type: "property-type",
    		doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."
    	},
    	"color-ramp": {
    		type: "property-type",
    		doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
    	},
    	"data-constant": {
    		type: "property-type",
    		doc: "Property is interpolable but cannot be represented using a property expression."
    	},
    	constant: {
    		type: "property-type",
    		doc: "Property is constant across all zoom levels and property values."
    	}
    },
    	promoteId: promoteId
    };

    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule$1(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    function commonjsRequire (target) {
    	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
    }

    /*! https://mths.be/punycode v1.3.2 by @mathias */

    var punycode = createCommonjsModule$1(function (module, exports) {
    (function(root) {

    	/** Detect free variables */
    	var freeExports = exports &&
    		!exports.nodeType && exports;
    	var freeModule = module &&
    		!module.nodeType && module;
    	var freeGlobal = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1;
    	if (
    		freeGlobal.global === freeGlobal ||
    		freeGlobal.window === freeGlobal ||
    		freeGlobal.self === freeGlobal
    	) {
    		root = freeGlobal;
    	}

    	/**
    	 * The `punycode` object.
    	 * @name punycode
    	 * @type Object
    	 */
    	var punycode,

    	/** Highest positive signed 32-bit float value */
    	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

    	/** Bootstring parameters */
    	base = 36,
    	tMin = 1,
    	tMax = 26,
    	skew = 38,
    	damp = 700,
    	initialBias = 72,
    	initialN = 128, // 0x80
    	delimiter = '-', // '\x2D'

    	/** Regular expressions */
    	regexPunycode = /^xn--/,
    	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
    	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

    	/** Error messages */
    	errors = {
    		'overflow': 'Overflow: input needs wider integers to process',
    		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    		'invalid-input': 'Invalid input'
    	},

    	/** Convenience shortcuts */
    	baseMinusTMin = base - tMin,
    	floor = Math.floor,
    	stringFromCharCode = String.fromCharCode,

    	/** Temporary variable */
    	key;

    	/*--------------------------------------------------------------------------*/

    	/**
    	 * A generic error utility function.
    	 * @private
    	 * @param {String} type The error type.
    	 * @returns {Error} Throws a `RangeError` with the applicable error message.
    	 */
    	function error(type) {
    		throw RangeError(errors[type]);
    	}

    	/**
    	 * A generic `Array#map` utility function.
    	 * @private
    	 * @param {Array} array The array to iterate over.
    	 * @param {Function} callback The function that gets called for every array
    	 * item.
    	 * @returns {Array} A new array of values returned by the callback function.
    	 */
    	function map(array, fn) {
    		var length = array.length;
    		var result = [];
    		while (length--) {
    			result[length] = fn(array[length]);
    		}
    		return result;
    	}

    	/**
    	 * A simple `Array#map`-like wrapper to work with domain name strings or email
    	 * addresses.
    	 * @private
    	 * @param {String} domain The domain name or email address.
    	 * @param {Function} callback The function that gets called for every
    	 * character.
    	 * @returns {Array} A new string of characters returned by the callback
    	 * function.
    	 */
    	function mapDomain(string, fn) {
    		var parts = string.split('@');
    		var result = '';
    		if (parts.length > 1) {
    			// In email addresses, only the domain name should be punycoded. Leave
    			// the local part (i.e. everything up to `@`) intact.
    			result = parts[0] + '@';
    			string = parts[1];
    		}
    		// Avoid `split(regex)` for IE8 compatibility. See #17.
    		string = string.replace(regexSeparators, '\x2E');
    		var labels = string.split('.');
    		var encoded = map(labels, fn).join('.');
    		return result + encoded;
    	}

    	/**
    	 * Creates an array containing the numeric code points of each Unicode
    	 * character in the string. While JavaScript uses UCS-2 internally,
    	 * this function will convert a pair of surrogate halves (each of which
    	 * UCS-2 exposes as separate characters) into a single code point,
    	 * matching UTF-16.
    	 * @see `punycode.ucs2.encode`
    	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
    	 * @memberOf punycode.ucs2
    	 * @name decode
    	 * @param {String} string The Unicode input string (UCS-2).
    	 * @returns {Array} The new array of code points.
    	 */
    	function ucs2decode(string) {
    		var output = [],
    		    counter = 0,
    		    length = string.length,
    		    value,
    		    extra;
    		while (counter < length) {
    			value = string.charCodeAt(counter++);
    			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    				// high surrogate, and there is a next character
    				extra = string.charCodeAt(counter++);
    				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
    					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    				} else {
    					// unmatched surrogate; only append this code unit, in case the next
    					// code unit is the high surrogate of a surrogate pair
    					output.push(value);
    					counter--;
    				}
    			} else {
    				output.push(value);
    			}
    		}
    		return output;
    	}

    	/**
    	 * Creates a string based on an array of numeric code points.
    	 * @see `punycode.ucs2.decode`
    	 * @memberOf punycode.ucs2
    	 * @name encode
    	 * @param {Array} codePoints The array of numeric code points.
    	 * @returns {String} The new Unicode string (UCS-2).
    	 */
    	function ucs2encode(array) {
    		return map(array, function(value) {
    			var output = '';
    			if (value > 0xFFFF) {
    				value -= 0x10000;
    				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
    				value = 0xDC00 | value & 0x3FF;
    			}
    			output += stringFromCharCode(value);
    			return output;
    		}).join('');
    	}

    	/**
    	 * Converts a basic code point into a digit/integer.
    	 * @see `digitToBasic()`
    	 * @private
    	 * @param {Number} codePoint The basic numeric code point value.
    	 * @returns {Number} The numeric value of a basic code point (for use in
    	 * representing integers) in the range `0` to `base - 1`, or `base` if
    	 * the code point does not represent a value.
    	 */
    	function basicToDigit(codePoint) {
    		if (codePoint - 48 < 10) {
    			return codePoint - 22;
    		}
    		if (codePoint - 65 < 26) {
    			return codePoint - 65;
    		}
    		if (codePoint - 97 < 26) {
    			return codePoint - 97;
    		}
    		return base;
    	}

    	/**
    	 * Converts a digit/integer into a basic code point.
    	 * @see `basicToDigit()`
    	 * @private
    	 * @param {Number} digit The numeric value of a basic code point.
    	 * @returns {Number} The basic code point whose value (when used for
    	 * representing integers) is `digit`, which needs to be in the range
    	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
    	 * used; else, the lowercase form is used. The behavior is undefined
    	 * if `flag` is non-zero and `digit` has no uppercase form.
    	 */
    	function digitToBasic(digit, flag) {
    		//  0..25 map to ASCII a..z or A..Z
    		// 26..35 map to ASCII 0..9
    		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    	}

    	/**
    	 * Bias adaptation function as per section 3.4 of RFC 3492.
    	 * http://tools.ietf.org/html/rfc3492#section-3.4
    	 * @private
    	 */
    	function adapt(delta, numPoints, firstTime) {
    		var k = 0;
    		delta = firstTime ? floor(delta / damp) : delta >> 1;
    		delta += floor(delta / numPoints);
    		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
    			delta = floor(delta / baseMinusTMin);
    		}
    		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    	}

    	/**
    	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
    	 * symbols.
    	 * @memberOf punycode
    	 * @param {String} input The Punycode string of ASCII-only symbols.
    	 * @returns {String} The resulting string of Unicode symbols.
    	 */
    	function decode(input) {
    		// Don't use UCS-2
    		var output = [],
    		    inputLength = input.length,
    		    out,
    		    i = 0,
    		    n = initialN,
    		    bias = initialBias,
    		    basic,
    		    j,
    		    index,
    		    oldi,
    		    w,
    		    k,
    		    digit,
    		    t,
    		    /** Cached calculation results */
    		    baseMinusT;

    		// Handle the basic code points: let `basic` be the number of input code
    		// points before the last delimiter, or `0` if there is none, then copy
    		// the first basic code points to the output.

    		basic = input.lastIndexOf(delimiter);
    		if (basic < 0) {
    			basic = 0;
    		}

    		for (j = 0; j < basic; ++j) {
    			// if it's not a basic code point
    			if (input.charCodeAt(j) >= 0x80) {
    				error('not-basic');
    			}
    			output.push(input.charCodeAt(j));
    		}

    		// Main decoding loop: start just after the last delimiter if any basic code
    		// points were copied; start at the beginning otherwise.

    		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

    			// `index` is the index of the next character to be consumed.
    			// Decode a generalized variable-length integer into `delta`,
    			// which gets added to `i`. The overflow checking is easier
    			// if we increase `i` as we go, then subtract off its starting
    			// value at the end to obtain `delta`.
    			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

    				if (index >= inputLength) {
    					error('invalid-input');
    				}

    				digit = basicToDigit(input.charCodeAt(index++));

    				if (digit >= base || digit > floor((maxInt - i) / w)) {
    					error('overflow');
    				}

    				i += digit * w;
    				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

    				if (digit < t) {
    					break;
    				}

    				baseMinusT = base - t;
    				if (w > floor(maxInt / baseMinusT)) {
    					error('overflow');
    				}

    				w *= baseMinusT;

    			}

    			out = output.length + 1;
    			bias = adapt(i - oldi, out, oldi == 0);

    			// `i` was supposed to wrap around from `out` to `0`,
    			// incrementing `n` each time, so we'll fix that now:
    			if (floor(i / out) > maxInt - n) {
    				error('overflow');
    			}

    			n += floor(i / out);
    			i %= out;

    			// Insert `n` at position `i` of the output
    			output.splice(i++, 0, n);

    		}

    		return ucs2encode(output);
    	}

    	/**
    	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
    	 * Punycode string of ASCII-only symbols.
    	 * @memberOf punycode
    	 * @param {String} input The string of Unicode symbols.
    	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
    	 */
    	function encode(input) {
    		var n,
    		    delta,
    		    handledCPCount,
    		    basicLength,
    		    bias,
    		    j,
    		    m,
    		    q,
    		    k,
    		    t,
    		    currentValue,
    		    output = [],
    		    /** `inputLength` will hold the number of code points in `input`. */
    		    inputLength,
    		    /** Cached calculation results */
    		    handledCPCountPlusOne,
    		    baseMinusT,
    		    qMinusT;

    		// Convert the input in UCS-2 to Unicode
    		input = ucs2decode(input);

    		// Cache the length
    		inputLength = input.length;

    		// Initialize the state
    		n = initialN;
    		delta = 0;
    		bias = initialBias;

    		// Handle the basic code points
    		for (j = 0; j < inputLength; ++j) {
    			currentValue = input[j];
    			if (currentValue < 0x80) {
    				output.push(stringFromCharCode(currentValue));
    			}
    		}

    		handledCPCount = basicLength = output.length;

    		// `handledCPCount` is the number of code points that have been handled;
    		// `basicLength` is the number of basic code points.

    		// Finish the basic string - if it is not empty - with a delimiter
    		if (basicLength) {
    			output.push(delimiter);
    		}

    		// Main encoding loop:
    		while (handledCPCount < inputLength) {

    			// All non-basic code points < n have been handled already. Find the next
    			// larger one:
    			for (m = maxInt, j = 0; j < inputLength; ++j) {
    				currentValue = input[j];
    				if (currentValue >= n && currentValue < m) {
    					m = currentValue;
    				}
    			}

    			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    			// but guard against overflow
    			handledCPCountPlusOne = handledCPCount + 1;
    			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
    				error('overflow');
    			}

    			delta += (m - n) * handledCPCountPlusOne;
    			n = m;

    			for (j = 0; j < inputLength; ++j) {
    				currentValue = input[j];

    				if (currentValue < n && ++delta > maxInt) {
    					error('overflow');
    				}

    				if (currentValue == n) {
    					// Represent delta as a generalized variable-length integer
    					for (q = delta, k = base; /* no condition */; k += base) {
    						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    						if (q < t) {
    							break;
    						}
    						qMinusT = q - t;
    						baseMinusT = base - t;
    						output.push(
    							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
    						);
    						q = floor(qMinusT / baseMinusT);
    					}

    					output.push(stringFromCharCode(digitToBasic(q, 0)));
    					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
    					delta = 0;
    					++handledCPCount;
    				}
    			}

    			++delta;
    			++n;

    		}
    		return output.join('');
    	}

    	/**
    	 * Converts a Punycode string representing a domain name or an email address
    	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
    	 * it doesn't matter if you call it on a string that has already been
    	 * converted to Unicode.
    	 * @memberOf punycode
    	 * @param {String} input The Punycoded domain name or email address to
    	 * convert to Unicode.
    	 * @returns {String} The Unicode representation of the given Punycode
    	 * string.
    	 */
    	function toUnicode(input) {
    		return mapDomain(input, function(string) {
    			return regexPunycode.test(string)
    				? decode(string.slice(4).toLowerCase())
    				: string;
    		});
    	}

    	/**
    	 * Converts a Unicode string representing a domain name or an email address to
    	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
    	 * i.e. it doesn't matter if you call it with a domain that's already in
    	 * ASCII.
    	 * @memberOf punycode
    	 * @param {String} input The domain name or email address to convert, as a
    	 * Unicode string.
    	 * @returns {String} The Punycode representation of the given domain name or
    	 * email address.
    	 */
    	function toASCII(input) {
    		return mapDomain(input, function(string) {
    			return regexNonASCII.test(string)
    				? 'xn--' + encode(string)
    				: string;
    		});
    	}

    	/*--------------------------------------------------------------------------*/

    	/** Define the public API */
    	punycode = {
    		/**
    		 * A string representing the current Punycode.js version number.
    		 * @memberOf punycode
    		 * @type String
    		 */
    		'version': '1.3.2',
    		/**
    		 * An object of methods to convert from JavaScript's internal character
    		 * representation (UCS-2) to Unicode code points, and back.
    		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
    		 * @memberOf punycode
    		 * @type Object
    		 */
    		'ucs2': {
    			'decode': ucs2decode,
    			'encode': ucs2encode
    		},
    		'decode': decode,
    		'encode': encode,
    		'toASCII': toASCII,
    		'toUnicode': toUnicode
    	};

    	/** Expose `punycode` */
    	// Some AMD build optimizers, like r.js, check for specific condition patterns
    	// like the following:
    	if (freeExports && freeModule) {
    		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
    			freeModule.exports = punycode;
    		} else { // in Narwhal or RingoJS v0.7.0-
    			for (key in punycode) {
    				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    			}
    		}
    	} else { // in Rhino or a web browser
    		root.punycode = punycode;
    	}

    }(commonjsGlobal$1));
    });

    var util = {
      isString: function(arg) {
        return typeof(arg) === 'string';
      },
      isObject: function(arg) {
        return typeof(arg) === 'object' && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };

    // Copyright Joyent, Inc. and other Node contributors.

    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var decode = function(qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }

      var regexp = /\+/g;
      qs = qs.split(sep);

      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }

      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr, vstr, k, v;

        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }

      return obj;
    };

    // Copyright Joyent, Inc. and other Node contributors.

    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case 'string':
          return v;

        case 'boolean':
          return v ? 'true' : 'false';

        case 'number':
          return isFinite(v) ? v : '';

        default:
          return '';
      }
    };

    var encode = function(obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }

      if (typeof obj === 'object') {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);

      }

      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
             encodeURIComponent(stringifyPrimitive(obj));
    };

    var querystring = createCommonjsModule$1(function (module, exports) {

    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
    });

    var parse = urlParse;
    var resolve = urlResolve;
    var resolveObject = urlResolveObject;
    var format = urlFormat;

    var Url_1 = Url;

    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }

    // Reference: RFC 3986, RFC 1808, RFC 2396

    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,

        // Special case for a simple path URL
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

        // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

        // RFC 2396: characters not allowed for various reasons.
        unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = ['\''].concat(unwise),
        // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
        hostEndingChars = ['/', '?', '#'],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
        unsafeProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that never have a hostname.
        hostlessProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that always contain a // bit.
        slashedProtocol = {
          'http': true,
          'https': true,
          'ftp': true,
          'gopher': true,
          'file': true,
          'http:': true,
          'https:': true,
          'ftp:': true,
          'gopher:': true,
          'file:': true
        };

    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url) return url;

      var u = new Url;
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }

    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }

      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
          splitter =
              (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
          uSplit = url.split(splitter),
          slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);

      var rest = url;

      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();

      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          return this;
        }
      }

      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }

      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }

      if (!hostlessProtocol[proto] &&
          (slashes || (proto && !slashedProtocol[proto]))) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1)
          hostEnd = rest.length;

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' &&
            this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        } else {
          // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }

      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }


      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
      }
      if (rest) this.pathname = rest;
      if (slashedProtocol[lowerProto] &&
          this.hostname && !this.pathname) {
        this.pathname = '/';
      }

      //to support http.request
      if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
      }

      // finally, reconstruct the href based on what has been validated.
      this.href = this.format();
      return this;
    };

    // format a parsed object into a url string
    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (util.isString(obj)) obj = urlParse(obj);
      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
      return obj.format();
    }

    Url.prototype.format = function() {
      var auth = this.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }

      var protocol = this.protocol || '',
          pathname = this.pathname || '',
          hash = this.hash || '',
          host = false,
          query = '';

      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ?
            this.hostname :
            '[' + this.hostname + ']');
        if (this.port) {
          host += ':' + this.port;
        }
      }

      if (this.query &&
          util.isObject(this.query) &&
          Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }

      var search = this.search || (query && ('?' + query)) || '';

      if (protocol && protocol.substr(-1) !== ':') protocol += ':';

      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (this.slashes ||
          (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;

      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');

      return protocol + host + pathname + search + hash;
    };

    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }

    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };

    function urlResolveObject(source, relative) {
      if (!source) return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }

    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }

      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }

      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;

      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }

      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] &&
            result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
      }

      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }

      var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
          isRelAbs = (
              relative.host ||
              relative.pathname && relative.pathname.charAt(0) === '/'
          ),
          mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname)),
          removeAllDots = mustEndAbs,
          srcPath = result.pathname && result.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol];

      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;
          else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;
            else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }

      if (isRelAbs) {
        // it's absolute.
        result.host = (relative.host || relative.host === '') ?
                      relative.host : result.host;
        result.hostname = (relative.hostname || relative.hostname === '') ?
                          relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ?
                           result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }

      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }

      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (
          (result.host || relative.host || srcPath.length > 1) &&
          (last === '.' || last === '..') || last === '');

      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }

      if (mustEndAbs && srcPath[0] !== '' &&
          (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }

      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('');
      }

      var isAbsolute = srcPath[0] === '' ||
          (srcPath[0] && srcPath[0].charAt(0) === '/');

      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' :
                                        srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                         result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }

      mustEndAbs = mustEndAbs || (result.host && srcPath.length);

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }

      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }

      //to support request.http
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
                      (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };

    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) this.hostname = host;
    };

    var url = {
    	parse: parse,
    	resolve: resolve,
    	resolveObject: resolveObject,
    	format: format,
    	Url: Url_1
    };

    function getPropertyReference(propertyName) {
        for (let i = 0; i < v8.layout.length; i++) {
            for (const key in v8[v8.layout[i]]) {
                if (key === propertyName)
                    return v8[v8.layout[i]][key];
            }
        }
        for (let i = 0; i < v8.paint.length; i++) {
            for (const key in v8[v8.paint[i]]) {
                if (key === propertyName)
                    return v8[v8.paint[i]][key];
            }
        }
        return null;
    }
    function eachSource(style, callback) {
        for (const k in style.sources) {
            callback(style.sources[k]);
        }
    }
    function eachLayer(style, callback) {
        for (const layer of style.layers) {
            callback(layer);
        }
    }
    function eachProperty(style, options, callback) {
        function inner(layer, propertyType) {
            const properties = layer[propertyType];
            if (!properties)
                return;
            Object.keys(properties).forEach(key => {
                callback({
                    path: [
                        layer.id,
                        propertyType,
                        key
                    ],
                    key,
                    value: properties[key],
                    reference: getPropertyReference(key),
                    set(x) {
                        properties[key] = x;
                    }
                });
            });
        }
        eachLayer(style, layer => {
            if (options.paint) {
                inner(layer, 'paint');
            }
            if (options.layout) {
                inner(layer, 'layout');
            }
        });
    }

    function eachLayout(layer, callback) {
        for (const k in layer) {
            if (k.indexOf('layout') === 0) {
                callback(layer[k], k);
            }
        }
    }
    function eachPaint(layer, callback) {
        for (const k in layer) {
            if (k.indexOf('paint') === 0) {
                callback(layer[k], k);
            }
        }
    }
    function resolveConstant(style, value) {
        if (typeof value === 'string' && value[0] === '@') {
            return resolveConstant(style, style.constants[value]);
        } else {
            return value;
        }
    }
    function isFunction$1(value) {
        return Array.isArray(value.stops);
    }
    function renameProperty(obj, from, to) {
        obj[to] = obj[from];
        delete obj[from];
    }
    function migrateToV8 (style) {
        style.version = 8;
        eachSource(style, source => {
            if (source.type === 'video' && source.url !== undefined) {
                renameProperty(source, 'url', 'urls');
            }
            if (source.type === 'video') {
                source.coordinates.forEach(coord => {
                    return coord.reverse();
                });
            }
        });
        eachLayer(style, layer => {
            eachLayout(layer, layout => {
                if (layout['symbol-min-distance'] !== undefined) {
                    renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');
                }
            });
            eachPaint(layer, paint => {
                if (paint['background-image'] !== undefined) {
                    renameProperty(paint, 'background-image', 'background-pattern');
                }
                if (paint['line-image'] !== undefined) {
                    renameProperty(paint, 'line-image', 'line-pattern');
                }
                if (paint['fill-image'] !== undefined) {
                    renameProperty(paint, 'fill-image', 'fill-pattern');
                }
            });
        });
        eachProperty(style, {
            paint: true,
            layout: true
        }, property => {
            const value = resolveConstant(style, property.value);
            if (isFunction$1(value)) {
                value.stops.forEach(stop => {
                    stop[1] = resolveConstant(style, stop[1]);
                });
            }
            property.set(value);
        });
        delete style.constants;
        eachLayer(style, layer => {
            eachLayout(layer, layout => {
                delete layout['text-max-size'];
                delete layout['icon-max-size'];
            });
            eachPaint(layer, paint => {
                if (paint['text-size']) {
                    if (!layer.layout)
                        layer.layout = {};
                    layer.layout['text-size'] = paint['text-size'];
                    delete paint['text-size'];
                }
                if (paint['icon-size']) {
                    if (!layer.layout)
                        layer.layout = {};
                    layer.layout['icon-size'] = paint['icon-size'];
                    delete paint['icon-size'];
                }
            });
        });
        function migrateFontstackURL(input) {
            const inputParsed = url.parse(input);
            const inputPathnameParts = inputParsed.pathname.split('/');
            if (inputParsed.protocol !== 'mapbox:') {
                return input;
            } else if (inputParsed.hostname === 'fontstack') {
                return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';
            } else if (inputParsed.hostname === 'fonts') {
                return `mapbox://fonts/${ inputPathnameParts[2] }/{fontstack}/{range}.pbf`;
            } else ;
        }
        if (style.glyphs) {
            style.glyphs = migrateFontstackURL(style.glyphs);
        }
        function migrateFontStack(font) {
            function splitAndTrim(string) {
                return string.split(',').map(s => {
                    return s.trim();
                });
            }
            if (Array.isArray(font)) {
                return font;
            } else if (typeof font === 'string') {
                return splitAndTrim(font);
            } else if (typeof font === 'object') {
                font.stops.forEach(stop => {
                    stop[1] = splitAndTrim(stop[1]);
                });
                return font;
            } else {
                throw new Error('unexpected font value');
            }
        }
        eachLayer(style, layer => {
            eachLayout(layer, layout => {
                if (layout['text-font']) {
                    layout['text-font'] = migrateFontStack(layout['text-font']);
                }
            });
        });
        let firstSymbolLayer = 0;
        for (let i = style.layers.length - 1; i >= 0; i--) {
            const layer = style.layers[i];
            if (layer.type !== 'symbol') {
                firstSymbolLayer = i + 1;
                break;
            }
        }
        const symbolLayers = style.layers.splice(firstSymbolLayer);
        symbolLayers.reverse();
        style.layers = style.layers.concat(symbolLayers);
        return style;
    }

    class ParsingError$1 extends Error {
        constructor(key, message) {
            super(message);
            this.message = message;
            this.key = key;
        }
    }
    var ParsingError$2 = ParsingError$1;

    class Scope {
        constructor(parent, bindings = []) {
            this.parent = parent;
            this.bindings = {};
            for (const [name, expression] of bindings) {
                this.bindings[name] = expression;
            }
        }
        concat(bindings) {
            return new Scope(this, bindings);
        }
        get(name) {
            if (this.bindings[name]) {
                return this.bindings[name];
            }
            if (this.parent) {
                return this.parent.get(name);
            }
            throw new Error(`${ name } not found in scope.`);
        }
        has(name) {
            if (this.bindings[name])
                return true;
            return this.parent ? this.parent.has(name) : false;
        }
    }
    var Scope$1 = Scope;

    const NullType = { kind: 'null' };
    const NumberType = { kind: 'number' };
    const StringType = { kind: 'string' };
    const BooleanType = { kind: 'boolean' };
    const ColorType = { kind: 'color' };
    const ObjectType = { kind: 'object' };
    const ValueType = { kind: 'value' };
    const ErrorType = { kind: 'error' };
    const CollatorType = { kind: 'collator' };
    const FormattedType = { kind: 'formatted' };
    const ResolvedImageType = { kind: 'resolvedImage' };
    function array$1(itemType, N) {
        return {
            kind: 'array',
            itemType,
            N
        };
    }
    function toString$1(type) {
        if (type.kind === 'array') {
            const itemType = toString$1(type.itemType);
            return typeof type.N === 'number' ? `array<${ itemType }, ${ type.N }>` : type.itemType.kind === 'value' ? 'array' : `array<${ itemType }>`;
        } else {
            return type.kind;
        }
    }
    const valueMemberTypes = [
        NullType,
        NumberType,
        StringType,
        BooleanType,
        ColorType,
        FormattedType,
        ObjectType,
        array$1(ValueType),
        ResolvedImageType
    ];
    function checkSubtype(expected, t) {
        if (t.kind === 'error') {
            return null;
        } else if (expected.kind === 'array') {
            if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
                return null;
            }
        } else if (expected.kind === t.kind) {
            return null;
        } else if (expected.kind === 'value') {
            for (const memberType of valueMemberTypes) {
                if (!checkSubtype(memberType, t)) {
                    return null;
                }
            }
        }
        return `Expected ${ toString$1(expected) } but found ${ toString$1(t) } instead.`;
    }
    function isValidType(provided, allowedTypes) {
        return allowedTypes.some(t => t.kind === provided.kind);
    }
    function isValidNativeType(provided, allowedTypes) {
        return allowedTypes.some(t => {
            if (t === 'null') {
                return provided === null;
            } else if (t === 'array') {
                return Array.isArray(provided);
            } else if (t === 'object') {
                return provided && !Array.isArray(provided) && typeof provided === 'object';
            } else {
                return t === typeof provided;
            }
        });
    }

    var csscolorparser = createCommonjsModule$1(function (module, exports) {
    // (c) Dean McNamee <dean@gmail.com>, 2012.
    //
    // https://github.com/deanm/css-color-parser-js
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    // IN THE SOFTWARE.

    // http://www.w3.org/TR/css3-color/
    var kCSSColorTable = {
      "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
      "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
      "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
      "beige": [245,245,220,1], "bisque": [255,228,196,1],
      "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
      "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
      "brown": [165,42,42,1], "burlywood": [222,184,135,1],
      "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
      "chocolate": [210,105,30,1], "coral": [255,127,80,1],
      "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
      "crimson": [220,20,60,1], "cyan": [0,255,255,1],
      "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
      "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
      "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
      "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
      "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
      "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
      "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
      "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
      "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
      "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
      "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
      "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
      "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
      "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
      "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
      "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
      "gray": [128,128,128,1], "green": [0,128,0,1],
      "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
      "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
      "indianred": [205,92,92,1], "indigo": [75,0,130,1],
      "ivory": [255,255,240,1], "khaki": [240,230,140,1],
      "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
      "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
      "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
      "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
      "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
      "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
      "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
      "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
      "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
      "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
      "limegreen": [50,205,50,1], "linen": [250,240,230,1],
      "magenta": [255,0,255,1], "maroon": [128,0,0,1],
      "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
      "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
      "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
      "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
      "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
      "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
      "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
      "navy": [0,0,128,1], "oldlace": [253,245,230,1],
      "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
      "orange": [255,165,0,1], "orangered": [255,69,0,1],
      "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
      "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
      "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
      "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
      "pink": [255,192,203,1], "plum": [221,160,221,1],
      "powderblue": [176,224,230,1], "purple": [128,0,128,1],
      "rebeccapurple": [102,51,153,1],
      "red": [255,0,0,1], "rosybrown": [188,143,143,1],
      "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
      "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
      "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
      "sienna": [160,82,45,1], "silver": [192,192,192,1],
      "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
      "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
      "snow": [255,250,250,1], "springgreen": [0,255,127,1],
      "steelblue": [70,130,180,1], "tan": [210,180,140,1],
      "teal": [0,128,128,1], "thistle": [216,191,216,1],
      "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
      "violet": [238,130,238,1], "wheat": [245,222,179,1],
      "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
      "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]};

    function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
      i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
      return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
      return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parse_css_int(str) {  // int or percentage.
      if (str[str.length - 1] === '%')
        return clamp_css_byte(parseFloat(str) / 100 * 255);
      return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {  // float or percentage.
      if (str[str.length - 1] === '%')
        return clamp_css_float(parseFloat(str) / 100);
      return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
      if (h < 0) h += 1;
      else if (h > 1) h -= 1;

      if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
      if (h * 2 < 1) return m2;
      if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
      return m1;
    }

    function parseCSSColor(css_str) {
      // Remove all whitespace, not compliant, but should just be more accepting.
      var str = css_str.replace(/ /g, '').toLowerCase();

      // Color keywords (and transparent) lookup.
      if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

      // #abc and #abc123 syntax.
      if (str[0] === '#') {
        if (str.length === 4) {
          var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
          if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
          return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                  (iv & 0xf0) | ((iv & 0xf0) >> 4),
                  (iv & 0xf) | ((iv & 0xf) << 4),
                  1];
        } else if (str.length === 7) {
          var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
          if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
          return [(iv & 0xff0000) >> 16,
                  (iv & 0xff00) >> 8,
                  iv & 0xff,
                  1];
        }

        return null;
      }

      var op = str.indexOf('('), ep = str.indexOf(')');
      if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op+1, ep-(op+1)).split(',');
        var alpha = 1;  // To allow case fallthrough.
        switch (fname) {
          case 'rgba':
            if (params.length !== 4) return null;
            alpha = parse_css_float(params.pop());
            // Fall through.
          case 'rgb':
            if (params.length !== 3) return null;
            return [parse_css_int(params[0]),
                    parse_css_int(params[1]),
                    parse_css_int(params[2]),
                    alpha];
          case 'hsla':
            if (params.length !== 4) return null;
            alpha = parse_css_float(params.pop());
            // Fall through.
          case 'hsl':
            if (params.length !== 3) return null;
            var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
            // NOTE(deanm): According to the CSS spec s/l should only be
            // percentages, but we don't bother and let float or percentage.
            var s = parse_css_float(params[1]);
            var l = parse_css_float(params[2]);
            var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
            var m1 = l * 2 - m2;
            return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                    clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                    clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                    alpha];
          default:
            return null;
        }
      }

      return null;
    }

    try { exports.parseCSSColor = parseCSSColor; } catch(e) { }
    });

    class Color$2 {
        constructor(r, g, b, a = 1) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        static parse(input) {
            if (!input) {
                return undefined;
            }
            if (input instanceof Color$2) {
                return input;
            }
            if (typeof input !== 'string') {
                return undefined;
            }
            const rgba = csscolorparser.parseCSSColor(input);
            if (!rgba) {
                return undefined;
            }
            return new Color$2(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
        }
        toString() {
            const [r, g, b, a] = this.toArray();
            return `rgba(${ Math.round(r) },${ Math.round(g) },${ Math.round(b) },${ a })`;
        }
        toArray() {
            const {r, g, b, a} = this;
            return a === 0 ? [
                0,
                0,
                0,
                0
            ] : [
                r * 255 / a,
                g * 255 / a,
                b * 255 / a,
                a
            ];
        }
        toArray01() {
            const {r, g, b, a} = this;
            return a === 0 ? [
                0,
                0,
                0,
                0
            ] : [
                r / a,
                g / a,
                b / a,
                a
            ];
        }
        toArray01PremultipliedAlpha() {
            const {r, g, b, a} = this;
            return [
                r,
                g,
                b,
                a
            ];
        }
    }
    Color$2.black = new Color$2(0, 0, 0, 1);
    Color$2.white = new Color$2(1, 1, 1, 1);
    Color$2.transparent = new Color$2(0, 0, 0, 0);
    Color$2.red = new Color$2(1, 0, 0, 1);
    Color$2.blue = new Color$2(0, 0, 1, 1);
    var Color$1$1 = Color$2;

    class Collator {
        constructor(caseSensitive, diacriticSensitive, locale) {
            if (caseSensitive)
                this.sensitivity = diacriticSensitive ? 'variant' : 'case';
            else
                this.sensitivity = diacriticSensitive ? 'accent' : 'base';
            this.locale = locale;
            this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                sensitivity: this.sensitivity,
                usage: 'search'
            });
        }
        compare(lhs, rhs) {
            return this.collator.compare(lhs, rhs);
        }
        resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
    }

    class FormattedSection {
        constructor(text, image, scale, fontStack, textColor) {
            this.text = text.normalize ? text.normalize() : text;
            this.image = image;
            this.scale = scale;
            this.fontStack = fontStack;
            this.textColor = textColor;
        }
    }
    class Formatted {
        constructor(sections) {
            this.sections = sections;
        }
        static fromString(unformatted) {
            return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
        }
        isEmpty() {
            if (this.sections.length === 0)
                return true;
            return !this.sections.some(section => section.text.length !== 0 || section.image && section.image.name.length !== 0);
        }
        static factory(text) {
            if (text instanceof Formatted) {
                return text;
            } else {
                return Formatted.fromString(text);
            }
        }
        toString() {
            if (this.sections.length === 0)
                return '';
            return this.sections.map(section => section.text).join('');
        }
        serialize() {
            const serialized = ['format'];
            for (const section of this.sections) {
                if (section.image) {
                    serialized.push([
                        'image',
                        section.image.name
                    ]);
                    continue;
                }
                serialized.push(section.text);
                const options = {};
                if (section.fontStack) {
                    options['text-font'] = [
                        'literal',
                        section.fontStack.split(',')
                    ];
                }
                if (section.scale) {
                    options['font-scale'] = section.scale;
                }
                if (section.textColor) {
                    options['text-color'] = ['rgba'].concat(section.textColor.toArray());
                }
                serialized.push(options);
            }
            return serialized;
        }
    }

    class ResolvedImage {
        constructor(options) {
            this.name = options.name;
            this.available = options.available;
        }
        toString() {
            return this.name;
        }
        static fromString(name) {
            if (!name)
                return null;
            return new ResolvedImage({
                name,
                available: false
            });
        }
        serialize() {
            return [
                'image',
                this.name
            ];
        }
    }

    function validateRGBA(r, g, b, a) {
        if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
            const value = typeof a === 'number' ? [
                r,
                g,
                b,
                a
            ] : [
                r,
                g,
                b
            ];
            return `Invalid rgba value [${ value.join(', ') }]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
            return `Invalid rgba value [${ [
            r,
            g,
            b,
            a
        ].join(', ') }]: 'a' must be between 0 and 1.`;
        }
        return null;
    }
    function isValue(mixed) {
        if (mixed === null) {
            return true;
        } else if (typeof mixed === 'string') {
            return true;
        } else if (typeof mixed === 'boolean') {
            return true;
        } else if (typeof mixed === 'number') {
            return true;
        } else if (mixed instanceof Color$1$1) {
            return true;
        } else if (mixed instanceof Collator) {
            return true;
        } else if (mixed instanceof Formatted) {
            return true;
        } else if (mixed instanceof ResolvedImage) {
            return true;
        } else if (Array.isArray(mixed)) {
            for (const item of mixed) {
                if (!isValue(item)) {
                    return false;
                }
            }
            return true;
        } else if (typeof mixed === 'object') {
            for (const key in mixed) {
                if (!isValue(mixed[key])) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    }
    function typeOf(value) {
        if (value === null) {
            return NullType;
        } else if (typeof value === 'string') {
            return StringType;
        } else if (typeof value === 'boolean') {
            return BooleanType;
        } else if (typeof value === 'number') {
            return NumberType;
        } else if (value instanceof Color$1$1) {
            return ColorType;
        } else if (value instanceof Collator) {
            return CollatorType;
        } else if (value instanceof Formatted) {
            return FormattedType;
        } else if (value instanceof ResolvedImage) {
            return ResolvedImageType;
        } else if (Array.isArray(value)) {
            const length = value.length;
            let itemType;
            for (const item of value) {
                const t = typeOf(item);
                if (!itemType) {
                    itemType = t;
                } else if (itemType === t) {
                    continue;
                } else {
                    itemType = ValueType;
                    break;
                }
            }
            return array$1(itemType || ValueType, length);
        } else {
            return ObjectType;
        }
    }
    function toString(value) {
        const type = typeof value;
        if (value === null) {
            return '';
        } else if (type === 'string' || type === 'number' || type === 'boolean') {
            return String(value);
        } else if (value instanceof Color$1$1 || value instanceof Formatted || value instanceof ResolvedImage) {
            return value.toString();
        } else {
            return JSON.stringify(value);
        }
    }

    class Literal {
        constructor(type, value) {
            this.type = type;
            this.value = value;
        }
        static parse(args, context) {
            if (args.length !== 2)
                return context.error(`'literal' expression requires exactly one argument, but found ${ args.length - 1 } instead.`);
            if (!isValue(args[1]))
                return context.error(`invalid value`);
            const value = args[1];
            let type = typeOf(value);
            const expected = context.expectedType;
            if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
                type = expected;
            }
            return new Literal(type, value);
        }
        evaluate() {
            return this.value;
        }
        eachChild() {
        }
        outputDefined() {
            return true;
        }
        serialize() {
            if (this.type.kind === 'array' || this.type.kind === 'object') {
                return [
                    'literal',
                    this.value
                ];
            } else if (this.value instanceof Color$1$1) {
                return ['rgba'].concat(this.value.toArray());
            } else if (this.value instanceof Formatted) {
                return this.value.serialize();
            } else {
                return this.value;
            }
        }
    }
    var Literal$1 = Literal;

    class RuntimeError {
        constructor(message) {
            this.name = 'ExpressionEvaluationError';
            this.message = message;
        }
        toJSON() {
            return this.message;
        }
    }
    var RuntimeError$1 = RuntimeError;

    const types$1 = {
        string: StringType,
        number: NumberType,
        boolean: BooleanType,
        object: ObjectType
    };
    class Assertion {
        constructor(type, args) {
            this.type = type;
            this.args = args;
        }
        static parse(args, context) {
            if (args.length < 2)
                return context.error(`Expected at least one argument.`);
            let i = 1;
            let type;
            const name = args[0];
            if (name === 'array') {
                let itemType;
                if (args.length > 2) {
                    const type = args[1];
                    if (typeof type !== 'string' || !(type in types$1) || type === 'object')
                        return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
                    itemType = types$1[type];
                    i++;
                } else {
                    itemType = ValueType;
                }
                let N;
                if (args.length > 3) {
                    if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                        return context.error('The length argument to "array" must be a positive integer literal', 2);
                    }
                    N = args[2];
                    i++;
                }
                type = array$1(itemType, N);
            } else {
                type = types$1[name];
            }
            const parsed = [];
            for (; i < args.length; i++) {
                const input = context.parse(args[i], i, ValueType);
                if (!input)
                    return null;
                parsed.push(input);
            }
            return new Assertion(type, parsed);
        }
        evaluate(ctx) {
            for (let i = 0; i < this.args.length; i++) {
                const value = this.args[i].evaluate(ctx);
                const error = checkSubtype(this.type, typeOf(value));
                if (!error) {
                    return value;
                } else if (i === this.args.length - 1) {
                    throw new RuntimeError$1(`Expected value to be of type ${ toString$1(this.type) }, but found ${ toString$1(typeOf(value)) } instead.`);
                }
            }
            return null;
        }
        eachChild(fn) {
            this.args.forEach(fn);
        }
        outputDefined() {
            return this.args.every(arg => arg.outputDefined());
        }
        serialize() {
            const type = this.type;
            const serialized = [type.kind];
            if (type.kind === 'array') {
                const itemType = type.itemType;
                if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
                    serialized.push(itemType.kind);
                    const N = type.N;
                    if (typeof N === 'number' || this.args.length > 1) {
                        serialized.push(N);
                    }
                }
            }
            return serialized.concat(this.args.map(arg => arg.serialize()));
        }
    }
    var Assertion$1 = Assertion;

    class FormatExpression {
        constructor(sections) {
            this.type = FormattedType;
            this.sections = sections;
        }
        static parse(args, context) {
            if (args.length < 2) {
                return context.error(`Expected at least one argument.`);
            }
            const firstArg = args[1];
            if (!Array.isArray(firstArg) && typeof firstArg === 'object') {
                return context.error(`First argument must be an image or text section.`);
            }
            const sections = [];
            let nextTokenMayBeObject = false;
            for (let i = 1; i <= args.length - 1; ++i) {
                const arg = args[i];
                if (nextTokenMayBeObject && typeof arg === 'object' && !Array.isArray(arg)) {
                    nextTokenMayBeObject = false;
                    let scale = null;
                    if (arg['font-scale']) {
                        scale = context.parse(arg['font-scale'], 1, NumberType);
                        if (!scale)
                            return null;
                    }
                    let font = null;
                    if (arg['text-font']) {
                        font = context.parse(arg['text-font'], 1, array$1(StringType));
                        if (!font)
                            return null;
                    }
                    let textColor = null;
                    if (arg['text-color']) {
                        textColor = context.parse(arg['text-color'], 1, ColorType);
                        if (!textColor)
                            return null;
                    }
                    const lastExpression = sections[sections.length - 1];
                    lastExpression.scale = scale;
                    lastExpression.font = font;
                    lastExpression.textColor = textColor;
                } else {
                    const content = context.parse(args[i], 1, ValueType);
                    if (!content)
                        return null;
                    const kind = content.type.kind;
                    if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage')
                        return context.error(`Formatted text type must be 'string', 'value', 'image' or 'null'.`);
                    nextTokenMayBeObject = true;
                    sections.push({
                        content,
                        scale: null,
                        font: null,
                        textColor: null
                    });
                }
            }
            return new FormatExpression(sections);
        }
        evaluate(ctx) {
            const evaluateSection = section => {
                const evaluatedContent = section.content.evaluate(ctx);
                if (typeOf(evaluatedContent) === ResolvedImageType) {
                    return new FormattedSection('', evaluatedContent, null, null, null);
                }
                return new FormattedSection(toString(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
            };
            return new Formatted(this.sections.map(evaluateSection));
        }
        eachChild(fn) {
            for (const section of this.sections) {
                fn(section.content);
                if (section.scale) {
                    fn(section.scale);
                }
                if (section.font) {
                    fn(section.font);
                }
                if (section.textColor) {
                    fn(section.textColor);
                }
            }
        }
        outputDefined() {
            return false;
        }
        serialize() {
            const serialized = ['format'];
            for (const section of this.sections) {
                serialized.push(section.content.serialize());
                const options = {};
                if (section.scale) {
                    options['font-scale'] = section.scale.serialize();
                }
                if (section.font) {
                    options['text-font'] = section.font.serialize();
                }
                if (section.textColor) {
                    options['text-color'] = section.textColor.serialize();
                }
                serialized.push(options);
            }
            return serialized;
        }
    }

    class ImageExpression {
        constructor(input) {
            this.type = ResolvedImageType;
            this.input = input;
        }
        static parse(args, context) {
            if (args.length !== 2) {
                return context.error(`Expected two arguments.`);
            }
            const name = context.parse(args[1], 1, StringType);
            if (!name)
                return context.error(`No image name provided.`);
            return new ImageExpression(name);
        }
        evaluate(ctx) {
            const evaluatedImageName = this.input.evaluate(ctx);
            const value = ResolvedImage.fromString(evaluatedImageName);
            if (value && ctx.availableImages)
                value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
            return value;
        }
        eachChild(fn) {
            fn(this.input);
        }
        outputDefined() {
            return false;
        }
        serialize() {
            return [
                'image',
                this.input.serialize()
            ];
        }
    }

    const types = {
        'to-boolean': BooleanType,
        'to-color': ColorType,
        'to-number': NumberType,
        'to-string': StringType
    };
    class Coercion {
        constructor(type, args) {
            this.type = type;
            this.args = args;
        }
        static parse(args, context) {
            if (args.length < 2)
                return context.error(`Expected at least one argument.`);
            const name = args[0];
            if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2)
                return context.error(`Expected one argument.`);
            const type = types[name];
            const parsed = [];
            for (let i = 1; i < args.length; i++) {
                const input = context.parse(args[i], i, ValueType);
                if (!input)
                    return null;
                parsed.push(input);
            }
            return new Coercion(type, parsed);
        }
        evaluate(ctx) {
            if (this.type.kind === 'boolean') {
                return Boolean(this.args[0].evaluate(ctx));
            } else if (this.type.kind === 'color') {
                let input;
                let error;
                for (const arg of this.args) {
                    input = arg.evaluate(ctx);
                    error = null;
                    if (input instanceof Color$1$1) {
                        return input;
                    } else if (typeof input === 'string') {
                        const c = ctx.parseColor(input);
                        if (c)
                            return c;
                    } else if (Array.isArray(input)) {
                        if (input.length < 3 || input.length > 4) {
                            error = `Invalid rbga value ${ JSON.stringify(input) }: expected an array containing either three or four numeric values.`;
                        } else {
                            error = validateRGBA(input[0], input[1], input[2], input[3]);
                        }
                        if (!error) {
                            return new Color$1$1(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                        }
                    }
                }
                throw new RuntimeError$1(error || `Could not parse color from value '${ typeof input === 'string' ? input : String(JSON.stringify(input)) }'`);
            } else if (this.type.kind === 'number') {
                let value = null;
                for (const arg of this.args) {
                    value = arg.evaluate(ctx);
                    if (value === null)
                        return 0;
                    const num = Number(value);
                    if (isNaN(num))
                        continue;
                    return num;
                }
                throw new RuntimeError$1(`Could not convert ${ JSON.stringify(value) } to number.`);
            } else if (this.type.kind === 'formatted') {
                return Formatted.fromString(toString(this.args[0].evaluate(ctx)));
            } else if (this.type.kind === 'resolvedImage') {
                return ResolvedImage.fromString(toString(this.args[0].evaluate(ctx)));
            } else {
                return toString(this.args[0].evaluate(ctx));
            }
        }
        eachChild(fn) {
            this.args.forEach(fn);
        }
        outputDefined() {
            return this.args.every(arg => arg.outputDefined());
        }
        serialize() {
            if (this.type.kind === 'formatted') {
                return new FormatExpression([{
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }]).serialize();
            }
            if (this.type.kind === 'resolvedImage') {
                return new ImageExpression(this.args[0]).serialize();
            }
            const serialized = [`to-${ this.type.kind }`];
            this.eachChild(child => {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }
    var Coercion$1 = Coercion;

    const geometryTypes = [
        'Unknown',
        'Point',
        'LineString',
        'Polygon'
    ];
    class EvaluationContext {
        constructor() {
            this.globals = null;
            this.feature = null;
            this.featureState = null;
            this.formattedSection = null;
            this._parseColorCache = {};
            this.availableImages = null;
            this.canonical = null;
            this.featureTileCoord = null;
            this.featureDistanceData = null;
        }
        id() {
            return this.feature && 'id' in this.feature && this.feature.id ? this.feature.id : null;
        }
        geometryType() {
            return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
        }
        geometry() {
            return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
            return this.canonical;
        }
        properties() {
            return this.feature && this.feature.properties || {};
        }
        distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
                const c = this.featureDistanceData.center;
                const scale = this.featureDistanceData.scale;
                const {x, y} = this.featureTileCoord;
                const dX = x * scale - c[0];
                const dY = y * scale - c[1];
                const bX = this.featureDistanceData.bearing[0];
                const bY = this.featureDistanceData.bearing[1];
                const dist = bX * dX + bY * dY;
                return dist;
            }
            return 0;
        }
        parseColor(input) {
            let cached = this._parseColorCache[input];
            if (!cached) {
                cached = this._parseColorCache[input] = Color$1$1.parse(input);
            }
            return cached;
        }
    }
    var EvaluationContext$1 = EvaluationContext;

    class CompoundExpression {
        constructor(name, type, evaluate, args) {
            this.name = name;
            this.type = type;
            this._evaluate = evaluate;
            this.args = args;
        }
        evaluate(ctx) {
            return this._evaluate(ctx, this.args);
        }
        eachChild(fn) {
            this.args.forEach(fn);
        }
        outputDefined() {
            return false;
        }
        serialize() {
            return [this.name].concat(this.args.map(arg => arg.serialize()));
        }
        static parse(args, context) {
            const op = args[0];
            const definition = CompoundExpression.definitions[op];
            if (!definition) {
                return context.error(`Unknown expression "${ op }". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            const type = Array.isArray(definition) ? definition[0] : definition.type;
            const availableOverloads = Array.isArray(definition) ? [[
                    definition[1],
                    definition[2]
                ]] : definition.overloads;
            const overloads = availableOverloads.filter(([signature]) => !Array.isArray(signature) || signature.length === args.length - 1);
            let signatureContext = null;
            for (const [params, evaluate] of overloads) {
                signatureContext = new ParsingContext$1(context.registry, context.path, null, context.scope);
                const parsedArgs = [];
                let argParseFailed = false;
                for (let i = 1; i < args.length; i++) {
                    const arg = args[i];
                    const expectedType = Array.isArray(params) ? params[i - 1] : params.type;
                    const parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
                    if (!parsed) {
                        argParseFailed = true;
                        break;
                    }
                    parsedArgs.push(parsed);
                }
                if (argParseFailed) {
                    continue;
                }
                if (Array.isArray(params)) {
                    if (params.length !== parsedArgs.length) {
                        signatureContext.error(`Expected ${ params.length } arguments, but found ${ parsedArgs.length } instead.`);
                        continue;
                    }
                }
                for (let i = 0; i < parsedArgs.length; i++) {
                    const expected = Array.isArray(params) ? params[i] : params.type;
                    const arg = parsedArgs[i];
                    signatureContext.concat(i + 1).checkSubtype(expected, arg.type);
                }
                if (signatureContext.errors.length === 0) {
                    return new CompoundExpression(op, type, evaluate, parsedArgs);
                }
            }
            if (overloads.length === 1) {
                context.errors.push(...signatureContext.errors);
            } else {
                const expected = overloads.length ? overloads : availableOverloads;
                const signatures = expected.map(([params]) => stringifySignature(params)).join(' | ');
                const actualTypes = [];
                for (let i = 1; i < args.length; i++) {
                    const parsed = context.parse(args[i], 1 + actualTypes.length);
                    if (!parsed)
                        return null;
                    actualTypes.push(toString$1(parsed.type));
                }
                context.error(`Expected arguments of type ${ signatures }, but found (${ actualTypes.join(', ') }) instead.`);
            }
            return null;
        }
        static register(registry, definitions) {
            CompoundExpression.definitions = definitions;
            for (const name in definitions) {
                registry[name] = CompoundExpression;
            }
        }
    }
    function stringifySignature(signature) {
        if (Array.isArray(signature)) {
            return `(${ signature.map(toString$1).join(', ') })`;
        } else {
            return `(${ toString$1(signature.type) }...)`;
        }
    }
    var CompoundExpression$1 = CompoundExpression;

    class CollatorExpression {
        constructor(caseSensitive, diacriticSensitive, locale) {
            this.type = CollatorType;
            this.locale = locale;
            this.caseSensitive = caseSensitive;
            this.diacriticSensitive = diacriticSensitive;
        }
        static parse(args, context) {
            if (args.length !== 2)
                return context.error(`Expected one argument.`);
            const options = args[1];
            if (typeof options !== 'object' || Array.isArray(options))
                return context.error(`Collator options argument must be an object.`);
            const caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
            if (!caseSensitive)
                return null;
            const diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
            if (!diacriticSensitive)
                return null;
            let locale = null;
            if (options['locale']) {
                locale = context.parse(options['locale'], 1, StringType);
                if (!locale)
                    return null;
            }
            return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
        }
        evaluate(ctx) {
            return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
        }
        eachChild(fn) {
            fn(this.caseSensitive);
            fn(this.diacriticSensitive);
            if (this.locale) {
                fn(this.locale);
            }
        }
        outputDefined() {
            return false;
        }
        serialize() {
            const options = {};
            options['case-sensitive'] = this.caseSensitive.serialize();
            options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
            if (this.locale) {
                options['locale'] = this.locale.serialize();
            }
            return [
                'collator',
                options
            ];
        }
    }

    const EXTENT = 8192;
    function updateBBox(bbox, coord) {
        bbox[0] = Math.min(bbox[0], coord[0]);
        bbox[1] = Math.min(bbox[1], coord[1]);
        bbox[2] = Math.max(bbox[2], coord[0]);
        bbox[3] = Math.max(bbox[3], coord[1]);
    }
    function mercatorXfromLng(lng) {
        return (180 + lng) / 360;
    }
    function mercatorYfromLat(lat) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
    }
    function boxWithinBox(bbox1, bbox2) {
        if (bbox1[0] <= bbox2[0])
            return false;
        if (bbox1[2] >= bbox2[2])
            return false;
        if (bbox1[1] <= bbox2[1])
            return false;
        if (bbox1[3] >= bbox2[3])
            return false;
        return true;
    }
    function getTileCoordinates(p, canonical) {
        const x = mercatorXfromLng(p[0]);
        const y = mercatorYfromLat(p[1]);
        const tilesAtZoom = Math.pow(2, canonical.z);
        return [
            Math.round(x * tilesAtZoom * EXTENT),
            Math.round(y * tilesAtZoom * EXTENT)
        ];
    }
    function onBoundary(p, p1, p2) {
        const x1 = p[0] - p1[0];
        const y1 = p[1] - p1[1];
        const x2 = p[0] - p2[0];
        const y2 = p[1] - p2[1];
        return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
    }
    function rayIntersect(p, p1, p2) {
        return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
    }
    function pointWithinPolygon(point, rings) {
        let inside = false;
        for (let i = 0, len = rings.length; i < len; i++) {
            const ring = rings[i];
            for (let j = 0, len2 = ring.length; j < len2 - 1; j++) {
                if (onBoundary(point, ring[j], ring[j + 1]))
                    return false;
                if (rayIntersect(point, ring[j], ring[j + 1]))
                    inside = !inside;
            }
        }
        return inside;
    }
    function pointWithinPolygons(point, polygons) {
        for (let i = 0; i < polygons.length; i++) {
            if (pointWithinPolygon(point, polygons[i]))
                return true;
        }
        return false;
    }
    function perp(v1, v2) {
        return v1[0] * v2[1] - v1[1] * v2[0];
    }
    function twoSided(p1, p2, q1, q2) {
        const x1 = p1[0] - q1[0];
        const y1 = p1[1] - q1[1];
        const x2 = p2[0] - q1[0];
        const y2 = p2[1] - q1[1];
        const x3 = q2[0] - q1[0];
        const y3 = q2[1] - q1[1];
        const det1 = x1 * y3 - x3 * y1;
        const det2 = x2 * y3 - x3 * y2;
        if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0)
            return true;
        return false;
    }
    function lineIntersectLine(a, b, c, d) {
        const vectorP = [
            b[0] - a[0],
            b[1] - a[1]
        ];
        const vectorQ = [
            d[0] - c[0],
            d[1] - c[1]
        ];
        if (perp(vectorQ, vectorP) === 0)
            return false;
        if (twoSided(a, b, c, d) && twoSided(c, d, a, b))
            return true;
        return false;
    }
    function lineIntersectPolygon(p1, p2, polygon) {
        for (const ring of polygon) {
            for (let j = 0; j < ring.length - 1; ++j) {
                if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
                    return true;
                }
            }
        }
        return false;
    }
    function lineStringWithinPolygon(line, polygon) {
        for (let i = 0; i < line.length; ++i) {
            if (!pointWithinPolygon(line[i], polygon)) {
                return false;
            }
        }
        for (let i = 0; i < line.length - 1; ++i) {
            if (lineIntersectPolygon(line[i], line[i + 1], polygon)) {
                return false;
            }
        }
        return true;
    }
    function lineStringWithinPolygons(line, polygons) {
        for (let i = 0; i < polygons.length; i++) {
            if (lineStringWithinPolygon(line, polygons[i]))
                return true;
        }
        return false;
    }
    function getTilePolygon(coordinates, bbox, canonical) {
        const polygon = [];
        for (let i = 0; i < coordinates.length; i++) {
            const ring = [];
            for (let j = 0; j < coordinates[i].length; j++) {
                const coord = getTileCoordinates(coordinates[i][j], canonical);
                updateBBox(bbox, coord);
                ring.push(coord);
            }
            polygon.push(ring);
        }
        return polygon;
    }
    function getTilePolygons(coordinates, bbox, canonical) {
        const polygons = [];
        for (let i = 0; i < coordinates.length; i++) {
            const polygon = getTilePolygon(coordinates[i], bbox, canonical);
            polygons.push(polygon);
        }
        return polygons;
    }
    function updatePoint(p, bbox, polyBBox, worldSize) {
        if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
            const halfWorldSize = worldSize * 0.5;
            let shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
            if (shift === 0) {
                shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
            }
            p[0] += shift;
        }
        updateBBox(bbox, p);
    }
    function resetBBox(bbox) {
        bbox[0] = bbox[1] = Infinity;
        bbox[2] = bbox[3] = -Infinity;
    }
    function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
        const worldSize = Math.pow(2, canonical.z) * EXTENT;
        const shifts = [
            canonical.x * EXTENT,
            canonical.y * EXTENT
        ];
        const tilePoints = [];
        if (!geometry)
            return tilePoints;
        for (const points of geometry) {
            for (const point of points) {
                const p = [
                    point.x + shifts[0],
                    point.y + shifts[1]
                ];
                updatePoint(p, pointBBox, polyBBox, worldSize);
                tilePoints.push(p);
            }
        }
        return tilePoints;
    }
    function getTileLines(geometry, lineBBox, polyBBox, canonical) {
        const worldSize = Math.pow(2, canonical.z) * EXTENT;
        const shifts = [
            canonical.x * EXTENT,
            canonical.y * EXTENT
        ];
        const tileLines = [];
        if (!geometry)
            return tileLines;
        for (const line of geometry) {
            const tileLine = [];
            for (const point of line) {
                const p = [
                    point.x + shifts[0],
                    point.y + shifts[1]
                ];
                updateBBox(lineBBox, p);
                tileLine.push(p);
            }
            tileLines.push(tileLine);
        }
        if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
            resetBBox(lineBBox);
            for (const line of tileLines) {
                for (const p of line) {
                    updatePoint(p, lineBBox, polyBBox, worldSize);
                }
            }
        }
        return tileLines;
    }
    function pointsWithinPolygons(ctx, polygonGeometry) {
        const pointBBox = [
            Infinity,
            Infinity,
            -Infinity,
            -Infinity
        ];
        const polyBBox = [
            Infinity,
            Infinity,
            -Infinity,
            -Infinity
        ];
        const canonical = ctx.canonicalID();
        if (!canonical) {
            return false;
        }
        if (polygonGeometry.type === 'Polygon') {
            const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
            const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
            if (!boxWithinBox(pointBBox, polyBBox))
                return false;
            for (const point of tilePoints) {
                if (!pointWithinPolygon(point, tilePolygon))
                    return false;
            }
        }
        if (polygonGeometry.type === 'MultiPolygon') {
            const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
            const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
            if (!boxWithinBox(pointBBox, polyBBox))
                return false;
            for (const point of tilePoints) {
                if (!pointWithinPolygons(point, tilePolygons))
                    return false;
            }
        }
        return true;
    }
    function linesWithinPolygons(ctx, polygonGeometry) {
        const lineBBox = [
            Infinity,
            Infinity,
            -Infinity,
            -Infinity
        ];
        const polyBBox = [
            Infinity,
            Infinity,
            -Infinity,
            -Infinity
        ];
        const canonical = ctx.canonicalID();
        if (!canonical) {
            return false;
        }
        if (polygonGeometry.type === 'Polygon') {
            const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
            const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
            if (!boxWithinBox(lineBBox, polyBBox))
                return false;
            for (const line of tileLines) {
                if (!lineStringWithinPolygon(line, tilePolygon))
                    return false;
            }
        }
        if (polygonGeometry.type === 'MultiPolygon') {
            const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
            const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
            if (!boxWithinBox(lineBBox, polyBBox))
                return false;
            for (const line of tileLines) {
                if (!lineStringWithinPolygons(line, tilePolygons))
                    return false;
            }
        }
        return true;
    }
    class Within {
        constructor(geojson, geometries) {
            this.type = BooleanType;
            this.geojson = geojson;
            this.geometries = geometries;
        }
        static parse(args, context) {
            if (args.length !== 2)
                return context.error(`'within' expression requires exactly one argument, but found ${ args.length - 1 } instead.`);
            if (isValue(args[1])) {
                const geojson = args[1];
                if (geojson.type === 'FeatureCollection') {
                    for (let i = 0; i < geojson.features.length; ++i) {
                        const type = geojson.features[i].geometry.type;
                        if (type === 'Polygon' || type === 'MultiPolygon') {
                            return new Within(geojson, geojson.features[i].geometry);
                        }
                    }
                } else if (geojson.type === 'Feature') {
                    const type = geojson.geometry.type;
                    if (type === 'Polygon' || type === 'MultiPolygon') {
                        return new Within(geojson, geojson.geometry);
                    }
                } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
                    return new Within(geojson, geojson);
                }
            }
            return context.error(`'within' expression requires valid geojson object that contains polygon geometry type.`);
        }
        evaluate(ctx) {
            if (ctx.geometry() != null && ctx.canonicalID() != null) {
                if (ctx.geometryType() === 'Point') {
                    return pointsWithinPolygons(ctx, this.geometries);
                } else if (ctx.geometryType() === 'LineString') {
                    return linesWithinPolygons(ctx, this.geometries);
                }
            }
            return false;
        }
        eachChild() {
        }
        outputDefined() {
            return true;
        }
        serialize() {
            return [
                'within',
                this.geojson
            ];
        }
    }
    var Within$1 = Within;

    function isFeatureConstant(e) {
        if (e instanceof CompoundExpression$1) {
            if (e.name === 'get' && e.args.length === 1) {
                return false;
            } else if (e.name === 'feature-state') {
                return false;
            } else if (e.name === 'has' && e.args.length === 1) {
                return false;
            } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
                return false;
            } else if (/^filter-/.test(e.name)) {
                return false;
            }
        }
        if (e instanceof Within$1) {
            return false;
        }
        let result = true;
        e.eachChild(arg => {
            if (result && !isFeatureConstant(arg)) {
                result = false;
            }
        });
        return result;
    }
    function isGlobalPropertyConstant(e, properties) {
        if (e instanceof CompoundExpression$1 && properties.indexOf(e.name) >= 0) {
            return false;
        }
        let result = true;
        e.eachChild(arg => {
            if (result && !isGlobalPropertyConstant(arg, properties)) {
                result = false;
            }
        });
        return result;
    }

    class Var {
        constructor(name, boundExpression) {
            this.type = boundExpression.type;
            this.name = name;
            this.boundExpression = boundExpression;
        }
        static parse(args, context) {
            if (args.length !== 2 || typeof args[1] !== 'string')
                return context.error(`'var' expression requires exactly one string literal argument.`);
            const name = args[1];
            if (!context.scope.has(name)) {
                return context.error(`Unknown variable "${ name }". Make sure "${ name }" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            return new Var(name, context.scope.get(name));
        }
        evaluate(ctx) {
            return this.boundExpression.evaluate(ctx);
        }
        eachChild() {
        }
        outputDefined() {
            return false;
        }
        serialize() {
            return [
                'var',
                this.name
            ];
        }
    }
    var Var$1 = Var;

    class ParsingContext {
        constructor(registry, path = [], expectedType, scope = new Scope$1(), errors = []) {
            this.registry = registry;
            this.path = path;
            this.key = path.map(part => `[${ part }]`).join('');
            this.scope = scope;
            this.errors = errors;
            this.expectedType = expectedType;
        }
        parse(expr, index, expectedType, bindings, options = {}) {
            if (index) {
                return this.concat(index, expectedType, bindings)._parse(expr, options);
            }
            return this._parse(expr, options);
        }
        _parse(expr, options) {
            if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
                expr = [
                    'literal',
                    expr
                ];
            }
            function annotate(parsed, type, typeAnnotation) {
                if (typeAnnotation === 'assert') {
                    return new Assertion$1(type, [parsed]);
                } else if (typeAnnotation === 'coerce') {
                    return new Coercion$1(type, [parsed]);
                } else {
                    return parsed;
                }
            }
            if (Array.isArray(expr)) {
                if (expr.length === 0) {
                    return this.error(`Expected an array with at least one element. If you wanted a literal array, use ["literal", []].`);
                }
                const op = expr[0];
                if (typeof op !== 'string') {
                    this.error(`Expression name must be a string, but found ${ typeof op } instead. If you wanted a literal array, use ["literal", [...]].`, 0);
                    return null;
                }
                const Expr = this.registry[op];
                if (Expr) {
                    let parsed = Expr.parse(expr, this);
                    if (!parsed)
                        return null;
                    if (this.expectedType) {
                        const expected = this.expectedType;
                        const actual = parsed.type;
                        if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
                            parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
                        } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
                            parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
                        } else if (this.checkSubtype(expected, actual)) {
                            return null;
                        }
                    }
                    if (!(parsed instanceof Literal$1) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
                        const ec = new EvaluationContext$1();
                        try {
                            parsed = new Literal$1(parsed.type, parsed.evaluate(ec));
                        } catch (e) {
                            this.error(e.message);
                            return null;
                        }
                    }
                    return parsed;
                }
                return this.error(`Unknown expression "${ op }". If you wanted a literal array, use ["literal", [...]].`, 0);
            } else if (typeof expr === 'undefined') {
                return this.error(`'undefined' value invalid. Use null instead.`);
            } else if (typeof expr === 'object') {
                return this.error(`Bare objects invalid. Use ["literal", {...}] instead.`);
            } else {
                return this.error(`Expected an array, but found ${ typeof expr } instead.`);
            }
        }
        concat(index, expectedType, bindings) {
            const path = typeof index === 'number' ? this.path.concat(index) : this.path;
            const scope = bindings ? this.scope.concat(bindings) : this.scope;
            return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
        }
        error(error, ...keys) {
            const key = `${ this.key }${ keys.map(k => `[${ k }]`).join('') }`;
            this.errors.push(new ParsingError$2(key, error));
        }
        checkSubtype(expected, t) {
            const error = checkSubtype(expected, t);
            if (error)
                this.error(error);
            return error;
        }
    }
    var ParsingContext$1 = ParsingContext;
    function isConstant(expression) {
        if (expression instanceof Var$1) {
            return isConstant(expression.boundExpression);
        } else if (expression instanceof CompoundExpression$1 && expression.name === 'error') {
            return false;
        } else if (expression instanceof CollatorExpression) {
            return false;
        } else if (expression instanceof Within$1) {
            return false;
        }
        const isTypeAnnotation = expression instanceof Coercion$1 || expression instanceof Assertion$1;
        let childrenConstant = true;
        expression.eachChild(child => {
            if (isTypeAnnotation) {
                childrenConstant = childrenConstant && isConstant(child);
            } else {
                childrenConstant = childrenConstant && child instanceof Literal$1;
            }
        });
        if (!childrenConstant) {
            return false;
        }
        return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [
            'zoom',
            'heatmap-density',
            'line-progress',
            'sky-radial-progress',
            'accumulated',
            'is-supported-script',
            'pitch',
            'distance-from-center'
        ]);
    }

    function findStopLessThanOrEqualTo(stops, input) {
        const lastIndex = stops.length - 1;
        let lowerIndex = 0;
        let upperIndex = lastIndex;
        let currentIndex = 0;
        let currentValue, nextValue;
        while (lowerIndex <= upperIndex) {
            currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
            currentValue = stops[currentIndex];
            nextValue = stops[currentIndex + 1];
            if (currentValue <= input) {
                if (currentIndex === lastIndex || input < nextValue) {
                    return currentIndex;
                }
                lowerIndex = currentIndex + 1;
            } else if (currentValue > input) {
                upperIndex = currentIndex - 1;
            } else {
                throw new RuntimeError$1('Input is not a number.');
            }
        }
        return 0;
    }

    class Step {
        constructor(type, input, stops) {
            this.type = type;
            this.input = input;
            this.labels = [];
            this.outputs = [];
            for (const [label, expression] of stops) {
                this.labels.push(label);
                this.outputs.push(expression);
            }
        }
        static parse(args, context) {
            if (args.length - 1 < 4) {
                return context.error(`Expected at least 4 arguments, but found only ${ args.length - 1 }.`);
            }
            if ((args.length - 1) % 2 !== 0) {
                return context.error(`Expected an even number of arguments.`);
            }
            const input = context.parse(args[1], 1, NumberType);
            if (!input)
                return null;
            const stops = [];
            let outputType = null;
            if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            for (let i = 1; i < args.length; i += 2) {
                const label = i === 1 ? -Infinity : args[i];
                const value = args[i + 1];
                const labelKey = i;
                const valueKey = i + 1;
                if (typeof label !== 'number') {
                    return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
                }
                if (stops.length && stops[stops.length - 1][0] >= label) {
                    return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
                }
                const parsed = context.parse(value, valueKey, outputType);
                if (!parsed)
                    return null;
                outputType = outputType || parsed.type;
                stops.push([
                    label,
                    parsed
                ]);
            }
            return new Step(outputType, input, stops);
        }
        evaluate(ctx) {
            const labels = this.labels;
            const outputs = this.outputs;
            if (labels.length === 1) {
                return outputs[0].evaluate(ctx);
            }
            const value = this.input.evaluate(ctx);
            if (value <= labels[0]) {
                return outputs[0].evaluate(ctx);
            }
            const stopCount = labels.length;
            if (value >= labels[stopCount - 1]) {
                return outputs[stopCount - 1].evaluate(ctx);
            }
            const index = findStopLessThanOrEqualTo(labels, value);
            return outputs[index].evaluate(ctx);
        }
        eachChild(fn) {
            fn(this.input);
            for (const expression of this.outputs) {
                fn(expression);
            }
        }
        outputDefined() {
            return this.outputs.every(out => out.outputDefined());
        }
        serialize() {
            const serialized = [
                'step',
                this.input.serialize()
            ];
            for (let i = 0; i < this.labels.length; i++) {
                if (i > 0) {
                    serialized.push(this.labels[i]);
                }
                serialized.push(this.outputs[i].serialize());
            }
            return serialized;
        }
    }
    var Step$1 = Step;

    /*
     * Copyright (C) 2008 Apple Inc. All Rights Reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions
     * are met:
     * 1. Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     * 2. Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in the
     *    documentation and/or other materials provided with the distribution.
     *
     * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
     * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
     * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * Ported from Webkit
     * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
     */
    var unitbezier = UnitBezier;

    function UnitBezier(p1x, p1y, p2x, p2y) {
        // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
        this.cx = 3.0 * p1x;
        this.bx = 3.0 * (p2x - p1x) - this.cx;
        this.ax = 1.0 - this.cx - this.bx;

        this.cy = 3.0 * p1y;
        this.by = 3.0 * (p2y - p1y) - this.cy;
        this.ay = 1.0 - this.cy - this.by;

        this.p1x = p1x;
        this.p1y = p2y;
        this.p2x = p2x;
        this.p2y = p2y;
    }

    UnitBezier.prototype.sampleCurveX = function(t) {
        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
        return ((this.ax * t + this.bx) * t + this.cx) * t;
    };

    UnitBezier.prototype.sampleCurveY = function(t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
    };

    UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
    };

    UnitBezier.prototype.solveCurveX = function(x, epsilon) {
        if (typeof epsilon === 'undefined') epsilon = 1e-6;

        var t0, t1, t2, x2, i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {

            x2 = this.sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) return t2;

            var d2 = this.sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) break;

            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 < t0) return t0;
        if (t2 > t1) return t1;

        while (t0 < t1) {

            x2 = this.sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) return t2;

            if (x > x2) {
                t0 = t2;
            } else {
                t1 = t2;
            }

            t2 = (t1 - t0) * 0.5 + t0;
        }

        // Failure.
        return t2;
    };

    UnitBezier.prototype.solve = function(x, epsilon) {
        return this.sampleCurveY(this.solveCurveX(x, epsilon));
    };

    function number(a, b, t) {
        return a * (1 - t) + b * t;
    }
    function color$1(from, to, t) {
        return new Color$1$1(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
    }
    function array(from, to, t) {
        return from.map((d, i) => {
            return number(d, to[i], t);
        });
    }

    var interpolate = /*#__PURE__*/Object.freeze({
      __proto__: null,
      number: number,
      color: color$1,
      array: array
    });

    const Xn = 0.95047, Yn = 1, Zn = 1.08883, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1, deg2rad = Math.PI / 180, rad2deg = 180 / Math.PI;
    function xyz2lab(t) {
        return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }
    function lab2xyz(t) {
        return t > t1 ? t * t * t : t2 * (t - t0);
    }
    function xyz2rgb(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }
    function rgb2xyz(x) {
        x /= 255;
        return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }
    function rgbToLab(rgbColor) {
        const b = rgb2xyz(rgbColor.r), a = rgb2xyz(rgbColor.g), l = rgb2xyz(rgbColor.b), x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn), y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn), z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
        return {
            l: 116 * y - 16,
            a: 500 * (x - y),
            b: 200 * (y - z),
            alpha: rgbColor.a
        };
    }
    function labToRgb(labColor) {
        let y = (labColor.l + 16) / 116, x = isNaN(labColor.a) ? y : y + labColor.a / 500, z = isNaN(labColor.b) ? y : y - labColor.b / 200;
        y = Yn * lab2xyz(y);
        x = Xn * lab2xyz(x);
        z = Zn * lab2xyz(z);
        return new Color$1$1(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
    }
    function interpolateLab(from, to, t) {
        return {
            l: number(from.l, to.l, t),
            a: number(from.a, to.a, t),
            b: number(from.b, to.b, t),
            alpha: number(from.alpha, to.alpha, t)
        };
    }
    function rgbToHcl(rgbColor) {
        const {l, a, b} = rgbToLab(rgbColor);
        const h = Math.atan2(b, a) * rad2deg;
        return {
            h: h < 0 ? h + 360 : h,
            c: Math.sqrt(a * a + b * b),
            l,
            alpha: rgbColor.a
        };
    }
    function hclToRgb(hclColor) {
        const h = hclColor.h * deg2rad, c = hclColor.c, l = hclColor.l;
        return labToRgb({
            l,
            a: Math.cos(h) * c,
            b: Math.sin(h) * c,
            alpha: hclColor.alpha
        });
    }
    function interpolateHue(a, b, t) {
        const d = b - a;
        return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
    }
    function interpolateHcl(from, to, t) {
        return {
            h: interpolateHue(from.h, to.h, t),
            c: number(from.c, to.c, t),
            l: number(from.l, to.l, t),
            alpha: number(from.alpha, to.alpha, t)
        };
    }
    const lab = {
        forward: rgbToLab,
        reverse: labToRgb,
        interpolate: interpolateLab
    };
    const hcl = {
        forward: rgbToHcl,
        reverse: hclToRgb,
        interpolate: interpolateHcl
    };

    class Interpolate {
        constructor(type, operator, interpolation, input, stops) {
            this.type = type;
            this.operator = operator;
            this.interpolation = interpolation;
            this.input = input;
            this.labels = [];
            this.outputs = [];
            for (const [label, expression] of stops) {
                this.labels.push(label);
                this.outputs.push(expression);
            }
        }
        static interpolationFactor(interpolation, input, lower, upper) {
            let t = 0;
            if (interpolation.name === 'exponential') {
                t = exponentialInterpolation(input, interpolation.base, lower, upper);
            } else if (interpolation.name === 'linear') {
                t = exponentialInterpolation(input, 1, lower, upper);
            } else if (interpolation.name === 'cubic-bezier') {
                const c = interpolation.controlPoints;
                const ub = new unitbezier(c[0], c[1], c[2], c[3]);
                t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
            }
            return t;
        }
        static parse(args, context) {
            let [operator, interpolation, input, ...rest] = args;
            if (!Array.isArray(interpolation) || interpolation.length === 0) {
                return context.error(`Expected an interpolation type expression.`, 1);
            }
            if (interpolation[0] === 'linear') {
                interpolation = { name: 'linear' };
            } else if (interpolation[0] === 'exponential') {
                const base = interpolation[1];
                if (typeof base !== 'number')
                    return context.error(`Exponential interpolation requires a numeric base.`, 1, 1);
                interpolation = {
                    name: 'exponential',
                    base
                };
            } else if (interpolation[0] === 'cubic-bezier') {
                const controlPoints = interpolation.slice(1);
                if (controlPoints.length !== 4 || controlPoints.some(t => typeof t !== 'number' || t < 0 || t > 1)) {
                    return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
                }
                interpolation = {
                    name: 'cubic-bezier',
                    controlPoints: controlPoints
                };
            } else {
                return context.error(`Unknown interpolation type ${ String(interpolation[0]) }`, 1, 0);
            }
            if (args.length - 1 < 4) {
                return context.error(`Expected at least 4 arguments, but found only ${ args.length - 1 }.`);
            }
            if ((args.length - 1) % 2 !== 0) {
                return context.error(`Expected an even number of arguments.`);
            }
            input = context.parse(input, 2, NumberType);
            if (!input)
                return null;
            const stops = [];
            let outputType = null;
            if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
                outputType = ColorType;
            } else if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            for (let i = 0; i < rest.length; i += 2) {
                const label = rest[i];
                const value = rest[i + 1];
                const labelKey = i + 3;
                const valueKey = i + 4;
                if (typeof label !== 'number') {
                    return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
                }
                if (stops.length && stops[stops.length - 1][0] >= label) {
                    return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
                }
                const parsed = context.parse(value, valueKey, outputType);
                if (!parsed)
                    return null;
                outputType = outputType || parsed.type;
                stops.push([
                    label,
                    parsed
                ]);
            }
            if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
                return context.error(`Type ${ toString$1(outputType) } is not interpolatable.`);
            }
            return new Interpolate(outputType, operator, interpolation, input, stops);
        }
        evaluate(ctx) {
            const labels = this.labels;
            const outputs = this.outputs;
            if (labels.length === 1) {
                return outputs[0].evaluate(ctx);
            }
            const value = this.input.evaluate(ctx);
            if (value <= labels[0]) {
                return outputs[0].evaluate(ctx);
            }
            const stopCount = labels.length;
            if (value >= labels[stopCount - 1]) {
                return outputs[stopCount - 1].evaluate(ctx);
            }
            const index = findStopLessThanOrEqualTo(labels, value);
            const lower = labels[index];
            const upper = labels[index + 1];
            const t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
            const outputLower = outputs[index].evaluate(ctx);
            const outputUpper = outputs[index + 1].evaluate(ctx);
            if (this.operator === 'interpolate') {
                return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
            } else if (this.operator === 'interpolate-hcl') {
                return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
            } else {
                return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
            }
        }
        eachChild(fn) {
            fn(this.input);
            for (const expression of this.outputs) {
                fn(expression);
            }
        }
        outputDefined() {
            return this.outputs.every(out => out.outputDefined());
        }
        serialize() {
            let interpolation;
            if (this.interpolation.name === 'linear') {
                interpolation = ['linear'];
            } else if (this.interpolation.name === 'exponential') {
                if (this.interpolation.base === 1) {
                    interpolation = ['linear'];
                } else {
                    interpolation = [
                        'exponential',
                        this.interpolation.base
                    ];
                }
            } else {
                interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
            }
            const serialized = [
                this.operator,
                interpolation,
                this.input.serialize()
            ];
            for (let i = 0; i < this.labels.length; i++) {
                serialized.push(this.labels[i], this.outputs[i].serialize());
            }
            return serialized;
        }
    }
    function exponentialInterpolation(input, base, lowerValue, upperValue) {
        const difference = upperValue - lowerValue;
        const progress = input - lowerValue;
        if (difference === 0) {
            return 0;
        } else if (base === 1) {
            return progress / difference;
        } else {
            return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
        }
    }
    var Interpolate$1 = Interpolate;

    class Coalesce {
        constructor(type, args) {
            this.type = type;
            this.args = args;
        }
        static parse(args, context) {
            if (args.length < 2) {
                return context.error('Expectected at least one argument.');
            }
            let outputType = null;
            const expectedType = context.expectedType;
            if (expectedType && expectedType.kind !== 'value') {
                outputType = expectedType;
            }
            const parsedArgs = [];
            for (const arg of args.slice(1)) {
                const parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
                if (!parsed)
                    return null;
                outputType = outputType || parsed.type;
                parsedArgs.push(parsed);
            }
            const needsAnnotation = expectedType && parsedArgs.some(arg => checkSubtype(expectedType, arg.type));
            return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
        }
        evaluate(ctx) {
            let result = null;
            let argCount = 0;
            let firstImage;
            for (const arg of this.args) {
                argCount++;
                result = arg.evaluate(ctx);
                if (result && result instanceof ResolvedImage && !result.available) {
                    if (!firstImage) {
                        firstImage = result;
                    }
                    result = null;
                    if (argCount === this.args.length) {
                        return firstImage;
                    }
                }
                if (result !== null)
                    break;
            }
            return result;
        }
        eachChild(fn) {
            this.args.forEach(fn);
        }
        outputDefined() {
            return this.args.every(arg => arg.outputDefined());
        }
        serialize() {
            const serialized = ['coalesce'];
            this.eachChild(child => {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }
    var Coalesce$1 = Coalesce;

    class Let {
        constructor(bindings, result) {
            this.type = result.type;
            this.bindings = [].concat(bindings);
            this.result = result;
        }
        evaluate(ctx) {
            return this.result.evaluate(ctx);
        }
        eachChild(fn) {
            for (const binding of this.bindings) {
                fn(binding[1]);
            }
            fn(this.result);
        }
        static parse(args, context) {
            if (args.length < 4)
                return context.error(`Expected at least 3 arguments, but found ${ args.length - 1 } instead.`);
            const bindings = [];
            for (let i = 1; i < args.length - 1; i += 2) {
                const name = args[i];
                if (typeof name !== 'string') {
                    return context.error(`Expected string, but found ${ typeof name } instead.`, i);
                }
                if (/[^a-zA-Z0-9_]/.test(name)) {
                    return context.error(`Variable names must contain only alphanumeric characters or '_'.`, i);
                }
                const value = context.parse(args[i + 1], i + 1);
                if (!value)
                    return null;
                bindings.push([
                    name,
                    value
                ]);
            }
            const result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
            if (!result)
                return null;
            return new Let(bindings, result);
        }
        outputDefined() {
            return this.result.outputDefined();
        }
        serialize() {
            const serialized = ['let'];
            for (const [name, expr] of this.bindings) {
                serialized.push(name, expr.serialize());
            }
            serialized.push(this.result.serialize());
            return serialized;
        }
    }
    var Let$1 = Let;

    class At {
        constructor(type, index, input) {
            this.type = type;
            this.index = index;
            this.input = input;
        }
        static parse(args, context) {
            if (args.length !== 3)
                return context.error(`Expected 2 arguments, but found ${ args.length - 1 } instead.`);
            const index = context.parse(args[1], 1, NumberType);
            const input = context.parse(args[2], 2, array$1(context.expectedType || ValueType));
            if (!index || !input)
                return null;
            const t = input.type;
            return new At(t.itemType, index, input);
        }
        evaluate(ctx) {
            const index = this.index.evaluate(ctx);
            const array = this.input.evaluate(ctx);
            if (index < 0) {
                throw new RuntimeError$1(`Array index out of bounds: ${ index } < 0.`);
            }
            if (index >= array.length) {
                throw new RuntimeError$1(`Array index out of bounds: ${ index } > ${ array.length - 1 }.`);
            }
            if (index !== Math.floor(index)) {
                throw new RuntimeError$1(`Array index must be an integer, but found ${ index } instead.`);
            }
            return array[index];
        }
        eachChild(fn) {
            fn(this.index);
            fn(this.input);
        }
        outputDefined() {
            return false;
        }
        serialize() {
            return [
                'at',
                this.index.serialize(),
                this.input.serialize()
            ];
        }
    }
    var At$1 = At;

    class In {
        constructor(needle, haystack) {
            this.type = BooleanType;
            this.needle = needle;
            this.haystack = haystack;
        }
        static parse(args, context) {
            if (args.length !== 3) {
                return context.error(`Expected 2 arguments, but found ${ args.length - 1 } instead.`);
            }
            const needle = context.parse(args[1], 1, ValueType);
            const haystack = context.parse(args[2], 2, ValueType);
            if (!needle || !haystack)
                return null;
            if (!isValidType(needle.type, [
                    BooleanType,
                    StringType,
                    NumberType,
                    NullType,
                    ValueType
                ])) {
                return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(needle.type) } instead`);
            }
            return new In(needle, haystack);
        }
        evaluate(ctx) {
            const needle = this.needle.evaluate(ctx);
            const haystack = this.haystack.evaluate(ctx);
            if (haystack == null)
                return false;
            if (!isValidNativeType(needle, [
                    'boolean',
                    'string',
                    'number',
                    'null'
                ])) {
                throw new RuntimeError$1(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(typeOf(needle)) } instead.`);
            }
            if (!isValidNativeType(haystack, [
                    'string',
                    'array'
                ])) {
                throw new RuntimeError$1(`Expected second argument to be of type array or string, but found ${ toString$1(typeOf(haystack)) } instead.`);
            }
            return haystack.indexOf(needle) >= 0;
        }
        eachChild(fn) {
            fn(this.needle);
            fn(this.haystack);
        }
        outputDefined() {
            return true;
        }
        serialize() {
            return [
                'in',
                this.needle.serialize(),
                this.haystack.serialize()
            ];
        }
    }
    var In$1 = In;

    class IndexOf {
        constructor(needle, haystack, fromIndex) {
            this.type = NumberType;
            this.needle = needle;
            this.haystack = haystack;
            this.fromIndex = fromIndex;
        }
        static parse(args, context) {
            if (args.length <= 2 || args.length >= 5) {
                return context.error(`Expected 3 or 4 arguments, but found ${ args.length - 1 } instead.`);
            }
            const needle = context.parse(args[1], 1, ValueType);
            const haystack = context.parse(args[2], 2, ValueType);
            if (!needle || !haystack)
                return null;
            if (!isValidType(needle.type, [
                    BooleanType,
                    StringType,
                    NumberType,
                    NullType,
                    ValueType
                ])) {
                return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(needle.type) } instead`);
            }
            if (args.length === 4) {
                const fromIndex = context.parse(args[3], 3, NumberType);
                if (!fromIndex)
                    return null;
                return new IndexOf(needle, haystack, fromIndex);
            } else {
                return new IndexOf(needle, haystack);
            }
        }
        evaluate(ctx) {
            const needle = this.needle.evaluate(ctx);
            const haystack = this.haystack.evaluate(ctx);
            if (!isValidNativeType(needle, [
                    'boolean',
                    'string',
                    'number',
                    'null'
                ])) {
                throw new RuntimeError$1(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(typeOf(needle)) } instead.`);
            }
            if (!isValidNativeType(haystack, [
                    'string',
                    'array'
                ])) {
                throw new RuntimeError$1(`Expected second argument to be of type array or string, but found ${ toString$1(typeOf(haystack)) } instead.`);
            }
            if (this.fromIndex) {
                const fromIndex = this.fromIndex.evaluate(ctx);
                return haystack.indexOf(needle, fromIndex);
            }
            return haystack.indexOf(needle);
        }
        eachChild(fn) {
            fn(this.needle);
            fn(this.haystack);
            if (this.fromIndex) {
                fn(this.fromIndex);
            }
        }
        outputDefined() {
            return false;
        }
        serialize() {
            if (this.fromIndex != null && this.fromIndex !== undefined) {
                const fromIndex = this.fromIndex.serialize();
                return [
                    'index-of',
                    this.needle.serialize(),
                    this.haystack.serialize(),
                    fromIndex
                ];
            }
            return [
                'index-of',
                this.needle.serialize(),
                this.haystack.serialize()
            ];
        }
    }
    var IndexOf$1 = IndexOf;

    class Match {
        constructor(inputType, outputType, input, cases, outputs, otherwise) {
            this.inputType = inputType;
            this.type = outputType;
            this.input = input;
            this.cases = cases;
            this.outputs = outputs;
            this.otherwise = otherwise;
        }
        static parse(args, context) {
            if (args.length < 5)
                return context.error(`Expected at least 4 arguments, but found only ${ args.length - 1 }.`);
            if (args.length % 2 !== 1)
                return context.error(`Expected an even number of arguments.`);
            let inputType;
            let outputType;
            if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            const cases = {};
            const outputs = [];
            for (let i = 2; i < args.length - 1; i += 2) {
                let labels = args[i];
                const value = args[i + 1];
                if (!Array.isArray(labels)) {
                    labels = [labels];
                }
                const labelContext = context.concat(i);
                if (labels.length === 0) {
                    return labelContext.error('Expected at least one branch label.');
                }
                for (const label of labels) {
                    if (typeof label !== 'number' && typeof label !== 'string') {
                        return labelContext.error(`Branch labels must be numbers or strings.`);
                    } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                        return labelContext.error(`Branch labels must be integers no larger than ${ Number.MAX_SAFE_INTEGER }.`);
                    } else if (typeof label === 'number' && Math.floor(label) !== label) {
                        return labelContext.error(`Numeric branch labels must be integer values.`);
                    } else if (!inputType) {
                        inputType = typeOf(label);
                    } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                        return null;
                    }
                    if (typeof cases[String(label)] !== 'undefined') {
                        return labelContext.error('Branch labels must be unique.');
                    }
                    cases[String(label)] = outputs.length;
                }
                const result = context.parse(value, i, outputType);
                if (!result)
                    return null;
                outputType = outputType || result.type;
                outputs.push(result);
            }
            const input = context.parse(args[1], 1, ValueType);
            if (!input)
                return null;
            const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
            if (!otherwise)
                return null;
            if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
                return null;
            }
            return new Match(inputType, outputType, input, cases, outputs, otherwise);
        }
        evaluate(ctx) {
            const input = this.input.evaluate(ctx);
            const output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
            return output.evaluate(ctx);
        }
        eachChild(fn) {
            fn(this.input);
            this.outputs.forEach(fn);
            fn(this.otherwise);
        }
        outputDefined() {
            return this.outputs.every(out => out.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
            const serialized = [
                'match',
                this.input.serialize()
            ];
            const sortedLabels = Object.keys(this.cases).sort();
            const groupedByOutput = [];
            const outputLookup = {};
            for (const label of sortedLabels) {
                const outputIndex = outputLookup[this.cases[label]];
                if (outputIndex === undefined) {
                    outputLookup[this.cases[label]] = groupedByOutput.length;
                    groupedByOutput.push([
                        this.cases[label],
                        [label]
                    ]);
                } else {
                    groupedByOutput[outputIndex][1].push(label);
                }
            }
            const coerceLabel = label => this.inputType.kind === 'number' ? Number(label) : label;
            for (const [outputIndex, labels] of groupedByOutput) {
                if (labels.length === 1) {
                    serialized.push(coerceLabel(labels[0]));
                } else {
                    serialized.push(labels.map(coerceLabel));
                }
                serialized.push(this.outputs[outputIndex].serialize());
            }
            serialized.push(this.otherwise.serialize());
            return serialized;
        }
    }
    var Match$1 = Match;

    class Case {
        constructor(type, branches, otherwise) {
            this.type = type;
            this.branches = branches;
            this.otherwise = otherwise;
        }
        static parse(args, context) {
            if (args.length < 4)
                return context.error(`Expected at least 3 arguments, but found only ${ args.length - 1 }.`);
            if (args.length % 2 !== 0)
                return context.error(`Expected an odd number of arguments.`);
            let outputType;
            if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            const branches = [];
            for (let i = 1; i < args.length - 1; i += 2) {
                const test = context.parse(args[i], i, BooleanType);
                if (!test)
                    return null;
                const result = context.parse(args[i + 1], i + 1, outputType);
                if (!result)
                    return null;
                branches.push([
                    test,
                    result
                ]);
                outputType = outputType || result.type;
            }
            const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
            if (!otherwise)
                return null;
            return new Case(outputType, branches, otherwise);
        }
        evaluate(ctx) {
            for (const [test, expression] of this.branches) {
                if (test.evaluate(ctx)) {
                    return expression.evaluate(ctx);
                }
            }
            return this.otherwise.evaluate(ctx);
        }
        eachChild(fn) {
            for (const [test, expression] of this.branches) {
                fn(test);
                fn(expression);
            }
            fn(this.otherwise);
        }
        outputDefined() {
            return this.branches.every(([_, out]) => out.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
            const serialized = ['case'];
            this.eachChild(child => {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }
    var Case$1 = Case;

    class Slice {
        constructor(type, input, beginIndex, endIndex) {
            this.type = type;
            this.input = input;
            this.beginIndex = beginIndex;
            this.endIndex = endIndex;
        }
        static parse(args, context) {
            if (args.length <= 2 || args.length >= 5) {
                return context.error(`Expected 3 or 4 arguments, but found ${ args.length - 1 } instead.`);
            }
            const input = context.parse(args[1], 1, ValueType);
            const beginIndex = context.parse(args[2], 2, NumberType);
            if (!input || !beginIndex)
                return null;
            if (!isValidType(input.type, [
                    array$1(ValueType),
                    StringType,
                    ValueType
                ])) {
                return context.error(`Expected first argument to be of type array or string, but found ${ toString$1(input.type) } instead`);
            }
            if (args.length === 4) {
                const endIndex = context.parse(args[3], 3, NumberType);
                if (!endIndex)
                    return null;
                return new Slice(input.type, input, beginIndex, endIndex);
            } else {
                return new Slice(input.type, input, beginIndex);
            }
        }
        evaluate(ctx) {
            const input = this.input.evaluate(ctx);
            const beginIndex = this.beginIndex.evaluate(ctx);
            if (!isValidNativeType(input, [
                    'string',
                    'array'
                ])) {
                throw new RuntimeError$1(`Expected first argument to be of type array or string, but found ${ toString$1(typeOf(input)) } instead.`);
            }
            if (this.endIndex) {
                const endIndex = this.endIndex.evaluate(ctx);
                return input.slice(beginIndex, endIndex);
            }
            return input.slice(beginIndex);
        }
        eachChild(fn) {
            fn(this.input);
            fn(this.beginIndex);
            if (this.endIndex) {
                fn(this.endIndex);
            }
        }
        outputDefined() {
            return false;
        }
        serialize() {
            if (this.endIndex != null && this.endIndex !== undefined) {
                const endIndex = this.endIndex.serialize();
                return [
                    'slice',
                    this.input.serialize(),
                    this.beginIndex.serialize(),
                    endIndex
                ];
            }
            return [
                'slice',
                this.input.serialize(),
                this.beginIndex.serialize()
            ];
        }
    }
    var Slice$1 = Slice;

    function isComparableType(op, type) {
        if (op === '==' || op === '!=') {
            return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
        } else {
            return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
        }
    }
    function eq(ctx, a, b) {
        return a === b;
    }
    function neq(ctx, a, b) {
        return a !== b;
    }
    function lt(ctx, a, b) {
        return a < b;
    }
    function gt(ctx, a, b) {
        return a > b;
    }
    function lteq(ctx, a, b) {
        return a <= b;
    }
    function gteq(ctx, a, b) {
        return a >= b;
    }
    function eqCollate(ctx, a, b, c) {
        return c.compare(a, b) === 0;
    }
    function neqCollate(ctx, a, b, c) {
        return !eqCollate(ctx, a, b, c);
    }
    function ltCollate(ctx, a, b, c) {
        return c.compare(a, b) < 0;
    }
    function gtCollate(ctx, a, b, c) {
        return c.compare(a, b) > 0;
    }
    function lteqCollate(ctx, a, b, c) {
        return c.compare(a, b) <= 0;
    }
    function gteqCollate(ctx, a, b, c) {
        return c.compare(a, b) >= 0;
    }
    function makeComparison(op, compareBasic, compareWithCollator) {
        const isOrderComparison = op !== '==' && op !== '!=';
        return class Comparison {
            constructor(lhs, rhs, collator) {
                this.type = BooleanType;
                this.lhs = lhs;
                this.rhs = rhs;
                this.collator = collator;
                this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
            }
            static parse(args, context) {
                if (args.length !== 3 && args.length !== 4)
                    return context.error(`Expected two or three arguments.`);
                const op = args[0];
                let lhs = context.parse(args[1], 1, ValueType);
                if (!lhs)
                    return null;
                if (!isComparableType(op, lhs.type)) {
                    return context.concat(1).error(`"${ op }" comparisons are not supported for type '${ toString$1(lhs.type) }'.`);
                }
                let rhs = context.parse(args[2], 2, ValueType);
                if (!rhs)
                    return null;
                if (!isComparableType(op, rhs.type)) {
                    return context.concat(2).error(`"${ op }" comparisons are not supported for type '${ toString$1(rhs.type) }'.`);
                }
                if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                    return context.error(`Cannot compare types '${ toString$1(lhs.type) }' and '${ toString$1(rhs.type) }'.`);
                }
                if (isOrderComparison) {
                    if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
                        lhs = new Assertion$1(rhs.type, [lhs]);
                    } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
                        rhs = new Assertion$1(lhs.type, [rhs]);
                    }
                }
                let collator = null;
                if (args.length === 4) {
                    if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                        return context.error(`Cannot use collator to compare non-string types.`);
                    }
                    collator = context.parse(args[3], 3, CollatorType);
                    if (!collator)
                        return null;
                }
                return new Comparison(lhs, rhs, collator);
            }
            evaluate(ctx) {
                const lhs = this.lhs.evaluate(ctx);
                const rhs = this.rhs.evaluate(ctx);
                if (isOrderComparison && this.hasUntypedArgument) {
                    const lt = typeOf(lhs);
                    const rt = typeOf(rhs);
                    if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
                        throw new RuntimeError$1(`Expected arguments for "${ op }" to be (string, string) or (number, number), but found (${ lt.kind }, ${ rt.kind }) instead.`);
                    }
                }
                if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                    const lt = typeOf(lhs);
                    const rt = typeOf(rhs);
                    if (lt.kind !== 'string' || rt.kind !== 'string') {
                        return compareBasic(ctx, lhs, rhs);
                    }
                }
                return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
            }
            eachChild(fn) {
                fn(this.lhs);
                fn(this.rhs);
                if (this.collator) {
                    fn(this.collator);
                }
            }
            outputDefined() {
                return true;
            }
            serialize() {
                const serialized = [op];
                this.eachChild(child => {
                    serialized.push(child.serialize());
                });
                return serialized;
            }
        };
    }
    const Equals = makeComparison('==', eq, eqCollate);
    const NotEquals = makeComparison('!=', neq, neqCollate);
    const LessThan = makeComparison('<', lt, ltCollate);
    const GreaterThan = makeComparison('>', gt, gtCollate);
    const LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
    const GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

    class NumberFormat {
        constructor(number, locale, currency, minFractionDigits, maxFractionDigits) {
            this.type = StringType;
            this.number = number;
            this.locale = locale;
            this.currency = currency;
            this.minFractionDigits = minFractionDigits;
            this.maxFractionDigits = maxFractionDigits;
        }
        static parse(args, context) {
            if (args.length !== 3)
                return context.error(`Expected two arguments.`);
            const number = context.parse(args[1], 1, NumberType);
            if (!number)
                return null;
            const options = args[2];
            if (typeof options !== 'object' || Array.isArray(options))
                return context.error(`NumberFormat options argument must be an object.`);
            let locale = null;
            if (options['locale']) {
                locale = context.parse(options['locale'], 1, StringType);
                if (!locale)
                    return null;
            }
            let currency = null;
            if (options['currency']) {
                currency = context.parse(options['currency'], 1, StringType);
                if (!currency)
                    return null;
            }
            let minFractionDigits = null;
            if (options['min-fraction-digits']) {
                minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
                if (!minFractionDigits)
                    return null;
            }
            let maxFractionDigits = null;
            if (options['max-fraction-digits']) {
                maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
                if (!maxFractionDigits)
                    return null;
            }
            return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
        }
        evaluate(ctx) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
                style: this.currency ? 'currency' : 'decimal',
                currency: this.currency ? this.currency.evaluate(ctx) : undefined,
                minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
                maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
            }).format(this.number.evaluate(ctx));
        }
        eachChild(fn) {
            fn(this.number);
            if (this.locale) {
                fn(this.locale);
            }
            if (this.currency) {
                fn(this.currency);
            }
            if (this.minFractionDigits) {
                fn(this.minFractionDigits);
            }
            if (this.maxFractionDigits) {
                fn(this.maxFractionDigits);
            }
        }
        outputDefined() {
            return false;
        }
        serialize() {
            const options = {};
            if (this.locale) {
                options['locale'] = this.locale.serialize();
            }
            if (this.currency) {
                options['currency'] = this.currency.serialize();
            }
            if (this.minFractionDigits) {
                options['min-fraction-digits'] = this.minFractionDigits.serialize();
            }
            if (this.maxFractionDigits) {
                options['max-fraction-digits'] = this.maxFractionDigits.serialize();
            }
            return [
                'number-format',
                this.number.serialize(),
                options
            ];
        }
    }

    class Length {
        constructor(input) {
            this.type = NumberType;
            this.input = input;
        }
        static parse(args, context) {
            if (args.length !== 2)
                return context.error(`Expected 1 argument, but found ${ args.length - 1 } instead.`);
            const input = context.parse(args[1], 1);
            if (!input)
                return null;
            if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value')
                return context.error(`Expected argument of type string or array, but found ${ toString$1(input.type) } instead.`);
            return new Length(input);
        }
        evaluate(ctx) {
            const input = this.input.evaluate(ctx);
            if (typeof input === 'string') {
                return input.length;
            } else if (Array.isArray(input)) {
                return input.length;
            } else {
                throw new RuntimeError$1(`Expected value to be of type string or array, but found ${ toString$1(typeOf(input)) } instead.`);
            }
        }
        eachChild(fn) {
            fn(this.input);
        }
        outputDefined() {
            return false;
        }
        serialize() {
            const serialized = ['length'];
            this.eachChild(child => {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }
    var Length$1 = Length;

    const expressions = {
        '==': Equals,
        '!=': NotEquals,
        '>': GreaterThan,
        '<': LessThan,
        '>=': GreaterThanOrEqual,
        '<=': LessThanOrEqual,
        'array': Assertion$1,
        'at': At$1,
        'boolean': Assertion$1,
        'case': Case$1,
        'coalesce': Coalesce$1,
        'collator': CollatorExpression,
        'format': FormatExpression,
        'image': ImageExpression,
        'in': In$1,
        'index-of': IndexOf$1,
        'interpolate': Interpolate$1,
        'interpolate-hcl': Interpolate$1,
        'interpolate-lab': Interpolate$1,
        'length': Length$1,
        'let': Let$1,
        'literal': Literal$1,
        'match': Match$1,
        'number': Assertion$1,
        'number-format': NumberFormat,
        'object': Assertion$1,
        'slice': Slice$1,
        'step': Step$1,
        'string': Assertion$1,
        'to-boolean': Coercion$1,
        'to-color': Coercion$1,
        'to-number': Coercion$1,
        'to-string': Coercion$1,
        'var': Var$1,
        'within': Within$1
    };
    function rgba(ctx, [r, g, b, a]) {
        r = r.evaluate(ctx);
        g = g.evaluate(ctx);
        b = b.evaluate(ctx);
        const alpha = a ? a.evaluate(ctx) : 1;
        const error = validateRGBA(r, g, b, alpha);
        if (error)
            throw new RuntimeError$1(error);
        return new Color$1$1(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
    }
    function has(key, obj) {
        return key in obj;
    }
    function get(key, obj) {
        const v = obj[key];
        return typeof v === 'undefined' ? null : v;
    }
    function binarySearch(v, a, i, j) {
        while (i <= j) {
            const m = i + j >> 1;
            if (a[m] === v)
                return true;
            if (a[m] > v)
                j = m - 1;
            else
                i = m + 1;
        }
        return false;
    }
    function varargs(type) {
        return { type };
    }
    CompoundExpression$1.register(expressions, {
        'error': [
            ErrorType,
            [StringType],
            (ctx, [v]) => {
                throw new RuntimeError$1(v.evaluate(ctx));
            }
        ],
        'typeof': [
            StringType,
            [ValueType],
            (ctx, [v]) => toString$1(typeOf(v.evaluate(ctx)))
        ],
        'to-rgba': [
            array$1(NumberType, 4),
            [ColorType],
            (ctx, [v]) => {
                return v.evaluate(ctx).toArray();
            }
        ],
        'rgb': [
            ColorType,
            [
                NumberType,
                NumberType,
                NumberType
            ],
            rgba
        ],
        'rgba': [
            ColorType,
            [
                NumberType,
                NumberType,
                NumberType,
                NumberType
            ],
            rgba
        ],
        'has': {
            type: BooleanType,
            overloads: [
                [
                    [StringType],
                    (ctx, [key]) => has(key.evaluate(ctx), ctx.properties())
                ],
                [
                    [
                        StringType,
                        ObjectType
                    ],
                    (ctx, [key, obj]) => has(key.evaluate(ctx), obj.evaluate(ctx))
                ]
            ]
        },
        'get': {
            type: ValueType,
            overloads: [
                [
                    [StringType],
                    (ctx, [key]) => get(key.evaluate(ctx), ctx.properties())
                ],
                [
                    [
                        StringType,
                        ObjectType
                    ],
                    (ctx, [key, obj]) => get(key.evaluate(ctx), obj.evaluate(ctx))
                ]
            ]
        },
        'feature-state': [
            ValueType,
            [StringType],
            (ctx, [key]) => get(key.evaluate(ctx), ctx.featureState || {})
        ],
        'properties': [
            ObjectType,
            [],
            ctx => ctx.properties()
        ],
        'geometry-type': [
            StringType,
            [],
            ctx => ctx.geometryType()
        ],
        'id': [
            ValueType,
            [],
            ctx => ctx.id()
        ],
        'zoom': [
            NumberType,
            [],
            ctx => ctx.globals.zoom
        ],
        'pitch': [
            NumberType,
            [],
            ctx => ctx.globals.pitch || 0
        ],
        'distance-from-center': [
            NumberType,
            [],
            ctx => ctx.distanceFromCenter()
        ],
        'heatmap-density': [
            NumberType,
            [],
            ctx => ctx.globals.heatmapDensity || 0
        ],
        'line-progress': [
            NumberType,
            [],
            ctx => ctx.globals.lineProgress || 0
        ],
        'sky-radial-progress': [
            NumberType,
            [],
            ctx => ctx.globals.skyRadialProgress || 0
        ],
        'accumulated': [
            ValueType,
            [],
            ctx => ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated
        ],
        '+': [
            NumberType,
            varargs(NumberType),
            (ctx, args) => {
                let result = 0;
                for (const arg of args) {
                    result += arg.evaluate(ctx);
                }
                return result;
            }
        ],
        '*': [
            NumberType,
            varargs(NumberType),
            (ctx, args) => {
                let result = 1;
                for (const arg of args) {
                    result *= arg.evaluate(ctx);
                }
                return result;
            }
        ],
        '-': {
            type: NumberType,
            overloads: [
                [
                    [
                        NumberType,
                        NumberType
                    ],
                    (ctx, [a, b]) => a.evaluate(ctx) - b.evaluate(ctx)
                ],
                [
                    [NumberType],
                    (ctx, [a]) => -a.evaluate(ctx)
                ]
            ]
        },
        '/': [
            NumberType,
            [
                NumberType,
                NumberType
            ],
            (ctx, [a, b]) => a.evaluate(ctx) / b.evaluate(ctx)
        ],
        '%': [
            NumberType,
            [
                NumberType,
                NumberType
            ],
            (ctx, [a, b]) => a.evaluate(ctx) % b.evaluate(ctx)
        ],
        'ln2': [
            NumberType,
            [],
            () => Math.LN2
        ],
        'pi': [
            NumberType,
            [],
            () => Math.PI
        ],
        'e': [
            NumberType,
            [],
            () => Math.E
        ],
        '^': [
            NumberType,
            [
                NumberType,
                NumberType
            ],
            (ctx, [b, e]) => Math.pow(b.evaluate(ctx), e.evaluate(ctx))
        ],
        'sqrt': [
            NumberType,
            [NumberType],
            (ctx, [x]) => Math.sqrt(x.evaluate(ctx))
        ],
        'log10': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN10
        ],
        'ln': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.log(n.evaluate(ctx))
        ],
        'log2': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN2
        ],
        'sin': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.sin(n.evaluate(ctx))
        ],
        'cos': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.cos(n.evaluate(ctx))
        ],
        'tan': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.tan(n.evaluate(ctx))
        ],
        'asin': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.asin(n.evaluate(ctx))
        ],
        'acos': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.acos(n.evaluate(ctx))
        ],
        'atan': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.atan(n.evaluate(ctx))
        ],
        'min': [
            NumberType,
            varargs(NumberType),
            (ctx, args) => Math.min(...args.map(arg => arg.evaluate(ctx)))
        ],
        'max': [
            NumberType,
            varargs(NumberType),
            (ctx, args) => Math.max(...args.map(arg => arg.evaluate(ctx)))
        ],
        'abs': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.abs(n.evaluate(ctx))
        ],
        'round': [
            NumberType,
            [NumberType],
            (ctx, [n]) => {
                const v = n.evaluate(ctx);
                return v < 0 ? -Math.round(-v) : Math.round(v);
            }
        ],
        'floor': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.floor(n.evaluate(ctx))
        ],
        'ceil': [
            NumberType,
            [NumberType],
            (ctx, [n]) => Math.ceil(n.evaluate(ctx))
        ],
        'filter-==': [
            BooleanType,
            [
                StringType,
                ValueType
            ],
            (ctx, [k, v]) => ctx.properties()[k.value] === v.value
        ],
        'filter-id-==': [
            BooleanType,
            [ValueType],
            (ctx, [v]) => ctx.id() === v.value
        ],
        'filter-type-==': [
            BooleanType,
            [StringType],
            (ctx, [v]) => ctx.geometryType() === v.value
        ],
        'filter-<': [
            BooleanType,
            [
                StringType,
                ValueType
            ],
            (ctx, [k, v]) => {
                const a = ctx.properties()[k.value];
                const b = v.value;
                return typeof a === typeof b && a < b;
            }
        ],
        'filter-id-<': [
            BooleanType,
            [ValueType],
            (ctx, [v]) => {
                const a = ctx.id();
                const b = v.value;
                return typeof a === typeof b && a < b;
            }
        ],
        'filter->': [
            BooleanType,
            [
                StringType,
                ValueType
            ],
            (ctx, [k, v]) => {
                const a = ctx.properties()[k.value];
                const b = v.value;
                return typeof a === typeof b && a > b;
            }
        ],
        'filter-id->': [
            BooleanType,
            [ValueType],
            (ctx, [v]) => {
                const a = ctx.id();
                const b = v.value;
                return typeof a === typeof b && a > b;
            }
        ],
        'filter-<=': [
            BooleanType,
            [
                StringType,
                ValueType
            ],
            (ctx, [k, v]) => {
                const a = ctx.properties()[k.value];
                const b = v.value;
                return typeof a === typeof b && a <= b;
            }
        ],
        'filter-id-<=': [
            BooleanType,
            [ValueType],
            (ctx, [v]) => {
                const a = ctx.id();
                const b = v.value;
                return typeof a === typeof b && a <= b;
            }
        ],
        'filter->=': [
            BooleanType,
            [
                StringType,
                ValueType
            ],
            (ctx, [k, v]) => {
                const a = ctx.properties()[k.value];
                const b = v.value;
                return typeof a === typeof b && a >= b;
            }
        ],
        'filter-id->=': [
            BooleanType,
            [ValueType],
            (ctx, [v]) => {
                const a = ctx.id();
                const b = v.value;
                return typeof a === typeof b && a >= b;
            }
        ],
        'filter-has': [
            BooleanType,
            [ValueType],
            (ctx, [k]) => k.value in ctx.properties()
        ],
        'filter-has-id': [
            BooleanType,
            [],
            ctx => ctx.id() !== null && ctx.id() !== undefined
        ],
        'filter-type-in': [
            BooleanType,
            [array$1(StringType)],
            (ctx, [v]) => v.value.indexOf(ctx.geometryType()) >= 0
        ],
        'filter-id-in': [
            BooleanType,
            [array$1(ValueType)],
            (ctx, [v]) => v.value.indexOf(ctx.id()) >= 0
        ],
        'filter-in-small': [
            BooleanType,
            [
                StringType,
                array$1(ValueType)
            ],
            (ctx, [k, v]) => v.value.indexOf(ctx.properties()[k.value]) >= 0
        ],
        'filter-in-large': [
            BooleanType,
            [
                StringType,
                array$1(ValueType)
            ],
            (ctx, [k, v]) => binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1)
        ],
        'all': {
            type: BooleanType,
            overloads: [
                [
                    [
                        BooleanType,
                        BooleanType
                    ],
                    (ctx, [a, b]) => a.evaluate(ctx) && b.evaluate(ctx)
                ],
                [
                    varargs(BooleanType),
                    (ctx, args) => {
                        for (const arg of args) {
                            if (!arg.evaluate(ctx))
                                return false;
                        }
                        return true;
                    }
                ]
            ]
        },
        'any': {
            type: BooleanType,
            overloads: [
                [
                    [
                        BooleanType,
                        BooleanType
                    ],
                    (ctx, [a, b]) => a.evaluate(ctx) || b.evaluate(ctx)
                ],
                [
                    varargs(BooleanType),
                    (ctx, args) => {
                        for (const arg of args) {
                            if (arg.evaluate(ctx))
                                return true;
                        }
                        return false;
                    }
                ]
            ]
        },
        '!': [
            BooleanType,
            [BooleanType],
            (ctx, [b]) => !b.evaluate(ctx)
        ],
        'is-supported-script': [
            BooleanType,
            [StringType],
            (ctx, [s]) => {
                const isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
                if (isSupportedScript) {
                    return isSupportedScript(s.evaluate(ctx));
                }
                return true;
            }
        ],
        'upcase': [
            StringType,
            [StringType],
            (ctx, [s]) => s.evaluate(ctx).toUpperCase()
        ],
        'downcase': [
            StringType,
            [StringType],
            (ctx, [s]) => s.evaluate(ctx).toLowerCase()
        ],
        'concat': [
            StringType,
            varargs(ValueType),
            (ctx, args) => args.map(arg => toString(arg.evaluate(ctx))).join('')
        ],
        'resolved-locale': [
            StringType,
            [CollatorType],
            (ctx, [collator]) => collator.evaluate(ctx).resolvedLocale()
        ]
    });
    var definitions = expressions;
    function isExpression(expression) {
        return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in definitions;
    }

    function convertLiteral(value) {
        return typeof value === 'object' ? [
            'literal',
            value
        ] : value;
    }
    function convertFunction(parameters, propertySpec) {
        let stops = parameters.stops;
        if (!stops) {
            return convertIdentityFunction(parameters, propertySpec);
        }
        const zoomAndFeatureDependent = stops && typeof stops[0][0] === 'object';
        const featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
        const zoomDependent = zoomAndFeatureDependent || !featureDependent;
        stops = stops.map(stop => {
            if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {
                return [
                    stop[0],
                    convertTokenString(stop[1])
                ];
            }
            return [
                stop[0],
                convertLiteral(stop[1])
            ];
        });
        if (zoomAndFeatureDependent) {
            return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
        } else if (zoomDependent) {
            return convertZoomFunction(parameters, propertySpec, stops);
        } else {
            return convertPropertyFunction(parameters, propertySpec, stops);
        }
    }
    function convertIdentityFunction(parameters, propertySpec) {
        const get = [
            'get',
            parameters.property
        ];
        if (parameters.default === undefined) {
            return propertySpec.type === 'string' ? [
                'string',
                get
            ] : get;
        } else if (propertySpec.type === 'enum') {
            return [
                'match',
                get,
                Object.keys(propertySpec.values),
                get,
                parameters.default
            ];
        } else {
            const expression = [
                propertySpec.type === 'color' ? 'to-color' : propertySpec.type,
                get,
                convertLiteral(parameters.default)
            ];
            if (propertySpec.type === 'array') {
                expression.splice(1, 0, propertySpec.value, propertySpec.length || null);
            }
            return expression;
        }
    }
    function getInterpolateOperator(parameters) {
        switch (parameters.colorSpace) {
        case 'hcl':
            return 'interpolate-hcl';
        case 'lab':
            return 'interpolate-lab';
        default:
            return 'interpolate';
        }
    }
    function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
        const featureFunctionParameters = {};
        const featureFunctionStops = {};
        const zoomStops = [];
        for (let s = 0; s < stops.length; s++) {
            const stop = stops[s];
            const zoom = stop[0].zoom;
            if (featureFunctionParameters[zoom] === undefined) {
                featureFunctionParameters[zoom] = {
                    zoom,
                    type: parameters.type,
                    property: parameters.property,
                    default: parameters.default
                };
                featureFunctionStops[zoom] = [];
                zoomStops.push(zoom);
            }
            featureFunctionStops[zoom].push([
                stop[0].value,
                stop[1]
            ]);
        }
        const functionType = getFunctionType({}, propertySpec);
        if (functionType === 'exponential') {
            const expression = [
                getInterpolateOperator(parameters),
                ['linear'],
                ['zoom']
            ];
            for (const z of zoomStops) {
                const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
                appendStopPair(expression, z, output, false);
            }
            return expression;
        } else {
            const expression = [
                'step',
                ['zoom']
            ];
            for (const z of zoomStops) {
                const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
                appendStopPair(expression, z, output, true);
            }
            fixupDegenerateStepCurve(expression);
            return expression;
        }
    }
    function coalesce(a, b) {
        if (a !== undefined)
            return a;
        if (b !== undefined)
            return b;
    }
    function getFallback(parameters, propertySpec) {
        const defaultValue = convertLiteral(coalesce(parameters.default, propertySpec.default));
        if (defaultValue === undefined && propertySpec.type === 'resolvedImage') {
            return '';
        }
        return defaultValue;
    }
    function convertPropertyFunction(parameters, propertySpec, stops) {
        const type = getFunctionType(parameters, propertySpec);
        const get = [
            'get',
            parameters.property
        ];
        if (type === 'categorical' && typeof stops[0][0] === 'boolean') {
            const expression = ['case'];
            for (const stop of stops) {
                expression.push([
                    '==',
                    get,
                    stop[0]
                ], stop[1]);
            }
            expression.push(getFallback(parameters, propertySpec));
            return expression;
        } else if (type === 'categorical') {
            const expression = [
                'match',
                get
            ];
            for (const stop of stops) {
                appendStopPair(expression, stop[0], stop[1], false);
            }
            expression.push(getFallback(parameters, propertySpec));
            return expression;
        } else if (type === 'interval') {
            const expression = [
                'step',
                [
                    'number',
                    get
                ]
            ];
            for (const stop of stops) {
                appendStopPair(expression, stop[0], stop[1], true);
            }
            fixupDegenerateStepCurve(expression);
            return parameters.default === undefined ? expression : [
                'case',
                [
                    '==',
                    [
                        'typeof',
                        get
                    ],
                    'number'
                ],
                expression,
                convertLiteral(parameters.default)
            ];
        } else if (type === 'exponential') {
            const base = parameters.base !== undefined ? parameters.base : 1;
            const expression = [
                getInterpolateOperator(parameters),
                base === 1 ? ['linear'] : [
                    'exponential',
                    base
                ],
                [
                    'number',
                    get
                ]
            ];
            for (const stop of stops) {
                appendStopPair(expression, stop[0], stop[1], false);
            }
            return parameters.default === undefined ? expression : [
                'case',
                [
                    '==',
                    [
                        'typeof',
                        get
                    ],
                    'number'
                ],
                expression,
                convertLiteral(parameters.default)
            ];
        } else {
            throw new Error(`Unknown property function type ${ type }`);
        }
    }
    function convertZoomFunction(parameters, propertySpec, stops, input = ['zoom']) {
        const type = getFunctionType(parameters, propertySpec);
        let expression;
        let isStep = false;
        if (type === 'interval') {
            expression = [
                'step',
                input
            ];
            isStep = true;
        } else if (type === 'exponential') {
            const base = parameters.base !== undefined ? parameters.base : 1;
            expression = [
                getInterpolateOperator(parameters),
                base === 1 ? ['linear'] : [
                    'exponential',
                    base
                ],
                input
            ];
        } else {
            throw new Error(`Unknown zoom function type "${ type }"`);
        }
        for (const stop of stops) {
            appendStopPair(expression, stop[0], stop[1], isStep);
        }
        fixupDegenerateStepCurve(expression);
        return expression;
    }
    function fixupDegenerateStepCurve(expression) {
        if (expression[0] === 'step' && expression.length === 3) {
            expression.push(0);
            expression.push(expression[3]);
        }
    }
    function appendStopPair(curve, input, output, isStep) {
        if (curve.length > 3 && input === curve[curve.length - 2]) {
            return;
        }
        if (!(isStep && curve.length === 2)) {
            curve.push(input);
        }
        curve.push(output);
    }
    function getFunctionType(parameters, propertySpec) {
        if (parameters.type) {
            return parameters.type;
        } else {
            return propertySpec.expression.interpolated ? 'exponential' : 'interval';
        }
    }
    function convertTokenString(s) {
        const result = ['concat'];
        const re = /{([^{}]+)}/g;
        let pos = 0;
        for (let match = re.exec(s); match !== null; match = re.exec(s)) {
            const literal = s.slice(pos, re.lastIndex - match[0].length);
            pos = re.lastIndex;
            if (literal.length > 0)
                result.push(literal);
            result.push([
                'get',
                match[1]
            ]);
        }
        if (result.length === 1) {
            return s;
        }
        if (pos < s.length) {
            result.push(s.slice(pos));
        } else if (result.length === 2) {
            return [
                'to-string',
                result[1]
            ];
        }
        return result;
    }

    function isExpressionFilter(filter) {
        if (filter === true || filter === false) {
            return true;
        }
        if (!Array.isArray(filter) || filter.length === 0) {
            return false;
        }
        switch (filter[0]) {
        case 'has':
            return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
        case 'in':
            return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
        case '!in':
        case '!has':
        case 'none':
            return false;
        case '==':
        case '!=':
        case '>':
        case '>=':
        case '<':
        case '<=':
            return filter.length !== 3 || (Array.isArray(filter[1]) || Array.isArray(filter[2]));
        case 'any':
        case 'all':
            for (const f of filter.slice(1)) {
                if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                    return false;
                }
            }
            return true;
        default:
            return true;
        }
    }

    function convertFilter(filter) {
        return _convertFilter(filter, {});
    }
    function _convertFilter(filter, expectedTypes) {
        if (isExpressionFilter(filter)) {
            return filter;
        }
        if (!filter)
            return true;
        const op = filter[0];
        if (filter.length <= 1)
            return op !== 'any';
        let converted;
        if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
            const [, property, value] = filter;
            converted = convertComparisonOp(property, value, op, expectedTypes);
        } else if (op === 'any') {
            const children = filter.slice(1).map(f => {
                const types = {};
                const child = _convertFilter(f, types);
                const typechecks = runtimeTypeChecks(types);
                return typechecks === true ? child : [
                    'case',
                    typechecks,
                    child,
                    false
                ];
            });
            return ['any'].concat(children);
        } else if (op === 'all') {
            const children = filter.slice(1).map(f => _convertFilter(f, expectedTypes));
            return children.length > 1 ? ['all'].concat(children) : [].concat(...children);
        } else if (op === 'none') {
            return [
                '!',
                _convertFilter(['any'].concat(filter.slice(1)), {})
            ];
        } else if (op === 'in') {
            converted = convertInOp(filter[1], filter.slice(2));
        } else if (op === '!in') {
            converted = convertInOp(filter[1], filter.slice(2), true);
        } else if (op === 'has') {
            converted = convertHasOp(filter[1]);
        } else if (op === '!has') {
            converted = [
                '!',
                convertHasOp(filter[1])
            ];
        } else {
            converted = true;
        }
        return converted;
    }
    function runtimeTypeChecks(expectedTypes) {
        const conditions = [];
        for (const property in expectedTypes) {
            const get = property === '$id' ? ['id'] : [
                'get',
                property
            ];
            conditions.push([
                '==',
                [
                    'typeof',
                    get
                ],
                expectedTypes[property]
            ]);
        }
        if (conditions.length === 0)
            return true;
        if (conditions.length === 1)
            return conditions[0];
        return ['all'].concat(conditions);
    }
    function convertComparisonOp(property, value, op, expectedTypes) {
        let get;
        if (property === '$type') {
            return [
                op,
                ['geometry-type'],
                value
            ];
        } else if (property === '$id') {
            get = ['id'];
        } else {
            get = [
                'get',
                property
            ];
        }
        if (expectedTypes && value !== null) {
            const type = typeof value;
            expectedTypes[property] = type;
        }
        if (op === '==' && property !== '$id' && value === null) {
            return [
                'all',
                [
                    'has',
                    property
                ],
                [
                    '==',
                    get,
                    null
                ]
            ];
        } else if (op === '!=' && property !== '$id' && value === null) {
            return [
                'any',
                [
                    '!',
                    [
                        'has',
                        property
                    ]
                ],
                [
                    '!=',
                    get,
                    null
                ]
            ];
        }
        return [
            op,
            get,
            value
        ];
    }
    function convertInOp(property, values, negate = false) {
        if (values.length === 0)
            return negate;
        let get;
        if (property === '$type') {
            get = ['geometry-type'];
        } else if (property === '$id') {
            get = ['id'];
        } else {
            get = [
                'get',
                property
            ];
        }
        let uniformTypes = true;
        const type = typeof values[0];
        for (const value of values) {
            if (typeof value !== type) {
                uniformTypes = false;
                break;
            }
        }
        if (uniformTypes && (type === 'string' || type === 'number')) {
            const uniqueValues = values.sort().filter((v, i) => i === 0 || values[i - 1] !== v);
            return [
                'match',
                get,
                uniqueValues,
                !negate,
                negate
            ];
        }
        return [negate ? 'all' : 'any'].concat(values.map(v => [
            negate ? '!=' : '==',
            get,
            v
        ]));
    }
    function convertHasOp(property) {
        if (property === '$type') {
            return true;
        } else if (property === '$id') {
            return [
                '!=',
                ['id'],
                null
            ];
        } else {
            return [
                'has',
                property
            ];
        }
    }

    function migrateToExpressions (style) {
        const converted = [];
        eachLayer(style, layer => {
            if (layer.filter) {
                layer.filter = convertFilter(layer.filter);
            }
        });
        eachProperty(style, {
            paint: true,
            layout: true
        }, ({path, value, reference, set}) => {
            if (isExpression(value))
                return;
            if (typeof value === 'object' && !Array.isArray(value)) {
                set(convertFunction(value, reference));
                converted.push(path.join('.'));
            } else if (reference.tokens && typeof value === 'string') {
                set(convertTokenString(value));
            }
        });
        return style;
    }

    function migrate (style) {
        let migrated = false;
        if (style.version === 7) {
            style = migrateToV8(style);
            migrated = true;
        }
        if (style.version === 8) {
            migrated = migrateToExpressions(style);
            migrated = true;
        }
        if (!migrated) {
            throw new Error('cannot migrate from', style.version);
        }
        return style;
    }

    /* parser generated by jison 0.4.15 */

    createCommonjsModule$1(function (module, exports) {
    /*
      Returns a Parser object of the following structure:

      Parser: {
        yy: {}
      }

      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),

        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),

            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },

            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }


      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }


      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = (function(){
    var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,13],$V2=[1,9],$V3=[1,10],$V4=[1,11],$V5=[1,14],$V6=[1,15],$V7=[14,18,22,24],$V8=[18,22],$V9=[22,24];
    var parser = {trace: function trace() { },
    yy: {},
    symbols_: {"error":2,"JSONString":3,"STRING":4,"JSONNumber":5,"NUMBER":6,"JSONNullLiteral":7,"NULL":8,"JSONBooleanLiteral":9,"TRUE":10,"FALSE":11,"JSONText":12,"JSONValue":13,"EOF":14,"JSONObject":15,"JSONArray":16,"{":17,"}":18,"JSONMemberList":19,"JSONMember":20,":":21,",":22,"[":23,"]":24,"JSONElementList":25,"$accept":0,"$end":1},
    terminals_: {2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},
    productions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
    /* this == yyval */

    var $0 = $$.length - 1;
    switch (yystate) {
    case 1:
     // replace escaped characters with actual character
              this.$ = new String(yytext.replace(/\\(\\|")/g, "$"+"1")
                         .replace(/\\n/g,'\n')
                         .replace(/\\r/g,'\r')
                         .replace(/\\t/g,'\t')
                         .replace(/\\v/g,'\v')
                         .replace(/\\f/g,'\f')
                         .replace(/\\b/g,'\b'));
              this.$.__line__ =  this._$.first_line;
            
    break;
    case 2:

                this.$ = new Number(yytext);
                this.$.__line__ =  this._$.first_line;
            
    break;
    case 3:

                this.$ = null;
            
    break;
    case 4:

                this.$ = new Boolean(true);
                this.$.__line__ = this._$.first_line;
            
    break;
    case 5:

                this.$ = new Boolean(false);
                this.$.__line__ = this._$.first_line;
            
    break;
    case 6:
    return this.$ = $$[$0-1];
    case 13:
    this.$ = {}; Object.defineProperty(this.$, '__line__', {
                value: this._$.first_line,
                enumerable: false
            });
    break;
    case 14: case 19:
    this.$ = $$[$0-1]; Object.defineProperty(this.$, '__line__', {
                value: this._$.first_line,
                enumerable: false
            });
    break;
    case 15:
    this.$ = [$$[$0-2], $$[$0]];
    break;
    case 16:
    this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
    break;
    case 17:
    this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];
    break;
    case 18:
    this.$ = []; Object.defineProperty(this.$, '__line__', {
                value: this._$.first_line,
                enumerable: false
            });
    break;
    case 20:
    this.$ = [$$[$0]];
    break;
    case 21:
    this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);
    break;
    }
    },
    table: [{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,12:1,13:2,15:7,16:8,17:$V5,23:$V6},{1:[3]},{14:[1,16]},o($V7,[2,7]),o($V7,[2,8]),o($V7,[2,9]),o($V7,[2,10]),o($V7,[2,11]),o($V7,[2,12]),o($V7,[2,3]),o($V7,[2,4]),o($V7,[2,5]),o([14,18,21,22,24],[2,1]),o($V7,[2,2]),{3:20,4:$V0,18:[1,17],19:18,20:19},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:23,15:7,16:8,17:$V5,23:$V6,24:[1,21],25:22},{1:[2,6]},o($V7,[2,13]),{18:[1,24],22:[1,25]},o($V8,[2,16]),{21:[1,26]},o($V7,[2,18]),{22:[1,28],24:[1,27]},o($V9,[2,20]),o($V7,[2,14]),{3:20,4:$V0,20:29},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:30,15:7,16:8,17:$V5,23:$V6},o($V7,[2,19]),{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:31,15:7,16:8,17:$V5,23:$V6},o($V8,[2,17]),o($V8,[2,15]),o($V9,[2,21])],
    defaultActions: {16:[2,6]},
    parseError: function parseError(str, hash) {
        if (hash.recoverable) {
            this.trace(str);
        } else {
            throw new Error(str);
        }
    },
    parse: function parse(input) {
        var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k in this.yy) {
            if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                sharedState.yy[k] = this.yy[k];
            }
        }
        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;
        if (typeof lexer.yylloc == 'undefined') {
            lexer.yylloc = {};
        }
        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;
        if (typeof sharedState.yy.parseError === 'function') {
            this.parseError = sharedState.yy.parseError;
        } else {
            this.parseError = Object.getPrototypeOf(this).parseError;
        }
        
            function lex() {
                var token;
                token = lexer.lex() || EOF;
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
                action = this.defaultActions[state];
            } else {
                if (symbol === null || typeof symbol == 'undefined') {
                    symbol = lex();
                }
                action = table[state] && table[state][symbol];
            }
                        if (typeof action === 'undefined' || !action.length || !action[0]) {
                    var errStr = '';
                    expected = [];
                    for (p in table[state]) {
                        if (this.terminals_[p] && p > TERROR) {
                            expected.push('\'' + this.terminals_[p] + '\'');
                        }
                    }
                    if (lexer.showPosition) {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                    } else {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                    }
                    this.parseError(errStr, {
                        text: lexer.match,
                        token: this.terminals_[symbol] || symbol,
                        line: lexer.yylineno,
                        loc: yyloc,
                        expected: expected
                    });
                }
            if (action[0] instanceof Array && action.length > 1) {
                throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                {
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;
                }
                break;
            case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                };
                if (ranges) {
                    yyval._$.range = [
                        lstack[lstack.length - (len || 1)].range[0],
                        lstack[lstack.length - 1].range[1]
                    ];
                }
                r = this.performAction.apply(yyval, [
                    yytext,
                    yyleng,
                    yylineno,
                    sharedState.yy,
                    action[1],
                    vstack,
                    lstack
                ].concat(args));
                if (typeof r !== 'undefined') {
                    return r;
                }
                if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
            case 3:
                return true;
            }
        }
        return true;
    }};
    /* generated by jison-lex 0.3.4 */
    var lexer = (function(){
    var lexer = ({

    EOF:1,

    parseError:function parseError(str, hash) {
            if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
            } else {
                throw new Error(str);
            }
        },

    // resets the lexer, sets new input
    setInput:function (input, yy) {
            this.yy = yy || this.yy || {};
            this._input = input;
            this._more = this._backtrack = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = '';
            this.conditionStack = ['INITIAL'];
            this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
            };
            if (this.options.ranges) {
                this.yylloc.range = [0,0];
            }
            this.offset = 0;
            return this;
        },

    // consumes and returns one char from the input
    input:function () {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
            } else {
                this.yylloc.last_column++;
            }
            if (this.options.ranges) {
                this.yylloc.range[1]++;
            }

            this._input = this._input.slice(1);
            return ch;
        },

    // unshifts one char (or a string) into the input
    unput:function (ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);

            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            //this.yyleng -= len;
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);

            if (lines.length - 1) {
                this.yylineno -= lines.length - 1;
            }
            var r = this.yylloc.range;

            this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ?
                    (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                     + oldLines[oldLines.length - lines.length].length - lines[0].length :
                  this.yylloc.first_column - len
            };

            if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
            }
            this.yyleng = this.yytext.length;
            return this;
        },

    // When called from action, caches matched text and appends it on next action
    more:function () {
            this._more = true;
            return this;
        },

    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
    reject:function () {
            if (this.options.backtrack_lexer) {
                this._backtrack = true;
            } else {
                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                });

            }
            return this;
        },

    // retain first n characters of the match
    less:function (n) {
            this.unput(this.match.slice(n));
        },

    // displays already matched input, i.e. for error messages
    pastInput:function () {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
        },

    // displays upcoming input, i.e. for error messages
    upcomingInput:function () {
            var next = this.match;
            if (next.length < 20) {
                next += this._input.substr(0, 20-next.length);
            }
            return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },

    // displays the character position where the lexing error occurred, i.e. for error messages
    showPosition:function () {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c + "^";
        },

    // test the lexed token: return FALSE when not a match, otherwise return token
    test_match:function (match, indexed_rule) {
            var token,
                lines,
                backup;

            if (this.options.backtrack_lexer) {
                // save context
                backup = {
                    yylineno: this.yylineno,
                    yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                };
                if (this.options.ranges) {
                    backup.yylloc.range = this.yylloc.range.slice(0);
                }
            }

            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) {
                this.yylineno += lines.length;
            }
            this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ?
                             lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                             this.yylloc.last_column + match[0].length
            };
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input) {
                this.done = false;
            }
            if (token) {
                return token;
            } else if (this._backtrack) {
                // recover context
                for (var k in backup) {
                    this[k] = backup[k];
                }
                return false; // rule action called reject() implying the next rule should be tested instead.
            }
            return false;
        },

    // return next match in input
    next:function () {
            if (this.done) {
                return this.EOF;
            }
            if (!this._input) {
                this.done = true;
            }

            var token,
                match,
                tempMatch,
                index;
            if (!this._more) {
                this.yytext = '';
                this.match = '';
            }
            var rules = this._currentRules();
            for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                    match = tempMatch;
                    index = i;
                    if (this.options.backtrack_lexer) {
                        token = this.test_match(tempMatch, rules[i]);
                        if (token !== false) {
                            return token;
                        } else if (this._backtrack) {
                            match = false;
                            continue; // rule action called reject() implying a rule MISmatch.
                        } else {
                            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                            return false;
                        }
                    } else if (!this.options.flex) {
                        break;
                    }
                }
            }
            if (match) {
                token = this.test_match(match, rules[index]);
                if (token !== false) {
                    return token;
                }
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
            }
            if (this._input === "") {
                return this.EOF;
            } else {
                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                });
            }
        },

    // return next match that has a token
    lex:function lex() {
            var r = this.next();
            if (r) {
                return r;
            } else {
                return this.lex();
            }
        },

    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
    begin:function begin(condition) {
            this.conditionStack.push(condition);
        },

    // pop the previously active lexer condition state off the condition stack
    popState:function popState() {
            var n = this.conditionStack.length - 1;
            if (n > 0) {
                return this.conditionStack.pop();
            } else {
                return this.conditionStack[0];
            }
        },

    // produce the lexer rule set which is active for the currently active lexer condition state
    _currentRules:function _currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            } else {
                return this.conditions["INITIAL"].rules;
            }
        },

    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
    topState:function topState(n) {
            n = this.conditionStack.length - 1 - Math.abs(n || 0);
            if (n >= 0) {
                return this.conditionStack[n];
            } else {
                return "INITIAL";
            }
        },

    // alias for begin(condition)
    pushState:function pushState(condition) {
            this.begin(condition);
        },

    // return the number of states currently on the stack
    stateStackSize:function stateStackSize() {
            return this.conditionStack.length;
        },
    options: {},
    performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
    switch($avoiding_name_collisions) {
    case 0:/* skip whitespace */
    break;
    case 1:return 6
    case 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4
    case 3:return 17
    case 4:return 18
    case 5:return 23
    case 6:return 24
    case 7:return 22
    case 8:return 21
    case 9:return 10
    case 10:return 11
    case 11:return 8
    case 12:return 14
    case 13:return 'INVALID'
    }
    },
    rules: [/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/],
    conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}}
    });
    return lexer;
    })();
    parser.lexer = lexer;
    function Parser () {
      this.yy = {};
    }
    Parser.prototype = parser;parser.Parser = Parser;
    return new Parser;
    })();


    if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
    exports.parser = parser;
    exports.Parser = parser.Parser;
    exports.parse = function () { return parser.parse.apply(parser, arguments); };
    }
    });

    const parseNumber = parseFloat;

    function joinCss(obj, separator = ';') {
      let texts;
      if (Array.isArray(obj)) {
        texts = obj.filter((text) => text);
      } else {
        texts = [];
        for (const prop in obj) {
          if (obj[prop]) {
            texts.push(`${prop}:${obj[prop]}`);
          }
        }
      }
      return texts.join(separator);
    }

    function getStyles(style, size, pull, fw) {
      let float;
      let width;
      const height = '1em';
      let lineHeight;
      let fontSize;
      let textAlign;
      let verticalAlign = '-.125em';
      const overflow = 'visible';

      if (fw) {
        textAlign = 'center';
        width = '1.25em';
      }

      if (pull) {
        float = pull;
      }

      if (size) {
        if (size == 'lg') {
          fontSize = '1.33333em';
          lineHeight = '.75em';
          verticalAlign = '-.225em';
        } else if (size == 'xs') {
          fontSize = '.75em';
        } else if (size == 'sm') {
          fontSize = '.875em';
        } else {
          fontSize = size.replace('x', 'em');
        }
      }

      return joinCss([
        joinCss({
          float,
          width,
          height,
          'line-height': lineHeight,
          'font-size': fontSize,
          'text-align': textAlign,
          'vertical-align': verticalAlign,
          'transform-origin': 'center',
          overflow,
        }),
        style,
      ]);
    }

    function getTransform(
      scale,
      translateX,
      translateY,
      rotate,
      flip,
      translateTimes = 1,
      translateUnit = '',
      rotateUnit = '',
    ) {
      let flipX = 1;
      let flipY = 1;

      if (flip) {
        if (flip == 'horizontal') {
          flipX = -1;
        } else if (flip == 'vertical') {
          flipY = -1;
        } else {
          flipX = flipY = -1;
        }
      }

      return joinCss(
        [
          `translate(${parseNumber(translateX) * translateTimes}${translateUnit},${parseNumber(translateY) * translateTimes}${translateUnit})`,
          `scale(${flipX * parseNumber(scale)},${flipY * parseNumber(scale)})`,
          rotate && `rotate(${rotate}${rotateUnit})`,
        ],
        ' ',
      );
    }

    var e=[],t=[];function n(n,r){if(n&&"undefined"!=typeof document){var a,s=!0===r.prepend?"prepend":"append",d=!0===r.singleTag,i="string"==typeof r.container?document.querySelector(r.container):document.getElementsByTagName("head")[0];if(d){var u=e.indexOf(i);-1===u&&(u=e.push(i)-1,t[u]={}),a=t[u]&&t[u][s]?t[u][s]:t[u][s]=c();}else a=c();65279===n.charCodeAt(0)&&(n=n.substring(1)),a.styleSheet?a.styleSheet.cssText+=n:a.appendChild(document.createTextNode(n));}function c(){var e=document.createElement("style");if(e.setAttribute("type","text/css"),r.attributes)for(var t=Object.keys(r.attributes),n=0;n<t.length;n++)e.setAttribute(t[n],r.attributes[t[n]]);var a="prepend"===s?"afterbegin":"beforeend";return i.insertAdjacentElement(a,e),e}}

    var css$9 = ".spin.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 2s 0s infinite linear}.pulse.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 1s infinite steps(8)}@keyframes svelte-1cj2gr0-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";
    n(css$9,{});

    /* node_modules/svelte-fa/src/fa.svelte generated by Svelte v3.48.0 */
    const file$9 = "node_modules/svelte-fa/src/fa.svelte";

    // (78:0) {#if i[4]}
    function create_if_block$6(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let g1_transform_value;
    	let g1_transform_origin_value;
    	let svg_class_value;
    	let svg_viewBox_value;

    	function select_block_type(ctx, dirty) {
    		if (typeof /*i*/ ctx[7][4] == 'string') return create_if_block_1$5;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			if_block.c();
    			attr_dev(g0, "transform", /*transform*/ ctx[10]);
    			add_location(g0, file$9, 91, 6, 1469);
    			attr_dev(g1, "transform", g1_transform_value = `translate(${/*i*/ ctx[7][0] / 2} ${/*i*/ ctx[7][1] / 2})`);
    			attr_dev(g1, "transform-origin", g1_transform_origin_value = `${/*i*/ ctx[7][0] / 4} 0`);
    			add_location(g1, file$9, 87, 4, 1358);
    			attr_dev(svg, "id", /*id*/ ctx[0]);
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*c*/ ctx[8]) + " svelte-1cj2gr0"));
    			attr_dev(svg, "style", /*s*/ ctx[9]);
    			attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*i*/ ctx[7][0]} ${/*i*/ ctx[7][1]}`);
    			attr_dev(svg, "aria-hidden", "true");
    			attr_dev(svg, "role", "img");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$9, 78, 2, 1195);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			if_block.m(g0, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(g0, null);
    				}
    			}

    			if (dirty & /*transform*/ 1024) {
    				attr_dev(g0, "transform", /*transform*/ ctx[10]);
    			}

    			if (dirty & /*i*/ 128 && g1_transform_value !== (g1_transform_value = `translate(${/*i*/ ctx[7][0] / 2} ${/*i*/ ctx[7][1] / 2})`)) {
    				attr_dev(g1, "transform", g1_transform_value);
    			}

    			if (dirty & /*i*/ 128 && g1_transform_origin_value !== (g1_transform_origin_value = `${/*i*/ ctx[7][0] / 4} 0`)) {
    				attr_dev(g1, "transform-origin", g1_transform_origin_value);
    			}

    			if (dirty & /*id*/ 1) {
    				attr_dev(svg, "id", /*id*/ ctx[0]);
    			}

    			if (dirty & /*c*/ 256 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*c*/ ctx[8]) + " svelte-1cj2gr0"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*s*/ 512) {
    				attr_dev(svg, "style", /*s*/ ctx[9]);
    			}

    			if (dirty & /*i*/ 128 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*i*/ ctx[7][0]} ${/*i*/ ctx[7][1]}`)) {
    				attr_dev(svg, "viewBox", svg_viewBox_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(78:0) {#if i[4]}",
    		ctx
    	});

    	return block;
    }

    // (99:8) {:else}
    function create_else_block(ctx) {
    	let path0;
    	let path0_d_value;
    	let path0_fill_value;
    	let path0_fill_opacity_value;
    	let path0_transform_value;
    	let path1;
    	let path1_d_value;
    	let path1_fill_value;
    	let path1_fill_opacity_value;
    	let path1_transform_value;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", path0_d_value = /*i*/ ctx[7][4][0]);
    			attr_dev(path0, "fill", path0_fill_value = /*secondaryColor*/ ctx[3] || /*color*/ ctx[1] || 'currentColor');

    			attr_dev(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
    			? /*primaryOpacity*/ ctx[4]
    			: /*secondaryOpacity*/ ctx[5]);

    			attr_dev(path0, "transform", path0_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`);
    			add_location(path0, file$9, 99, 10, 1721);
    			attr_dev(path1, "d", path1_d_value = /*i*/ ctx[7][4][1]);
    			attr_dev(path1, "fill", path1_fill_value = /*primaryColor*/ ctx[2] || /*color*/ ctx[1] || 'currentColor');

    			attr_dev(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
    			? /*secondaryOpacity*/ ctx[5]
    			: /*primaryOpacity*/ ctx[4]);

    			attr_dev(path1, "transform", path1_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`);
    			add_location(path1, file$9, 105, 10, 1982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*i*/ 128 && path0_d_value !== (path0_d_value = /*i*/ ctx[7][4][0])) {
    				attr_dev(path0, "d", path0_d_value);
    			}

    			if (dirty & /*secondaryColor, color*/ 10 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/ ctx[3] || /*color*/ ctx[1] || 'currentColor')) {
    				attr_dev(path0, "fill", path0_fill_value);
    			}

    			if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/ 112 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
    			? /*primaryOpacity*/ ctx[4]
    			: /*secondaryOpacity*/ ctx[5])) {
    				attr_dev(path0, "fill-opacity", path0_fill_opacity_value);
    			}

    			if (dirty & /*i*/ 128 && path0_transform_value !== (path0_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`)) {
    				attr_dev(path0, "transform", path0_transform_value);
    			}

    			if (dirty & /*i*/ 128 && path1_d_value !== (path1_d_value = /*i*/ ctx[7][4][1])) {
    				attr_dev(path1, "d", path1_d_value);
    			}

    			if (dirty & /*primaryColor, color*/ 6 && path1_fill_value !== (path1_fill_value = /*primaryColor*/ ctx[2] || /*color*/ ctx[1] || 'currentColor')) {
    				attr_dev(path1, "fill", path1_fill_value);
    			}

    			if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/ 112 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
    			? /*secondaryOpacity*/ ctx[5]
    			: /*primaryOpacity*/ ctx[4])) {
    				attr_dev(path1, "fill-opacity", path1_fill_opacity_value);
    			}

    			if (dirty & /*i*/ 128 && path1_transform_value !== (path1_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`)) {
    				attr_dev(path1, "transform", path1_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching) detach_dev(path1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(99:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (93:8) {#if typeof i[4] == 'string'}
    function create_if_block_1$5(ctx) {
    	let path;
    	let path_d_value;
    	let path_fill_value;
    	let path_transform_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", path_d_value = /*i*/ ctx[7][4]);
    			attr_dev(path, "fill", path_fill_value = /*color*/ ctx[1] || /*primaryColor*/ ctx[2] || 'currentColor');
    			attr_dev(path, "transform", path_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`);
    			add_location(path, file$9, 93, 10, 1533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*i*/ 128 && path_d_value !== (path_d_value = /*i*/ ctx[7][4])) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty & /*color, primaryColor*/ 6 && path_fill_value !== (path_fill_value = /*color*/ ctx[1] || /*primaryColor*/ ctx[2] || 'currentColor')) {
    				attr_dev(path, "fill", path_fill_value);
    			}

    			if (dirty & /*i*/ 128 && path_transform_value !== (path_transform_value = `translate(${/*i*/ ctx[7][0] / -2} ${/*i*/ ctx[7][1] / -2})`)) {
    				attr_dev(path, "transform", path_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(93:8) {#if typeof i[4] == 'string'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let if_block_anchor;
    	let if_block = /*i*/ ctx[7][4] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*i*/ ctx[7][4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fa', slots, []);
    	let { class: clazz = '' } = $$props;
    	let { id = '' } = $$props;
    	let { style = '' } = $$props;
    	let { icon } = $$props;
    	let { size = '' } = $$props;
    	let { color = '' } = $$props;
    	let { fw = false } = $$props;
    	let { pull = '' } = $$props;
    	let { scale = 1 } = $$props;
    	let { translateX = 0 } = $$props;
    	let { translateY = 0 } = $$props;
    	let { rotate = '' } = $$props;
    	let { flip = false } = $$props;
    	let { spin = false } = $$props;
    	let { pulse = false } = $$props;
    	let { primaryColor = '' } = $$props;
    	let { secondaryColor = '' } = $$props;
    	let { primaryOpacity = 1 } = $$props;
    	let { secondaryOpacity = 0.4 } = $$props;
    	let { swapOpacity = false } = $$props;
    	let i;
    	let c;
    	let s;
    	let transform;

    	const writable_props = [
    		'class',
    		'id',
    		'style',
    		'icon',
    		'size',
    		'color',
    		'fw',
    		'pull',
    		'scale',
    		'translateX',
    		'translateY',
    		'rotate',
    		'flip',
    		'spin',
    		'pulse',
    		'primaryColor',
    		'secondaryColor',
    		'primaryOpacity',
    		'secondaryOpacity',
    		'swapOpacity'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Fa> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('class' in $$props) $$invalidate(11, clazz = $$props.class);
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('style' in $$props) $$invalidate(12, style = $$props.style);
    		if ('icon' in $$props) $$invalidate(13, icon = $$props.icon);
    		if ('size' in $$props) $$invalidate(14, size = $$props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    		if ('fw' in $$props) $$invalidate(15, fw = $$props.fw);
    		if ('pull' in $$props) $$invalidate(16, pull = $$props.pull);
    		if ('scale' in $$props) $$invalidate(17, scale = $$props.scale);
    		if ('translateX' in $$props) $$invalidate(18, translateX = $$props.translateX);
    		if ('translateY' in $$props) $$invalidate(19, translateY = $$props.translateY);
    		if ('rotate' in $$props) $$invalidate(20, rotate = $$props.rotate);
    		if ('flip' in $$props) $$invalidate(21, flip = $$props.flip);
    		if ('spin' in $$props) $$invalidate(22, spin = $$props.spin);
    		if ('pulse' in $$props) $$invalidate(23, pulse = $$props.pulse);
    		if ('primaryColor' in $$props) $$invalidate(2, primaryColor = $$props.primaryColor);
    		if ('secondaryColor' in $$props) $$invalidate(3, secondaryColor = $$props.secondaryColor);
    		if ('primaryOpacity' in $$props) $$invalidate(4, primaryOpacity = $$props.primaryOpacity);
    		if ('secondaryOpacity' in $$props) $$invalidate(5, secondaryOpacity = $$props.secondaryOpacity);
    		if ('swapOpacity' in $$props) $$invalidate(6, swapOpacity = $$props.swapOpacity);
    	};

    	$$self.$capture_state = () => ({
    		joinCss,
    		getStyles,
    		getTransform,
    		clazz,
    		id,
    		style,
    		icon,
    		size,
    		color,
    		fw,
    		pull,
    		scale,
    		translateX,
    		translateY,
    		rotate,
    		flip,
    		spin,
    		pulse,
    		primaryColor,
    		secondaryColor,
    		primaryOpacity,
    		secondaryOpacity,
    		swapOpacity,
    		i,
    		c,
    		s,
    		transform
    	});

    	$$self.$inject_state = $$props => {
    		if ('clazz' in $$props) $$invalidate(11, clazz = $$props.clazz);
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('style' in $$props) $$invalidate(12, style = $$props.style);
    		if ('icon' in $$props) $$invalidate(13, icon = $$props.icon);
    		if ('size' in $$props) $$invalidate(14, size = $$props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    		if ('fw' in $$props) $$invalidate(15, fw = $$props.fw);
    		if ('pull' in $$props) $$invalidate(16, pull = $$props.pull);
    		if ('scale' in $$props) $$invalidate(17, scale = $$props.scale);
    		if ('translateX' in $$props) $$invalidate(18, translateX = $$props.translateX);
    		if ('translateY' in $$props) $$invalidate(19, translateY = $$props.translateY);
    		if ('rotate' in $$props) $$invalidate(20, rotate = $$props.rotate);
    		if ('flip' in $$props) $$invalidate(21, flip = $$props.flip);
    		if ('spin' in $$props) $$invalidate(22, spin = $$props.spin);
    		if ('pulse' in $$props) $$invalidate(23, pulse = $$props.pulse);
    		if ('primaryColor' in $$props) $$invalidate(2, primaryColor = $$props.primaryColor);
    		if ('secondaryColor' in $$props) $$invalidate(3, secondaryColor = $$props.secondaryColor);
    		if ('primaryOpacity' in $$props) $$invalidate(4, primaryOpacity = $$props.primaryOpacity);
    		if ('secondaryOpacity' in $$props) $$invalidate(5, secondaryOpacity = $$props.secondaryOpacity);
    		if ('swapOpacity' in $$props) $$invalidate(6, swapOpacity = $$props.swapOpacity);
    		if ('i' in $$props) $$invalidate(7, i = $$props.i);
    		if ('c' in $$props) $$invalidate(8, c = $$props.c);
    		if ('s' in $$props) $$invalidate(9, s = $$props.s);
    		if ('transform' in $$props) $$invalidate(10, transform = $$props.transform);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*icon*/ 8192) {
    			$$invalidate(7, i = icon && icon.icon || [0, 0, '', [], '']);
    		}

    		if ($$self.$$.dirty & /*clazz, spin, pulse*/ 12584960) {
    			$$invalidate(8, c = joinCss([clazz, 'svelte-fa', spin && 'spin', pulse && 'pulse'], ' '));
    		}

    		if ($$self.$$.dirty & /*style, size, pull, fw*/ 118784) {
    			$$invalidate(9, s = getStyles(style, size, pull, fw));
    		}

    		if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/ 4063232) {
    			$$invalidate(10, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
    		}
    	};

    	return [
    		id,
    		color,
    		primaryColor,
    		secondaryColor,
    		primaryOpacity,
    		secondaryOpacity,
    		swapOpacity,
    		i,
    		c,
    		s,
    		transform,
    		clazz,
    		style,
    		icon,
    		size,
    		fw,
    		pull,
    		scale,
    		translateX,
    		translateY,
    		rotate,
    		flip,
    		spin,
    		pulse
    	];
    }

    class Fa extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			class: 11,
    			id: 0,
    			style: 12,
    			icon: 13,
    			size: 14,
    			color: 1,
    			fw: 15,
    			pull: 16,
    			scale: 17,
    			translateX: 18,
    			translateY: 19,
    			rotate: 20,
    			flip: 21,
    			spin: 22,
    			pulse: 23,
    			primaryColor: 2,
    			secondaryColor: 3,
    			primaryOpacity: 4,
    			secondaryOpacity: 5,
    			swapOpacity: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fa",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*icon*/ ctx[13] === undefined && !('icon' in props)) {
    			console.warn("<Fa> was created without expected prop 'icon'");
    		}
    	}

    	get class() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fw() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fw(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pull() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pull(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scale() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scale(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get translateX() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set translateX(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get translateY() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set translateY(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rotate() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rotate(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spin() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spin(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pulse() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pulse(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primaryColor() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primaryColor(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get secondaryColor() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set secondaryColor(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primaryOpacity() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primaryOpacity(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get secondaryOpacity() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set secondaryOpacity(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swapOpacity() {
    		throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swapOpacity(value) {
    		throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Fa$1 = Fa;

    /*!
     * Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com
     * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
     * Copyright 2022 Fonticons, Inc.
     */
    var faDownload = {
      prefix: 'fas',
      iconName: 'download',
      icon: [512, 512, [], "f019", "M480 352h-133.5l-45.25 45.25C289.2 409.3 273.1 416 256 416s-33.16-6.656-45.25-18.75L165.5 352H32c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h448c17.67 0 32-14.33 32-32v-96C512 366.3 497.7 352 480 352zM432 456c-13.2 0-24-10.8-24-24c0-13.2 10.8-24 24-24s24 10.8 24 24C456 445.2 445.2 456 432 456zM233.4 374.6C239.6 380.9 247.8 384 256 384s16.38-3.125 22.62-9.375l128-128c12.49-12.5 12.49-32.75 0-45.25c-12.5-12.5-32.76-12.5-45.25 0L288 274.8V32c0-17.67-14.33-32-32-32C238.3 0 224 14.33 224 32v242.8L150.6 201.4c-12.49-12.5-32.75-12.5-45.25 0c-12.49 12.5-12.49 32.75 0 45.25L233.4 374.6z"]
    };
    var faTrash = {
      prefix: 'fas',
      iconName: 'trash',
      icon: [448, 512, [], "f1f8", "M135.2 17.69C140.6 6.848 151.7 0 163.8 0H284.2C296.3 0 307.4 6.848 312.8 17.69L320 32H416C433.7 32 448 46.33 448 64C448 81.67 433.7 96 416 96H32C14.33 96 0 81.67 0 64C0 46.33 14.33 32 32 32H128L135.2 17.69zM394.8 466.1C393.2 492.3 372.3 512 346.9 512H101.1C75.75 512 54.77 492.3 53.19 466.1L31.1 128H416L394.8 466.1z"]
    };

    function readQuery() {
      return Object.fromEntries(
        window.location.hash
          .slice(1)
          .split('&')
          .map(s => s.split('='))
      );
    }

    function writeQuery(state) {
      window.location.hash = Object.entries(state)
        .map(([k, v]) => {
          return [encodeURIComponent(k), encodeURIComponent(v)].join('=');
        })
        .join('&');
    }

    var css$8 = ".tab.svelte-c8a31t{margin-right:1em;cursor:pointer}.selected.svelte-c8a31t{text-decoration:underline}";
    n(css$8,{});

    /* src/Tab.svelte generated by Svelte v3.48.0 */
    const file$8 = "src/Tab.svelte";

    function create_fragment$8(ctx) {
    	let div;
    	let t_value = /*label*/ ctx[0][0].toUpperCase() + /*label*/ ctx[0].substring(1) + "";
    	let t;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text$1(t_value);
    			attr_dev(div, "class", div_class_value = "tab " + (/*selected*/ ctx[1] ? 'selected' : '') + " svelte-c8a31t");
    			add_location(div, file$8, 11, 0, 232);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*handleClick*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*label*/ 1 && t_value !== (t_value = /*label*/ ctx[0][0].toUpperCase() + /*label*/ ctx[0].substring(1) + "")) set_data_dev(t, t_value);

    			if (dirty & /*selected*/ 2 && div_class_value !== (div_class_value = "tab " + (/*selected*/ ctx[1] ? 'selected' : '') + " svelte-c8a31t")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, []);
    	let { label } = $$props;
    	let { selected } = $$props;
    	const dispatch = createEventDispatcher();

    	function handleClick() {
    		dispatch('tabchange', { tab: label });
    	}

    	const writable_props = ['label', 'selected'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		label,
    		selected,
    		dispatch,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label, selected, handleClick];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, { label: 0, selected: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !('label' in props)) {
    			console.warn("<Tab> was created without expected prop 'label'");
    		}

    		if (/*selected*/ ctx[1] === undefined && !('selected' in props)) {
    			console.warn("<Tab> was created without expected prop 'selected'");
    		}
    	}

    	get label() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$7 = ".tabs.svelte-1fkp8yf{display:flex;justify-content:space-between;font-weight:bold}";
    n(css$7,{});

    /* src/Tabs.svelte generated by Svelte v3.48.0 */
    const file$7 = "src/Tabs.svelte";

    function create_fragment$7(ctx) {
    	let div;
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				label: "fill",
    				selected: /*selectedTab*/ ctx[0] === 'fill'
    			},
    			$$inline: true
    		});

    	tab0.$on("tabchange", /*tabchange_handler*/ ctx[1]);

    	tab1 = new Tab({
    			props: {
    				label: "lines",
    				selected: /*selectedTab*/ ctx[0] === 'lines'
    			},
    			$$inline: true
    		});

    	tab1.$on("tabchange", /*tabchange_handler_1*/ ctx[2]);

    	tab2 = new Tab({
    			props: {
    				label: "typography",
    				selected: /*selectedTab*/ ctx[0] === 'typography'
    			},
    			$$inline: true
    		});

    	tab2.$on("tabchange", /*tabchange_handler_2*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    			attr_dev(div, "class", "tabs svelte-1fkp8yf");
    			add_location(div, file$7, 6, 0, 81);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tab0, div, null);
    			append_dev(div, t0);
    			mount_component(tab1, div, null);
    			append_dev(div, t1);
    			mount_component(tab2, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tab0_changes = {};
    			if (dirty & /*selectedTab*/ 1) tab0_changes.selected = /*selectedTab*/ ctx[0] === 'fill';
    			tab0.$set(tab0_changes);
    			const tab1_changes = {};
    			if (dirty & /*selectedTab*/ 1) tab1_changes.selected = /*selectedTab*/ ctx[0] === 'lines';
    			tab1.$set(tab1_changes);
    			const tab2_changes = {};
    			if (dirty & /*selectedTab*/ 1) tab2_changes.selected = /*selectedTab*/ ctx[0] === 'typography';
    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tab0);
    			destroy_component(tab1);
    			destroy_component(tab2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, []);
    	let { selectedTab } = $$props;
    	const writable_props = ['selectedTab'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	function tabchange_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function tabchange_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function tabchange_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('selectedTab' in $$props) $$invalidate(0, selectedTab = $$props.selectedTab);
    	};

    	$$self.$capture_state = () => ({ Tab, selectedTab });

    	$$self.$inject_state = $$props => {
    		if ('selectedTab' in $$props) $$invalidate(0, selectedTab = $$props.selectedTab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selectedTab, tabchange_handler, tabchange_handler_1, tabchange_handler_2];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { selectedTab: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*selectedTab*/ ctx[0] === undefined && !('selectedTab' in props)) {
    			console.warn("<Tabs> was created without expected prop 'selectedTab'");
    		}
    	}

    	get selectedTab() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedTab(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$6 = ".tooltip.svelte-1aqii99{background:white;border:1px solid black;padding:1em;position:absolute}.close-button.svelte-1aqii99{background:none;border:none;float:right;margin:0;margin-right:-0.5em;margin-top:-0.5em;padding:0.5em}";
    n(css$6,{});

    /* src/Tooltip.svelte generated by Svelte v3.48.0 */
    const file$6 = "src/Tooltip.svelte";

    // (15:2) {#if showCloseButton}
    function create_if_block$5(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "×";
    			attr_dev(button, "class", "close-button svelte-1aqii99");
    			add_location(button, file$6, 15, 4, 332);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClose*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(15:2) {#if showCloseButton}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div;
    	let t0;
    	let pre;
    	let t1;
    	let code;
    	let t2;
    	let t3;
    	let t4;
    	let current;
    	let if_block = /*showCloseButton*/ ctx[2] && create_if_block$5(ctx);
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			pre = element("pre");
    			t1 = text$1("    ");
    			code = element("code");
    			t2 = text$1("\n      ");
    			if (default_slot) default_slot.c();
    			t3 = text$1("\n    ");
    			t4 = text$1("\n  ");
    			add_location(code, file$6, 18, 4, 421);
    			add_location(pre, file$6, 17, 2, 411);
    			attr_dev(div, "class", "tooltip svelte-1aqii99");
    			set_style(div, "left", /*left*/ ctx[0] + "px");
    			set_style(div, "top", /*top*/ ctx[1] + "px");
    			add_location(div, file$6, 13, 0, 244);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, pre);
    			append_dev(pre, t1);
    			append_dev(pre, code);
    			append_dev(code, t2);

    			if (default_slot) {
    				default_slot.m(code, null);
    			}

    			append_dev(code, t3);
    			append_dev(pre, t4);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showCloseButton*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*left*/ 1) {
    				set_style(div, "left", /*left*/ ctx[0] + "px");
    			}

    			if (!current || dirty & /*top*/ 2) {
    				set_style(div, "top", /*top*/ ctx[1] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tooltip', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { left } = $$props;
    	let { top } = $$props;
    	let { showCloseButton = true } = $$props;

    	function handleClose() {
    		dispatch('close');
    	}

    	const writable_props = ['left', 'top', 'showCloseButton'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('left' in $$props) $$invalidate(0, left = $$props.left);
    		if ('top' in $$props) $$invalidate(1, top = $$props.top);
    		if ('showCloseButton' in $$props) $$invalidate(2, showCloseButton = $$props.showCloseButton);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		left,
    		top,
    		showCloseButton,
    		handleClose
    	});

    	$$self.$inject_state = $$props => {
    		if ('left' in $$props) $$invalidate(0, left = $$props.left);
    		if ('top' in $$props) $$invalidate(1, top = $$props.top);
    		if ('showCloseButton' in $$props) $$invalidate(2, showCloseButton = $$props.showCloseButton);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [left, top, showCloseButton, handleClose, $$scope, slots];
    }

    class Tooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, { left: 0, top: 1, showCloseButton: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*left*/ ctx[0] === undefined && !('left' in props)) {
    			console.warn("<Tooltip> was created without expected prop 'left'");
    		}

    		if (/*top*/ ctx[1] === undefined && !('top' in props)) {
    			console.warn("<Tooltip> was created without expected prop 'top'");
    		}
    	}

    	get left() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showCloseButton() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showCloseButton(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function getLinearFunction(expression) {
      const [expressionType, [interpolationType], [input], ...stops] = expression;
      return value => {
        if (value < stops[0]) return stops[1];
        if (value > stops[stops.length - 2]) return stops[stops.length - 1];
        return linear(
          stops.filter((e, i) => i % 2 === 0),
          stops.filter((e, i) => i % 2 === 1)
        )(value);
      };
    }

    function getStepFunction(expression) {
      return zoom => {
        const steps = expression.slice(2).reverse();
        for (let i = 0; i < steps.length; i++) {
          const currentValue = steps[i];
          const currentZoom = steps[i + 1] || 0;
          if (zoom >= currentZoom) return currentValue;
        }
        return steps[0];
      };
    }

    function getFunction(expression) {
      const [expressionType] = expression;
      if (expressionType === 'step') return getStepFunction(expression);
      if (expressionType === 'interpolate') {
        const interpolationType = expression[1][0];
        if (interpolationType === 'linear') {
          return getLinearFunction(expression);
        }
      }
      return () => {};
    }

    function getValue(expression, zoom, defaultValue = null) {
      if (expression == undefined) return defaultValue;
      if (typeof expression === 'number') return expression;
      if (Array.isArray(expression)) {
        return getFunction(expression)(zoom);
      }
      return defaultValue;
    }

    let MIN_ZOOM = 0;
    let MAX_ZOOM = 24;
    let CHART_WIDTH = 1000;
    let MARGIN = {
      bottom: 25,
      left: 250,
      right: 50,
      top: 25,
    };

    // Literal expressions are unnecessary but valid for opacity and color
    // so we remove them for things to run smoothly
    const handleLiteral = value => {
      if (Array.isArray(value) && value[0] === 'literal') {
        return value[1];
      }
      if (Array.isArray(value)) {
        return value.map(handleLiteral);
      }
      return value;
    };

    const isGradient = value => {
      if (!Array.isArray(value)) return false;

      const expressionType = value[0];

      switch (expressionType) {
        case 'step': {
          const [, [attribute]] = value;
          if (attribute === 'zoom') {
            return true;
          }
          break;
        }
        case 'interpolate': {
          const [, [interpolationType], [attribute]] = value;
          if (interpolationType === 'linear' && attribute === 'zoom') {
            return true;
          }
          break;
        }
        default:
          return false;
      }
    };

    const getZoomOutputArray = scaleExpression => {
      if (!isGradient(scaleExpression)) return [];
      const expressionType = scaleExpression[0];

      if (expressionType === 'interpolate') return scaleExpression.slice(3);

      // For the sake of consistent gradient handling, convert step functions
      // to look more like interpolate functions
      let stepZoomOutput = scaleExpression.slice(2);
      stepZoomOutput.unshift(0.1);

      stepZoomOutput = stepZoomOutput.reduce((acc, item, i) => {
        // zoom
        if (i % 2 === 0 && i !== 0) {
          acc.push(Number(item) - 0.01, stepZoomOutput[i - 1]);
          acc.push(item);
        } // output
        else {
          acc.push(item);
        }

        return acc;
      }, []);

      return stepZoomOutput;
    };

    const getGradientStops = ({
      layerId,
      color,
      opacity,
      minZoom,
      maxZoom,
      xScale,
    }) => {
      const colorInterpolation = isGradient(color) && color[0];
      const opacityInterpolation = isGradient(opacity) && opacity[0];

      const gradientStops = [];

      if (colorInterpolation || opacityInterpolation) {
        const lineStart = xScale(minZoom);
        const lineLength = xScale(maxZoom) - xScale(minZoom);

        opacity = opacity;
        let gradientColorArray = getZoomOutputArray(color);
        let gradientOpacityArray = getZoomOutputArray(opacity);

        const stops = gradientColorArray
          .concat(gradientOpacityArray)
          .filter((v, i) => i % 2 === 0)
          .sort((a, b) => a - b);

        stops.forEach(zoomStop => {
          let colorOutput = colorInterpolation
            ? getValue(color, zoomStop, null)
            : color;
          let opacityOutput = opacityInterpolation
            ? getValue(opacity, zoomStop, null)
            : opacity;

          if (Array.isArray(colorOutput)) {
            console.warn(
              `${layerId}: Unhandled data expression, ${JSON.stringify(
            colorOutput,
            null,
            2
          )}`
            );
            colorOutput = 'black';
          }
          if (Array.isArray(opacityOutput)) {
            console.warn(
              `${layerId}: Unhandled data expression, ${JSON.stringify(
            opacityOutput,
            null,
            2
          )}`
            );
            opacityOutput = 1;
          }
          opacityOutput = parseFloat(opacityOutput.toFixed(2));

          gradientStops.push({
            offset: ((xScale(zoomStop) - lineStart) / lineLength) * 100,
            stopColor: colorOutput,
            stopOpacity: opacityOutput,
          });
        });
      }

      return gradientStops;
    };

    const getValidGradientId = id => {
      const invalidGradientUrlChars = ['"', ' ', "'"];

      let nextId = id;
      for (const char of invalidGradientUrlChars) {
        nextId = nextId.replaceAll(char, '');
      }
      return nextId;
    };

    const getColor = (layer, xScale) => {
      let gradients = [];
      const minZoom = layer.minzoom || MIN_ZOOM;
      const maxZoom = layer.maxzoom || MAX_ZOOM;

      let color;
      let opacity;
      let strokeColor;
      let strokeWidth = 0;

      // Return early for hidden layers
      const isNotVisible = layer?.layout?.visibility === 'none';
      if (isNotVisible) {
        return {
          gradients,
          color: {
            color: 'rgba(0, 0, 0, 0)',
            strokeColor: 'rgba(0, 0, 0, 0)',
            strokeWidth,
          },
        };
      }

      switch (layer.type) {
        case 'fill':
          color = layer?.paint?.['fill-color'];
          opacity = layer?.paint?.['fill-opacity'];
          strokeColor = layer?.paint?.['fill-outline-color'];
          if (strokeColor) strokeWidth = 1;
          break;
        case 'background':
          color = layer?.paint?.['background-color'];
          break;
        case 'line':
          color = layer?.paint?.['line-color'];
          opacity = layer?.paint?.['line-opacity'];
          break;
        case 'symbol':
          color = layer?.paint?.['text-color'];
          opacity = layer?.paint?.['text-opacity'];
          break;
      }

      // Defaults
      color = handleLiteral(color) || 'black';
      opacity = opacity !== undefined ? handleLiteral(opacity) : 1;

      const gradientStops = getGradientStops({
        layerId: layer.id,
        color,
        opacity,
        minZoom,
        maxZoom,
        xScale,
      });

      if (gradientStops.length > 1) {
        const gradientId = getValidGradientId(layer.id);

        gradients = [
          {
            id: gradientId,
            stops: gradientStops.map(stop => ({
              offset: `${stop.offset}%`,
              stopColor: stop.stopColor,
              stopOpacity: stop.stopOpacity,
            })),
          },
        ];

        color = `url(#${gradientId})`;
      }

      return { gradients, color: { color, strokeColor, strokeWidth } };
    };

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$4) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$4) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$4;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const propertyValueComboLimitStore = writable(10);

    const loadingStore = writable({ loading: false, progress: null });

    const displayLayersStore = writable({
      style: null,
      layers: [],
      limitHit: [],
    });

    var css$5 = ".x-axis.svelte-rpuqmp text.svelte-rpuqmp{font-size:0.9em;text-anchor:middle}.y-axis.svelte-rpuqmp text.svelte-rpuqmp{font-size:0.9em}";
    n(css$5,{});

    /* src/FillsChart.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1$2 } = globals;
    const file$5 = "src/FillsChart.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    function get_each_context_5$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[33] = list[i];
    	return child_ctx;
    }

    // (128:10) {#each gradient.stops as stop}
    function create_each_block_5$1(ctx) {
    	let stop;
    	let stop_offset_value;
    	let stop_stop_color_value;
    	let stop_stop_opacity_value;

    	const block = {
    		c: function create() {
    			stop = svg_element("stop");
    			attr_dev(stop, "offset", stop_offset_value = /*stop*/ ctx[33].offset);
    			attr_dev(stop, "stop-color", stop_stop_color_value = /*stop*/ ctx[33].stopColor);
    			attr_dev(stop, "stop-opacity", stop_stop_opacity_value = /*stop*/ ctx[33].stopOpacity);
    			add_location(stop, file$5, 128, 12, 3280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, stop, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gradients*/ 4 && stop_offset_value !== (stop_offset_value = /*stop*/ ctx[33].offset)) {
    				attr_dev(stop, "offset", stop_offset_value);
    			}

    			if (dirty[0] & /*gradients*/ 4 && stop_stop_color_value !== (stop_stop_color_value = /*stop*/ ctx[33].stopColor)) {
    				attr_dev(stop, "stop-color", stop_stop_color_value);
    			}

    			if (dirty[0] & /*gradients*/ 4 && stop_stop_opacity_value !== (stop_stop_opacity_value = /*stop*/ ctx[33].stopOpacity)) {
    				attr_dev(stop, "stop-opacity", stop_stop_opacity_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(stop);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$1.name,
    		type: "each",
    		source: "(128:10) {#each gradient.stops as stop}",
    		ctx
    	});

    	return block;
    }

    // (126:6) {#each gradients as gradient}
    function create_each_block_4$1(ctx) {
    	let linearGradient;
    	let linearGradient_id_value;
    	let each_value_5 = /*gradient*/ ctx[30].stops;
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5$1(get_each_context_5$1(ctx, each_value_5, i));
    	}

    	const block = {
    		c: function create() {
    			linearGradient = svg_element("linearGradient");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(linearGradient, "id", linearGradient_id_value = /*gradient*/ ctx[30].id);
    			add_location(linearGradient, file$5, 126, 8, 3193);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, linearGradient, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(linearGradient, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gradients*/ 4) {
    				each_value_5 = /*gradient*/ ctx[30].stops;
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$1(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_5$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(linearGradient, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_5.length;
    			}

    			if (dirty[0] & /*gradients*/ 4 && linearGradient_id_value !== (linearGradient_id_value = /*gradient*/ ctx[30].id)) {
    				attr_dev(linearGradient, "id", linearGradient_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(linearGradient);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$1.name,
    		type: "each",
    		source: "(126:6) {#each gradients as gradient}",
    		ctx
    	});

    	return block;
    }

    // (139:6) {#each rects as rect}
    function create_each_block_3$1(ctx) {
    	let rect;
    	let rect_x_value;
    	let rect_y_value;
    	let rect_width_value;
    	let rect_height_value;
    	let rect_fill_value;
    	let rect_stroke_value;
    	let rect_strokewidth_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[15](/*rect*/ ctx[19]);
    	}

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "x", rect_x_value = /*rect*/ ctx[19].x);
    			attr_dev(rect, "y", rect_y_value = /*rect*/ ctx[19].y);
    			attr_dev(rect, "width", rect_width_value = /*rect*/ ctx[19].width);

    			attr_dev(rect, "height", rect_height_value = /*rect*/ ctx[19].layer.type === 'background'
    			? /*chartHeight*/ ctx[0] - MARGIN.top - MARGIN.bottom
    			: /*rect*/ ctx[19].height);

    			attr_dev(rect, "fill", rect_fill_value = /*rect*/ ctx[19].fill);
    			attr_dev(rect, "stroke", rect_stroke_value = /*rect*/ ctx[19].stroke);
    			attr_dev(rect, "strokewidth", rect_strokewidth_value = /*rect*/ ctx[19].strokeWidth);
    			attr_dev(rect, "rx", "20");
    			add_location(rect, file$5, 139, 8, 3538);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);

    			if (!mounted) {
    				dispose = listen_dev(rect, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rects*/ 2 && rect_x_value !== (rect_x_value = /*rect*/ ctx[19].x)) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty[0] & /*rects*/ 2 && rect_y_value !== (rect_y_value = /*rect*/ ctx[19].y)) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (dirty[0] & /*rects*/ 2 && rect_width_value !== (rect_width_value = /*rect*/ ctx[19].width)) {
    				attr_dev(rect, "width", rect_width_value);
    			}

    			if (dirty[0] & /*rects, chartHeight*/ 3 && rect_height_value !== (rect_height_value = /*rect*/ ctx[19].layer.type === 'background'
    			? /*chartHeight*/ ctx[0] - MARGIN.top - MARGIN.bottom
    			: /*rect*/ ctx[19].height)) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty[0] & /*rects*/ 2 && rect_fill_value !== (rect_fill_value = /*rect*/ ctx[19].fill)) {
    				attr_dev(rect, "fill", rect_fill_value);
    			}

    			if (dirty[0] & /*rects*/ 2 && rect_stroke_value !== (rect_stroke_value = /*rect*/ ctx[19].stroke)) {
    				attr_dev(rect, "stroke", rect_stroke_value);
    			}

    			if (dirty[0] & /*rects*/ 2 && rect_strokewidth_value !== (rect_strokewidth_value = /*rect*/ ctx[19].strokeWidth)) {
    				attr_dev(rect, "strokewidth", rect_strokewidth_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(139:6) {#each rects as rect}",
    		ctx
    	});

    	return block;
    }

    // (157:6) {#each zoomLevels as zoomLevel}
    function create_each_block_2$1(ctx) {
    	let g;
    	let text_1;
    	let t_value = /*zoomLevel*/ ctx[25] + "";
    	let t;
    	let g_transform_value;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			text_1 = svg_element("text");
    			t = text$1(t_value);
    			attr_dev(text_1, "y", "9");
    			attr_dev(text_1, "class", "svelte-rpuqmp");
    			add_location(text_1, file$5, 162, 10, 4193);
    			attr_dev(g, "class", "tick");
    			attr_dev(g, "opacity", "1");
    			attr_dev(g, "transform", g_transform_value = "translate(" + /*xScale*/ ctx[3](/*zoomLevel*/ ctx[25]) + ", 0)");
    			add_location(g, file$5, 157, 8, 4069);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, text_1);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*zoomLevels*/ 64 && t_value !== (t_value = /*zoomLevel*/ ctx[25] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*xScale, zoomLevels*/ 72 && g_transform_value !== (g_transform_value = "translate(" + /*xScale*/ ctx[3](/*zoomLevel*/ ctx[25]) + ", 0)")) {
    				attr_dev(g, "transform", g_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(157:6) {#each zoomLevels as zoomLevel}",
    		ctx
    	});

    	return block;
    }

    // (179:14) {#if i === 0 && limitHit.includes(idSection)}
    function create_if_block_2$4(ctx) {
    	let circle;
    	let mounted;
    	let dispose;

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[16](/*idSection*/ ctx[22], /*rect*/ ctx[19]);
    	}

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "6");
    			attr_dev(circle, "cy", "-6");
    			attr_dev(circle, "r", "6");
    			attr_dev(circle, "fill", "red");
    			add_location(circle, file$5, 179, 16, 4663);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(circle, "mouseover", mouseover_handler, false, false, false),
    					listen_dev(circle, "mouseout", /*handleTooltipClose*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(179:14) {#if i === 0 && limitHit.includes(idSection)}",
    		ctx
    	});

    	return block;
    }

    // (194:16) {#if i > 0}
    function create_if_block_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("↳");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(194:16) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (178:10) {#each rect.layer.id.split('/') as idSection, i}
    function create_each_block_1$1(ctx) {
    	let g;
    	let show_if = /*i*/ ctx[24] === 0 && /*limitHit*/ ctx[7].includes(/*idSection*/ ctx[22]);
    	let text_1;
    	let t_value = /*idSection*/ ctx[22] + "";
    	let t;
    	let text_1_x_value;
    	let if_block0 = show_if && create_if_block_2$4(ctx);
    	let if_block1 = /*i*/ ctx[24] > 0 && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			if (if_block0) if_block0.c();
    			text_1 = svg_element("text");
    			if (if_block1) if_block1.c();
    			t = text$1(t_value);
    			attr_dev(text_1, "y", 18 * /*i*/ ctx[24]);

    			attr_dev(text_1, "x", text_1_x_value = (/*i*/ ctx[24] > 0 ? 18 : 0) + /*limitHit*/ ctx[7].includes(/*idSection*/ ctx[22])
    			? 18
    			: 0);

    			attr_dev(text_1, "class", "svelte-rpuqmp");
    			add_location(text_1, file$5, 189, 14, 4985);
    			add_location(g, file$5, 177, 58, 4583);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			if (if_block0) if_block0.m(g, null);
    			append_dev(g, text_1);
    			if (if_block1) if_block1.m(text_1, null);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*limitHit, rects*/ 130) show_if = /*i*/ ctx[24] === 0 && /*limitHit*/ ctx[7].includes(/*idSection*/ ctx[22]);

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$4(ctx);
    					if_block0.c();
    					if_block0.m(g, text_1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*rects*/ 2 && t_value !== (t_value = /*idSection*/ ctx[22] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*limitHit, rects*/ 130 && text_1_x_value !== (text_1_x_value = (/*i*/ ctx[24] > 0 ? 18 : 0) + /*limitHit*/ ctx[7].includes(/*idSection*/ ctx[22])
    			? 18
    			: 0)) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(178:10) {#each rect.layer.id.split('/') as idSection, i}",
    		ctx
    	});

    	return block;
    }

    // (171:6) {#each rects as rect}
    function create_each_block$1(ctx) {
    	let g;
    	let g_transform_value;
    	let each_value_1 = /*rect*/ ctx[19].layer.id.split('/');
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g, "class", "tick");
    			attr_dev(g, "opacity", "1");
    			attr_dev(g, "transform", g_transform_value = "translate(0,\n          " + (/*yScale*/ ctx[4](/*rect*/ ctx[19].layer.id) + /*yScale*/ ctx[4].bandwidth() / 2) + ")");
    			add_location(g, file$5, 171, 8, 4372);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*limitHit, rects, handleTooltipWarning, handleTooltipClose*/ 2690) {
    				each_value_1 = /*rect*/ ctx[19].layer.id.split('/');
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*yScale, rects*/ 18 && g_transform_value !== (g_transform_value = "translate(0,\n          " + (/*yScale*/ ctx[4](/*rect*/ ctx[19].layer.id) + /*yScale*/ ctx[4].bandwidth() / 2) + ")")) {
    				attr_dev(g, "transform", g_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(171:6) {#each rects as rect}",
    		ctx
    	});

    	return block;
    }

    // (205:2) {#if Object.keys(tooltip).length > 0}
    function create_if_block$4(ctx) {
    	let tooltip_1;
    	let current;

    	tooltip_1 = new Tooltip({
    			props: {
    				left: /*tooltip*/ ctx[8].left,
    				top: /*tooltip*/ ctx[8].top,
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tooltip_1.$on("close", /*handleTooltipClose*/ ctx[9]);

    	const block = {
    		c: function create() {
    			create_component(tooltip_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tooltip_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tooltip_1_changes = {};
    			if (dirty[0] & /*tooltip*/ 256) tooltip_1_changes.left = /*tooltip*/ ctx[8].left;
    			if (dirty[0] & /*tooltip*/ 256) tooltip_1_changes.top = /*tooltip*/ ctx[8].top;

    			if (dirty[0] & /*tooltip*/ 256 | dirty[1] & /*$$scope*/ 32) {
    				tooltip_1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip_1.$set(tooltip_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tooltip_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(205:2) {#if Object.keys(tooltip).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (206:4) <Tooltip       left={tooltip.left}       top={tooltip.top}       on:close={handleTooltipClose}     >
    function create_default_slot$2(ctx) {
    	let t_value = (/*tooltip*/ ctx[8].text || '') + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tooltip*/ 256 && t_value !== (t_value = (/*tooltip*/ ctx[8].text || '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(206:4) <Tooltip       left={tooltip.left}       top={tooltip.top}       on:close={handleTooltipClose}     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let svg;
    	let defs;
    	let g0;
    	let g1;
    	let g1_transform_value;
    	let g2;
    	let t;
    	let show_if = Object.keys(/*tooltip*/ ctx[8]).length > 0;
    	let current;
    	let each_value_4 = /*gradients*/ ctx[2];
    	validate_each_argument(each_value_4);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_3[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
    	}

    	let each_value_3 = /*rects*/ ctx[1];
    	validate_each_argument(each_value_3);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_2[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*zoomLevels*/ ctx[6];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let each_value = /*rects*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	let if_block = show_if && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			defs = svg_element("defs");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			g0 = svg_element("g");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			g1 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			g2 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			add_location(defs, file$5, 124, 4, 3142);
    			add_location(g0, file$5, 137, 4, 3498);
    			attr_dev(g1, "transform", g1_transform_value = "translate(0, " + (MARGIN.top + /*scrollY*/ ctx[5]) + ")");
    			attr_dev(g1, "class", "x-axis svelte-rpuqmp");
    			add_location(g1, file$5, 155, 4, 3955);
    			attr_dev(g2, "transform", "translate(0, 0)");
    			attr_dev(g2, "class", "y-axis svelte-rpuqmp");
    			add_location(g2, file$5, 169, 4, 4289);
    			attr_dev(svg, "id", "fill");
    			attr_dev(svg, "width", CHART_WIDTH);
    			attr_dev(svg, "height", /*chartHeight*/ ctx[0]);
    			add_location(svg, file$5, 123, 2, 3081);
    			attr_dev(div, "class", "fills-chart");
    			add_location(div, file$5, 122, 0, 3053);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, defs);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(defs, null);
    			}

    			append_dev(svg, g0);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(g0, null);
    			}

    			append_dev(svg, g1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g1, null);
    			}

    			append_dev(svg, g2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g2, null);
    			}

    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gradients*/ 4) {
    				each_value_4 = /*gradients*/ ctx[2];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_4$1(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(defs, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_4.length;
    			}

    			if (dirty[0] & /*rects, chartHeight, handleClick*/ 1027) {
    				each_value_3 = /*rects*/ ctx[1];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_3$1(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_3.length;
    			}

    			if (dirty[0] & /*xScale, zoomLevels*/ 72) {
    				each_value_2 = /*zoomLevels*/ ctx[6];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (!current || dirty[0] & /*scrollY*/ 32 && g1_transform_value !== (g1_transform_value = "translate(0, " + (MARGIN.top + /*scrollY*/ ctx[5]) + ")")) {
    				attr_dev(g1, "transform", g1_transform_value);
    			}

    			if (dirty[0] & /*yScale, rects, limitHit, handleTooltipWarning, handleTooltipClose*/ 2706) {
    				each_value = /*rects*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty[0] & /*chartHeight*/ 1) {
    				attr_dev(svg, "height", /*chartHeight*/ ctx[0]);
    			}

    			if (dirty[0] & /*tooltip*/ 256) show_if = Object.keys(/*tooltip*/ ctx[8]).length > 0;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*tooltip*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let tooltip;
    	let $propertyValueComboLimitStore;
    	validate_store(propertyValueComboLimitStore, 'propertyValueComboLimitStore');
    	component_subscribe($$self, propertyValueComboLimitStore, $$value => $$invalidate(17, $propertyValueComboLimitStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FillsChart', slots, []);
    	let { style } = $$props;
    	let { updateBackgroundRect } = $$props;
    	let chartHeight;
    	let rects = [];
    	let gradients = [];
    	const handleTooltipClose = () => $$invalidate(8, tooltip = {});
    	let xScale;
    	let yScale;
    	let scrollY = 0;
    	let zoomLevels = [];
    	let expandedLayers = [];
    	let limitHit = [];

    	displayLayersStore.subscribe(value => {
    		$$invalidate(14, expandedLayers = value.layers);
    		$$invalidate(7, limitHit = value.limitHit);
    	});

    	const initChart = () => {
    		let layers = expandedLayers;
    		$$invalidate(0, chartHeight = layers.length * 65);
    		$$invalidate(3, xScale = linear([MIN_ZOOM, MAX_ZOOM], [MARGIN.left, CHART_WIDTH - MARGIN.right]));
    		$$invalidate(4, yScale = band(layers.map(({ id }) => id), [MARGIN.top, chartHeight - MARGIN.bottom]).padding(0.25));
    		$$invalidate(6, zoomLevels = range$2(MIN_ZOOM, MAX_ZOOM + 1, 1));

    		const getDrawLayer = layer => {
    			const { color: layerColor, gradients: layerGradients } = getColor(layer, xScale);
    			const { color, strokeColor, strokeWidth } = layerColor;
    			$$invalidate(2, gradients = gradients.concat(layerGradients));

    			return {
    				...layer,
    				fill: color,
    				stroke: strokeColor,
    				strokeWidth
    			};
    		};

    		layers = layers.map(getDrawLayer);

    		// TODO consider combining casing with roads
    		$$invalidate(1, rects = layers.map(d => {
    			return {
    				x: xScale(d.minzoom || MIN_ZOOM),
    				y: yScale(d.id),
    				height: yScale.bandwidth(),
    				width: xScale(d.maxzoom || MAX_ZOOM) - xScale(d.minzoom || MIN_ZOOM),
    				fill: d.fill,
    				stroke: d.stroke,
    				strokeWidth: d.strokeWidth,
    				layer: d
    			};
    		}));

    		const backgroundRect = rects.find(rect => rect.layer.type === 'background');

    		if (backgroundRect) {
    			const backgroundGradient = gradients.find(g => g.id === backgroundRect.layer.id);
    			updateBackgroundRect(backgroundRect, backgroundGradient);
    		}
    	};

    	onMount(() => {
    		document.addEventListener('scroll', () => $$invalidate(5, scrollY = window.scrollY));
    	});

    	function handleClick(layer) {
    		$$invalidate(8, tooltip = {
    			text: JSON.stringify(layer.paint, null, 2),
    			left: xScale(MAX_ZOOM) + 10,
    			top: yScale(layer.id) + yScale.bandwidth()
    		});
    	}

    	function handleTooltipWarning(layerId, expandedLayerId) {
    		$$invalidate(8, tooltip = {
    			text: `${layerId} had too many possible property/value combinations and has been limited to showing ${$propertyValueComboLimitStore} for performance.`,
    			left: 24,
    			top: yScale(expandedLayerId) + yScale.bandwidth() * 0.75
    		});
    	}

    	const writable_props = ['style', 'updateBackgroundRect'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FillsChart> was created with unknown prop '${key}'`);
    	});

    	const click_handler = rect => handleClick(rect.layer);
    	const mouseover_handler = (idSection, rect) => handleTooltipWarning(idSection, rect.layer.id);

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(12, style = $$props.style);
    		if ('updateBackgroundRect' in $$props) $$invalidate(13, updateBackgroundRect = $$props.updateBackgroundRect);
    	};

    	$$self.$capture_state = () => ({
    		d3,
    		onMount,
    		Tooltip,
    		getColor,
    		displayLayersStore,
    		propertyValueComboLimitStore,
    		MIN_ZOOM,
    		MAX_ZOOM,
    		CHART_WIDTH,
    		MARGIN,
    		style,
    		updateBackgroundRect,
    		chartHeight,
    		rects,
    		gradients,
    		handleTooltipClose,
    		xScale,
    		yScale,
    		scrollY,
    		zoomLevels,
    		expandedLayers,
    		limitHit,
    		initChart,
    		handleClick,
    		handleTooltipWarning,
    		tooltip,
    		$propertyValueComboLimitStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(12, style = $$props.style);
    		if ('updateBackgroundRect' in $$props) $$invalidate(13, updateBackgroundRect = $$props.updateBackgroundRect);
    		if ('chartHeight' in $$props) $$invalidate(0, chartHeight = $$props.chartHeight);
    		if ('rects' in $$props) $$invalidate(1, rects = $$props.rects);
    		if ('gradients' in $$props) $$invalidate(2, gradients = $$props.gradients);
    		if ('xScale' in $$props) $$invalidate(3, xScale = $$props.xScale);
    		if ('yScale' in $$props) $$invalidate(4, yScale = $$props.yScale);
    		if ('scrollY' in $$props) $$invalidate(5, scrollY = $$props.scrollY);
    		if ('zoomLevels' in $$props) $$invalidate(6, zoomLevels = $$props.zoomLevels);
    		if ('expandedLayers' in $$props) $$invalidate(14, expandedLayers = $$props.expandedLayers);
    		if ('limitHit' in $$props) $$invalidate(7, limitHit = $$props.limitHit);
    		if ('tooltip' in $$props) $$invalidate(8, tooltip = $$props.tooltip);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*style*/ 4096) {
    			{
    				handleTooltipClose();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*expandedLayers*/ 16384) {
    			if (expandedLayers) {
    				initChart();
    			}
    		}
    	};

    	$$invalidate(8, tooltip = {});

    	return [
    		chartHeight,
    		rects,
    		gradients,
    		xScale,
    		yScale,
    		scrollY,
    		zoomLevels,
    		limitHit,
    		tooltip,
    		handleTooltipClose,
    		handleClick,
    		handleTooltipWarning,
    		style,
    		updateBackgroundRect,
    		expandedLayers,
    		click_handler,
    		mouseover_handler
    	];
    }

    class FillsChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { style: 12, updateBackgroundRect: 13 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FillsChart",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*style*/ ctx[12] === undefined && !('style' in props)) {
    			console.warn("<FillsChart> was created without expected prop 'style'");
    		}

    		if (/*updateBackgroundRect*/ ctx[13] === undefined && !('updateBackgroundRect' in props)) {
    			console.warn("<FillsChart> was created without expected prop 'updateBackgroundRect'");
    		}
    	}

    	get style() {
    		throw new Error("<FillsChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<FillsChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateBackgroundRect() {
    		throw new Error("<FillsChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateBackgroundRect(value) {
    		throw new Error("<FillsChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // Gathers outputs of expression based on expression type
    const gatherOutputs = exp => {
      // Prevent unwanted mutations
      const expression = JSON.parse(JSON.stringify(exp));
      if (typeof expression === 'number') return [expression];
      const outputs = [];
      const expressionType = expression.hasOwnProperty('stops')
        ? 'legacy'
        : expression[0];

      switch (expressionType) {
        case 'case': {
          let inputOutputs = expression.slice(1);
          const fallback = inputOutputs.pop();
          inputOutputs.forEach((val, i) => i % 2 !== 0 && outputs.push(val));
          outputs.push(fallback);
          break;
        }
        case 'match': {
          let inputOutputs = expression.slice(2);
          const fallback = inputOutputs.pop();
          inputOutputs.forEach((val, i) => i % 2 !== 0 && outputs.push(val));
          outputs.push(fallback);
          break;
        }
        case 'interpolate': {
          let inputOutputs = expression.slice(3);
          inputOutputs.forEach((val, i) => i % 2 !== 0 && outputs.push(val));
          break;
        }
        case 'step': {
          let inputOutputs = expression.slice(2);
          const fallback = inputOutputs.pop();
          inputOutputs.forEach((val, i) => i % 2 === 0 && outputs.push(val));
          outputs.push(fallback);
          break;
        }
        case 'legacy': {
          let inputOutputs = expression.stops;
          inputOutputs.forEach(val => outputs.push(val[1]));
          break;
        }
        default:
          return expression;
      }
      if (outputs.some(item => Array.isArray(item))) {
        return outputs.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc = acc.concat(gatherOutputs(item));
          } else {
            acc = acc.concat([item]);
          }
          return acc;
        }, []);
      }
      return outputs;
    };

    var css$4 = ".x-axis.svelte-rpuqmp text.svelte-rpuqmp{font-size:0.9em;text-anchor:middle}.y-axis.svelte-rpuqmp text.svelte-rpuqmp{font-size:0.9em}";
    n(css$4,{});

    /* src/LinesChart.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1$1, console: console_1 } = globals;
    const file$4 = "src/LinesChart.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	return child_ctx;
    }

    // (269:10) {#each gradient.stops as stop}
    function create_each_block_5(ctx) {
    	let stop;
    	let stop_offset_value;
    	let stop_stop_color_value;
    	let stop_stop_opacity_value;

    	const block = {
    		c: function create() {
    			stop = svg_element("stop");
    			attr_dev(stop, "offset", stop_offset_value = /*stop*/ ctx[38].offset);
    			attr_dev(stop, "stop-color", stop_stop_color_value = /*stop*/ ctx[38].stopColor);
    			attr_dev(stop, "stop-opacity", stop_stop_opacity_value = /*stop*/ ctx[38].stopOpacity);
    			add_location(stop, file$4, 269, 12, 7565);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, stop, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gradients*/ 2 && stop_offset_value !== (stop_offset_value = /*stop*/ ctx[38].offset)) {
    				attr_dev(stop, "offset", stop_offset_value);
    			}

    			if (dirty[0] & /*gradients*/ 2 && stop_stop_color_value !== (stop_stop_color_value = /*stop*/ ctx[38].stopColor)) {
    				attr_dev(stop, "stop-color", stop_stop_color_value);
    			}

    			if (dirty[0] & /*gradients*/ 2 && stop_stop_opacity_value !== (stop_stop_opacity_value = /*stop*/ ctx[38].stopOpacity)) {
    				attr_dev(stop, "stop-opacity", stop_stop_opacity_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(stop);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(269:10) {#each gradient.stops as stop}",
    		ctx
    	});

    	return block;
    }

    // (267:6) {#each gradients as gradient}
    function create_each_block_4(ctx) {
    	let linearGradient;
    	let linearGradient_id_value;
    	let each_value_5 = /*gradient*/ ctx[35].stops;
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const block = {
    		c: function create() {
    			linearGradient = svg_element("linearGradient");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(linearGradient, "id", linearGradient_id_value = /*gradient*/ ctx[35].id);
    			add_location(linearGradient, file$4, 267, 8, 7478);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, linearGradient, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(linearGradient, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gradients*/ 2) {
    				each_value_5 = /*gradient*/ ctx[35].stops;
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(linearGradient, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_5.length;
    			}

    			if (dirty[0] & /*gradients*/ 2 && linearGradient_id_value !== (linearGradient_id_value = /*gradient*/ ctx[35].id)) {
    				attr_dev(linearGradient, "id", linearGradient_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(linearGradient);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(267:6) {#each gradients as gradient}",
    		ctx
    	});

    	return block;
    }

    // (280:6) {#if backgroundRect}
    function create_if_block_3$2(ctx) {
    	let rect;
    	let rect_x_value;
    	let rect_y_value;
    	let rect_width_value;
    	let rect_height_value;
    	let rect_fill_value;
    	let rect_stroke_value;
    	let rect_strokewidth_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "x", rect_x_value = /*backgroundRect*/ ctx[8].x);
    			attr_dev(rect, "y", rect_y_value = /*backgroundRect*/ ctx[8].y);
    			attr_dev(rect, "width", rect_width_value = /*backgroundRect*/ ctx[8].width);
    			attr_dev(rect, "height", rect_height_value = /*chartHeight*/ ctx[0] - MARGIN.top - MARGIN.bottom);
    			attr_dev(rect, "fill", rect_fill_value = /*backgroundRect*/ ctx[8].fill);
    			attr_dev(rect, "stroke", rect_stroke_value = /*backgroundRect*/ ctx[8].stroke);
    			attr_dev(rect, "strokewidth", rect_strokewidth_value = /*backgroundRect*/ ctx[8].strokeWidth);
    			attr_dev(rect, "rx", "20");
    			add_location(rect, file$4, 280, 8, 7822);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*backgroundRect*/ 256 && rect_x_value !== (rect_x_value = /*backgroundRect*/ ctx[8].x)) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty[0] & /*backgroundRect*/ 256 && rect_y_value !== (rect_y_value = /*backgroundRect*/ ctx[8].y)) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (dirty[0] & /*backgroundRect*/ 256 && rect_width_value !== (rect_width_value = /*backgroundRect*/ ctx[8].width)) {
    				attr_dev(rect, "width", rect_width_value);
    			}

    			if (dirty[0] & /*chartHeight*/ 1 && rect_height_value !== (rect_height_value = /*chartHeight*/ ctx[0] - MARGIN.top - MARGIN.bottom)) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty[0] & /*backgroundRect*/ 256 && rect_fill_value !== (rect_fill_value = /*backgroundRect*/ ctx[8].fill)) {
    				attr_dev(rect, "fill", rect_fill_value);
    			}

    			if (dirty[0] & /*backgroundRect*/ 256 && rect_stroke_value !== (rect_stroke_value = /*backgroundRect*/ ctx[8].stroke)) {
    				attr_dev(rect, "stroke", rect_stroke_value);
    			}

    			if (dirty[0] & /*backgroundRect*/ 256 && rect_strokewidth_value !== (rect_strokewidth_value = /*backgroundRect*/ ctx[8].strokeWidth)) {
    				attr_dev(rect, "strokewidth", rect_strokewidth_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(280:6) {#if backgroundRect}",
    		ctx
    	});

    	return block;
    }

    // (292:6) {#each layers as layer}
    function create_each_block_3(ctx) {
    	let path;
    	let path_d_value;
    	let path_fill_value;
    	let path_stroke_value;
    	let path_strokewidth_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[16](/*layer*/ ctx[24]);
    	}

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", path_d_value = /*layer*/ ctx[24].path);
    			attr_dev(path, "fill", path_fill_value = /*layer*/ ctx[24].fill);
    			attr_dev(path, "stroke", path_stroke_value = /*layer*/ ctx[24].stroke);
    			attr_dev(path, "strokewidth", path_strokewidth_value = /*layer*/ ctx[24].strokeWidth);
    			add_location(path, file$4, 292, 8, 8197);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);

    			if (!mounted) {
    				dispose = listen_dev(path, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*layers*/ 128 && path_d_value !== (path_d_value = /*layer*/ ctx[24].path)) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (dirty[0] & /*layers*/ 128 && path_fill_value !== (path_fill_value = /*layer*/ ctx[24].fill)) {
    				attr_dev(path, "fill", path_fill_value);
    			}

    			if (dirty[0] & /*layers*/ 128 && path_stroke_value !== (path_stroke_value = /*layer*/ ctx[24].stroke)) {
    				attr_dev(path, "stroke", path_stroke_value);
    			}

    			if (dirty[0] & /*layers*/ 128 && path_strokewidth_value !== (path_strokewidth_value = /*layer*/ ctx[24].strokeWidth)) {
    				attr_dev(path, "strokewidth", path_strokewidth_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(292:6) {#each layers as layer}",
    		ctx
    	});

    	return block;
    }

    // (304:6) {#each zoomLevels as zoomLevel}
    function create_each_block_2(ctx) {
    	let g;
    	let text_1;
    	let t_value = /*zoomLevel*/ ctx[30] + "";
    	let t;
    	let g_transform_value;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			text_1 = svg_element("text");
    			t = text$1(t_value);
    			attr_dev(text_1, "y", "9");
    			attr_dev(text_1, "class", "svelte-rpuqmp");
    			add_location(text_1, file$4, 309, 10, 8653);
    			attr_dev(g, "class", "tick");
    			attr_dev(g, "opacity", "1");
    			attr_dev(g, "transform", g_transform_value = "translate(" + /*xScale*/ ctx[2](/*zoomLevel*/ ctx[30]) + ", 0)");
    			add_location(g, file$4, 304, 8, 8529);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, text_1);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*zoomLevels*/ 64 && t_value !== (t_value = /*zoomLevel*/ ctx[30] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*xScale, zoomLevels*/ 68 && g_transform_value !== (g_transform_value = "translate(" + /*xScale*/ ctx[2](/*zoomLevel*/ ctx[30]) + ", 0)")) {
    				attr_dev(g, "transform", g_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(304:6) {#each zoomLevels as zoomLevel}",
    		ctx
    	});

    	return block;
    }

    // (326:14) {#if i === 0 && limitHit.includes(idSection)}
    function create_if_block_2$3(ctx) {
    	let circle;
    	let mounted;
    	let dispose;

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[17](/*idSection*/ ctx[27], /*layer*/ ctx[24]);
    	}

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "6");
    			attr_dev(circle, "cy", "-6");
    			attr_dev(circle, "r", "6");
    			attr_dev(circle, "fill", "red");
    			add_location(circle, file$4, 326, 16, 9123);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(circle, "mouseover", mouseover_handler, false, false, false),
    					listen_dev(circle, "mouseout", /*handleTooltipClose*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(326:14) {#if i === 0 && limitHit.includes(idSection)}",
    		ctx
    	});

    	return block;
    }

    // (339:17) {#if i > 0}
    function create_if_block_1$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("↳");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(339:17) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (325:10) {#each layer.id.split('/') as idSection, i}
    function create_each_block_1(ctx) {
    	let g;
    	let show_if = /*i*/ ctx[29] === 0 && /*limitHit*/ ctx[9].includes(/*idSection*/ ctx[27]);
    	let text_1;
    	let t_value = /*idSection*/ ctx[27] + "";
    	let t;
    	let text_1_x_value;
    	let if_block0 = show_if && create_if_block_2$3(ctx);
    	let if_block1 = /*i*/ ctx[29] > 0 && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			if (if_block0) if_block0.c();
    			text_1 = svg_element("text");
    			if (if_block1) if_block1.c();
    			t = text$1(t_value);
    			attr_dev(text_1, "y", 18 * /*i*/ ctx[29]);

    			attr_dev(text_1, "x", text_1_x_value = (/*i*/ ctx[29] > 0 ? 18 : 0) + /*limitHit*/ ctx[9].includes(/*idSection*/ ctx[27])
    			? 18
    			: 0);

    			attr_dev(text_1, "class", "svelte-rpuqmp");
    			add_location(text_1, file$4, 335, 14, 9420);
    			add_location(g, file$4, 324, 53, 9043);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			if (if_block0) if_block0.m(g, null);
    			append_dev(g, text_1);
    			if (if_block1) if_block1.m(text_1, null);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*limitHit, layers*/ 640) show_if = /*i*/ ctx[29] === 0 && /*limitHit*/ ctx[9].includes(/*idSection*/ ctx[27]);

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					if_block0.m(g, text_1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*layers*/ 128 && t_value !== (t_value = /*idSection*/ ctx[27] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*limitHit, layers*/ 640 && text_1_x_value !== (text_1_x_value = (/*i*/ ctx[29] > 0 ? 18 : 0) + /*limitHit*/ ctx[9].includes(/*idSection*/ ctx[27])
    			? 18
    			: 0)) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(325:10) {#each layer.id.split('/') as idSection, i}",
    		ctx
    	});

    	return block;
    }

    // (318:6) {#each layers as layer}
    function create_each_block(ctx) {
    	let g;
    	let g_transform_value;
    	let each_value_1 = /*layer*/ ctx[24].id.split('/');
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g, "class", "tick");
    			attr_dev(g, "opacity", "1");
    			attr_dev(g, "transform", g_transform_value = "translate(0,\n          " + (/*adjustedYScale*/ ctx[4](/*layer*/ ctx[24].id) + /*yScale*/ ctx[3].bandwidth() / 2) + ")");
    			add_location(g, file$4, 318, 8, 8834);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*limitHit, layers, handleTooltipWarning, handleTooltipClose*/ 10880) {
    				each_value_1 = /*layer*/ ctx[24].id.split('/');
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*adjustedYScale, layers, yScale*/ 152 && g_transform_value !== (g_transform_value = "translate(0,\n          " + (/*adjustedYScale*/ ctx[4](/*layer*/ ctx[24].id) + /*yScale*/ ctx[3].bandwidth() / 2) + ")")) {
    				attr_dev(g, "transform", g_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(318:6) {#each layers as layer}",
    		ctx
    	});

    	return block;
    }

    // (348:2) {#if Object.keys(tooltip).length > 0}
    function create_if_block$3(ctx) {
    	let tooltip_1;
    	let current;

    	tooltip_1 = new Tooltip({
    			props: {
    				left: /*tooltip*/ ctx[10].left,
    				top: /*tooltip*/ ctx[10].top,
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tooltip_1.$on("close", /*handleTooltipClose*/ ctx[11]);

    	const block = {
    		c: function create() {
    			create_component(tooltip_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tooltip_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tooltip_1_changes = {};
    			if (dirty[0] & /*tooltip*/ 1024) tooltip_1_changes.left = /*tooltip*/ ctx[10].left;
    			if (dirty[0] & /*tooltip*/ 1024) tooltip_1_changes.top = /*tooltip*/ ctx[10].top;

    			if (dirty[0] & /*tooltip*/ 1024 | dirty[1] & /*$$scope*/ 1024) {
    				tooltip_1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip_1.$set(tooltip_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tooltip_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(348:2) {#if Object.keys(tooltip).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (349:4) <Tooltip       left={tooltip.left}       top={tooltip.top}       on:close={handleTooltipClose}     >
    function create_default_slot$1(ctx) {
    	let t_value = (/*tooltip*/ ctx[10].text || '') + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tooltip*/ 1024 && t_value !== (t_value = (/*tooltip*/ ctx[10].text || '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(349:4) <Tooltip       left={tooltip.left}       top={tooltip.top}       on:close={handleTooltipClose}     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div;
    	let svg;
    	let defs;
    	let g0;
    	let if_block0_anchor;
    	let g1;
    	let g1_transform_value;
    	let g2;
    	let t;
    	let show_if = Object.keys(/*tooltip*/ ctx[10]).length > 0;
    	let current;
    	let each_value_4 = /*gradients*/ ctx[1];
    	validate_each_argument(each_value_4);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_3[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	let if_block0 = /*backgroundRect*/ ctx[8] && create_if_block_3$2(ctx);
    	let each_value_3 = /*layers*/ ctx[7];
    	validate_each_argument(each_value_3);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_2[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*zoomLevels*/ ctx[6];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	let each_value = /*layers*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	let if_block1 = show_if && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			defs = svg_element("defs");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			g0 = svg_element("g");
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			g1 = svg_element("g");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			g2 = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block1) if_block1.c();
    			add_location(defs, file$4, 265, 4, 7427);
    			add_location(g0, file$4, 278, 4, 7783);
    			attr_dev(g1, "transform", g1_transform_value = "translate(0, " + (MARGIN.top + /*scrollY*/ ctx[5]) + ")");
    			attr_dev(g1, "class", "x-axis svelte-rpuqmp");
    			add_location(g1, file$4, 302, 4, 8415);
    			attr_dev(g2, "transform", "translate(0, 0)");
    			attr_dev(g2, "class", "y-axis svelte-rpuqmp");
    			add_location(g2, file$4, 316, 4, 8749);
    			attr_dev(svg, "id", "lines");
    			attr_dev(svg, "width", CHART_WIDTH);
    			attr_dev(svg, "height", /*chartHeight*/ ctx[0]);
    			add_location(svg, file$4, 264, 2, 7365);
    			attr_dev(div, "class", "fills-chart");
    			add_location(div, file$4, 263, 0, 7337);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, defs);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(defs, null);
    			}

    			append_dev(svg, g0);
    			if (if_block0) if_block0.m(g0, null);
    			append_dev(g0, if_block0_anchor);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(g0, null);
    			}

    			append_dev(svg, g1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(g1, null);
    			}

    			append_dev(svg, g2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g2, null);
    			}

    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gradients*/ 2) {
    				each_value_4 = /*gradients*/ ctx[1];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_4(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(defs, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_4.length;
    			}

    			if (/*backgroundRect*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					if_block0.m(g0, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*layers, handleClick*/ 4224) {
    				each_value_3 = /*layers*/ ctx[7];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_3(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(g0, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_3.length;
    			}

    			if (dirty[0] & /*xScale, zoomLevels*/ 68) {
    				each_value_2 = /*zoomLevels*/ ctx[6];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(g1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (!current || dirty[0] & /*scrollY*/ 32 && g1_transform_value !== (g1_transform_value = "translate(0, " + (MARGIN.top + /*scrollY*/ ctx[5]) + ")")) {
    				attr_dev(g1, "transform", g1_transform_value);
    			}

    			if (dirty[0] & /*adjustedYScale, layers, yScale, limitHit, handleTooltipWarning, handleTooltipClose*/ 10904) {
    				each_value = /*layers*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty[0] & /*chartHeight*/ 1) {
    				attr_dev(svg, "height", /*chartHeight*/ ctx[0]);
    			}

    			if (dirty[0] & /*tooltip*/ 1024) show_if = Object.keys(/*tooltip*/ ctx[10]).length > 0;

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*tooltip*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks_3, detaching);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let tooltip;
    	let $propertyValueComboLimitStore;
    	validate_store(propertyValueComboLimitStore, 'propertyValueComboLimitStore');
    	component_subscribe($$self, propertyValueComboLimitStore, $$value => $$invalidate(19, $propertyValueComboLimitStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LinesChart', slots, []);
    	let { style } = $$props;
    	let { backgroundSvgData } = $$props;
    	let chartHeight;
    	let gradients = [];
    	const handleTooltipClose = () => $$invalidate(10, tooltip = {});
    	let xScale;
    	let yScale;
    	let adjustedYScale;
    	let scrollY = 0;
    	let zoomLevels = [];
    	let layers;
    	let backgroundRect;
    	let expandedLayers = [];
    	let limitHit = [];

    	displayLayersStore.subscribe(value => {
    		expandedLayers = value.layers;
    		$$invalidate(9, limitHit = value.limitHit);
    	});

    	// Returns the largest width a line reaches within an expression
    	function getFullLineWidth(layer) {
    		const lineWidth = layer?.paint?.['line-width'];
    		if (!lineWidth) return 1;
    		let outputs = gatherOutputs(lineWidth);

    		if (!outputs.every(output => typeof output === 'number')) {
    			console.warn('Outputs of line-width expression contain non-numerical values. This indicates a problem in expanding layers.');
    			outputs = [1];
    		}

    		return Math.max(...outputs);
    	}

    	function getPath(layer) {
    		const width = layer.paint ? layer.paint['line-width'] : null;
    		const layerMaxZoom = layer.maxzoom || MAX_ZOOM;
    		const layerMinZoom = layer.minzoom !== undefined ? layer.minzoom : MIN_ZOOM;
    		const topPoints = [];
    		const bottomPoints = [];
    		let lastZoom;
    		let lastWidth;
    		let path;

    		if (Array.isArray(width)) {
    			const [expressionType, [interpolationType, interpolationBase], [attribute]] = width;

    			if (expressionType === 'interpolate' && interpolationType === 'linear' && attribute === 'zoom') {
    				// TODO look into base for interpolation
    				const widthArray = width.slice(3);

    				topPoints.push([xScale(layerMinZoom), adjustedYScale(layer.id) + yScale.bandwidth() / 2]);

    				for (let i = 0; i < widthArray.length; i += 2) {
    					const zoom = widthArray[i];
    					const width = widthArray[i + 1];
    					if (zoom < layerMinZoom) continue;

    					topPoints.push([
    						xScale(zoom),
    						adjustedYScale(layer.id) - width / 2 + yScale.bandwidth() / 2
    					]);

    					if (width > 0) {
    						bottomPoints.push([
    							xScale(zoom),
    							adjustedYScale(layer.id) + width / 2 + yScale.bandwidth() / 2
    						]);
    					}
    				}

    				[lastZoom, lastWidth] = widthArray.slice(-2);
    			} else if (interpolationType === 'exponential') ; else {
    				console.log('array but not linear', width); // TODO create scale, sample zoom levels, create points
    			}
    		} else if (width && width.stops) {
    			width.stops.forEach(stop => {
    				const [zoom, width] = stop;

    				topPoints.push([
    					xScale(zoom),
    					adjustedYScale(layer.id) - width / 2 + yScale.bandwidth() / 2
    				]);

    				if (width > 0) {
    					bottomPoints.push([
    						xScale(zoom),
    						adjustedYScale(layer.id) + width / 2 + yScale.bandwidth() / 2
    					]);
    				}
    			});

    			[lastZoom, lastWidth] = width.stops.slice(-1)[0];
    		} else if (!width) {
    			let layerWidth = 1;

    			topPoints.push([
    				xScale(layerMinZoom),
    				adjustedYScale(layer.id) - layerWidth / 2 + yScale.bandwidth() / 2
    			]);

    			topPoints.push([
    				xScale(layerMaxZoom),
    				adjustedYScale(layer.id) - layerWidth / 2 + yScale.bandwidth() / 2
    			]);

    			bottomPoints.push([
    				xScale(layerMinZoom),
    				adjustedYScale(layer.id) + layerWidth / 2 + yScale.bandwidth() / 2
    			]);

    			bottomPoints.push([
    				xScale(layerMaxZoom),
    				adjustedYScale(layer.id) + layerWidth / 2 + yScale.bandwidth() / 2
    			]);
    		}

    		if (topPoints.length) {
    			if (layerMaxZoom > lastZoom) {
    				topPoints.push([
    					xScale(layerMaxZoom),
    					adjustedYScale(layer.id) - lastWidth / 2 + yScale.bandwidth() / 2
    				]);

    				if (lastWidth > 0) {
    					bottomPoints.push([
    						xScale(layerMaxZoom),
    						adjustedYScale(layer.id) + lastWidth / 2 + yScale.bandwidth() / 2
    					]);
    				}
    			}

    			path = topPoints.concat(bottomPoints.reverse());
    		}

    		return path;
    	}

    	const getDrawLayer = layer => {
    		const { color: layerColor, gradients: layerGradients } = getColor(layer, xScale);
    		const { color, strokeColor, strokeWidth } = layerColor;
    		$$invalidate(1, gradients = gradients.concat(layerGradients));
    		const path = getPath(layer);

    		return {
    			...layer,
    			path: line()(path || []),
    			fill: color,
    			stroke: strokeColor,
    			strokeWidth
    		};
    	};

    	const initChart = () => {
    		let lineLayers = expandedLayers.filter(l => l.type === 'line');
    		$$invalidate(0, chartHeight = lineLayers.length * 65);
    		$$invalidate(2, xScale = linear([MIN_ZOOM, MAX_ZOOM], [MARGIN.left, CHART_WIDTH - MARGIN.right]));
    		$$invalidate(3, yScale = band(lineLayers.map(({ id }) => id), [MARGIN.top, chartHeight - MARGIN.bottom]).padding(0.25));

    		// Adjust the yScale to account for layer width since D3 scaleBand spaces evenly
    		const yScaleObj = lineLayers.reduce(
    			(acc, l) => {
    				acc[l.id] = yScale(l.id);
    				return acc;
    			},
    			{}
    		);

    		let yOffset = 0;

    		for (let i = 0; i < lineLayers.length; i++) {
    			const l = lineLayers[i];
    			let placement = yScaleObj[l.id];

    			const prevLineWidth = lineLayers[i - 1]
    			? getFullLineWidth(lineLayers[i - 1])
    			: 1;

    			const currentLineWidth = getFullLineWidth(l);
    			yOffset += prevLineWidth / 2 + currentLineWidth / 2;
    			const nextPlacement = placement + yOffset;
    			yScaleObj[l.id] = nextPlacement;
    		}

    		// Adjust the height to account for the increased offsets
    		$$invalidate(0, chartHeight = chartHeight + yOffset);

    		// Adjusted yScale function to use throughout
    		$$invalidate(4, adjustedYScale = layerId => yScaleObj[layerId]);

    		$$invalidate(6, zoomLevels = range$2(MIN_ZOOM, MAX_ZOOM + 1, 1));
    		$$invalidate(7, layers = lineLayers.map(getDrawLayer));
    		$$invalidate(8, backgroundRect = backgroundSvgData.rect);

    		if (backgroundSvgData.gradientDefs) {
    			gradients.push(backgroundSvgData.gradientDefs);
    		}
    	};

    	onMount(() => {
    		document.addEventListener('scroll', () => $$invalidate(5, scrollY = window.scrollY));
    	});

    	function handleClick(layer) {
    		$$invalidate(10, tooltip = {
    			text: JSON.stringify(layer.paint, null, 2),
    			left: xScale(MAX_ZOOM) + 10,
    			top: adjustedYScale(layer.id) + yScale.bandwidth()
    		});
    	}

    	function handleTooltipWarning(layerId, expandedLayerId) {
    		$$invalidate(10, tooltip = {
    			text: `${layerId} had too many possible property/value combinations and has been limited to showing ${$propertyValueComboLimitStore} for performance.`,
    			left: 24,
    			top: adjustedYScale(expandedLayerId) + yScale.bandwidth() * 0.75
    		});
    	}

    	const writable_props = ['style', 'backgroundSvgData'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<LinesChart> was created with unknown prop '${key}'`);
    	});

    	const click_handler = layer => handleClick(layer);
    	const mouseover_handler = (idSection, layer) => handleTooltipWarning(idSection, layer.id);

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(14, style = $$props.style);
    		if ('backgroundSvgData' in $$props) $$invalidate(15, backgroundSvgData = $$props.backgroundSvgData);
    	};

    	$$self.$capture_state = () => ({
    		d3,
    		onMount,
    		Tooltip,
    		getColor,
    		gatherOutputs,
    		displayLayersStore,
    		propertyValueComboLimitStore,
    		MIN_ZOOM,
    		MAX_ZOOM,
    		CHART_WIDTH,
    		MARGIN,
    		style,
    		backgroundSvgData,
    		chartHeight,
    		gradients,
    		handleTooltipClose,
    		xScale,
    		yScale,
    		adjustedYScale,
    		scrollY,
    		zoomLevels,
    		layers,
    		backgroundRect,
    		expandedLayers,
    		limitHit,
    		getFullLineWidth,
    		getPath,
    		getDrawLayer,
    		initChart,
    		handleClick,
    		handleTooltipWarning,
    		tooltip,
    		$propertyValueComboLimitStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(14, style = $$props.style);
    		if ('backgroundSvgData' in $$props) $$invalidate(15, backgroundSvgData = $$props.backgroundSvgData);
    		if ('chartHeight' in $$props) $$invalidate(0, chartHeight = $$props.chartHeight);
    		if ('gradients' in $$props) $$invalidate(1, gradients = $$props.gradients);
    		if ('xScale' in $$props) $$invalidate(2, xScale = $$props.xScale);
    		if ('yScale' in $$props) $$invalidate(3, yScale = $$props.yScale);
    		if ('adjustedYScale' in $$props) $$invalidate(4, adjustedYScale = $$props.adjustedYScale);
    		if ('scrollY' in $$props) $$invalidate(5, scrollY = $$props.scrollY);
    		if ('zoomLevels' in $$props) $$invalidate(6, zoomLevels = $$props.zoomLevels);
    		if ('layers' in $$props) $$invalidate(7, layers = $$props.layers);
    		if ('backgroundRect' in $$props) $$invalidate(8, backgroundRect = $$props.backgroundRect);
    		if ('expandedLayers' in $$props) expandedLayers = $$props.expandedLayers;
    		if ('limitHit' in $$props) $$invalidate(9, limitHit = $$props.limitHit);
    		if ('tooltip' in $$props) $$invalidate(10, tooltip = $$props.tooltip);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*style*/ 16384) {
    			{
    				handleTooltipClose();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*style*/ 16384) {
    			if (style && style.layers) {
    				initChart();
    			}
    		}
    	};

    	$$invalidate(10, tooltip = {});

    	return [
    		chartHeight,
    		gradients,
    		xScale,
    		yScale,
    		adjustedYScale,
    		scrollY,
    		zoomLevels,
    		layers,
    		backgroundRect,
    		limitHit,
    		tooltip,
    		handleTooltipClose,
    		handleClick,
    		handleTooltipWarning,
    		style,
    		backgroundSvgData,
    		click_handler,
    		mouseover_handler
    	];
    }

    class LinesChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { style: 14, backgroundSvgData: 15 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LinesChart",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*style*/ ctx[14] === undefined && !('style' in props)) {
    			console_1.warn("<LinesChart> was created without expected prop 'style'");
    		}

    		if (/*backgroundSvgData*/ ctx[15] === undefined && !('backgroundSvgData' in props)) {
    			console_1.warn("<LinesChart> was created without expected prop 'backgroundSvgData'");
    		}
    	}

    	get style() {
    		throw new Error("<LinesChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<LinesChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundSvgData() {
    		throw new Error("<LinesChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundSvgData(value) {
    		throw new Error("<LinesChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /* Mapbox GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/mapbox/mapbox-gl-js/blob/v1.13.2/LICENSE.txt */

    var mapboxGl = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
    module.exports = factory() ;
    }(commonjsGlobal, (function () {
    /* eslint-disable */

    var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
    if (!shared) {
        shared = chunk;
    } else if (!worker) {
        worker = chunk;
    } else {
        var workerBundleString = 'var sharedChunk = {}; (' + shared + ')(sharedChunk); (' + worker + ')(sharedChunk);';

        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl = chunk(sharedChunk);
        if (typeof window !== 'undefined') {
            mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
        }
    }
    }


    define(["exports"],(function(t){function e(t,e){return t(e={exports:{}},e.exports),e.exports}var r=n;function n(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=n,this.p2x=r,this.p2y=n;}n.prototype.sampleCurveX=function(t){return ((this.ax*t+this.bx)*t+this.cx)*t},n.prototype.sampleCurveY=function(t){return ((this.ay*t+this.by)*t+this.cy)*t},n.prototype.sampleCurveDerivativeX=function(t){return (3*this.ax*t+2*this.bx)*t+this.cx},n.prototype.solveCurveX=function(t,e){var r,n,i,a,o;for(void 0===e&&(e=1e-6),i=t,o=0;o<8;o++){if(a=this.sampleCurveX(i)-t,Math.abs(a)<e)return i;var s=this.sampleCurveDerivativeX(i);if(Math.abs(s)<1e-6)break;i-=a/s;}if((i=t)<(r=0))return r;if(i>(n=1))return n;for(;r<n;){if(a=this.sampleCurveX(i),Math.abs(a-t)<e)return i;t>a?r=i:n=i,i=.5*(n-r)+r;}return i},n.prototype.solve=function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))};var i=a;function a(t,e){this.x=t,this.y=e;}a.prototype={clone:function(){return new a(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[2]*this.x+t[3]*this.y;return this.x=t[0]*this.x+t[1]*this.y,this.y=e,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=r*this.x+e*this.y;return this.x=e*this.x-r*this.y,this.y=n,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),i=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=e.x+r*(this.x-e.x)-n*(this.y-e.y),this.y=i,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},a.convert=function(t){return t instanceof a?t:Array.isArray(t)?new a(t[0],t[1]):t};var o="undefined"!=typeof self?self:{},s=Math.pow(2,53)-1;function u(t,e,n,i){var a=new r(t,e,n,i);return function(t){return a.solve(t)}}var l=u(.25,.1,.25,1);function p(t,e,r){return Math.min(r,Math.max(e,t))}function c(t,e,r){var n=r-e,i=((t-e)%n+n)%n+e;return i===e?r:i}function h(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];for(var n=0,i=e;n<i.length;n+=1){var a=i[n];for(var o in a)t[o]=a[o];}return t}var f=1;function y(){return f++}function d(){return function t(e){return e?(e^16*Math.random()>>e/4).toString(16):([1e7]+-[1e3]+-4e3+-8e3+-1e11).replace(/[018]/g,t)}()}function m(t){return !!t&&/^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)}function v(t,e){t.forEach((function(t){e[t]&&(e[t]=e[t].bind(e));}));}function g(t,e){return -1!==t.indexOf(e,t.length-e.length)}function x(t,e,r){var n={};for(var i in t)n[i]=e.call(r||this,t[i],i,t);return n}function b(t,e,r){var n={};for(var i in t)e.call(r||this,t[i],i,t)&&(n[i]=t[i]);return n}function w(t){return Array.isArray(t)?t.map(w):"object"==typeof t&&t?x(t,w):t}var _={};function A(t){_[t]||("undefined"!=typeof console&&console.warn(t),_[t]=!0);}function S(t,e,r){return (r.y-t.y)*(e.x-t.x)>(e.y-t.y)*(r.x-t.x)}function k(t){for(var e=0,r=0,n=t.length,i=n-1,a=void 0,o=void 0;r<n;i=r++)e+=((o=t[i]).x-(a=t[r]).x)*(a.y+o.y);return e}function I(){return "undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope}function z(t){var e={};if(t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,(function(t,r,n,i){var a=n||i;return e[r]=!a||a.toLowerCase(),""})),e["max-age"]){var r=parseInt(e["max-age"],10);isNaN(r)?delete e["max-age"]:e["max-age"]=r;}return e}var C=null;function E(t){if(null==C){var e=t.navigator?t.navigator.userAgent:null;C=!!t.safari||!(!e||!(/\b(iPad|iPhone|iPod)\b/.test(e)||e.match("Safari")&&!e.match("Chrome")));}return C}function P(t){try{var e=o[t];return e.setItem("_mapbox_test_",1),e.removeItem("_mapbox_test_"),!0}catch(t){return !1}}var M,B,T,V,F=o.performance&&o.performance.now?o.performance.now.bind(o.performance):Date.now.bind(Date),D=o.requestAnimationFrame||o.mozRequestAnimationFrame||o.webkitRequestAnimationFrame||o.msRequestAnimationFrame,L=o.cancelAnimationFrame||o.mozCancelAnimationFrame||o.webkitCancelAnimationFrame||o.msCancelAnimationFrame,O={now:F,frame:function(t){var e=D(t);return {cancel:function(){return L(e)}}},getImageData:function(t,e){void 0===e&&(e=0);var r=o.document.createElement("canvas"),n=r.getContext("2d");if(!n)throw new Error("failed to create canvas 2d context");return r.width=t.width,r.height=t.height,n.drawImage(t,0,0,t.width,t.height),n.getImageData(-e,-e,t.width+2*e,t.height+2*e)},resolveURL:function(t){return M||(M=o.document.createElement("a")),M.href=t,M.href},hardwareConcurrency:o.navigator&&o.navigator.hardwareConcurrency||4,get devicePixelRatio(){return o.devicePixelRatio},get prefersReducedMotion(){return !!o.matchMedia&&(null==B&&(B=o.matchMedia("(prefers-reduced-motion: reduce)")),B.matches)}},R={API_URL:"https://api.mapbox.com",get EVENTS_URL(){return this.API_URL?0===this.API_URL.indexOf("https://api.mapbox.cn")?"https://events.mapbox.cn/events/v2":0===this.API_URL.indexOf("https://api.mapbox.com")?"https://events.mapbox.com/events/v2":null:null},FEEDBACK_URL:"https://apps.mapbox.com/feedback",REQUIRE_ACCESS_TOKEN:!0,ACCESS_TOKEN:null,MAX_PARALLEL_IMAGE_REQUESTS:16},U={supported:!1,testSupport:function(t){!j&&V&&(q?N(t):T=t);}},j=!1,q=!1;function N(t){var e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);try{if(t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,V),t.isContextLost())return;U.supported=!0;}catch(t){}t.deleteTexture(e),j=!0;}o.document&&((V=o.document.createElement("img")).onload=function(){T&&N(T),T=null,q=!0;},V.onerror=function(){j=!0,T=null;},V.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");var K="01",G=function(t,e){this._transformRequestFn=t,this._customAccessToken=e,this._createSkuToken();};function Z(t){return 0===t.indexOf("mapbox:")}G.prototype._createSkuToken=function(){var t=function(){for(var t="",e=0;e<10;e++)t+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62*Math.random())];return {token:["1",K,t].join(""),tokenExpiresAt:Date.now()+432e5}}();this._skuToken=t.token,this._skuTokenExpiresAt=t.tokenExpiresAt;},G.prototype._isSkuTokenExpired=function(){return Date.now()>this._skuTokenExpiresAt},G.prototype.transformRequest=function(t,e){return this._transformRequestFn&&this._transformRequestFn(t,e)||{url:t}},G.prototype.normalizeStyleURL=function(t,e){if(!Z(t))return t;var r=Y(t);return r.path="/styles/v1"+r.path,this._makeAPIURL(r,this._customAccessToken||e)},G.prototype.normalizeGlyphsURL=function(t,e){if(!Z(t))return t;var r=Y(t);return r.path="/fonts/v1"+r.path,this._makeAPIURL(r,this._customAccessToken||e)},G.prototype.normalizeSourceURL=function(t,e){if(!Z(t))return t;var r=Y(t);return r.path="/v4/"+r.authority+".json",r.params.push("secure"),this._makeAPIURL(r,this._customAccessToken||e)},G.prototype.normalizeSpriteURL=function(t,e,r,n){var i=Y(t);return Z(t)?(i.path="/styles/v1"+i.path+"/sprite"+e+r,this._makeAPIURL(i,this._customAccessToken||n)):(i.path+=""+e+r,$(i))},G.prototype.normalizeTileURL=function(t,e){if(this._isSkuTokenExpired()&&this._createSkuToken(),t&&!Z(t))return t;var r=Y(t);r.path=r.path.replace(/(\.(png|jpg)\d*)(?=$)/,(O.devicePixelRatio>=2||512===e?"@2x":"")+(U.supported?".webp":"$1")),r.path=r.path.replace(/^.+\/v4\//,"/"),r.path="/v4"+r.path;var n=this._customAccessToken||function(t){for(var e=0,r=t;e<r.length;e+=1){var n=r[e].match(/^access_token=(.*)$/);if(n)return n[1]}return null}(r.params)||R.ACCESS_TOKEN;return R.REQUIRE_ACCESS_TOKEN&&n&&this._skuToken&&r.params.push("sku="+this._skuToken),this._makeAPIURL(r,n)},G.prototype.canonicalizeTileURL=function(t,e){var r=Y(t);if(!r.path.match(/(^\/v4\/)/)||!r.path.match(/\.[\w]+$/))return t;var n="mapbox://tiles/";n+=r.path.replace("/v4/","");var i=r.params;return e&&(i=i.filter((function(t){return !t.match(/^access_token=/)}))),i.length&&(n+="?"+i.join("&")),n},G.prototype.canonicalizeTileset=function(t,e){for(var r=!!e&&Z(e),n=[],i=0,a=t.tiles||[];i<a.length;i+=1){var o=a[i];J(o)?n.push(this.canonicalizeTileURL(o,r)):n.push(o);}return n},G.prototype._makeAPIURL=function(t,e){var r="See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",n=Y(R.API_URL);if(t.protocol=n.protocol,t.authority=n.authority,"http"===t.protocol){var i=t.params.indexOf("secure");i>=0&&t.params.splice(i,1);}if("/"!==n.path&&(t.path=""+n.path+t.path),!R.REQUIRE_ACCESS_TOKEN)return $(t);if(!(e=e||R.ACCESS_TOKEN))throw new Error("An API access token is required to use Mapbox GL. "+r);if("s"===e[0])throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). "+r);return t.params=t.params.filter((function(t){return -1===t.indexOf("access_token")})),t.params.push("access_token="+e),$(t)};var X=/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;function J(t){return X.test(t)}var H=/^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;function Y(t){var e=t.match(H);if(!e)throw new Error("Unable to parse URL object");return {protocol:e[1],authority:e[2],path:e[3]||"/",params:e[4]?e[4].split("&"):[]}}function $(t){var e=t.params.length?"?"+t.params.join("&"):"";return t.protocol+"://"+t.authority+t.path+e}function W(t){if(!t)return null;var e=t.split(".");if(!e||3!==e.length)return null;try{return JSON.parse(decodeURIComponent(o.atob(e[1]).split("").map((function(t){return "%"+("00"+t.charCodeAt(0).toString(16)).slice(-2)})).join("")))}catch(t){return null}}var Q=function(t){this.type=t,this.anonId=null,this.eventData={},this.queue=[],this.pendingRequest=null;};Q.prototype.getStorageKey=function(t){var e,r=W(R.ACCESS_TOKEN);return e=r&&r.u?o.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g,(function(t,e){return String.fromCharCode(Number("0x"+e))}))):R.ACCESS_TOKEN||"",t?"mapbox.eventData."+t+":"+e:"mapbox.eventData:"+e},Q.prototype.fetchEventData=function(){var t=P("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid");if(t)try{var n=o.localStorage.getItem(e);n&&(this.eventData=JSON.parse(n));var i=o.localStorage.getItem(r);i&&(this.anonId=i);}catch(t){A("Unable to read from LocalStorage");}},Q.prototype.saveEventData=function(){var t=P("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid");if(t)try{o.localStorage.setItem(r,this.anonId),Object.keys(this.eventData).length>=1&&o.localStorage.setItem(e,JSON.stringify(this.eventData));}catch(t){A("Unable to write to LocalStorage");}},Q.prototype.processRequests=function(t){},Q.prototype.postEvent=function(t,e,r,n){var i=this;if(R.EVENTS_URL){var a=Y(R.EVENTS_URL);a.params.push("access_token="+(n||R.ACCESS_TOKEN||""));var o={event:this.type,created:new Date(t).toISOString(),sdkIdentifier:"mapbox-gl-js",sdkVersion:"1.13.2",skuId:K,userId:this.anonId},s=e?h(o,e):o,u={url:$(a),headers:{"Content-Type":"text/plain"},body:JSON.stringify([s])};this.pendingRequest=wt(u,(function(t){i.pendingRequest=null,r(t),i.saveEventData(),i.processRequests(n);}));}},Q.prototype.queueRequest=function(t,e){this.queue.push(t),this.processRequests(e);};var tt,et,rt=function(t){function e(){t.call(this,"map.load"),this.success={},this.skuToken="";}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.postMapLoadEvent=function(t,e,r,n){this.skuToken=r,(R.EVENTS_URL&&n||R.ACCESS_TOKEN&&Array.isArray(t)&&t.some((function(t){return Z(t)||J(t)})))&&this.queueRequest({id:e,timestamp:Date.now()},n);},e.prototype.processRequests=function(t){var e=this;if(!this.pendingRequest&&0!==this.queue.length){var r=this.queue.shift(),n=r.id,i=r.timestamp;n&&this.success[n]||(this.anonId||this.fetchEventData(),m(this.anonId)||(this.anonId=d()),this.postEvent(i,{skuToken:this.skuToken},(function(t){t||n&&(e.success[n]=!0);}),t));}},e}(Q),nt=new(function(t){function e(e){t.call(this,"appUserTurnstile"),this._customAccessToken=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.postTurnstileEvent=function(t,e){R.EVENTS_URL&&R.ACCESS_TOKEN&&Array.isArray(t)&&t.some((function(t){return Z(t)||J(t)}))&&this.queueRequest(Date.now(),e);},e.prototype.processRequests=function(t){var e=this;if(!this.pendingRequest&&0!==this.queue.length){this.anonId&&this.eventData.lastSuccess&&this.eventData.tokenU||this.fetchEventData();var r=W(R.ACCESS_TOKEN),n=r?r.u:R.ACCESS_TOKEN,i=n!==this.eventData.tokenU;m(this.anonId)||(this.anonId=d(),i=!0);var a=this.queue.shift();if(this.eventData.lastSuccess){var o=new Date(this.eventData.lastSuccess),s=new Date(a),u=(a-this.eventData.lastSuccess)/864e5;i=i||u>=1||u<-1||o.getDate()!==s.getDate();}else i=!0;if(!i)return this.processRequests();this.postEvent(a,{"enabled.telemetry":!1},(function(t){t||(e.eventData.lastSuccess=a,e.eventData.tokenU=n);}),t);}},e}(Q)),it=nt.postTurnstileEvent.bind(nt),at=new rt,ot=at.postMapLoadEvent.bind(at),st=500,ut=50;function lt(){o.caches&&!tt&&(tt=o.caches.open("mapbox-tiles"));}function pt(t){var e=t.indexOf("?");return e<0?t:t.slice(0,e)}var ct,ht=1/0;function ft(){return null==ct&&(ct=o.OffscreenCanvas&&new o.OffscreenCanvas(1,1).getContext("2d")&&"function"==typeof o.createImageBitmap),ct}var yt={Unknown:"Unknown",Style:"Style",Source:"Source",Tile:"Tile",Glyphs:"Glyphs",SpriteImage:"SpriteImage",SpriteJSON:"SpriteJSON",Image:"Image"};"function"==typeof Object.freeze&&Object.freeze(yt);var dt=function(t){function e(e,r,n){401===r&&J(n)&&(e+=": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"),t.call(this,e),this.status=r,this.url=n,this.name=this.constructor.name,this.message=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.toString=function(){return this.name+": "+this.message+" ("+this.status+"): "+this.url},e}(Error),mt=I()?function(){return self.worker&&self.worker.referrer}:function(){return ("blob:"===o.location.protocol?o.parent:o).location.href};var vt,gt,xt=function(t,e){if(!(/^file:/.test(r=t.url)||/^file:/.test(mt())&&!/^\w+:/.test(r))){if(o.fetch&&o.Request&&o.AbortController&&o.Request.prototype.hasOwnProperty("signal"))return function(t,e){var r,n=new o.AbortController,i=new o.Request(t.url,{method:t.method||"GET",body:t.body,credentials:t.credentials,headers:t.headers,referrer:mt(),signal:n.signal}),a=!1,s=!1,u=(r=i.url).indexOf("sku=")>0&&J(r);"json"===t.type&&i.headers.set("Accept","application/json");var l=function(r,n,a){if(!s){if(r&&"SecurityError"!==r.message&&A(r),n&&a)return p(n);var l=Date.now();o.fetch(i).then((function(r){if(r.ok){var n=u?r.clone():null;return p(r,n,l)}return e(new dt(r.statusText,r.status,t.url))})).catch((function(t){20!==t.code&&e(new Error(t.message));}));}},p=function(r,n,u){("arrayBuffer"===t.type?r.arrayBuffer():"json"===t.type?r.json():r.text()).then((function(t){s||(n&&u&&function(t,e,r){if(lt(),tt){var n={status:e.status,statusText:e.statusText,headers:new o.Headers};e.headers.forEach((function(t,e){return n.headers.set(e,t)}));var i=z(e.headers.get("Cache-Control")||"");i["no-store"]||(i["max-age"]&&n.headers.set("Expires",new Date(r+1e3*i["max-age"]).toUTCString()),new Date(n.headers.get("Expires")).getTime()-r<42e4||function(t,e){if(void 0===et)try{new Response(new ReadableStream),et=!0;}catch(t){et=!1;}et?e(t.body):t.blob().then(e);}(e,(function(e){var r=new o.Response(e,n);lt(),tt&&tt.then((function(e){return e.put(pt(t.url),r)})).catch((function(t){return A(t.message)}));})));}}(i,n,u),a=!0,e(null,t,r.headers.get("Cache-Control"),r.headers.get("Expires")));})).catch((function(t){s||e(new Error(t.message));}));};return u?function(t,e){if(lt(),!tt)return e(null);var r=pt(t.url);tt.then((function(t){t.match(r).then((function(n){var i=function(t){if(!t)return !1;var e=new Date(t.headers.get("Expires")||0),r=z(t.headers.get("Cache-Control")||"");return e>Date.now()&&!r["no-cache"]}(n);t.delete(r),i&&t.put(r,n.clone()),e(null,n,i);})).catch(e);})).catch(e);}(i,l):l(null,null),{cancel:function(){s=!0,a||n.abort();}}}(t,e);if(I()&&self.worker&&self.worker.actor)return self.worker.actor.send("getResource",t,e,void 0,!0)}var r;return function(t,e){var r=new o.XMLHttpRequest;for(var n in r.open(t.method||"GET",t.url,!0),"arrayBuffer"===t.type&&(r.responseType="arraybuffer"),t.headers)r.setRequestHeader(n,t.headers[n]);return "json"===t.type&&(r.responseType="text",r.setRequestHeader("Accept","application/json")),r.withCredentials="include"===t.credentials,r.onerror=function(){e(new Error(r.statusText));},r.onload=function(){if((r.status>=200&&r.status<300||0===r.status)&&null!==r.response){var n=r.response;if("json"===t.type)try{n=JSON.parse(r.response);}catch(t){return e(t)}e(null,n,r.getResponseHeader("Cache-Control"),r.getResponseHeader("Expires"));}else e(new dt(r.statusText,r.status,t.url));},r.send(t.body),{cancel:function(){return r.abort()}}}(t,e)},bt=function(t,e){return xt(h(t,{type:"arrayBuffer"}),e)},wt=function(t,e){return xt(h(t,{method:"POST"}),e)},_t="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";vt=[],gt=0;var At=function(t,e){if(U.supported&&(t.headers||(t.headers={}),t.headers.accept="image/webp,*/*"),gt>=R.MAX_PARALLEL_IMAGE_REQUESTS){var r={requestParameters:t,callback:e,cancelled:!1,cancel:function(){this.cancelled=!0;}};return vt.push(r),r}gt++;var n=!1,i=function(){if(!n)for(n=!0,gt--;vt.length&&gt<R.MAX_PARALLEL_IMAGE_REQUESTS;){var t=vt.shift();t.cancelled||(t.cancel=At(t.requestParameters,t.callback).cancel);}},a=bt(t,(function(t,r,n,a){i(),t?e(t):r&&(ft()?function(t,e){var r=new o.Blob([new Uint8Array(t)],{type:"image/png"});o.createImageBitmap(r).then((function(t){e(null,t);})).catch((function(t){e(new Error("Could not load image because of "+t.message+". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));}));}(r,e):function(t,e,r,n){var i=new o.Image,a=o.URL;i.onload=function(){e(null,i),a.revokeObjectURL(i.src),i.onload=null,o.requestAnimationFrame((function(){i.src=_t;}));},i.onerror=function(){return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))};var s=new o.Blob([new Uint8Array(t)],{type:"image/png"});i.cacheControl=r,i.expires=n,i.src=t.byteLength?a.createObjectURL(s):_t;}(r,e,n,a));}));return {cancel:function(){a.cancel(),i();}}};function St(t,e,r){r[t]&&-1!==r[t].indexOf(e)||(r[t]=r[t]||[],r[t].push(e));}function kt(t,e,r){if(r&&r[t]){var n=r[t].indexOf(e);-1!==n&&r[t].splice(n,1);}}var It=function(t,e){void 0===e&&(e={}),h(this,e),this.type=t;},zt=function(t){function e(e,r){void 0===r&&(r={}),t.call(this,"error",h({error:e},r));}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(It),Ct=function(){};Ct.prototype.on=function(t,e){return this._listeners=this._listeners||{},St(t,e,this._listeners),this},Ct.prototype.off=function(t,e){return kt(t,e,this._listeners),kt(t,e,this._oneTimeListeners),this},Ct.prototype.once=function(t,e){return this._oneTimeListeners=this._oneTimeListeners||{},St(t,e,this._oneTimeListeners),this},Ct.prototype.fire=function(t,e){"string"==typeof t&&(t=new It(t,e||{}));var r=t.type;if(this.listens(r)){t.target=this;for(var n=0,i=this._listeners&&this._listeners[r]?this._listeners[r].slice():[];n<i.length;n+=1)i[n].call(this,t);for(var a=0,o=this._oneTimeListeners&&this._oneTimeListeners[r]?this._oneTimeListeners[r].slice():[];a<o.length;a+=1){var s=o[a];kt(r,s,this._oneTimeListeners),s.call(this,t);}var u=this._eventedParent;u&&(h(t,"function"==typeof this._eventedParentData?this._eventedParentData():this._eventedParentData),u.fire(t));}else t instanceof zt&&console.error(t.error);return this},Ct.prototype.listens=function(t){return this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t)},Ct.prototype.setEventedParent=function(t,e){return this._eventedParent=t,this._eventedParentData=e,this};var Et={$version:8,$root:{version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},light:{type:"light"},sources:{required:!0,type:"sources"},sprite:{type:"string"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},sources:{"*":{type:"source"}},source:["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],source_vector:{type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},promoteId:{type:"promoteId"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},source_raster:{type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},source_raster_dem:{type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{}},default:"mapbox"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},source_geojson:{type:{required:!0,type:"enum",values:{geojson:{}}},data:{type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},filter:{type:"*"},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterMinPoints:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1},promoteId:{type:"promoteId"}},source_video:{type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},source_image:{type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},layer:{id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},layout:["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background"],layout_background:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_fill:{"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_circle:{"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_heatmap:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:{"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_symbol:{"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"resolvedImage",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_raster:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_hillshade:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},filter:{type:"array",value:"*"},filter_operator:{type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{},within:{}}},geometry_type:{type:"enum",values:{Point:{},LineString:{},Polygon:{}}},function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:{type:"array",minimum:0,maximum:24,value:["number","color"],length:2},expression:{type:"array",value:"*",minimum:1},light:{anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},paint:["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background"],paint_fill:{"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:{"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},paint_circle:{"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},paint_heatmap:{"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_symbol:{"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_raster:{"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_hillshade:{"hillshade-illumination-direction":{type:"number",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"color",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_background:{"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},transition:{duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}},promoteId:{"*":{type:"string"}}},Pt=function(t,e,r,n){this.message=(t?t+": ":"")+r,n&&(this.identifier=n),null!=e&&e.__line__&&(this.line=e.__line__);};function Mt(t){var e=t.value;return e?[new Pt(t.key,e,"constants have been deprecated as of v8")]:[]}function Bt(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];for(var n=0,i=e;n<i.length;n+=1){var a=i[n];for(var o in a)t[o]=a[o];}return t}function Tt(t){return t instanceof Number||t instanceof String||t instanceof Boolean?t.valueOf():t}function Vt(t){if(Array.isArray(t))return t.map(Vt);if(t instanceof Object&&!(t instanceof Number||t instanceof String||t instanceof Boolean)){var e={};for(var r in t)e[r]=Vt(t[r]);return e}return Tt(t)}var Ft=function(t){function e(e,r){t.call(this,r),this.message=r,this.key=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(Error),Dt=function(t,e){void 0===e&&(e=[]),this.parent=t,this.bindings={};for(var r=0,n=e;r<n.length;r+=1){var i=n[r];this.bindings[i[0]]=i[1];}};Dt.prototype.concat=function(t){return new Dt(this,t)},Dt.prototype.get=function(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error(t+" not found in scope.")},Dt.prototype.has=function(t){return !!this.bindings[t]||!!this.parent&&this.parent.has(t)};var Lt={kind:"null"},Ot={kind:"number"},Rt={kind:"string"},Ut={kind:"boolean"},jt={kind:"color"},qt={kind:"object"},Nt={kind:"value"},Kt={kind:"collator"},Gt={kind:"formatted"},Zt={kind:"resolvedImage"};function Xt(t,e){return {kind:"array",itemType:t,N:e}}function Jt(t){if("array"===t.kind){var e=Jt(t.itemType);return "number"==typeof t.N?"array<"+e+", "+t.N+">":"value"===t.itemType.kind?"array":"array<"+e+">"}return t.kind}var Ht=[Lt,Ot,Rt,Ut,jt,Gt,qt,Xt(Nt),Zt];function Yt(t,e){if("error"===e.kind)return null;if("array"===t.kind){if("array"===e.kind&&(0===e.N&&"value"===e.itemType.kind||!Yt(t.itemType,e.itemType))&&("number"!=typeof t.N||t.N===e.N))return null}else {if(t.kind===e.kind)return null;if("value"===t.kind)for(var r=0,n=Ht;r<n.length;r+=1)if(!Yt(n[r],e))return null}return "Expected "+Jt(t)+" but found "+Jt(e)+" instead."}function $t(t,e){return e.some((function(e){return e.kind===t.kind}))}function Wt(t,e){return e.some((function(e){return "null"===e?null===t:"array"===e?Array.isArray(t):"object"===e?t&&!Array.isArray(t)&&"object"==typeof t:e===typeof t}))}var Qt=e((function(t,e){var r={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function n(t){return (t=Math.round(t))<0?0:t>255?255:t}function i(t){return n("%"===t[t.length-1]?parseFloat(t)/100*255:parseInt(t))}function a(t){return (e="%"===t[t.length-1]?parseFloat(t)/100:parseFloat(t))<0?0:e>1?1:e;var e;}function o(t,e,r){return r<0?r+=1:r>1&&(r-=1),6*r<1?t+(e-t)*r*6:2*r<1?e:3*r<2?t+(e-t)*(2/3-r)*6:t}try{e.parseCSSColor=function(t){var e,s=t.replace(/ /g,"").toLowerCase();if(s in r)return r[s].slice();if("#"===s[0])return 4===s.length?(e=parseInt(s.substr(1),16))>=0&&e<=4095?[(3840&e)>>4|(3840&e)>>8,240&e|(240&e)>>4,15&e|(15&e)<<4,1]:null:7===s.length&&(e=parseInt(s.substr(1),16))>=0&&e<=16777215?[(16711680&e)>>16,(65280&e)>>8,255&e,1]:null;var u=s.indexOf("("),l=s.indexOf(")");if(-1!==u&&l+1===s.length){var p=s.substr(0,u),c=s.substr(u+1,l-(u+1)).split(","),h=1;switch(p){case"rgba":if(4!==c.length)return null;h=a(c.pop());case"rgb":return 3!==c.length?null:[i(c[0]),i(c[1]),i(c[2]),h];case"hsla":if(4!==c.length)return null;h=a(c.pop());case"hsl":if(3!==c.length)return null;var f=(parseFloat(c[0])%360+360)%360/360,y=a(c[1]),d=a(c[2]),m=d<=.5?d*(y+1):d+y-d*y,v=2*d-m;return [n(255*o(v,m,f+1/3)),n(255*o(v,m,f)),n(255*o(v,m,f-1/3)),h];default:return null}}return null};}catch(t){}})).parseCSSColor,te=function(t,e,r,n){void 0===n&&(n=1),this.r=t,this.g=e,this.b=r,this.a=n;};te.parse=function(t){if(t){if(t instanceof te)return t;if("string"==typeof t){var e=Qt(t);if(e)return new te(e[0]/255*e[3],e[1]/255*e[3],e[2]/255*e[3],e[3])}}},te.prototype.toString=function(){var t=this.toArray(),e=t[1],r=t[2],n=t[3];return "rgba("+Math.round(t[0])+","+Math.round(e)+","+Math.round(r)+","+n+")"},te.prototype.toArray=function(){var t=this.a;return 0===t?[0,0,0,0]:[255*this.r/t,255*this.g/t,255*this.b/t,t]},te.black=new te(0,0,0,1),te.white=new te(1,1,1,1),te.transparent=new te(0,0,0,0),te.red=new te(1,0,0,1);var ee=function(t,e,r){this.sensitivity=t?e?"variant":"case":e?"accent":"base",this.locale=r,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"});};ee.prototype.compare=function(t,e){return this.collator.compare(t,e)},ee.prototype.resolvedLocale=function(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale};var re=function(t,e,r,n,i){this.text=t,this.image=e,this.scale=r,this.fontStack=n,this.textColor=i;},ne=function(t){this.sections=t;};ne.fromString=function(t){return new ne([new re(t,null,null,null,null)])},ne.prototype.isEmpty=function(){return 0===this.sections.length||!this.sections.some((function(t){return 0!==t.text.length||t.image&&0!==t.image.name.length}))},ne.factory=function(t){return t instanceof ne?t:ne.fromString(t)},ne.prototype.toString=function(){return 0===this.sections.length?"":this.sections.map((function(t){return t.text})).join("")},ne.prototype.serialize=function(){for(var t=["format"],e=0,r=this.sections;e<r.length;e+=1){var n=r[e];if(n.image)t.push(["image",n.image.name]);else {t.push(n.text);var i={};n.fontStack&&(i["text-font"]=["literal",n.fontStack.split(",")]),n.scale&&(i["font-scale"]=n.scale),n.textColor&&(i["text-color"]=["rgba"].concat(n.textColor.toArray())),t.push(i);}}return t};var ie=function(t){this.name=t.name,this.available=t.available;};function ae(t,e,r,n){return "number"==typeof t&&t>=0&&t<=255&&"number"==typeof e&&e>=0&&e<=255&&"number"==typeof r&&r>=0&&r<=255?void 0===n||"number"==typeof n&&n>=0&&n<=1?null:"Invalid rgba value ["+[t,e,r,n].join(", ")+"]: 'a' must be between 0 and 1.":"Invalid rgba value ["+("number"==typeof n?[t,e,r,n]:[t,e,r]).join(", ")+"]: 'r', 'g', and 'b' must be between 0 and 255."}function oe(t){if(null===t)return !0;if("string"==typeof t)return !0;if("boolean"==typeof t)return !0;if("number"==typeof t)return !0;if(t instanceof te)return !0;if(t instanceof ee)return !0;if(t instanceof ne)return !0;if(t instanceof ie)return !0;if(Array.isArray(t)){for(var e=0,r=t;e<r.length;e+=1)if(!oe(r[e]))return !1;return !0}if("object"==typeof t){for(var n in t)if(!oe(t[n]))return !1;return !0}return !1}function se(t){if(null===t)return Lt;if("string"==typeof t)return Rt;if("boolean"==typeof t)return Ut;if("number"==typeof t)return Ot;if(t instanceof te)return jt;if(t instanceof ee)return Kt;if(t instanceof ne)return Gt;if(t instanceof ie)return Zt;if(Array.isArray(t)){for(var e,r=t.length,n=0,i=t;n<i.length;n+=1){var a=se(i[n]);if(e){if(e===a)continue;e=Nt;break}e=a;}return Xt(e||Nt,r)}return qt}function ue(t){var e=typeof t;return null===t?"":"string"===e||"number"===e||"boolean"===e?String(t):t instanceof te||t instanceof ne||t instanceof ie?t.toString():JSON.stringify(t)}ie.prototype.toString=function(){return this.name},ie.fromString=function(t){return t?new ie({name:t,available:!1}):null},ie.prototype.serialize=function(){return ["image",this.name]};var le=function(t,e){this.type=t,this.value=e;};le.parse=function(t,e){if(2!==t.length)return e.error("'literal' expression requires exactly one argument, but found "+(t.length-1)+" instead.");if(!oe(t[1]))return e.error("invalid value");var r=t[1],n=se(r),i=e.expectedType;return "array"!==n.kind||0!==n.N||!i||"array"!==i.kind||"number"==typeof i.N&&0!==i.N||(n=i),new le(n,r)},le.prototype.evaluate=function(){return this.value},le.prototype.eachChild=function(){},le.prototype.outputDefined=function(){return !0},le.prototype.serialize=function(){return "array"===this.type.kind||"object"===this.type.kind?["literal",this.value]:this.value instanceof te?["rgba"].concat(this.value.toArray()):this.value instanceof ne?this.value.serialize():this.value};var pe=function(t){this.name="ExpressionEvaluationError",this.message=t;};pe.prototype.toJSON=function(){return this.message};var ce={string:Rt,number:Ot,boolean:Ut,object:qt},he=function(t,e){this.type=t,this.args=e;};he.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r,n=1,i=t[0];if("array"===i){var a,o;if(t.length>2){var s=t[1];if("string"!=typeof s||!(s in ce)||"object"===s)return e.error('The item type argument of "array" must be one of string, number, boolean',1);a=ce[s],n++;}else a=Nt;if(t.length>3){if(null!==t[2]&&("number"!=typeof t[2]||t[2]<0||t[2]!==Math.floor(t[2])))return e.error('The length argument to "array" must be a positive integer literal',2);o=t[2],n++;}r=Xt(a,o);}else r=ce[i];for(var u=[];n<t.length;n++){var l=e.parse(t[n],n,Nt);if(!l)return null;u.push(l);}return new he(r,u)},he.prototype.evaluate=function(t){for(var e=0;e<this.args.length;e++){var r=this.args[e].evaluate(t);if(!Yt(this.type,se(r)))return r;if(e===this.args.length-1)throw new pe("Expected value to be of type "+Jt(this.type)+", but found "+Jt(se(r))+" instead.")}return null},he.prototype.eachChild=function(t){this.args.forEach(t);},he.prototype.outputDefined=function(){return this.args.every((function(t){return t.outputDefined()}))},he.prototype.serialize=function(){var t=this.type,e=[t.kind];if("array"===t.kind){var r=t.itemType;if("string"===r.kind||"number"===r.kind||"boolean"===r.kind){e.push(r.kind);var n=t.N;("number"==typeof n||this.args.length>1)&&e.push(n);}}return e.concat(this.args.map((function(t){return t.serialize()})))};var fe=function(t){this.type=Gt,this.sections=t;};fe.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r=t[1];if(!Array.isArray(r)&&"object"==typeof r)return e.error("First argument must be an image or text section.");for(var n=[],i=!1,a=1;a<=t.length-1;++a){var o=t[a];if(i&&"object"==typeof o&&!Array.isArray(o)){i=!1;var s=null;if(o["font-scale"]&&!(s=e.parse(o["font-scale"],1,Ot)))return null;var u=null;if(o["text-font"]&&!(u=e.parse(o["text-font"],1,Xt(Rt))))return null;var l=null;if(o["text-color"]&&!(l=e.parse(o["text-color"],1,jt)))return null;var p=n[n.length-1];p.scale=s,p.font=u,p.textColor=l;}else {var c=e.parse(t[a],1,Nt);if(!c)return null;var h=c.type.kind;if("string"!==h&&"value"!==h&&"null"!==h&&"resolvedImage"!==h)return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");i=!0,n.push({content:c,scale:null,font:null,textColor:null});}}return new fe(n)},fe.prototype.evaluate=function(t){return new ne(this.sections.map((function(e){var r=e.content.evaluate(t);return se(r)===Zt?new re("",r,null,null,null):new re(ue(r),null,e.scale?e.scale.evaluate(t):null,e.font?e.font.evaluate(t).join(","):null,e.textColor?e.textColor.evaluate(t):null)})))},fe.prototype.eachChild=function(t){for(var e=0,r=this.sections;e<r.length;e+=1){var n=r[e];t(n.content),n.scale&&t(n.scale),n.font&&t(n.font),n.textColor&&t(n.textColor);}},fe.prototype.outputDefined=function(){return !1},fe.prototype.serialize=function(){for(var t=["format"],e=0,r=this.sections;e<r.length;e+=1){var n=r[e];t.push(n.content.serialize());var i={};n.scale&&(i["font-scale"]=n.scale.serialize()),n.font&&(i["text-font"]=n.font.serialize()),n.textColor&&(i["text-color"]=n.textColor.serialize()),t.push(i);}return t};var ye=function(t){this.type=Zt,this.input=t;};ye.parse=function(t,e){if(2!==t.length)return e.error("Expected two arguments.");var r=e.parse(t[1],1,Rt);return r?new ye(r):e.error("No image name provided.")},ye.prototype.evaluate=function(t){var e=this.input.evaluate(t),r=ie.fromString(e);return r&&t.availableImages&&(r.available=t.availableImages.indexOf(e)>-1),r},ye.prototype.eachChild=function(t){t(this.input);},ye.prototype.outputDefined=function(){return !1},ye.prototype.serialize=function(){return ["image",this.input.serialize()]};var de={"to-boolean":Ut,"to-color":jt,"to-number":Ot,"to-string":Rt},me=function(t,e){this.type=t,this.args=e;};me.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r=t[0];if(("to-boolean"===r||"to-string"===r)&&2!==t.length)return e.error("Expected one argument.");for(var n=de[r],i=[],a=1;a<t.length;a++){var o=e.parse(t[a],a,Nt);if(!o)return null;i.push(o);}return new me(n,i)},me.prototype.evaluate=function(t){if("boolean"===this.type.kind)return Boolean(this.args[0].evaluate(t));if("color"===this.type.kind){for(var e,r,n=0,i=this.args;n<i.length;n+=1){if(r=null,(e=i[n].evaluate(t))instanceof te)return e;if("string"==typeof e){var a=t.parseColor(e);if(a)return a}else if(Array.isArray(e)&&!(r=e.length<3||e.length>4?"Invalid rbga value "+JSON.stringify(e)+": expected an array containing either three or four numeric values.":ae(e[0],e[1],e[2],e[3])))return new te(e[0]/255,e[1]/255,e[2]/255,e[3])}throw new pe(r||"Could not parse color from value '"+("string"==typeof e?e:String(JSON.stringify(e)))+"'")}if("number"===this.type.kind){for(var o=null,s=0,u=this.args;s<u.length;s+=1){if(null===(o=u[s].evaluate(t)))return 0;var l=Number(o);if(!isNaN(l))return l}throw new pe("Could not convert "+JSON.stringify(o)+" to number.")}return "formatted"===this.type.kind?ne.fromString(ue(this.args[0].evaluate(t))):"resolvedImage"===this.type.kind?ie.fromString(ue(this.args[0].evaluate(t))):ue(this.args[0].evaluate(t))},me.prototype.eachChild=function(t){this.args.forEach(t);},me.prototype.outputDefined=function(){return this.args.every((function(t){return t.outputDefined()}))},me.prototype.serialize=function(){if("formatted"===this.type.kind)return new fe([{content:this.args[0],scale:null,font:null,textColor:null}]).serialize();if("resolvedImage"===this.type.kind)return new ye(this.args[0]).serialize();var t=["to-"+this.type.kind];return this.eachChild((function(e){t.push(e.serialize());})),t};var ve=["Unknown","Point","LineString","Polygon"],ge=function(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null;};ge.prototype.id=function(){return this.feature&&"id"in this.feature?this.feature.id:null},ge.prototype.geometryType=function(){return this.feature?"number"==typeof this.feature.type?ve[this.feature.type]:this.feature.type:null},ge.prototype.geometry=function(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null},ge.prototype.canonicalID=function(){return this.canonical},ge.prototype.properties=function(){return this.feature&&this.feature.properties||{}},ge.prototype.parseColor=function(t){var e=this._parseColorCache[t];return e||(e=this._parseColorCache[t]=te.parse(t)),e};var xe=function(t,e,r,n){this.name=t,this.type=e,this._evaluate=r,this.args=n;};xe.prototype.evaluate=function(t){return this._evaluate(t,this.args)},xe.prototype.eachChild=function(t){this.args.forEach(t);},xe.prototype.outputDefined=function(){return !1},xe.prototype.serialize=function(){return [this.name].concat(this.args.map((function(t){return t.serialize()})))},xe.parse=function(t,e){var r,n=t[0],i=xe.definitions[n];if(!i)return e.error('Unknown expression "'+n+'". If you wanted a literal array, use ["literal", [...]].',0);for(var a=Array.isArray(i)?i[0]:i.type,o=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=o.filter((function(e){var r=e[0];return !Array.isArray(r)||r.length===t.length-1})),u=null,l=0,p=s;l<p.length;l+=1){var c=p[l],h=c[0],f=c[1];u=new je(e.registry,e.path,null,e.scope);for(var y=[],d=!1,m=1;m<t.length;m++){var v=t[m],g=Array.isArray(h)?h[m-1]:h.type,x=u.parse(v,1+y.length,g);if(!x){d=!0;break}y.push(x);}if(!d)if(Array.isArray(h)&&h.length!==y.length)u.error("Expected "+h.length+" arguments, but found "+y.length+" instead.");else {for(var b=0;b<y.length;b++){var w=Array.isArray(h)?h[b]:h.type,_=y[b];u.concat(b+1).checkSubtype(w,_.type);}if(0===u.errors.length)return new xe(n,a,f,y)}}if(1===s.length)(r=e.errors).push.apply(r,u.errors);else {for(var A=(s.length?s:o).map((function(t){var e;return e=t[0],Array.isArray(e)?"("+e.map(Jt).join(", ")+")":"("+Jt(e.type)+"...)"})).join(" | "),S=[],k=1;k<t.length;k++){var I=e.parse(t[k],1+S.length);if(!I)return null;S.push(Jt(I.type));}e.error("Expected arguments of type "+A+", but found ("+S.join(", ")+") instead.");}return null},xe.register=function(t,e){for(var r in xe.definitions=e,e)t[r]=xe;};var be=function(t,e,r){this.type=Kt,this.locale=r,this.caseSensitive=t,this.diacriticSensitive=e;};function we(t,e){t[0]=Math.min(t[0],e[0]),t[1]=Math.min(t[1],e[1]),t[2]=Math.max(t[2],e[0]),t[3]=Math.max(t[3],e[1]);}function _e(t,e){return !(t[0]<=e[0]||t[2]>=e[2]||t[1]<=e[1]||t[3]>=e[3])}function Ae(t,e){var r=(180+t[0])/360,n=(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t[1]*Math.PI/360)))/360,i=Math.pow(2,e.z);return [Math.round(r*i*8192),Math.round(n*i*8192)]}function Se(t,e,r){return e[1]>t[1]!=r[1]>t[1]&&t[0]<(r[0]-e[0])*(t[1]-e[1])/(r[1]-e[1])+e[0]}function ke(t,e){for(var r,n,i,a,o,s,u,l=!1,p=0,c=e.length;p<c;p++)for(var h=e[p],f=0,y=h.length;f<y-1;f++){if((a=(r=t)[0]-(n=h[f])[0])*(u=r[1]-(i=h[f+1])[1])-(s=r[0]-i[0])*(o=r[1]-n[1])==0&&a*s<=0&&o*u<=0)return !1;Se(t,h[f],h[f+1])&&(l=!l);}return l}function Ie(t,e){for(var r=0;r<e.length;r++)if(ke(t,e[r]))return !0;return !1}function ze(t,e,r,n){var i=n[0]-r[0],a=n[1]-r[1],o=(t[0]-r[0])*a-i*(t[1]-r[1]),s=(e[0]-r[0])*a-i*(e[1]-r[1]);return o>0&&s<0||o<0&&s>0}function Ce(t,e,r){for(var n=0,i=r;n<i.length;n+=1)for(var a=i[n],o=0;o<a.length-1;++o)if(0!=(c=[(p=a[o+1])[0]-(l=a[o])[0],p[1]-l[1]])[0]*(h=[(u=e)[0]-(s=t)[0],u[1]-s[1]])[1]-c[1]*h[0]&&ze(s,u,l,p)&&ze(l,p,s,u))return !0;var s,u,l,p,c,h;return !1}function Ee(t,e){for(var r=0;r<t.length;++r)if(!ke(t[r],e))return !1;for(var n=0;n<t.length-1;++n)if(Ce(t[n],t[n+1],e))return !1;return !0}function Pe(t,e){for(var r=0;r<e.length;r++)if(Ee(t,e[r]))return !0;return !1}function Me(t,e,r){for(var n=[],i=0;i<t.length;i++){for(var a=[],o=0;o<t[i].length;o++){var s=Ae(t[i][o],r);we(e,s),a.push(s);}n.push(a);}return n}function Be(t,e,r){for(var n=[],i=0;i<t.length;i++){var a=Me(t[i],e,r);n.push(a);}return n}function Te(t,e,r,n){if(t[0]<r[0]||t[0]>r[2]){var i=.5*n,a=t[0]-r[0]>i?-n:r[0]-t[0]>i?n:0;0===a&&(a=t[0]-r[2]>i?-n:r[2]-t[0]>i?n:0),t[0]+=a;}we(e,t);}function Ve(t,e,r,n){for(var i=8192*Math.pow(2,n.z),a=[8192*n.x,8192*n.y],o=[],s=0,u=t;s<u.length;s+=1)for(var l=0,p=u[s];l<p.length;l+=1){var c=p[l],h=[c.x+a[0],c.y+a[1]];Te(h,e,r,i),o.push(h);}return o}function Fe(t,e,r,n){for(var i,a=8192*Math.pow(2,n.z),o=[8192*n.x,8192*n.y],s=[],u=0,l=t;u<l.length;u+=1){for(var p=[],c=0,h=l[u];c<h.length;c+=1){var f=h[c],y=[f.x+o[0],f.y+o[1]];we(e,y),p.push(y);}s.push(p);}if(e[2]-e[0]<=a/2){(i=e)[0]=i[1]=1/0,i[2]=i[3]=-1/0;for(var d=0,m=s;d<m.length;d+=1)for(var v=0,g=m[d];v<g.length;v+=1)Te(g[v],e,r,a);}return s}be.parse=function(t,e){if(2!==t.length)return e.error("Expected one argument.");var r=t[1];if("object"!=typeof r||Array.isArray(r))return e.error("Collator options argument must be an object.");var n=e.parse(void 0!==r["case-sensitive"]&&r["case-sensitive"],1,Ut);if(!n)return null;var i=e.parse(void 0!==r["diacritic-sensitive"]&&r["diacritic-sensitive"],1,Ut);if(!i)return null;var a=null;return r.locale&&!(a=e.parse(r.locale,1,Rt))?null:new be(n,i,a)},be.prototype.evaluate=function(t){return new ee(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)},be.prototype.eachChild=function(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale);},be.prototype.outputDefined=function(){return !1},be.prototype.serialize=function(){var t={};return t["case-sensitive"]=this.caseSensitive.serialize(),t["diacritic-sensitive"]=this.diacriticSensitive.serialize(),this.locale&&(t.locale=this.locale.serialize()),["collator",t]};var De=function(t,e){this.type=Ut,this.geojson=t,this.geometries=e;};function Le(t){if(t instanceof xe){if("get"===t.name&&1===t.args.length)return !1;if("feature-state"===t.name)return !1;if("has"===t.name&&1===t.args.length)return !1;if("properties"===t.name||"geometry-type"===t.name||"id"===t.name)return !1;if(/^filter-/.test(t.name))return !1}if(t instanceof De)return !1;var e=!0;return t.eachChild((function(t){e&&!Le(t)&&(e=!1);})),e}function Oe(t){if(t instanceof xe&&"feature-state"===t.name)return !1;var e=!0;return t.eachChild((function(t){e&&!Oe(t)&&(e=!1);})),e}function Re(t,e){if(t instanceof xe&&e.indexOf(t.name)>=0)return !1;var r=!0;return t.eachChild((function(t){r&&!Re(t,e)&&(r=!1);})),r}De.parse=function(t,e){if(2!==t.length)return e.error("'within' expression requires exactly one argument, but found "+(t.length-1)+" instead.");if(oe(t[1])){var r=t[1];if("FeatureCollection"===r.type)for(var n=0;n<r.features.length;++n){var i=r.features[n].geometry.type;if("Polygon"===i||"MultiPolygon"===i)return new De(r,r.features[n].geometry)}else if("Feature"===r.type){var a=r.geometry.type;if("Polygon"===a||"MultiPolygon"===a)return new De(r,r.geometry)}else if("Polygon"===r.type||"MultiPolygon"===r.type)return new De(r,r)}return e.error("'within' expression requires valid geojson object that contains polygon geometry type.")},De.prototype.evaluate=function(t){if(null!=t.geometry()&&null!=t.canonicalID()){if("Point"===t.geometryType())return function(t,e){var r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if("Polygon"===e.type){var a=Me(e.coordinates,n,i),o=Ve(t.geometry(),r,n,i);if(!_e(r,n))return !1;for(var s=0,u=o;s<u.length;s+=1)if(!ke(u[s],a))return !1}if("MultiPolygon"===e.type){var l=Be(e.coordinates,n,i),p=Ve(t.geometry(),r,n,i);if(!_e(r,n))return !1;for(var c=0,h=p;c<h.length;c+=1)if(!Ie(h[c],l))return !1}return !0}(t,this.geometries);if("LineString"===t.geometryType())return function(t,e){var r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if("Polygon"===e.type){var a=Me(e.coordinates,n,i),o=Fe(t.geometry(),r,n,i);if(!_e(r,n))return !1;for(var s=0,u=o;s<u.length;s+=1)if(!Ee(u[s],a))return !1}if("MultiPolygon"===e.type){var l=Be(e.coordinates,n,i),p=Fe(t.geometry(),r,n,i);if(!_e(r,n))return !1;for(var c=0,h=p;c<h.length;c+=1)if(!Pe(h[c],l))return !1}return !0}(t,this.geometries)}return !1},De.prototype.eachChild=function(){},De.prototype.outputDefined=function(){return !0},De.prototype.serialize=function(){return ["within",this.geojson]};var Ue=function(t,e){this.type=e.type,this.name=t,this.boundExpression=e;};Ue.parse=function(t,e){if(2!==t.length||"string"!=typeof t[1])return e.error("'var' expression requires exactly one string literal argument.");var r=t[1];return e.scope.has(r)?new Ue(r,e.scope.get(r)):e.error('Unknown variable "'+r+'". Make sure "'+r+'" has been bound in an enclosing "let" expression before using it.',1)},Ue.prototype.evaluate=function(t){return this.boundExpression.evaluate(t)},Ue.prototype.eachChild=function(){},Ue.prototype.outputDefined=function(){return !1},Ue.prototype.serialize=function(){return ["var",this.name]};var je=function(t,e,r,n,i){void 0===e&&(e=[]),void 0===n&&(n=new Dt),void 0===i&&(i=[]),this.registry=t,this.path=e,this.key=e.map((function(t){return "["+t+"]"})).join(""),this.scope=n,this.errors=i,this.expectedType=r;};function qe(t,e){for(var r,n=t.length-1,i=0,a=n,o=0;i<=a;)if((r=t[o=Math.floor((i+a)/2)])<=e){if(o===n||e<t[o+1])return o;i=o+1;}else {if(!(r>e))throw new pe("Input is not a number.");a=o-1;}return 0}je.prototype.parse=function(t,e,r,n,i){return void 0===i&&(i={}),e?this.concat(e,r,n)._parse(t,i):this._parse(t,i)},je.prototype._parse=function(t,e){function r(t,e,r){return "assert"===r?new he(e,[t]):"coerce"===r?new me(e,[t]):t}if(null!==t&&"string"!=typeof t&&"boolean"!=typeof t&&"number"!=typeof t||(t=["literal",t]),Array.isArray(t)){if(0===t.length)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');var n=t[0];if("string"!=typeof n)return this.error("Expression name must be a string, but found "+typeof n+' instead. If you wanted a literal array, use ["literal", [...]].',0),null;var i=this.registry[n];if(i){var a=i.parse(t,this);if(!a)return null;if(this.expectedType){var o=this.expectedType,s=a.type;if("string"!==o.kind&&"number"!==o.kind&&"boolean"!==o.kind&&"object"!==o.kind&&"array"!==o.kind||"value"!==s.kind)if("color"!==o.kind&&"formatted"!==o.kind&&"resolvedImage"!==o.kind||"value"!==s.kind&&"string"!==s.kind){if(this.checkSubtype(o,s))return null}else a=r(a,o,e.typeAnnotation||"coerce");else a=r(a,o,e.typeAnnotation||"assert");}if(!(a instanceof le)&&"resolvedImage"!==a.type.kind&&function t(e){if(e instanceof Ue)return t(e.boundExpression);if(e instanceof xe&&"error"===e.name)return !1;if(e instanceof be)return !1;if(e instanceof De)return !1;var r=e instanceof me||e instanceof he,n=!0;return e.eachChild((function(e){n=r?n&&t(e):n&&e instanceof le;})),!!n&&Le(e)&&Re(e,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"])}(a)){var u=new ge;try{a=new le(a.type,a.evaluate(u));}catch(t){return this.error(t.message),null}}return a}return this.error('Unknown expression "'+n+'". If you wanted a literal array, use ["literal", [...]].',0)}return this.error(void 0===t?"'undefined' value invalid. Use null instead.":"object"==typeof t?'Bare objects invalid. Use ["literal", {...}] instead.':"Expected an array, but found "+typeof t+" instead.")},je.prototype.concat=function(t,e,r){var n="number"==typeof t?this.path.concat(t):this.path,i=r?this.scope.concat(r):this.scope;return new je(this.registry,n,e||null,i,this.errors)},je.prototype.error=function(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];var n=""+this.key+e.map((function(t){return "["+t+"]"})).join("");this.errors.push(new Ft(n,t));},je.prototype.checkSubtype=function(t,e){var r=Yt(t,e);return r&&this.error(r),r};var Ne=function(t,e,r){this.type=t,this.input=e,this.labels=[],this.outputs=[];for(var n=0,i=r;n<i.length;n+=1){var a=i[n],o=a[1];this.labels.push(a[0]),this.outputs.push(o);}};function Ke(t,e,r){return t*(1-r)+e*r}Ne.parse=function(t,e){if(t.length-1<4)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");var r=e.parse(t[1],1,Ot);if(!r)return null;var n=[],i=null;e.expectedType&&"value"!==e.expectedType.kind&&(i=e.expectedType);for(var a=1;a<t.length;a+=2){var o=1===a?-1/0:t[a],s=t[a+1],u=a,l=a+1;if("number"!=typeof o)return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',u);if(n.length&&n[n.length-1][0]>=o)return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',u);var p=e.parse(s,l,i);if(!p)return null;i=i||p.type,n.push([o,p]);}return new Ne(i,r,n)},Ne.prototype.evaluate=function(t){var e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);var n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);var i=e.length;return n>=e[i-1]?r[i-1].evaluate(t):r[qe(e,n)].evaluate(t)},Ne.prototype.eachChild=function(t){t(this.input);for(var e=0,r=this.outputs;e<r.length;e+=1)t(r[e]);},Ne.prototype.outputDefined=function(){return this.outputs.every((function(t){return t.outputDefined()}))},Ne.prototype.serialize=function(){for(var t=["step",this.input.serialize()],e=0;e<this.labels.length;e++)e>0&&t.push(this.labels[e]),t.push(this.outputs[e].serialize());return t};var Ge=Object.freeze({__proto__:null,number:Ke,color:function(t,e,r){return new te(Ke(t.r,e.r,r),Ke(t.g,e.g,r),Ke(t.b,e.b,r),Ke(t.a,e.a,r))},array:function(t,e,r){return t.map((function(t,n){return Ke(t,e[n],r)}))}}),Ze=6/29*3*(6/29),Xe=Math.PI/180,Je=180/Math.PI;function He(t){return t>.008856451679035631?Math.pow(t,1/3):t/Ze+4/29}function Ye(t){return t>6/29?t*t*t:Ze*(t-4/29)}function $e(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function We(t){return (t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function Qe(t){var e=We(t.r),r=We(t.g),n=We(t.b),i=He((.4124564*e+.3575761*r+.1804375*n)/.95047),a=He((.2126729*e+.7151522*r+.072175*n)/1);return {l:116*a-16,a:500*(i-a),b:200*(a-He((.0193339*e+.119192*r+.9503041*n)/1.08883)),alpha:t.a}}function tr(t){var e=(t.l+16)/116,r=isNaN(t.a)?e:e+t.a/500,n=isNaN(t.b)?e:e-t.b/200;return e=1*Ye(e),r=.95047*Ye(r),n=1.08883*Ye(n),new te($e(3.2404542*r-1.5371385*e-.4985314*n),$e(-.969266*r+1.8760108*e+.041556*n),$e(.0556434*r-.2040259*e+1.0572252*n),t.alpha)}function er(t,e,r){var n=e-t;return t+r*(n>180||n<-180?n-360*Math.round(n/360):n)}var rr={forward:Qe,reverse:tr,interpolate:function(t,e,r){return {l:Ke(t.l,e.l,r),a:Ke(t.a,e.a,r),b:Ke(t.b,e.b,r),alpha:Ke(t.alpha,e.alpha,r)}}},nr={forward:function(t){var e=Qe(t),r=e.l,n=e.a,i=e.b,a=Math.atan2(i,n)*Je;return {h:a<0?a+360:a,c:Math.sqrt(n*n+i*i),l:r,alpha:t.a}},reverse:function(t){var e=t.h*Xe,r=t.c;return tr({l:t.l,a:Math.cos(e)*r,b:Math.sin(e)*r,alpha:t.alpha})},interpolate:function(t,e,r){return {h:er(t.h,e.h,r),c:Ke(t.c,e.c,r),l:Ke(t.l,e.l,r),alpha:Ke(t.alpha,e.alpha,r)}}},ir=Object.freeze({__proto__:null,lab:rr,hcl:nr}),ar=function(t,e,r,n,i){this.type=t,this.operator=e,this.interpolation=r,this.input=n,this.labels=[],this.outputs=[];for(var a=0,o=i;a<o.length;a+=1){var s=o[a],u=s[1];this.labels.push(s[0]),this.outputs.push(u);}};function or(t,e,r,n){var i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}ar.interpolationFactor=function(t,e,n,i){var a=0;if("exponential"===t.name)a=or(e,t.base,n,i);else if("linear"===t.name)a=or(e,1,n,i);else if("cubic-bezier"===t.name){var o=t.controlPoints;a=new r(o[0],o[1],o[2],o[3]).solve(or(e,1,n,i));}return a},ar.parse=function(t,e){var r=t[0],n=t[1],i=t[2],a=t.slice(3);if(!Array.isArray(n)||0===n.length)return e.error("Expected an interpolation type expression.",1);if("linear"===n[0])n={name:"linear"};else if("exponential"===n[0]){var o=n[1];if("number"!=typeof o)return e.error("Exponential interpolation requires a numeric base.",1,1);n={name:"exponential",base:o};}else {if("cubic-bezier"!==n[0])return e.error("Unknown interpolation type "+String(n[0]),1,0);var s=n.slice(1);if(4!==s.length||s.some((function(t){return "number"!=typeof t||t<0||t>1})))return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);n={name:"cubic-bezier",controlPoints:s};}if(t.length-1<4)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");if(!(i=e.parse(i,2,Ot)))return null;var u=[],l=null;"interpolate-hcl"===r||"interpolate-lab"===r?l=jt:e.expectedType&&"value"!==e.expectedType.kind&&(l=e.expectedType);for(var p=0;p<a.length;p+=2){var c=a[p],h=a[p+1],f=p+3,y=p+4;if("number"!=typeof c)return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',f);if(u.length&&u[u.length-1][0]>=c)return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',f);var d=e.parse(h,y,l);if(!d)return null;l=l||d.type,u.push([c,d]);}return "number"===l.kind||"color"===l.kind||"array"===l.kind&&"number"===l.itemType.kind&&"number"==typeof l.N?new ar(l,r,n,i,u):e.error("Type "+Jt(l)+" is not interpolatable.")},ar.prototype.evaluate=function(t){var e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);var n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);var i=e.length;if(n>=e[i-1])return r[i-1].evaluate(t);var a=qe(e,n),o=ar.interpolationFactor(this.interpolation,n,e[a],e[a+1]),s=r[a].evaluate(t),u=r[a+1].evaluate(t);return "interpolate"===this.operator?Ge[this.type.kind.toLowerCase()](s,u,o):"interpolate-hcl"===this.operator?nr.reverse(nr.interpolate(nr.forward(s),nr.forward(u),o)):rr.reverse(rr.interpolate(rr.forward(s),rr.forward(u),o))},ar.prototype.eachChild=function(t){t(this.input);for(var e=0,r=this.outputs;e<r.length;e+=1)t(r[e]);},ar.prototype.outputDefined=function(){return this.outputs.every((function(t){return t.outputDefined()}))},ar.prototype.serialize=function(){var t;t="linear"===this.interpolation.name?["linear"]:"exponential"===this.interpolation.name?1===this.interpolation.base?["linear"]:["exponential",this.interpolation.base]:["cubic-bezier"].concat(this.interpolation.controlPoints);for(var e=[this.operator,t,this.input.serialize()],r=0;r<this.labels.length;r++)e.push(this.labels[r],this.outputs[r].serialize());return e};var sr=function(t,e){this.type=t,this.args=e;};sr.parse=function(t,e){if(t.length<2)return e.error("Expectected at least one argument.");var r=null,n=e.expectedType;n&&"value"!==n.kind&&(r=n);for(var i=[],a=0,o=t.slice(1);a<o.length;a+=1){var s=e.parse(o[a],1+i.length,r,void 0,{typeAnnotation:"omit"});if(!s)return null;r=r||s.type,i.push(s);}var u=n&&i.some((function(t){return Yt(n,t.type)}));return new sr(u?Nt:r,i)},sr.prototype.evaluate=function(t){for(var e,r=null,n=0,i=0,a=this.args;i<a.length&&(n++,(r=a[i].evaluate(t))&&r instanceof ie&&!r.available&&(e||(e=r.name),r=null,n===this.args.length&&(r=e)),null===r);i+=1);return r},sr.prototype.eachChild=function(t){this.args.forEach(t);},sr.prototype.outputDefined=function(){return this.args.every((function(t){return t.outputDefined()}))},sr.prototype.serialize=function(){var t=["coalesce"];return this.eachChild((function(e){t.push(e.serialize());})),t};var ur=function(t,e){this.type=e.type,this.bindings=[].concat(t),this.result=e;};ur.prototype.evaluate=function(t){return this.result.evaluate(t)},ur.prototype.eachChild=function(t){for(var e=0,r=this.bindings;e<r.length;e+=1)t(r[e][1]);t(this.result);},ur.parse=function(t,e){if(t.length<4)return e.error("Expected at least 3 arguments, but found "+(t.length-1)+" instead.");for(var r=[],n=1;n<t.length-1;n+=2){var i=t[n];if("string"!=typeof i)return e.error("Expected string, but found "+typeof i+" instead.",n);if(/[^a-zA-Z0-9_]/.test(i))return e.error("Variable names must contain only alphanumeric characters or '_'.",n);var a=e.parse(t[n+1],n+1);if(!a)return null;r.push([i,a]);}var o=e.parse(t[t.length-1],t.length-1,e.expectedType,r);return o?new ur(r,o):null},ur.prototype.outputDefined=function(){return this.result.outputDefined()},ur.prototype.serialize=function(){for(var t=["let"],e=0,r=this.bindings;e<r.length;e+=1){var n=r[e];t.push(n[0],n[1].serialize());}return t.push(this.result.serialize()),t};var lr=function(t,e,r){this.type=t,this.index=e,this.input=r;};lr.parse=function(t,e){if(3!==t.length)return e.error("Expected 2 arguments, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1,Ot),n=e.parse(t[2],2,Xt(e.expectedType||Nt));return r&&n?new lr(n.type.itemType,r,n):null},lr.prototype.evaluate=function(t){var e=this.index.evaluate(t),r=this.input.evaluate(t);if(e<0)throw new pe("Array index out of bounds: "+e+" < 0.");if(e>=r.length)throw new pe("Array index out of bounds: "+e+" > "+(r.length-1)+".");if(e!==Math.floor(e))throw new pe("Array index must be an integer, but found "+e+" instead.");return r[e]},lr.prototype.eachChild=function(t){t(this.index),t(this.input);},lr.prototype.outputDefined=function(){return !1},lr.prototype.serialize=function(){return ["at",this.index.serialize(),this.input.serialize()]};var pr=function(t,e){this.type=Ut,this.needle=t,this.haystack=e;};pr.parse=function(t,e){if(3!==t.length)return e.error("Expected 2 arguments, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1,Nt),n=e.parse(t[2],2,Nt);return r&&n?$t(r.type,[Ut,Rt,Ot,Lt,Nt])?new pr(r,n):e.error("Expected first argument to be of type boolean, string, number or null, but found "+Jt(r.type)+" instead"):null},pr.prototype.evaluate=function(t){var e=this.needle.evaluate(t),r=this.haystack.evaluate(t);if(!r)return !1;if(!Wt(e,["boolean","string","number","null"]))throw new pe("Expected first argument to be of type boolean, string, number or null, but found "+Jt(se(e))+" instead.");if(!Wt(r,["string","array"]))throw new pe("Expected second argument to be of type array or string, but found "+Jt(se(r))+" instead.");return r.indexOf(e)>=0},pr.prototype.eachChild=function(t){t(this.needle),t(this.haystack);},pr.prototype.outputDefined=function(){return !0},pr.prototype.serialize=function(){return ["in",this.needle.serialize(),this.haystack.serialize()]};var cr=function(t,e,r){this.type=Ot,this.needle=t,this.haystack=e,this.fromIndex=r;};cr.parse=function(t,e){if(t.length<=2||t.length>=5)return e.error("Expected 3 or 4 arguments, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1,Nt),n=e.parse(t[2],2,Nt);if(!r||!n)return null;if(!$t(r.type,[Ut,Rt,Ot,Lt,Nt]))return e.error("Expected first argument to be of type boolean, string, number or null, but found "+Jt(r.type)+" instead");if(4===t.length){var i=e.parse(t[3],3,Ot);return i?new cr(r,n,i):null}return new cr(r,n)},cr.prototype.evaluate=function(t){var e=this.needle.evaluate(t),r=this.haystack.evaluate(t);if(!Wt(e,["boolean","string","number","null"]))throw new pe("Expected first argument to be of type boolean, string, number or null, but found "+Jt(se(e))+" instead.");if(!Wt(r,["string","array"]))throw new pe("Expected second argument to be of type array or string, but found "+Jt(se(r))+" instead.");if(this.fromIndex){var n=this.fromIndex.evaluate(t);return r.indexOf(e,n)}return r.indexOf(e)},cr.prototype.eachChild=function(t){t(this.needle),t(this.haystack),this.fromIndex&&t(this.fromIndex);},cr.prototype.outputDefined=function(){return !1},cr.prototype.serialize=function(){if(null!=this.fromIndex&&void 0!==this.fromIndex){var t=this.fromIndex.serialize();return ["index-of",this.needle.serialize(),this.haystack.serialize(),t]}return ["index-of",this.needle.serialize(),this.haystack.serialize()]};var hr=function(t,e,r,n,i,a){this.inputType=t,this.type=e,this.input=r,this.cases=n,this.outputs=i,this.otherwise=a;};hr.parse=function(t,e){if(t.length<5)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if(t.length%2!=1)return e.error("Expected an even number of arguments.");var r,n;e.expectedType&&"value"!==e.expectedType.kind&&(n=e.expectedType);for(var i={},a=[],o=2;o<t.length-1;o+=2){var s=t[o],u=t[o+1];Array.isArray(s)||(s=[s]);var l=e.concat(o);if(0===s.length)return l.error("Expected at least one branch label.");for(var p=0,c=s;p<c.length;p+=1){var h=c[p];if("number"!=typeof h&&"string"!=typeof h)return l.error("Branch labels must be numbers or strings.");if("number"==typeof h&&Math.abs(h)>Number.MAX_SAFE_INTEGER)return l.error("Branch labels must be integers no larger than "+Number.MAX_SAFE_INTEGER+".");if("number"==typeof h&&Math.floor(h)!==h)return l.error("Numeric branch labels must be integer values.");if(r){if(l.checkSubtype(r,se(h)))return null}else r=se(h);if(void 0!==i[String(h)])return l.error("Branch labels must be unique.");i[String(h)]=a.length;}var f=e.parse(u,o,n);if(!f)return null;n=n||f.type,a.push(f);}var y=e.parse(t[1],1,Nt);if(!y)return null;var d=e.parse(t[t.length-1],t.length-1,n);return d?"value"!==y.type.kind&&e.concat(1).checkSubtype(r,y.type)?null:new hr(r,n,y,i,a,d):null},hr.prototype.evaluate=function(t){var e=this.input.evaluate(t);return (se(e)===this.inputType&&this.outputs[this.cases[e]]||this.otherwise).evaluate(t)},hr.prototype.eachChild=function(t){t(this.input),this.outputs.forEach(t),t(this.otherwise);},hr.prototype.outputDefined=function(){return this.outputs.every((function(t){return t.outputDefined()}))&&this.otherwise.outputDefined()},hr.prototype.serialize=function(){for(var t=this,e=["match",this.input.serialize()],r=[],n={},i=0,a=Object.keys(this.cases).sort();i<a.length;i+=1){var o=a[i];void 0===(c=n[this.cases[o]])?(n[this.cases[o]]=r.length,r.push([this.cases[o],[o]])):r[c][1].push(o);}for(var s=function(e){return "number"===t.inputType.kind?Number(e):e},u=0,l=r;u<l.length;u+=1){var p=l[u],c=p[0],h=p[1];e.push(1===h.length?s(h[0]):h.map(s)),e.push(this.outputs[outputIndex$1].serialize());}return e.push(this.otherwise.serialize()),e};var fr=function(t,e,r){this.type=t,this.branches=e,this.otherwise=r;};fr.parse=function(t,e){if(t.length<4)return e.error("Expected at least 3 arguments, but found only "+(t.length-1)+".");if(t.length%2!=0)return e.error("Expected an odd number of arguments.");var r;e.expectedType&&"value"!==e.expectedType.kind&&(r=e.expectedType);for(var n=[],i=1;i<t.length-1;i+=2){var a=e.parse(t[i],i,Ut);if(!a)return null;var o=e.parse(t[i+1],i+1,r);if(!o)return null;n.push([a,o]),r=r||o.type;}var s=e.parse(t[t.length-1],t.length-1,r);return s?new fr(r,n,s):null},fr.prototype.evaluate=function(t){for(var e=0,r=this.branches;e<r.length;e+=1){var n=r[e],i=n[1];if(n[0].evaluate(t))return i.evaluate(t)}return this.otherwise.evaluate(t)},fr.prototype.eachChild=function(t){for(var e=0,r=this.branches;e<r.length;e+=1){var n=r[e],i=n[1];t(n[0]),t(i);}t(this.otherwise);},fr.prototype.outputDefined=function(){return this.branches.every((function(t){return t[1].outputDefined()}))&&this.otherwise.outputDefined()},fr.prototype.serialize=function(){var t=["case"];return this.eachChild((function(e){t.push(e.serialize());})),t};var yr=function(t,e,r,n){this.type=t,this.input=e,this.beginIndex=r,this.endIndex=n;};function dr(t,e){return "=="===t||"!="===t?"boolean"===e.kind||"string"===e.kind||"number"===e.kind||"null"===e.kind||"value"===e.kind:"string"===e.kind||"number"===e.kind||"value"===e.kind}function mr(t,e,r,n){return 0===n.compare(e,r)}function vr(t,e,r){var n="=="!==t&&"!="!==t;return function(){function i(t,e,r){this.type=Ut,this.lhs=t,this.rhs=e,this.collator=r,this.hasUntypedArgument="value"===t.type.kind||"value"===e.type.kind;}return i.parse=function(t,e){if(3!==t.length&&4!==t.length)return e.error("Expected two or three arguments.");var r=t[0],a=e.parse(t[1],1,Nt);if(!a)return null;if(!dr(r,a.type))return e.concat(1).error('"'+r+"\" comparisons are not supported for type '"+Jt(a.type)+"'.");var o=e.parse(t[2],2,Nt);if(!o)return null;if(!dr(r,o.type))return e.concat(2).error('"'+r+"\" comparisons are not supported for type '"+Jt(o.type)+"'.");if(a.type.kind!==o.type.kind&&"value"!==a.type.kind&&"value"!==o.type.kind)return e.error("Cannot compare types '"+Jt(a.type)+"' and '"+Jt(o.type)+"'.");n&&("value"===a.type.kind&&"value"!==o.type.kind?a=new he(o.type,[a]):"value"!==a.type.kind&&"value"===o.type.kind&&(o=new he(a.type,[o])));var s=null;if(4===t.length){if("string"!==a.type.kind&&"string"!==o.type.kind&&"value"!==a.type.kind&&"value"!==o.type.kind)return e.error("Cannot use collator to compare non-string types.");if(!(s=e.parse(t[3],3,Kt)))return null}return new i(a,o,s)},i.prototype.evaluate=function(i){var a=this.lhs.evaluate(i),o=this.rhs.evaluate(i);if(n&&this.hasUntypedArgument){var s=se(a),u=se(o);if(s.kind!==u.kind||"string"!==s.kind&&"number"!==s.kind)throw new pe('Expected arguments for "'+t+'" to be (string, string) or (number, number), but found ('+s.kind+", "+u.kind+") instead.")}if(this.collator&&!n&&this.hasUntypedArgument){var l=se(a),p=se(o);if("string"!==l.kind||"string"!==p.kind)return e(i,a,o)}return this.collator?r(i,a,o,this.collator.evaluate(i)):e(i,a,o)},i.prototype.eachChild=function(t){t(this.lhs),t(this.rhs),this.collator&&t(this.collator);},i.prototype.outputDefined=function(){return !0},i.prototype.serialize=function(){var e=[t];return this.eachChild((function(t){e.push(t.serialize());})),e},i}()}yr.parse=function(t,e){if(t.length<=2||t.length>=5)return e.error("Expected 3 or 4 arguments, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1,Nt),n=e.parse(t[2],2,Ot);if(!r||!n)return null;if(!$t(r.type,[Xt(Nt),Rt,Nt]))return e.error("Expected first argument to be of type array or string, but found "+Jt(r.type)+" instead");if(4===t.length){var i=e.parse(t[3],3,Ot);return i?new yr(r.type,r,n,i):null}return new yr(r.type,r,n)},yr.prototype.evaluate=function(t){var e=this.input.evaluate(t),r=this.beginIndex.evaluate(t);if(!Wt(e,["string","array"]))throw new pe("Expected first argument to be of type array or string, but found "+Jt(se(e))+" instead.");if(this.endIndex){var n=this.endIndex.evaluate(t);return e.slice(r,n)}return e.slice(r)},yr.prototype.eachChild=function(t){t(this.input),t(this.beginIndex),this.endIndex&&t(this.endIndex);},yr.prototype.outputDefined=function(){return !1},yr.prototype.serialize=function(){if(null!=this.endIndex&&void 0!==this.endIndex){var t=this.endIndex.serialize();return ["slice",this.input.serialize(),this.beginIndex.serialize(),t]}return ["slice",this.input.serialize(),this.beginIndex.serialize()]};var gr=vr("==",(function(t,e,r){return e===r}),mr),xr=vr("!=",(function(t,e,r){return e!==r}),(function(t,e,r,n){return !mr(0,e,r,n)})),br=vr("<",(function(t,e,r){return e<r}),(function(t,e,r,n){return n.compare(e,r)<0})),wr=vr(">",(function(t,e,r){return e>r}),(function(t,e,r,n){return n.compare(e,r)>0})),_r=vr("<=",(function(t,e,r){return e<=r}),(function(t,e,r,n){return n.compare(e,r)<=0})),Ar=vr(">=",(function(t,e,r){return e>=r}),(function(t,e,r,n){return n.compare(e,r)>=0})),Sr=function(t,e,r,n,i){this.type=Rt,this.number=t,this.locale=e,this.currency=r,this.minFractionDigits=n,this.maxFractionDigits=i;};Sr.parse=function(t,e){if(3!==t.length)return e.error("Expected two arguments.");var r=e.parse(t[1],1,Ot);if(!r)return null;var n=t[2];if("object"!=typeof n||Array.isArray(n))return e.error("NumberFormat options argument must be an object.");var i=null;if(n.locale&&!(i=e.parse(n.locale,1,Rt)))return null;var a=null;if(n.currency&&!(a=e.parse(n.currency,1,Rt)))return null;var o=null;if(n["min-fraction-digits"]&&!(o=e.parse(n["min-fraction-digits"],1,Ot)))return null;var s=null;return n["max-fraction-digits"]&&!(s=e.parse(n["max-fraction-digits"],1,Ot))?null:new Sr(r,i,a,o,s)},Sr.prototype.evaluate=function(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))},Sr.prototype.eachChild=function(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits);},Sr.prototype.outputDefined=function(){return !1},Sr.prototype.serialize=function(){var t={};return this.locale&&(t.locale=this.locale.serialize()),this.currency&&(t.currency=this.currency.serialize()),this.minFractionDigits&&(t["min-fraction-digits"]=this.minFractionDigits.serialize()),this.maxFractionDigits&&(t["max-fraction-digits"]=this.maxFractionDigits.serialize()),["number-format",this.number.serialize(),t]};var kr=function(t){this.type=Ot,this.input=t;};kr.parse=function(t,e){if(2!==t.length)return e.error("Expected 1 argument, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1);return r?"array"!==r.type.kind&&"string"!==r.type.kind&&"value"!==r.type.kind?e.error("Expected argument of type string or array, but found "+Jt(r.type)+" instead."):new kr(r):null},kr.prototype.evaluate=function(t){var e=this.input.evaluate(t);if("string"==typeof e)return e.length;if(Array.isArray(e))return e.length;throw new pe("Expected value to be of type string or array, but found "+Jt(se(e))+" instead.")},kr.prototype.eachChild=function(t){t(this.input);},kr.prototype.outputDefined=function(){return !1},kr.prototype.serialize=function(){var t=["length"];return this.eachChild((function(e){t.push(e.serialize());})),t};var Ir={"==":gr,"!=":xr,">":wr,"<":br,">=":Ar,"<=":_r,array:he,at:lr,boolean:he,case:fr,coalesce:sr,collator:be,format:fe,image:ye,in:pr,"index-of":cr,interpolate:ar,"interpolate-hcl":ar,"interpolate-lab":ar,length:kr,let:ur,literal:le,match:hr,number:he,"number-format":Sr,object:he,slice:yr,step:Ne,string:he,"to-boolean":me,"to-color":me,"to-number":me,"to-string":me,var:Ue,within:De};function zr(t,e){var r=e[0],n=e[1],i=e[2],a=e[3];r=r.evaluate(t),n=n.evaluate(t),i=i.evaluate(t);var o=a?a.evaluate(t):1,s=ae(r,n,i,o);if(s)throw new pe(s);return new te(r/255*o,n/255*o,i/255*o,o)}function Cr(t,e){return t in e}function Er(t,e){var r=e[t];return void 0===r?null:r}function Pr(t){return {type:t}}function Mr(t){return {result:"success",value:t}}function Br(t){return {result:"error",value:t}}function Tr(t){return "data-driven"===t["property-type"]||"cross-faded-data-driven"===t["property-type"]}function Vr(t){return !!t.expression&&t.expression.parameters.indexOf("zoom")>-1}function Fr(t){return !!t.expression&&t.expression.interpolated}function Dr(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":null===t?"null":typeof t}function Lr(t){return "object"==typeof t&&null!==t&&!Array.isArray(t)}function Or(t){return t}function Rr(t,e,r){return void 0!==t?t:void 0!==e?e:void 0!==r?r:void 0}function Ur(t,e,r,n,i){return Rr(typeof r===i?n[r]:void 0,t.default,e.default)}function jr(t,e,r){if("number"!==Dr(r))return Rr(t.default,e.default);var n=t.stops.length;if(1===n)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[n-1][0])return t.stops[n-1][1];var i=qe(t.stops.map((function(t){return t[0]})),r);return t.stops[i][1]}function qr(t,e,r){var n=void 0!==t.base?t.base:1;if("number"!==Dr(r))return Rr(t.default,e.default);var i=t.stops.length;if(1===i)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[i-1][0])return t.stops[i-1][1];var a=qe(t.stops.map((function(t){return t[0]})),r),o=function(t,e,r,n){var i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}(r,n,t.stops[a][0],t.stops[a+1][0]),s=t.stops[a][1],u=t.stops[a+1][1],l=Ge[e.type]||Or;if(t.colorSpace&&"rgb"!==t.colorSpace){var p=ir[t.colorSpace];l=function(t,e){return p.reverse(p.interpolate(p.forward(t),p.forward(e),o))};}return "function"==typeof s.evaluate?{evaluate:function(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];var r=s.evaluate.apply(void 0,t),n=u.evaluate.apply(void 0,t);if(void 0!==r&&void 0!==n)return l(r,n,o)}}:l(s,u,o)}function Nr(t,e,r){return "color"===e.type?r=te.parse(r):"formatted"===e.type?r=ne.fromString(r.toString()):"resolvedImage"===e.type?r=ie.fromString(r.toString()):Dr(r)===e.type||"enum"===e.type&&e.values[r]||(r=void 0),Rr(r,t.default,e.default)}xe.register(Ir,{error:[{kind:"error"},[Rt],function(t,e){throw new pe(e[0].evaluate(t))}],typeof:[Rt,[Nt],function(t,e){return Jt(se(e[0].evaluate(t)))}],"to-rgba":[Xt(Ot,4),[jt],function(t,e){return e[0].evaluate(t).toArray()}],rgb:[jt,[Ot,Ot,Ot],zr],rgba:[jt,[Ot,Ot,Ot,Ot],zr],has:{type:Ut,overloads:[[[Rt],function(t,e){return Cr(e[0].evaluate(t),t.properties())}],[[Rt,qt],function(t,e){var r=e[1];return Cr(e[0].evaluate(t),r.evaluate(t))}]]},get:{type:Nt,overloads:[[[Rt],function(t,e){return Er(e[0].evaluate(t),t.properties())}],[[Rt,qt],function(t,e){var r=e[1];return Er(e[0].evaluate(t),r.evaluate(t))}]]},"feature-state":[Nt,[Rt],function(t,e){return Er(e[0].evaluate(t),t.featureState||{})}],properties:[qt,[],function(t){return t.properties()}],"geometry-type":[Rt,[],function(t){return t.geometryType()}],id:[Nt,[],function(t){return t.id()}],zoom:[Ot,[],function(t){return t.globals.zoom}],"heatmap-density":[Ot,[],function(t){return t.globals.heatmapDensity||0}],"line-progress":[Ot,[],function(t){return t.globals.lineProgress||0}],accumulated:[Nt,[],function(t){return void 0===t.globals.accumulated?null:t.globals.accumulated}],"+":[Ot,Pr(Ot),function(t,e){for(var r=0,n=0,i=e;n<i.length;n+=1)r+=i[n].evaluate(t);return r}],"*":[Ot,Pr(Ot),function(t,e){for(var r=1,n=0,i=e;n<i.length;n+=1)r*=i[n].evaluate(t);return r}],"-":{type:Ot,overloads:[[[Ot,Ot],function(t,e){var r=e[1];return e[0].evaluate(t)-r.evaluate(t)}],[[Ot],function(t,e){return -e[0].evaluate(t)}]]},"/":[Ot,[Ot,Ot],function(t,e){var r=e[1];return e[0].evaluate(t)/r.evaluate(t)}],"%":[Ot,[Ot,Ot],function(t,e){var r=e[1];return e[0].evaluate(t)%r.evaluate(t)}],ln2:[Ot,[],function(){return Math.LN2}],pi:[Ot,[],function(){return Math.PI}],e:[Ot,[],function(){return Math.E}],"^":[Ot,[Ot,Ot],function(t,e){var r=e[1];return Math.pow(e[0].evaluate(t),r.evaluate(t))}],sqrt:[Ot,[Ot],function(t,e){return Math.sqrt(e[0].evaluate(t))}],log10:[Ot,[Ot],function(t,e){return Math.log(e[0].evaluate(t))/Math.LN10}],ln:[Ot,[Ot],function(t,e){return Math.log(e[0].evaluate(t))}],log2:[Ot,[Ot],function(t,e){return Math.log(e[0].evaluate(t))/Math.LN2}],sin:[Ot,[Ot],function(t,e){return Math.sin(e[0].evaluate(t))}],cos:[Ot,[Ot],function(t,e){return Math.cos(e[0].evaluate(t))}],tan:[Ot,[Ot],function(t,e){return Math.tan(e[0].evaluate(t))}],asin:[Ot,[Ot],function(t,e){return Math.asin(e[0].evaluate(t))}],acos:[Ot,[Ot],function(t,e){return Math.acos(e[0].evaluate(t))}],atan:[Ot,[Ot],function(t,e){return Math.atan(e[0].evaluate(t))}],min:[Ot,Pr(Ot),function(t,e){return Math.min.apply(Math,e.map((function(e){return e.evaluate(t)})))}],max:[Ot,Pr(Ot),function(t,e){return Math.max.apply(Math,e.map((function(e){return e.evaluate(t)})))}],abs:[Ot,[Ot],function(t,e){return Math.abs(e[0].evaluate(t))}],round:[Ot,[Ot],function(t,e){var r=e[0].evaluate(t);return r<0?-Math.round(-r):Math.round(r)}],floor:[Ot,[Ot],function(t,e){return Math.floor(e[0].evaluate(t))}],ceil:[Ot,[Ot],function(t,e){return Math.ceil(e[0].evaluate(t))}],"filter-==":[Ut,[Rt,Nt],function(t,e){var r=e[0],n=e[1];return t.properties()[r.value]===n.value}],"filter-id-==":[Ut,[Nt],function(t,e){var r=e[0];return t.id()===r.value}],"filter-type-==":[Ut,[Rt],function(t,e){var r=e[0];return t.geometryType()===r.value}],"filter-<":[Ut,[Rt,Nt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i<a}],"filter-id-<":[Ut,[Nt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n<i}],"filter->":[Ut,[Rt,Nt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i>a}],"filter-id->":[Ut,[Nt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n>i}],"filter-<=":[Ut,[Rt,Nt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i<=a}],"filter-id-<=":[Ut,[Nt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n<=i}],"filter->=":[Ut,[Rt,Nt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i>=a}],"filter-id->=":[Ut,[Nt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n>=i}],"filter-has":[Ut,[Nt],function(t,e){return e[0].value in t.properties()}],"filter-has-id":[Ut,[],function(t){return null!==t.id()&&void 0!==t.id()}],"filter-type-in":[Ut,[Xt(Rt)],function(t,e){return e[0].value.indexOf(t.geometryType())>=0}],"filter-id-in":[Ut,[Xt(Nt)],function(t,e){return e[0].value.indexOf(t.id())>=0}],"filter-in-small":[Ut,[Rt,Xt(Nt)],function(t,e){var r=e[0];return e[1].value.indexOf(t.properties()[r.value])>=0}],"filter-in-large":[Ut,[Rt,Xt(Nt)],function(t,e){var r=e[0],n=e[1];return function(t,e,r,n){for(;r<=n;){var i=r+n>>1;if(e[i]===t)return !0;e[i]>t?n=i-1:r=i+1;}return !1}(t.properties()[r.value],n.value,0,n.value.length-1)}],all:{type:Ut,overloads:[[[Ut,Ut],function(t,e){var r=e[1];return e[0].evaluate(t)&&r.evaluate(t)}],[Pr(Ut),function(t,e){for(var r=0,n=e;r<n.length;r+=1)if(!n[r].evaluate(t))return !1;return !0}]]},any:{type:Ut,overloads:[[[Ut,Ut],function(t,e){var r=e[1];return e[0].evaluate(t)||r.evaluate(t)}],[Pr(Ut),function(t,e){for(var r=0,n=e;r<n.length;r+=1)if(n[r].evaluate(t))return !0;return !1}]]},"!":[Ut,[Ut],function(t,e){return !e[0].evaluate(t)}],"is-supported-script":[Ut,[Rt],function(t,e){var r=t.globals&&t.globals.isSupportedScript;return !r||r(e[0].evaluate(t))}],upcase:[Rt,[Rt],function(t,e){return e[0].evaluate(t).toUpperCase()}],downcase:[Rt,[Rt],function(t,e){return e[0].evaluate(t).toLowerCase()}],concat:[Rt,Pr(Nt),function(t,e){return e.map((function(e){return ue(e.evaluate(t))})).join("")}],"resolved-locale":[Rt,[Kt],function(t,e){return e[0].evaluate(t).resolvedLocale()}]});var Kr=function(t,e){this.expression=t,this._warningHistory={},this._evaluator=new ge,this._defaultValue=e?function(t){return "color"===t.type&&Lr(t.default)?new te(0,0,0,0):"color"===t.type?te.parse(t.default)||null:void 0===t.default?null:t.default}(e):null,this._enumValues=e&&"enum"===e.type?e.values:null;};function Gr(t){return Array.isArray(t)&&t.length>0&&"string"==typeof t[0]&&t[0]in Ir}function Zr(t,e){var r=new je(Ir,[],e?function(t){var e={color:jt,string:Rt,number:Ot,enum:Rt,boolean:Ut,formatted:Gt,resolvedImage:Zt};return "array"===t.type?Xt(e[t.value]||Nt,t.length):e[t.type]}(e):void 0),n=r.parse(t,void 0,void 0,void 0,e&&"string"===e.type?{typeAnnotation:"coerce"}:void 0);return n?Mr(new Kr(n,e)):Br(r.errors)}Kr.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i,a){return this._evaluator.globals=t,this._evaluator.feature=e,this._evaluator.featureState=r,this._evaluator.canonical=n,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=a,this.expression.evaluate(this._evaluator)},Kr.prototype.evaluate=function(t,e,r,n,i,a){this._evaluator.globals=t,this._evaluator.feature=e||null,this._evaluator.featureState=r||null,this._evaluator.canonical=n,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=a||null;try{var o=this.expression.evaluate(this._evaluator);if(null==o||"number"==typeof o&&o!=o)return this._defaultValue;if(this._enumValues&&!(o in this._enumValues))throw new pe("Expected value to be one of "+Object.keys(this._enumValues).map((function(t){return JSON.stringify(t)})).join(", ")+", but found "+JSON.stringify(o)+" instead.");return o}catch(t){return this._warningHistory[t.message]||(this._warningHistory[t.message]=!0,"undefined"!=typeof console&&console.warn(t.message)),this._defaultValue}};var Xr=function(t,e){this.kind=t,this._styleExpression=e,this.isStateDependent="constant"!==t&&!Oe(e.expression);};Xr.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i,a){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,a)},Xr.prototype.evaluate=function(t,e,r,n,i,a){return this._styleExpression.evaluate(t,e,r,n,i,a)};var Jr=function(t,e,r,n){this.kind=t,this.zoomStops=r,this._styleExpression=e,this.isStateDependent="camera"!==t&&!Oe(e.expression),this.interpolationType=n;};function Hr(t,e){if("error"===(t=Zr(t,e)).result)return t;var r=t.value.expression,n=Le(r);if(!n&&!Tr(e))return Br([new Ft("","data expressions not supported")]);var i=Re(r,["zoom"]);if(!i&&!Vr(e))return Br([new Ft("","zoom expressions not supported")]);var a=function t(e){var r=null;if(e instanceof ur)r=t(e.result);else if(e instanceof sr)for(var n=0,i=e.args;n<i.length&&!(r=t(i[n]));n+=1);else (e instanceof Ne||e instanceof ar)&&e.input instanceof xe&&"zoom"===e.input.name&&(r=e);return r instanceof Ft||e.eachChild((function(e){var n=t(e);n instanceof Ft?r=n:!r&&n?r=new Ft("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'):r&&n&&r!==n&&(r=new Ft("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));})),r}(r);return a||i?a instanceof Ft?Br([a]):a instanceof ar&&!Fr(e)?Br([new Ft("",'"interpolate" expressions cannot be used with this property')]):Mr(a?new Jr(n?"camera":"composite",t.value,a.labels,a instanceof ar?a.interpolation:void 0):new Xr(n?"constant":"source",t.value)):Br([new Ft("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])}Jr.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i,a){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,a)},Jr.prototype.evaluate=function(t,e,r,n,i,a){return this._styleExpression.evaluate(t,e,r,n,i,a)},Jr.prototype.interpolationFactor=function(t,e,r){return this.interpolationType?ar.interpolationFactor(this.interpolationType,t,e,r):0};var Yr=function(t,e){this._parameters=t,this._specification=e,Bt(this,function t(e,r){var n,i,a,o="color"===r.type,s=e.stops&&"object"==typeof e.stops[0][0],u=s||!(s||void 0!==e.property),l=e.type||(Fr(r)?"exponential":"interval");if(o&&((e=Bt({},e)).stops&&(e.stops=e.stops.map((function(t){return [t[0],te.parse(t[1])]}))),e.default=te.parse(e.default?e.default:r.default)),e.colorSpace&&"rgb"!==e.colorSpace&&!ir[e.colorSpace])throw new Error("Unknown color space: "+e.colorSpace);if("exponential"===l)n=qr;else if("interval"===l)n=jr;else if("categorical"===l){n=Ur,i=Object.create(null);for(var p=0,c=e.stops;p<c.length;p+=1){var h=c[p];i[h[0]]=h[1];}a=typeof e.stops[0][0];}else {if("identity"!==l)throw new Error('Unknown function type "'+l+'"');n=Nr;}if(s){for(var f={},y=[],d=0;d<e.stops.length;d++){var m=e.stops[d],v=m[0].zoom;void 0===f[v]&&(f[v]={zoom:v,type:e.type,property:e.property,default:e.default,stops:[]},y.push(v)),f[v].stops.push([m[0].value,m[1]]);}for(var g=[],x=0,b=y;x<b.length;x+=1){var w=b[x];g.push([f[w].zoom,t(f[w],r)]);}var _={name:"linear"};return {kind:"composite",interpolationType:_,interpolationFactor:ar.interpolationFactor.bind(void 0,_),zoomStops:g.map((function(t){return t[0]})),evaluate:function(t,n){var i=t.zoom;return qr({stops:g,base:e.base},r,i).evaluate(i,n)}}}if(u){var A="exponential"===l?{name:"exponential",base:void 0!==e.base?e.base:1}:null;return {kind:"camera",interpolationType:A,interpolationFactor:ar.interpolationFactor.bind(void 0,A),zoomStops:e.stops.map((function(t){return t[0]})),evaluate:function(t){return n(e,r,t.zoom,i,a)}}}return {kind:"source",evaluate:function(t,o){var s=o&&o.properties?o.properties[e.property]:void 0;return void 0===s?Rr(e.default,r.default):n(e,r,s,i,a)}}}(this._parameters,this._specification));};function $r(t){var e=t.key,r=t.value,n=t.valueSpec||{},i=t.objectElementValidators||{},a=t.style,o=t.styleSpec,s=[],u=Dr(r);if("object"!==u)return [new Pt(e,r,"object expected, "+u+" found")];for(var l in r){var p=l.split(".")[0],c=n[p]||n["*"],h=void 0;if(i[p])h=i[p];else if(n[p])h=An;else if(i["*"])h=i["*"];else {if(!n["*"]){s.push(new Pt(e,r[l],'unknown property "'+l+'"'));continue}h=An;}s=s.concat(h({key:(e?e+".":e)+l,value:r[l],valueSpec:c,style:a,styleSpec:o,object:r,objectKey:l},r));}for(var f in n)i[f]||n[f].required&&void 0===n[f].default&&void 0===r[f]&&s.push(new Pt(e,r,'missing required property "'+f+'"'));return s}function Wr(t){var e=t.value,r=t.valueSpec,n=t.style,i=t.styleSpec,a=t.key,o=t.arrayElementValidator||An;if("array"!==Dr(e))return [new Pt(a,e,"array expected, "+Dr(e)+" found")];if(r.length&&e.length!==r.length)return [new Pt(a,e,"array length "+r.length+" expected, length "+e.length+" found")];if(r["min-length"]&&e.length<r["min-length"])return [new Pt(a,e,"array length at least "+r["min-length"]+" expected, length "+e.length+" found")];var s={type:r.value,values:r.values};i.$version<7&&(s.function=r.function),"object"===Dr(r.value)&&(s=r.value);for(var u=[],l=0;l<e.length;l++)u=u.concat(o({array:e,arrayIndex:l,value:e[l],valueSpec:s,style:n,styleSpec:i,key:a+"["+l+"]"}));return u}function Qr(t){var e=t.key,r=t.value,n=t.valueSpec,i=Dr(r);return "number"===i&&r!=r&&(i="NaN"),"number"!==i?[new Pt(e,r,"number expected, "+i+" found")]:"minimum"in n&&r<n.minimum?[new Pt(e,r,r+" is less than the minimum value "+n.minimum)]:"maximum"in n&&r>n.maximum?[new Pt(e,r,r+" is greater than the maximum value "+n.maximum)]:[]}function tn(t){var e,r,n,i=t.valueSpec,a=Tt(t.value.type),o={},s="categorical"!==a&&void 0===t.value.property,u=!s,l="array"===Dr(t.value.stops)&&"array"===Dr(t.value.stops[0])&&"object"===Dr(t.value.stops[0][0]),p=$r({key:t.key,value:t.value,valueSpec:t.styleSpec.function,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{stops:function(t){if("identity"===a)return [new Pt(t.key,t.value,'identity function may not have a "stops" property')];var e=[],r=t.value;return e=e.concat(Wr({key:t.key,value:r,valueSpec:t.valueSpec,style:t.style,styleSpec:t.styleSpec,arrayElementValidator:c})),"array"===Dr(r)&&0===r.length&&e.push(new Pt(t.key,r,"array must have at least one stop")),e},default:function(t){return An({key:t.key,value:t.value,valueSpec:i,style:t.style,styleSpec:t.styleSpec})}}});return "identity"===a&&s&&p.push(new Pt(t.key,t.value,'missing required property "property"')),"identity"===a||t.value.stops||p.push(new Pt(t.key,t.value,'missing required property "stops"')),"exponential"===a&&t.valueSpec.expression&&!Fr(t.valueSpec)&&p.push(new Pt(t.key,t.value,"exponential functions not supported")),t.styleSpec.$version>=8&&(u&&!Tr(t.valueSpec)?p.push(new Pt(t.key,t.value,"property functions not supported")):s&&!Vr(t.valueSpec)&&p.push(new Pt(t.key,t.value,"zoom functions not supported"))),"categorical"!==a&&!l||void 0!==t.value.property||p.push(new Pt(t.key,t.value,'"property" property is required')),p;function c(t){var e=[],a=t.value,s=t.key;if("array"!==Dr(a))return [new Pt(s,a,"array expected, "+Dr(a)+" found")];if(2!==a.length)return [new Pt(s,a,"array length 2 expected, length "+a.length+" found")];if(l){if("object"!==Dr(a[0]))return [new Pt(s,a,"object expected, "+Dr(a[0])+" found")];if(void 0===a[0].zoom)return [new Pt(s,a,"object stop key must have zoom")];if(void 0===a[0].value)return [new Pt(s,a,"object stop key must have value")];if(n&&n>Tt(a[0].zoom))return [new Pt(s,a[0].zoom,"stop zoom values must appear in ascending order")];Tt(a[0].zoom)!==n&&(n=Tt(a[0].zoom),r=void 0,o={}),e=e.concat($r({key:s+"[0]",value:a[0],valueSpec:{zoom:{}},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{zoom:Qr,value:h}}));}else e=e.concat(h({key:s+"[0]",value:a[0],valueSpec:{},style:t.style,styleSpec:t.styleSpec},a));return Gr(Vt(a[1]))?e.concat([new Pt(s+"[1]",a[1],"expressions are not allowed in function stops.")]):e.concat(An({key:s+"[1]",value:a[1],valueSpec:i,style:t.style,styleSpec:t.styleSpec}))}function h(t,n){var s=Dr(t.value),u=Tt(t.value),l=null!==t.value?t.value:n;if(e){if(s!==e)return [new Pt(t.key,l,s+" stop domain type must match previous stop domain type "+e)]}else e=s;if("number"!==s&&"string"!==s&&"boolean"!==s)return [new Pt(t.key,l,"stop domain value must be a number, string, or boolean")];if("number"!==s&&"categorical"!==a){var p="number expected, "+s+" found";return Tr(i)&&void 0===a&&(p+='\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),[new Pt(t.key,l,p)]}return "categorical"!==a||"number"!==s||isFinite(u)&&Math.floor(u)===u?"categorical"!==a&&"number"===s&&void 0!==r&&u<r?[new Pt(t.key,l,"stop domain values must appear in ascending order")]:(r=u,"categorical"===a&&u in o?[new Pt(t.key,l,"stop domain values must be unique")]:(o[u]=!0,[])):[new Pt(t.key,l,"integer expected, found "+u)]}}function en(t){var e=("property"===t.expressionContext?Hr:Zr)(Vt(t.value),t.valueSpec);if("error"===e.result)return e.value.map((function(e){return new Pt(""+t.key+e.key,t.value,e.message)}));var r=e.value.expression||e.value._styleExpression.expression;if("property"===t.expressionContext&&"text-font"===t.propertyKey&&!r.outputDefined())return [new Pt(t.key,t.value,'Invalid data expression for "'+t.propertyKey+'". Output values must be contained as literals within the expression.')];if("property"===t.expressionContext&&"layout"===t.propertyType&&!Oe(r))return [new Pt(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];if("filter"===t.expressionContext&&!Oe(r))return [new Pt(t.key,t.value,'"feature-state" data expressions are not supported with filters.')];if(t.expressionContext&&0===t.expressionContext.indexOf("cluster")){if(!Re(r,["zoom","feature-state"]))return [new Pt(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if("cluster-initial"===t.expressionContext&&!Le(r))return [new Pt(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return []}function rn(t){var e=t.key,r=t.value,n=t.valueSpec,i=[];return Array.isArray(n.values)?-1===n.values.indexOf(Tt(r))&&i.push(new Pt(e,r,"expected one of ["+n.values.join(", ")+"], "+JSON.stringify(r)+" found")):-1===Object.keys(n.values).indexOf(Tt(r))&&i.push(new Pt(e,r,"expected one of ["+Object.keys(n.values).join(", ")+"], "+JSON.stringify(r)+" found")),i}function nn(t){if(!0===t||!1===t)return !0;if(!Array.isArray(t)||0===t.length)return !1;switch(t[0]){case"has":return t.length>=2&&"$id"!==t[1]&&"$type"!==t[1];case"in":return t.length>=3&&("string"!=typeof t[1]||Array.isArray(t[2]));case"!in":case"!has":case"none":return !1;case"==":case"!=":case">":case">=":case"<":case"<=":return 3!==t.length||Array.isArray(t[1])||Array.isArray(t[2]);case"any":case"all":for(var e=0,r=t.slice(1);e<r.length;e+=1){var n=r[e];if(!nn(n)&&"boolean"!=typeof n)return !1}return !0;default:return !0}}Yr.deserialize=function(t){return new Yr(t._parameters,t._specification)},Yr.serialize=function(t){return {_parameters:t._parameters,_specification:t._specification}};var an={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function on(t){if(null==t)return {filter:function(){return !0},needGeometry:!1};nn(t)||(t=un(t));var e=Zr(t,an);if("error"===e.result)throw new Error(e.value.map((function(t){return t.key+": "+t.message})).join(", "));return {filter:function(t,r,n){return e.value.evaluate(t,r,{},n)},needGeometry:function t(e){if(!Array.isArray(e))return !1;if("within"===e[0])return !0;for(var r=1;r<e.length;r++)if(t(e[r]))return !0;return !1}(t)}}function sn(t,e){return t<e?-1:t>e?1:0}function un(t){if(!t)return !0;var e,r=t[0];return t.length<=1?"any"!==r:"=="===r?ln(t[1],t[2],"=="):"!="===r?hn(ln(t[1],t[2],"==")):"<"===r||">"===r||"<="===r||">="===r?ln(t[1],t[2],r):"any"===r?(e=t.slice(1),["any"].concat(e.map(un))):"all"===r?["all"].concat(t.slice(1).map(un)):"none"===r?["all"].concat(t.slice(1).map(un).map(hn)):"in"===r?pn(t[1],t.slice(2)):"!in"===r?hn(pn(t[1],t.slice(2))):"has"===r?cn(t[1]):"!has"===r?hn(cn(t[1])):"within"!==r||t}function ln(t,e,r){switch(t){case"$type":return ["filter-type-"+r,e];case"$id":return ["filter-id-"+r,e];default:return ["filter-"+r,t,e]}}function pn(t,e){if(0===e.length)return !1;switch(t){case"$type":return ["filter-type-in",["literal",e]];case"$id":return ["filter-id-in",["literal",e]];default:return e.length>200&&!e.some((function(t){return typeof t!=typeof e[0]}))?["filter-in-large",t,["literal",e.sort(sn)]]:["filter-in-small",t,["literal",e]]}}function cn(t){switch(t){case"$type":return !0;case"$id":return ["filter-has-id"];default:return ["filter-has",t]}}function hn(t){return ["!",t]}function fn(t){return nn(Vt(t.value))?en(Bt({},t,{expressionContext:"filter",valueSpec:{value:"boolean"}})):function t(e){var r=e.value,n=e.key;if("array"!==Dr(r))return [new Pt(n,r,"array expected, "+Dr(r)+" found")];var i,a=e.styleSpec,o=[];if(r.length<1)return [new Pt(n,r,"filter array must have at least 1 element")];switch(o=o.concat(rn({key:n+"[0]",value:r[0],valueSpec:a.filter_operator,style:e.style,styleSpec:e.styleSpec})),Tt(r[0])){case"<":case"<=":case">":case">=":r.length>=2&&"$type"===Tt(r[1])&&o.push(new Pt(n,r,'"$type" cannot be use with operator "'+r[0]+'"'));case"==":case"!=":3!==r.length&&o.push(new Pt(n,r,'filter array for operator "'+r[0]+'" must have 3 elements'));case"in":case"!in":r.length>=2&&"string"!==(i=Dr(r[1]))&&o.push(new Pt(n+"[1]",r[1],"string expected, "+i+" found"));for(var s=2;s<r.length;s++)i=Dr(r[s]),"$type"===Tt(r[1])?o=o.concat(rn({key:n+"["+s+"]",value:r[s],valueSpec:a.geometry_type,style:e.style,styleSpec:e.styleSpec})):"string"!==i&&"number"!==i&&"boolean"!==i&&o.push(new Pt(n+"["+s+"]",r[s],"string, number, or boolean expected, "+i+" found"));break;case"any":case"all":case"none":for(var u=1;u<r.length;u++)o=o.concat(t({key:n+"["+u+"]",value:r[u],style:e.style,styleSpec:e.styleSpec}));break;case"has":case"!has":i=Dr(r[1]),2!==r.length?o.push(new Pt(n,r,'filter array for "'+r[0]+'" operator must have 2 elements')):"string"!==i&&o.push(new Pt(n+"[1]",r[1],"string expected, "+i+" found"));break;case"within":i=Dr(r[1]),2!==r.length?o.push(new Pt(n,r,'filter array for "'+r[0]+'" operator must have 2 elements')):"object"!==i&&o.push(new Pt(n+"[1]",r[1],"object expected, "+i+" found"));}return o}(t)}function yn(t,e){var r=t.key,n=t.style,i=t.styleSpec,a=t.value,o=t.objectKey,s=i[e+"_"+t.layerType];if(!s)return [];var u=o.match(/^(.*)-transition$/);if("paint"===e&&u&&s[u[1]]&&s[u[1]].transition)return An({key:r,value:a,valueSpec:i.transition,style:n,styleSpec:i});var l,p=t.valueSpec||s[o];if(!p)return [new Pt(r,a,'unknown property "'+o+'"')];if("string"===Dr(a)&&Tr(p)&&!p.tokens&&(l=/^{([^}]+)}$/.exec(a)))return [new Pt(r,a,'"'+o+'" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": '+JSON.stringify(l[1])+" }`.")];var c=[];return "symbol"===t.layerType&&("text-field"===o&&n&&!n.glyphs&&c.push(new Pt(r,a,'use of "text-field" requires a style "glyphs" property')),"text-font"===o&&Lr(Vt(a))&&"identity"===Tt(a.type)&&c.push(new Pt(r,a,'"text-font" does not support identity functions'))),c.concat(An({key:t.key,value:a,valueSpec:p,style:n,styleSpec:i,expressionContext:"property",propertyType:e,propertyKey:o}))}function dn(t){return yn(t,"paint")}function mn(t){return yn(t,"layout")}function vn(t){var e=[],r=t.value,n=t.key,i=t.style,a=t.styleSpec;r.type||r.ref||e.push(new Pt(n,r,'either "type" or "ref" is required'));var o,s=Tt(r.type),u=Tt(r.ref);if(r.id)for(var l=Tt(r.id),p=0;p<t.arrayIndex;p++){var c=i.layers[p];Tt(c.id)===l&&e.push(new Pt(n,r.id,'duplicate layer id "'+r.id+'", previously used at line '+c.id.__line__));}if("ref"in r)["type","source","source-layer","filter","layout"].forEach((function(t){t in r&&e.push(new Pt(n,r[t],'"'+t+'" is prohibited for ref layers'));})),i.layers.forEach((function(t){Tt(t.id)===u&&(o=t);})),o?o.ref?e.push(new Pt(n,r.ref,"ref cannot reference another ref layer")):s=Tt(o.type):e.push(new Pt(n,r.ref,'ref layer "'+u+'" not found'));else if("background"!==s)if(r.source){var h=i.sources&&i.sources[r.source],f=h&&Tt(h.type);h?"vector"===f&&"raster"===s?e.push(new Pt(n,r.source,'layer "'+r.id+'" requires a raster source')):"raster"===f&&"raster"!==s?e.push(new Pt(n,r.source,'layer "'+r.id+'" requires a vector source')):"vector"!==f||r["source-layer"]?"raster-dem"===f&&"hillshade"!==s?e.push(new Pt(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")):"line"!==s||!r.paint||!r.paint["line-gradient"]||"geojson"===f&&h.lineMetrics||e.push(new Pt(n,r,'layer "'+r.id+'" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')):e.push(new Pt(n,r,'layer "'+r.id+'" must specify a "source-layer"')):e.push(new Pt(n,r.source,'source "'+r.source+'" not found'));}else e.push(new Pt(n,r,'missing required property "source"'));return e=e.concat($r({key:n,value:r,valueSpec:a.layer,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(){return []},type:function(){return An({key:n+".type",value:r.type,valueSpec:a.layer.type,style:t.style,styleSpec:t.styleSpec,object:r,objectKey:"type"})},filter:fn,layout:function(t){return $r({layer:r,key:t.key,value:t.value,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(t){return mn(Bt({layerType:s},t))}}})},paint:function(t){return $r({layer:r,key:t.key,value:t.value,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(t){return dn(Bt({layerType:s},t))}}})}}}))}function gn(t){var e=t.value,r=t.key,n=Dr(e);return "string"!==n?[new Pt(r,e,"string expected, "+n+" found")]:[]}var xn={promoteId:function(t){var e=t.key,r=t.value;if("string"===Dr(r))return gn({key:e,value:r});var n=[];for(var i in r)n.push.apply(n,gn({key:e+"."+i,value:r[i]}));return n}};function bn(t){var e=t.value,r=t.key,n=t.styleSpec,i=t.style;if(!e.type)return [new Pt(r,e,'"type" is required')];var a,o=Tt(e.type);switch(o){case"vector":case"raster":case"raster-dem":return $r({key:r,value:e,valueSpec:n["source_"+o.replace("-","_")],style:t.style,styleSpec:n,objectElementValidators:xn});case"geojson":if(a=$r({key:r,value:e,valueSpec:n.source_geojson,style:i,styleSpec:n,objectElementValidators:xn}),e.cluster)for(var s in e.clusterProperties){var u=e.clusterProperties[s],l=u[0],p="string"==typeof l?[l,["accumulated"],["get",s]]:l;a.push.apply(a,en({key:r+"."+s+".map",value:u[1],expressionContext:"cluster-map"})),a.push.apply(a,en({key:r+"."+s+".reduce",value:p,expressionContext:"cluster-reduce"}));}return a;case"video":return $r({key:r,value:e,valueSpec:n.source_video,style:i,styleSpec:n});case"image":return $r({key:r,value:e,valueSpec:n.source_image,style:i,styleSpec:n});case"canvas":return [new Pt(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return rn({key:r+".type",value:e.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]},style:i,styleSpec:n})}}function wn(t){var e=t.value,r=t.styleSpec,n=r.light,i=t.style,a=[],o=Dr(e);if(void 0===e)return a;if("object"!==o)return a.concat([new Pt("light",e,"object expected, "+o+" found")]);for(var s in e){var u=s.match(/^(.*)-transition$/);a=a.concat(u&&n[u[1]]&&n[u[1]].transition?An({key:s,value:e[s],valueSpec:r.transition,style:i,styleSpec:r}):n[s]?An({key:s,value:e[s],valueSpec:n[s],style:i,styleSpec:r}):[new Pt(s,e[s],'unknown property "'+s+'"')]);}return a}var _n={"*":function(){return []},array:Wr,boolean:function(t){var e=t.value,r=t.key,n=Dr(e);return "boolean"!==n?[new Pt(r,e,"boolean expected, "+n+" found")]:[]},number:Qr,color:function(t){var e=t.key,r=t.value,n=Dr(r);return "string"!==n?[new Pt(e,r,"color expected, "+n+" found")]:null===Qt(r)?[new Pt(e,r,'color expected, "'+r+'" found')]:[]},constants:Mt,enum:rn,filter:fn,function:tn,layer:vn,object:$r,source:bn,light:wn,string:gn,formatted:function(t){return 0===gn(t).length?[]:en(t)},resolvedImage:function(t){return 0===gn(t).length?[]:en(t)}};function An(t){var e=t.value,r=t.valueSpec,n=t.styleSpec;return r.expression&&Lr(Tt(e))?tn(t):r.expression&&Gr(Vt(e))?en(t):r.type&&_n[r.type]?_n[r.type](t):$r(Bt({},t,{valueSpec:r.type?n[r.type]:r}))}function Sn(t){var e=t.value,r=t.key,n=gn(t);return n.length||(-1===e.indexOf("{fontstack}")&&n.push(new Pt(r,e,'"glyphs" url must include a "{fontstack}" token')),-1===e.indexOf("{range}")&&n.push(new Pt(r,e,'"glyphs" url must include a "{range}" token'))),n}function kn(t,e){void 0===e&&(e=Et);var r=[];return r=r.concat(An({key:"",value:t,valueSpec:e.$root,styleSpec:e,style:t,objectElementValidators:{glyphs:Sn,"*":function(){return []}}})),t.constants&&(r=r.concat(Mt({key:"constants",value:t.constants,style:t,styleSpec:e}))),In(r)}function In(t){return [].concat(t).sort((function(t,e){return t.line-e.line}))}function zn(t){return function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];return In(t.apply(this,e))}}kn.source=zn(bn),kn.light=zn(wn),kn.layer=zn(vn),kn.filter=zn(fn),kn.paintProperty=zn(dn),kn.layoutProperty=zn(mn);var Cn=kn,En=Cn.light,Pn=Cn.paintProperty,Mn=Cn.layoutProperty;function Bn(t,e){var r=!1;if(e&&e.length)for(var n=0,i=e;n<i.length;n+=1)t.fire(new zt(new Error(i[n].message))),r=!0;return r}var Tn=Vn;function Vn(t,e,r){var n=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;var i=new Int32Array(this.arrayBuffer);t=i[0],this.d=(e=i[1])+2*(r=i[2]);for(var a=0;a<this.d*this.d;a++){var o=i[3+a],s=i[3+a+1];n.push(o===s?null:i.subarray(o,s));}var u=i[3+n.length+1];this.keys=i.subarray(i[3+n.length],u),this.bboxes=i.subarray(u),this.insert=this._insertReadonly;}else {this.d=e+2*r;for(var l=0;l<this.d*this.d;l++)n.push([]);this.keys=[],this.bboxes=[];}this.n=e,this.extent=t,this.padding=r,this.scale=e/t,this.uid=0;var p=r/e*t;this.min=-p,this.max=t+p;}Vn.prototype.insert=function(t,e,r,n,i){this._forEachCell(e,r,n,i,this._insertCell,this.uid++),this.keys.push(t),this.bboxes.push(e),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i);},Vn.prototype._insertReadonly=function(){throw "Cannot insert into a GridIndex created from an ArrayBuffer."},Vn.prototype._insertCell=function(t,e,r,n,i,a){this.cells[i].push(a);},Vn.prototype.query=function(t,e,r,n,i){var a=this.min,o=this.max;if(t<=a&&e<=a&&o<=r&&o<=n&&!i)return Array.prototype.slice.call(this.keys);var s=[];return this._forEachCell(t,e,r,n,this._queryCell,s,{},i),s},Vn.prototype._queryCell=function(t,e,r,n,i,a,o,s){var u=this.cells[i];if(null!==u)for(var l=this.keys,p=this.bboxes,c=0;c<u.length;c++){var h=u[c];if(void 0===o[h]){var f=4*h;(s?s(p[f+0],p[f+1],p[f+2],p[f+3]):t<=p[f+2]&&e<=p[f+3]&&r>=p[f+0]&&n>=p[f+1])?(o[h]=!0,a.push(l[h])):o[h]=!1;}}},Vn.prototype._forEachCell=function(t,e,r,n,i,a,o,s){for(var u=this._convertToCellCoord(t),l=this._convertToCellCoord(e),p=this._convertToCellCoord(r),c=this._convertToCellCoord(n),h=u;h<=p;h++)for(var f=l;f<=c;f++){var y=this.d*f+h;if((!s||s(this._convertFromCellCoord(h),this._convertFromCellCoord(f),this._convertFromCellCoord(h+1),this._convertFromCellCoord(f+1)))&&i.call(this,t,e,r,n,y,a,o,s))return}},Vn.prototype._convertFromCellCoord=function(t){return (t-this.padding)/this.scale},Vn.prototype._convertToCellCoord=function(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))},Vn.prototype.toArrayBuffer=function(){if(this.arrayBuffer)return this.arrayBuffer;for(var t=this.cells,e=3+this.cells.length+1+1,r=0,n=0;n<this.cells.length;n++)r+=this.cells[n].length;var i=new Int32Array(e+r+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;for(var a=e,o=0;o<t.length;o++){var s=t[o];i[3+o]=a,i.set(s,a),a+=s.length;}return i[3+t.length]=a,i.set(this.keys,a),i[3+t.length+1]=a+=this.keys.length,i.set(this.bboxes,a),a+=this.bboxes.length,i.buffer};var Fn=o.ImageData,Dn=o.ImageBitmap,Ln={};function On(t,e,r){void 0===r&&(r={}),Object.defineProperty(e,"_classRegistryKey",{value:t,writeable:!1}),Ln[t]={klass:e,omit:r.omit||[],shallow:r.shallow||[]};}for(var Rn in On("Object",Object),Tn.serialize=function(t,e){var r=t.toArrayBuffer();return e&&e.push(r),{buffer:r}},Tn.deserialize=function(t){return new Tn(t.buffer)},On("Grid",Tn),On("Color",te),On("Error",Error),On("ResolvedImage",ie),On("StylePropertyFunction",Yr),On("StyleExpression",Kr,{omit:["_evaluator"]}),On("ZoomDependentExpression",Jr),On("ZoomConstantExpression",Xr),On("CompoundExpression",xe,{omit:["_evaluate"]}),Ir)Ir[Rn]._classRegistryKey||On("Expression_"+Rn,Ir[Rn]);function Un(t){return t&&"undefined"!=typeof ArrayBuffer&&(t instanceof ArrayBuffer||t.constructor&&"ArrayBuffer"===t.constructor.name)}function jn(t){return Dn&&t instanceof Dn}function qn(t,e){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp)return t;if(Un(t)||jn(t))return e&&e.push(t),t;if(ArrayBuffer.isView(t)){var r=t;return e&&e.push(r.buffer),r}if(t instanceof Fn)return e&&e.push(t.data.buffer),t;if(Array.isArray(t)){for(var n=[],i=0,a=t;i<a.length;i+=1)n.push(qn(a[i],e));return n}if("object"==typeof t){var o=t.constructor,s=o._classRegistryKey;if(!s)throw new Error("can't serialize object of unregistered class");var u=o.serialize?o.serialize(t,e):{};if(!o.serialize){for(var l in t)if(t.hasOwnProperty(l)&&!(Ln[s].omit.indexOf(l)>=0)){var p=t[l];u[l]=Ln[s].shallow.indexOf(l)>=0?p:qn(p,e);}t instanceof Error&&(u.message=t.message);}if(u.$name)throw new Error("$name property is reserved for worker serialization logic.");return "Object"!==s&&(u.$name=s),u}throw new Error("can't serialize object of type "+typeof t)}function Nn(t){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||Un(t)||jn(t)||ArrayBuffer.isView(t)||t instanceof Fn)return t;if(Array.isArray(t))return t.map(Nn);if("object"==typeof t){var e=t.$name||"Object",r=Ln[e].klass;if(!r)throw new Error("can't deserialize unregistered class "+e);if(r.deserialize)return r.deserialize(t);for(var n=Object.create(r.prototype),i=0,a=Object.keys(t);i<a.length;i+=1){var o=a[i];if("$name"!==o){var s=t[o];n[o]=Ln[e].shallow.indexOf(o)>=0?s:Nn(s);}}return n}throw new Error("can't deserialize object of type "+typeof t)}var Kn=function(){this.first=!0;};Kn.prototype.update=function(t,e){var r=Math.floor(t);return this.first?(this.first=!1,this.lastIntegerZoom=r,this.lastIntegerZoomTime=0,this.lastZoom=t,this.lastFloorZoom=r,!0):(this.lastFloorZoom>r?(this.lastIntegerZoom=r+1,this.lastIntegerZoomTime=e):this.lastFloorZoom<r&&(this.lastIntegerZoom=r,this.lastIntegerZoomTime=e),t!==this.lastZoom&&(this.lastZoom=t,this.lastFloorZoom=r,!0))};var Gn={"Latin-1 Supplement":function(t){return t>=128&&t<=255},Arabic:function(t){return t>=1536&&t<=1791},"Arabic Supplement":function(t){return t>=1872&&t<=1919},"Arabic Extended-A":function(t){return t>=2208&&t<=2303},"Hangul Jamo":function(t){return t>=4352&&t<=4607},"Unified Canadian Aboriginal Syllabics":function(t){return t>=5120&&t<=5759},Khmer:function(t){return t>=6016&&t<=6143},"Unified Canadian Aboriginal Syllabics Extended":function(t){return t>=6320&&t<=6399},"General Punctuation":function(t){return t>=8192&&t<=8303},"Letterlike Symbols":function(t){return t>=8448&&t<=8527},"Number Forms":function(t){return t>=8528&&t<=8591},"Miscellaneous Technical":function(t){return t>=8960&&t<=9215},"Control Pictures":function(t){return t>=9216&&t<=9279},"Optical Character Recognition":function(t){return t>=9280&&t<=9311},"Enclosed Alphanumerics":function(t){return t>=9312&&t<=9471},"Geometric Shapes":function(t){return t>=9632&&t<=9727},"Miscellaneous Symbols":function(t){return t>=9728&&t<=9983},"Miscellaneous Symbols and Arrows":function(t){return t>=11008&&t<=11263},"CJK Radicals Supplement":function(t){return t>=11904&&t<=12031},"Kangxi Radicals":function(t){return t>=12032&&t<=12255},"Ideographic Description Characters":function(t){return t>=12272&&t<=12287},"CJK Symbols and Punctuation":function(t){return t>=12288&&t<=12351},Hiragana:function(t){return t>=12352&&t<=12447},Katakana:function(t){return t>=12448&&t<=12543},Bopomofo:function(t){return t>=12544&&t<=12591},"Hangul Compatibility Jamo":function(t){return t>=12592&&t<=12687},Kanbun:function(t){return t>=12688&&t<=12703},"Bopomofo Extended":function(t){return t>=12704&&t<=12735},"CJK Strokes":function(t){return t>=12736&&t<=12783},"Katakana Phonetic Extensions":function(t){return t>=12784&&t<=12799},"Enclosed CJK Letters and Months":function(t){return t>=12800&&t<=13055},"CJK Compatibility":function(t){return t>=13056&&t<=13311},"CJK Unified Ideographs Extension A":function(t){return t>=13312&&t<=19903},"Yijing Hexagram Symbols":function(t){return t>=19904&&t<=19967},"CJK Unified Ideographs":function(t){return t>=19968&&t<=40959},"Yi Syllables":function(t){return t>=40960&&t<=42127},"Yi Radicals":function(t){return t>=42128&&t<=42191},"Hangul Jamo Extended-A":function(t){return t>=43360&&t<=43391},"Hangul Syllables":function(t){return t>=44032&&t<=55215},"Hangul Jamo Extended-B":function(t){return t>=55216&&t<=55295},"Private Use Area":function(t){return t>=57344&&t<=63743},"CJK Compatibility Ideographs":function(t){return t>=63744&&t<=64255},"Arabic Presentation Forms-A":function(t){return t>=64336&&t<=65023},"Vertical Forms":function(t){return t>=65040&&t<=65055},"CJK Compatibility Forms":function(t){return t>=65072&&t<=65103},"Small Form Variants":function(t){return t>=65104&&t<=65135},"Arabic Presentation Forms-B":function(t){return t>=65136&&t<=65279},"Halfwidth and Fullwidth Forms":function(t){return t>=65280&&t<=65519}};function Zn(t){for(var e=0,r=t;e<r.length;e+=1)if(Xn(r[e].charCodeAt(0)))return !0;return !1}function Xn(t){return !(746!==t&&747!==t&&(t<4352||!(Gn["Bopomofo Extended"](t)||Gn.Bopomofo(t)||Gn["CJK Compatibility Forms"](t)&&!(t>=65097&&t<=65103)||Gn["CJK Compatibility Ideographs"](t)||Gn["CJK Compatibility"](t)||Gn["CJK Radicals Supplement"](t)||Gn["CJK Strokes"](t)||!(!Gn["CJK Symbols and Punctuation"](t)||t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||Gn["CJK Unified Ideographs Extension A"](t)||Gn["CJK Unified Ideographs"](t)||Gn["Enclosed CJK Letters and Months"](t)||Gn["Hangul Compatibility Jamo"](t)||Gn["Hangul Jamo Extended-A"](t)||Gn["Hangul Jamo Extended-B"](t)||Gn["Hangul Jamo"](t)||Gn["Hangul Syllables"](t)||Gn.Hiragana(t)||Gn["Ideographic Description Characters"](t)||Gn.Kanbun(t)||Gn["Kangxi Radicals"](t)||Gn["Katakana Phonetic Extensions"](t)||Gn.Katakana(t)&&12540!==t||!(!Gn["Halfwidth and Fullwidth Forms"](t)||65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||!(!Gn["Small Form Variants"](t)||t>=65112&&t<=65118||t>=65123&&t<=65126)||Gn["Unified Canadian Aboriginal Syllabics"](t)||Gn["Unified Canadian Aboriginal Syllabics Extended"](t)||Gn["Vertical Forms"](t)||Gn["Yijing Hexagram Symbols"](t)||Gn["Yi Syllables"](t)||Gn["Yi Radicals"](t))))}function Jn(t){return !(Xn(t)||function(t){return !!(Gn["Latin-1 Supplement"](t)&&(167===t||169===t||174===t||177===t||188===t||189===t||190===t||215===t||247===t)||Gn["General Punctuation"](t)&&(8214===t||8224===t||8225===t||8240===t||8241===t||8251===t||8252===t||8258===t||8263===t||8264===t||8265===t||8273===t)||Gn["Letterlike Symbols"](t)||Gn["Number Forms"](t)||Gn["Miscellaneous Technical"](t)&&(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||9003===t||t>=9085&&t<=9114||t>=9150&&t<=9165||9167===t||t>=9169&&t<=9179||t>=9186&&t<=9215)||Gn["Control Pictures"](t)&&9251!==t||Gn["Optical Character Recognition"](t)||Gn["Enclosed Alphanumerics"](t)||Gn["Geometric Shapes"](t)||Gn["Miscellaneous Symbols"](t)&&!(t>=9754&&t<=9759)||Gn["Miscellaneous Symbols and Arrows"](t)&&(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243)||Gn["CJK Symbols and Punctuation"](t)||Gn.Katakana(t)||Gn["Private Use Area"](t)||Gn["CJK Compatibility Forms"](t)||Gn["Small Form Variants"](t)||Gn["Halfwidth and Fullwidth Forms"](t)||8734===t||8756===t||8757===t||t>=9984&&t<=10087||t>=10102&&t<=10131||65532===t||65533===t)}(t))}function Hn(t){return t>=1424&&t<=2303||Gn["Arabic Presentation Forms-A"](t)||Gn["Arabic Presentation Forms-B"](t)}function Yn(t,e){return !(!e&&Hn(t)||t>=2304&&t<=3583||t>=3840&&t<=4255||Gn.Khmer(t))}function $n(t){for(var e=0,r=t;e<r.length;e+=1)if(Hn(r[e].charCodeAt(0)))return !0;return !1}var Wn=null,Qn="unavailable",ti=null,ei=function(t){t&&"string"==typeof t&&t.indexOf("NetworkError")>-1&&(Qn="error"),Wn&&Wn(t);};function ri(){ni.fire(new It("pluginStateChange",{pluginStatus:Qn,pluginURL:ti}));}var ni=new Ct,ii=function(){return Qn},ai=function(){if("deferred"!==Qn||!ti)throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");Qn="loading",ri(),ti&&bt({url:ti},(function(t){t?ei(t):(Qn="loaded",ri());}));},oi={applyArabicShaping:null,processBidirectionalText:null,processStyledBidirectionalText:null,isLoaded:function(){return "loaded"===Qn||null!=oi.applyArabicShaping},isLoading:function(){return "loading"===Qn},setState:function(t){Qn=t.pluginStatus,ti=t.pluginURL;},isParsed:function(){return null!=oi.applyArabicShaping&&null!=oi.processBidirectionalText&&null!=oi.processStyledBidirectionalText},getPluginURL:function(){return ti}},si=function(t,e){this.zoom=t,e?(this.now=e.now,this.fadeDuration=e.fadeDuration,this.zoomHistory=e.zoomHistory,this.transition=e.transition):(this.now=0,this.fadeDuration=0,this.zoomHistory=new Kn,this.transition={});};si.prototype.isSupportedScript=function(t){return function(t,e){for(var r=0,n=t;r<n.length;r+=1)if(!Yn(n[r].charCodeAt(0),e))return !1;return !0}(t,oi.isLoaded())},si.prototype.crossFadingFactor=function(){return 0===this.fadeDuration?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)},si.prototype.getCrossfadeParameters=function(){var t=this.zoom,e=t-Math.floor(t),r=this.crossFadingFactor();return t>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:e+(1-e)*r}:{fromScale:.5,toScale:1,t:1-(1-r)*e}};var ui=function(t,e){this.property=t,this.value=e,this.expression=function(t,e){if(Lr(t))return new Yr(t,e);if(Gr(t)){var r=Hr(t,e);if("error"===r.result)throw new Error(r.value.map((function(t){return t.key+": "+t.message})).join(", "));return r.value}var n=t;return "string"==typeof t&&"color"===e.type&&(n=te.parse(t)),{kind:"constant",evaluate:function(){return n}}}(void 0===e?t.specification.default:e,t.specification);};ui.prototype.isDataDriven=function(){return "source"===this.expression.kind||"composite"===this.expression.kind},ui.prototype.possiblyEvaluate=function(t,e,r){return this.property.possiblyEvaluate(this,t,e,r)};var li=function(t){this.property=t,this.value=new ui(t,void 0);};li.prototype.transitioned=function(t,e){return new ci(this.property,this.value,e,h({},t.transition,this.transition),t.now)},li.prototype.untransitioned=function(){return new ci(this.property,this.value,null,{},0)};var pi=function(t){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues);};pi.prototype.getValue=function(t){return w(this._values[t].value.value)},pi.prototype.setValue=function(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new li(this._values[t].property)),this._values[t].value=new ui(this._values[t].property,null===e?void 0:w(e));},pi.prototype.getTransition=function(t){return w(this._values[t].transition)},pi.prototype.setTransition=function(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new li(this._values[t].property)),this._values[t].transition=w(e)||void 0;},pi.prototype.serialize=function(){for(var t={},e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e],i=this.getValue(n);void 0!==i&&(t[n]=i);var a=this.getTransition(n);void 0!==a&&(t[n+"-transition"]=a);}return t},pi.prototype.transitioned=function(t,e){for(var r=new hi(this._properties),n=0,i=Object.keys(this._values);n<i.length;n+=1){var a=i[n];r._values[a]=this._values[a].transitioned(t,e._values[a]);}return r},pi.prototype.untransitioned=function(){for(var t=new hi(this._properties),e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e];t._values[n]=this._values[n].untransitioned();}return t};var ci=function(t,e,r,n,i){this.property=t,this.value=e,this.begin=i+n.delay||0,this.end=this.begin+n.duration||0,t.specification.transition&&(n.delay||n.duration)&&(this.prior=r);};ci.prototype.possiblyEvaluate=function(t,e,r){var n=t.now||0,i=this.value.possiblyEvaluate(t,e,r),a=this.prior;if(a){if(n>this.end)return this.prior=null,i;if(this.value.isDataDriven())return this.prior=null,i;if(n<this.begin)return a.possiblyEvaluate(t,e,r);var o=(n-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(t,e,r),i,function(t){if(t<=0)return 0;if(t>=1)return 1;var e=t*t,r=e*t;return 4*(t<.5?r:3*(t-e)+r-.75)}(o))}return i};var hi=function(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues);};hi.prototype.possiblyEvaluate=function(t,e,r){for(var n=new di(this._properties),i=0,a=Object.keys(this._values);i<a.length;i+=1){var o=a[i];n._values[o]=this._values[o].possiblyEvaluate(t,e,r);}return n},hi.prototype.hasTransition=function(){for(var t=0,e=Object.keys(this._values);t<e.length;t+=1)if(this._values[e[t]].prior)return !0;return !1};var fi=function(t){this._properties=t,this._values=Object.create(t.defaultPropertyValues);};fi.prototype.getValue=function(t){return w(this._values[t].value)},fi.prototype.setValue=function(t,e){this._values[t]=new ui(this._values[t].property,null===e?void 0:w(e));},fi.prototype.serialize=function(){for(var t={},e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e],i=this.getValue(n);void 0!==i&&(t[n]=i);}return t},fi.prototype.possiblyEvaluate=function(t,e,r){for(var n=new di(this._properties),i=0,a=Object.keys(this._values);i<a.length;i+=1){var o=a[i];n._values[o]=this._values[o].possiblyEvaluate(t,e,r);}return n};var yi=function(t,e,r){this.property=t,this.value=e,this.parameters=r;};yi.prototype.isConstant=function(){return "constant"===this.value.kind},yi.prototype.constantOr=function(t){return "constant"===this.value.kind?this.value.value:t},yi.prototype.evaluate=function(t,e,r,n){return this.property.evaluate(this.value,this.parameters,t,e,r,n)};var di=function(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues);};di.prototype.get=function(t){return this._values[t]};var mi=function(t){this.specification=t;};mi.prototype.possiblyEvaluate=function(t,e){return t.expression.evaluate(e)},mi.prototype.interpolate=function(t,e,r){var n=Ge[this.specification.type];return n?n(t,e,r):t};var vi=function(t,e){this.specification=t,this.overrides=e;};vi.prototype.possiblyEvaluate=function(t,e,r,n){return new yi(this,"constant"===t.expression.kind||"camera"===t.expression.kind?{kind:"constant",value:t.expression.evaluate(e,null,{},r,n)}:t.expression,e)},vi.prototype.interpolate=function(t,e,r){if("constant"!==t.value.kind||"constant"!==e.value.kind)return t;if(void 0===t.value.value||void 0===e.value.value)return new yi(this,{kind:"constant",value:void 0},t.parameters);var n=Ge[this.specification.type];return n?new yi(this,{kind:"constant",value:n(t.value.value,e.value.value,r)},t.parameters):t},vi.prototype.evaluate=function(t,e,r,n,i,a){return "constant"===t.kind?t.value:t.evaluate(e,r,n,i,a)};var gi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.possiblyEvaluate=function(t,e,r,n){if(void 0===t.value)return new yi(this,{kind:"constant",value:void 0},e);if("constant"===t.expression.kind){var i=t.expression.evaluate(e,null,{},r,n),a="resolvedImage"===t.property.specification.type&&"string"!=typeof i?i.name:i,o=this._calculate(a,a,a,e);return new yi(this,{kind:"constant",value:o},e)}if("camera"===t.expression.kind){var s=this._calculate(t.expression.evaluate({zoom:e.zoom-1}),t.expression.evaluate({zoom:e.zoom}),t.expression.evaluate({zoom:e.zoom+1}),e);return new yi(this,{kind:"constant",value:s},e)}return new yi(this,t.expression,e)},e.prototype.evaluate=function(t,e,r,n,i,a){if("source"===t.kind){var o=t.evaluate(e,r,n,i,a);return this._calculate(o,o,o,e)}return "composite"===t.kind?this._calculate(t.evaluate({zoom:Math.floor(e.zoom)-1},r,n),t.evaluate({zoom:Math.floor(e.zoom)},r,n),t.evaluate({zoom:Math.floor(e.zoom)+1},r,n),e):t.value},e.prototype._calculate=function(t,e,r,n){return n.zoom>n.zoomHistory.lastIntegerZoom?{from:t,to:e}:{from:r,to:e}},e.prototype.interpolate=function(t){return t},e}(vi),xi=function(t){this.specification=t;};xi.prototype.possiblyEvaluate=function(t,e,r,n){if(void 0!==t.value){if("constant"===t.expression.kind){var i=t.expression.evaluate(e,null,{},r,n);return this._calculate(i,i,i,e)}return this._calculate(t.expression.evaluate(new si(Math.floor(e.zoom-1),e)),t.expression.evaluate(new si(Math.floor(e.zoom),e)),t.expression.evaluate(new si(Math.floor(e.zoom+1),e)),e)}},xi.prototype._calculate=function(t,e,r,n){return n.zoom>n.zoomHistory.lastIntegerZoom?{from:t,to:e}:{from:r,to:e}},xi.prototype.interpolate=function(t){return t};var bi=function(t){this.specification=t;};bi.prototype.possiblyEvaluate=function(t,e,r,n){return !!t.expression.evaluate(e,null,{},r,n)},bi.prototype.interpolate=function(){return !1};var wi=function(t){for(var e in this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[],t){var r=t[e];r.specification.overridable&&this.overridableProperties.push(e);var n=this.defaultPropertyValues[e]=new ui(r,void 0),i=this.defaultTransitionablePropertyValues[e]=new li(r);this.defaultTransitioningPropertyValues[e]=i.untransitioned(),this.defaultPossiblyEvaluatedValues[e]=n.possiblyEvaluate({});}};On("DataDrivenProperty",vi),On("DataConstantProperty",mi),On("CrossFadedDataDrivenProperty",gi),On("CrossFadedProperty",xi),On("ColorRampProperty",bi);var _i=function(t){function e(e,r){if(t.call(this),this.id=e.id,this.type=e.type,this._featureFilter={filter:function(){return !0},needGeometry:!1},"custom"!==e.type&&(this.metadata=(e=e).metadata,this.minzoom=e.minzoom,this.maxzoom=e.maxzoom,"background"!==e.type&&(this.source=e.source,this.sourceLayer=e["source-layer"],this.filter=e.filter),r.layout&&(this._unevaluatedLayout=new fi(r.layout)),r.paint)){for(var n in this._transitionablePaint=new pi(r.paint),e.paint)this.setPaintProperty(n,e.paint[n],{validate:!1});for(var i in e.layout)this.setLayoutProperty(i,e.layout[i],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new di(r.paint);}}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getCrossfadeParameters=function(){return this._crossfadeParameters},e.prototype.getLayoutProperty=function(t){return "visibility"===t?this.visibility:this._unevaluatedLayout.getValue(t)},e.prototype.setLayoutProperty=function(t,e,r){void 0===r&&(r={}),null!=e&&this._validate(Mn,"layers."+this.id+".layout."+t,t,e,r)||("visibility"!==t?this._unevaluatedLayout.setValue(t,e):this.visibility=e);},e.prototype.getPaintProperty=function(t){return g(t,"-transition")?this._transitionablePaint.getTransition(t.slice(0,-"-transition".length)):this._transitionablePaint.getValue(t)},e.prototype.setPaintProperty=function(t,e,r){if(void 0===r&&(r={}),null!=e&&this._validate(Pn,"layers."+this.id+".paint."+t,t,e,r))return !1;if(g(t,"-transition"))return this._transitionablePaint.setTransition(t.slice(0,-"-transition".length),e||void 0),!1;var n=this._transitionablePaint._values[t],i="cross-faded-data-driven"===n.property.specification["property-type"],a=n.value.isDataDriven(),o=n.value;this._transitionablePaint.setValue(t,e),this._handleSpecialPaintPropertyUpdate(t);var s=this._transitionablePaint._values[t].value;return s.isDataDriven()||a||i||this._handleOverridablePaintPropertyUpdate(t,o,s)},e.prototype._handleSpecialPaintPropertyUpdate=function(t){},e.prototype._handleOverridablePaintPropertyUpdate=function(t,e,r){return !1},e.prototype.isHidden=function(t){return !!(this.minzoom&&t<this.minzoom)||!!(this.maxzoom&&t>=this.maxzoom)||"none"===this.visibility},e.prototype.updateTransitions=function(t){this._transitioningPaint=this._transitionablePaint.transitioned(t,this._transitioningPaint);},e.prototype.hasTransition=function(){return this._transitioningPaint.hasTransition()},e.prototype.recalculate=function(t,e){t.getCrossfadeParameters&&(this._crossfadeParameters=t.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(t,void 0,e)),this.paint=this._transitioningPaint.possiblyEvaluate(t,void 0,e);},e.prototype.serialize=function(){var t={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(t.layout=t.layout||{},t.layout.visibility=this.visibility),b(t,(function(t,e){return !(void 0===t||"layout"===e&&!Object.keys(t).length||"paint"===e&&!Object.keys(t).length)}))},e.prototype._validate=function(t,e,r,n,i){return void 0===i&&(i={}),(!i||!1!==i.validate)&&Bn(this,t.call(Cn,{key:e,layerType:this.type,objectKey:r,value:n,styleSpec:Et,style:{glyphs:!0,sprite:!0}}))},e.prototype.is3D=function(){return !1},e.prototype.isTileClipped=function(){return !1},e.prototype.hasOffscreenPass=function(){return !1},e.prototype.resize=function(){},e.prototype.isStateDependent=function(){for(var t in this.paint._values){var e=this.paint.get(t);if(e instanceof yi&&Tr(e.property.specification)&&("source"===e.value.kind||"composite"===e.value.kind)&&e.value.isStateDependent)return !0}return !1},e}(Ct),Ai={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Si=function(t,e){this._structArray=t,this._pos1=e*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8;},ki=function(){this.isTransferred=!1,this.capacity=-1,this.resize(0);};function Ii(t,e){void 0===e&&(e=1);var r=0,n=0;return {members:t.map((function(t){var i=Ai[t.type].BYTES_PER_ELEMENT,a=r=zi(r,Math.max(e,i)),o=t.components||1;return n=Math.max(n,i),r+=i*o,{name:t.name,type:t.type,components:o,offset:a}})),size:zi(r,Math.max(n,e)),alignment:e}}function zi(t,e){return Math.ceil(t/e)*e}ki.serialize=function(t,e){return t._trim(),e&&(t.isTransferred=!0,e.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}},ki.deserialize=function(t){var e=Object.create(this.prototype);return e.arrayBuffer=t.arrayBuffer,e.length=t.length,e.capacity=t.arrayBuffer.byteLength/e.bytesPerElement,e._refreshViews(),e},ki.prototype._trim=function(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews());},ki.prototype.clear=function(){this.length=0;},ki.prototype.resize=function(t){this.reserve(t),this.length=t;},ki.prototype.reserve=function(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(5*this.capacity),128),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);var e=this.uint8;this._refreshViews(),e&&this.uint8.set(e);}},ki.prototype._refreshViews=function(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")};var Ci=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.int16[n+0]=e,this.int16[n+1]=r,t},e}(ki);Ci.prototype.bytesPerElement=4,On("StructArrayLayout2i4",Ci);var Ei=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=4*t;return this.int16[a+0]=e,this.int16[a+1]=r,this.int16[a+2]=n,this.int16[a+3]=i,t},e}(ki);Ei.prototype.bytesPerElement=8,On("StructArrayLayout4i8",Ei);var Pi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=6*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,this.int16[s+4]=a,this.int16[s+5]=o,t},e}(ki);Pi.prototype.bytesPerElement=12,On("StructArrayLayout2i4i12",Pi);var Mi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=4*t,u=8*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.uint8[u+4]=n,this.uint8[u+5]=i,this.uint8[u+6]=a,this.uint8[u+7]=o,t},e}(ki);Mi.prototype.bytesPerElement=8,On("StructArrayLayout2i4ub8",Mi);var Bi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.float32[n+0]=e,this.float32[n+1]=r,t},e}(ki);Bi.prototype.bytesPerElement=8,On("StructArrayLayout2f8",Bi);var Ti=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l){var p=this.length;return this.resize(p+1),this.emplace(p,t,e,r,n,i,a,o,s,u,l)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p){var c=10*t;return this.uint16[c+0]=e,this.uint16[c+1]=r,this.uint16[c+2]=n,this.uint16[c+3]=i,this.uint16[c+4]=a,this.uint16[c+5]=o,this.uint16[c+6]=s,this.uint16[c+7]=u,this.uint16[c+8]=l,this.uint16[c+9]=p,t},e}(ki);Ti.prototype.bytesPerElement=20,On("StructArrayLayout10ui20",Ti);var Vi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c){var h=this.length;return this.resize(h+1),this.emplace(h,t,e,r,n,i,a,o,s,u,l,p,c)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h){var f=12*t;return this.int16[f+0]=e,this.int16[f+1]=r,this.int16[f+2]=n,this.int16[f+3]=i,this.uint16[f+4]=a,this.uint16[f+5]=o,this.uint16[f+6]=s,this.uint16[f+7]=u,this.int16[f+8]=l,this.int16[f+9]=p,this.int16[f+10]=c,this.int16[f+11]=h,t},e}(ki);Vi.prototype.bytesPerElement=24,On("StructArrayLayout4i4ui4i24",Vi);var Fi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.float32[i+0]=e,this.float32[i+1]=r,this.float32[i+2]=n,t},e}(ki);Fi.prototype.bytesPerElement=12,On("StructArrayLayout3f12",Fi);var Di=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){return this.uint32[1*t+0]=e,t},e}(ki);Di.prototype.bytesPerElement=4,On("StructArrayLayout1ul4",Di);var Li=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u){var l=this.length;return this.resize(l+1),this.emplace(l,t,e,r,n,i,a,o,s,u)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l){var p=10*t,c=5*t;return this.int16[p+0]=e,this.int16[p+1]=r,this.int16[p+2]=n,this.int16[p+3]=i,this.int16[p+4]=a,this.int16[p+5]=o,this.uint32[c+3]=s,this.uint16[p+8]=u,this.uint16[p+9]=l,t},e}(ki);Li.prototype.bytesPerElement=20,On("StructArrayLayout6i1ul2ui20",Li);var Oi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=6*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,this.int16[s+4]=a,this.int16[s+5]=o,t},e}(ki);Oi.prototype.bytesPerElement=12,On("StructArrayLayout2i2i2i12",Oi);var Ri=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i){var a=this.length;return this.resize(a+1),this.emplace(a,t,e,r,n,i)},e.prototype.emplace=function(t,e,r,n,i,a){var o=4*t,s=8*t;return this.float32[o+0]=e,this.float32[o+1]=r,this.float32[o+2]=n,this.int16[s+6]=i,this.int16[s+7]=a,t},e}(ki);Ri.prototype.bytesPerElement=16,On("StructArrayLayout2f1f2i16",Ri);var Ui=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=12*t,o=3*t;return this.uint8[a+0]=e,this.uint8[a+1]=r,this.float32[o+1]=n,this.float32[o+2]=i,t},e}(ki);Ui.prototype.bytesPerElement=12,On("StructArrayLayout2ub2f12",Ui);var ji=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.uint16[i+0]=e,this.uint16[i+1]=r,this.uint16[i+2]=n,t},e}(ki);ji.prototype.bytesPerElement=6,On("StructArrayLayout3ui6",ji);var qi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m){var v=this.length;return this.resize(v+1),this.emplace(v,t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v){var g=24*t,x=12*t,b=48*t;return this.int16[g+0]=e,this.int16[g+1]=r,this.uint16[g+2]=n,this.uint16[g+3]=i,this.uint32[x+2]=a,this.uint32[x+3]=o,this.uint32[x+4]=s,this.uint16[g+10]=u,this.uint16[g+11]=l,this.uint16[g+12]=p,this.float32[x+7]=c,this.float32[x+8]=h,this.uint8[b+36]=f,this.uint8[b+37]=y,this.uint8[b+38]=d,this.uint32[x+10]=m,this.int16[g+22]=v,t},e}(ki);qi.prototype.bytesPerElement=48,On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",qi);var Ni=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,w,_,A,S,k,I,z){var C=this.length;return this.resize(C+1),this.emplace(C,t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,w,_,A,S,k,I,z)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,w,_,A,S,k,I,z,C){var E=34*t,P=17*t;return this.int16[E+0]=e,this.int16[E+1]=r,this.int16[E+2]=n,this.int16[E+3]=i,this.int16[E+4]=a,this.int16[E+5]=o,this.int16[E+6]=s,this.int16[E+7]=u,this.uint16[E+8]=l,this.uint16[E+9]=p,this.uint16[E+10]=c,this.uint16[E+11]=h,this.uint16[E+12]=f,this.uint16[E+13]=y,this.uint16[E+14]=d,this.uint16[E+15]=m,this.uint16[E+16]=v,this.uint16[E+17]=g,this.uint16[E+18]=x,this.uint16[E+19]=b,this.uint16[E+20]=w,this.uint16[E+21]=_,this.uint16[E+22]=A,this.uint32[P+12]=S,this.float32[P+13]=k,this.float32[P+14]=I,this.float32[P+15]=z,this.float32[P+16]=C,t},e}(ki);Ni.prototype.bytesPerElement=68,On("StructArrayLayout8i15ui1ul4f68",Ni);var Ki=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){return this.float32[1*t+0]=e,t},e}(ki);Ki.prototype.bytesPerElement=4,On("StructArrayLayout1f4",Ki);var Gi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.int16[i+0]=e,this.int16[i+1]=r,this.int16[i+2]=n,t},e}(ki);Gi.prototype.bytesPerElement=6,On("StructArrayLayout3i6",Gi);var Zi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=4*t;return this.uint32[2*t+0]=e,this.uint16[i+2]=r,this.uint16[i+3]=n,t},e}(ki);Zi.prototype.bytesPerElement=8,On("StructArrayLayout1ul2ui8",Zi);var Xi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.uint16[n+0]=e,this.uint16[n+1]=r,t},e}(ki);Xi.prototype.bytesPerElement=4,On("StructArrayLayout2ui4",Xi);var Ji=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){return this.uint16[1*t+0]=e,t},e}(ki);Ji.prototype.bytesPerElement=2,On("StructArrayLayout1ui2",Ji);var Hi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=4*t;return this.float32[a+0]=e,this.float32[a+1]=r,this.float32[a+2]=n,this.float32[a+3]=i,t},e}(ki);Hi.prototype.bytesPerElement=16,On("StructArrayLayout4f16",Hi);var Yi=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={anchorPointX:{configurable:!0},anchorPointY:{configurable:!0},x1:{configurable:!0},y1:{configurable:!0},x2:{configurable:!0},y2:{configurable:!0},featureIndex:{configurable:!0},sourceLayerIndex:{configurable:!0},bucketIndex:{configurable:!0},anchorPoint:{configurable:!0}};return r.anchorPointX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorPointY.get=function(){return this._structArray.int16[this._pos2+1]},r.x1.get=function(){return this._structArray.int16[this._pos2+2]},r.y1.get=function(){return this._structArray.int16[this._pos2+3]},r.x2.get=function(){return this._structArray.int16[this._pos2+4]},r.y2.get=function(){return this._structArray.int16[this._pos2+5]},r.featureIndex.get=function(){return this._structArray.uint32[this._pos4+3]},r.sourceLayerIndex.get=function(){return this._structArray.uint16[this._pos2+8]},r.bucketIndex.get=function(){return this._structArray.uint16[this._pos2+9]},r.anchorPoint.get=function(){return new i(this.anchorPointX,this.anchorPointY)},Object.defineProperties(e.prototype,r),e}(Si);Yi.prototype.size=20;var $i=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new Yi(this,t)},e}(Li);On("CollisionBoxArray",$i);var Wi=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={anchorX:{configurable:!0},anchorY:{configurable:!0},glyphStartIndex:{configurable:!0},numGlyphs:{configurable:!0},vertexStartIndex:{configurable:!0},lineStartIndex:{configurable:!0},lineLength:{configurable:!0},segment:{configurable:!0},lowerSize:{configurable:!0},upperSize:{configurable:!0},lineOffsetX:{configurable:!0},lineOffsetY:{configurable:!0},writingMode:{configurable:!0},placedOrientation:{configurable:!0},hidden:{configurable:!0},crossTileID:{configurable:!0},associatedIconIndex:{configurable:!0}};return r.anchorX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorY.get=function(){return this._structArray.int16[this._pos2+1]},r.glyphStartIndex.get=function(){return this._structArray.uint16[this._pos2+2]},r.numGlyphs.get=function(){return this._structArray.uint16[this._pos2+3]},r.vertexStartIndex.get=function(){return this._structArray.uint32[this._pos4+2]},r.lineStartIndex.get=function(){return this._structArray.uint32[this._pos4+3]},r.lineLength.get=function(){return this._structArray.uint32[this._pos4+4]},r.segment.get=function(){return this._structArray.uint16[this._pos2+10]},r.lowerSize.get=function(){return this._structArray.uint16[this._pos2+11]},r.upperSize.get=function(){return this._structArray.uint16[this._pos2+12]},r.lineOffsetX.get=function(){return this._structArray.float32[this._pos4+7]},r.lineOffsetY.get=function(){return this._structArray.float32[this._pos4+8]},r.writingMode.get=function(){return this._structArray.uint8[this._pos1+36]},r.placedOrientation.get=function(){return this._structArray.uint8[this._pos1+37]},r.placedOrientation.set=function(t){this._structArray.uint8[this._pos1+37]=t;},r.hidden.get=function(){return this._structArray.uint8[this._pos1+38]},r.hidden.set=function(t){this._structArray.uint8[this._pos1+38]=t;},r.crossTileID.get=function(){return this._structArray.uint32[this._pos4+10]},r.crossTileID.set=function(t){this._structArray.uint32[this._pos4+10]=t;},r.associatedIconIndex.get=function(){return this._structArray.int16[this._pos2+22]},Object.defineProperties(e.prototype,r),e}(Si);Wi.prototype.size=48;var Qi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new Wi(this,t)},e}(qi);On("PlacedSymbolArray",Qi);var ta=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={anchorX:{configurable:!0},anchorY:{configurable:!0},rightJustifiedTextSymbolIndex:{configurable:!0},centerJustifiedTextSymbolIndex:{configurable:!0},leftJustifiedTextSymbolIndex:{configurable:!0},verticalPlacedTextSymbolIndex:{configurable:!0},placedIconSymbolIndex:{configurable:!0},verticalPlacedIconSymbolIndex:{configurable:!0},key:{configurable:!0},textBoxStartIndex:{configurable:!0},textBoxEndIndex:{configurable:!0},verticalTextBoxStartIndex:{configurable:!0},verticalTextBoxEndIndex:{configurable:!0},iconBoxStartIndex:{configurable:!0},iconBoxEndIndex:{configurable:!0},verticalIconBoxStartIndex:{configurable:!0},verticalIconBoxEndIndex:{configurable:!0},featureIndex:{configurable:!0},numHorizontalGlyphVertices:{configurable:!0},numVerticalGlyphVertices:{configurable:!0},numIconVertices:{configurable:!0},numVerticalIconVertices:{configurable:!0},useRuntimeCollisionCircles:{configurable:!0},crossTileID:{configurable:!0},textBoxScale:{configurable:!0},textOffset0:{configurable:!0},textOffset1:{configurable:!0},collisionCircleDiameter:{configurable:!0}};return r.anchorX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorY.get=function(){return this._structArray.int16[this._pos2+1]},r.rightJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+2]},r.centerJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+3]},r.leftJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+4]},r.verticalPlacedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+5]},r.placedIconSymbolIndex.get=function(){return this._structArray.int16[this._pos2+6]},r.verticalPlacedIconSymbolIndex.get=function(){return this._structArray.int16[this._pos2+7]},r.key.get=function(){return this._structArray.uint16[this._pos2+8]},r.textBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+9]},r.textBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+10]},r.verticalTextBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+11]},r.verticalTextBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+12]},r.iconBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+13]},r.iconBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+14]},r.verticalIconBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+15]},r.verticalIconBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+16]},r.featureIndex.get=function(){return this._structArray.uint16[this._pos2+17]},r.numHorizontalGlyphVertices.get=function(){return this._structArray.uint16[this._pos2+18]},r.numVerticalGlyphVertices.get=function(){return this._structArray.uint16[this._pos2+19]},r.numIconVertices.get=function(){return this._structArray.uint16[this._pos2+20]},r.numVerticalIconVertices.get=function(){return this._structArray.uint16[this._pos2+21]},r.useRuntimeCollisionCircles.get=function(){return this._structArray.uint16[this._pos2+22]},r.crossTileID.get=function(){return this._structArray.uint32[this._pos4+12]},r.crossTileID.set=function(t){this._structArray.uint32[this._pos4+12]=t;},r.textBoxScale.get=function(){return this._structArray.float32[this._pos4+13]},r.textOffset0.get=function(){return this._structArray.float32[this._pos4+14]},r.textOffset1.get=function(){return this._structArray.float32[this._pos4+15]},r.collisionCircleDiameter.get=function(){return this._structArray.float32[this._pos4+16]},Object.defineProperties(e.prototype,r),e}(Si);ta.prototype.size=68;var ea=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new ta(this,t)},e}(Ni);On("SymbolInstanceArray",ea);var ra=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getoffsetX=function(t){return this.float32[1*t+0]},e}(Ki);On("GlyphOffsetArray",ra);var na=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getx=function(t){return this.int16[3*t+0]},e.prototype.gety=function(t){return this.int16[3*t+1]},e.prototype.gettileUnitDistanceFromAnchor=function(t){return this.int16[3*t+2]},e}(Gi);On("SymbolLineVertexArray",na);var ia=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={featureIndex:{configurable:!0},sourceLayerIndex:{configurable:!0},bucketIndex:{configurable:!0}};return r.featureIndex.get=function(){return this._structArray.uint32[this._pos4+0]},r.sourceLayerIndex.get=function(){return this._structArray.uint16[this._pos2+2]},r.bucketIndex.get=function(){return this._structArray.uint16[this._pos2+3]},Object.defineProperties(e.prototype,r),e}(Si);ia.prototype.size=8;var aa=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new ia(this,t)},e}(Zi);On("FeatureIndexArray",aa);var oa=Ii([{name:"a_pos",components:2,type:"Int16"}],4).members,sa=function(t){void 0===t&&(t=[]),this.segments=t;};function ua(t,e){return 256*(t=p(Math.floor(t),0,255))+p(Math.floor(e),0,255)}sa.prototype.prepareSegment=function(t,e,r,n){var i=this.segments[this.segments.length-1];return t>sa.MAX_VERTEX_ARRAY_LENGTH&&A("Max vertices per segment is "+sa.MAX_VERTEX_ARRAY_LENGTH+": bucket requested "+t),(!i||i.vertexLength+t>sa.MAX_VERTEX_ARRAY_LENGTH||i.sortKey!==n)&&(i={vertexOffset:e.length,primitiveOffset:r.length,vertexLength:0,primitiveLength:0},void 0!==n&&(i.sortKey=n),this.segments.push(i)),i},sa.prototype.get=function(){return this.segments},sa.prototype.destroy=function(){for(var t=0,e=this.segments;t<e.length;t+=1){var r=e[t];for(var n in r.vaos)r.vaos[n].destroy();}},sa.simpleSegment=function(t,e,r,n){return new sa([{vertexOffset:t,primitiveOffset:e,vertexLength:r,primitiveLength:n,vaos:{},sortKey:0}])},sa.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1,On("SegmentVector",sa);var la=Ii([{name:"a_pattern_from",components:4,type:"Uint16"},{name:"a_pattern_to",components:4,type:"Uint16"},{name:"a_pixel_ratio_from",components:1,type:"Uint16"},{name:"a_pixel_ratio_to",components:1,type:"Uint16"}]),pa=e((function(t){t.exports=function(t,e){var r,n,i,a,o,s,u,l;for(n=t.length-(r=3&t.length),i=e,o=3432918353,s=461845907,l=0;l<n;)u=255&t.charCodeAt(l)|(255&t.charCodeAt(++l))<<8|(255&t.charCodeAt(++l))<<16|(255&t.charCodeAt(++l))<<24,++l,i=27492+(65535&(a=5*(65535&(i=(i^=u=(65535&(u=(u=(65535&u)*o+(((u>>>16)*o&65535)<<16)&4294967295)<<15|u>>>17))*s+(((u>>>16)*s&65535)<<16)&4294967295)<<13|i>>>19))+((5*(i>>>16)&65535)<<16)&4294967295))+((58964+(a>>>16)&65535)<<16);switch(u=0,r){case 3:u^=(255&t.charCodeAt(l+2))<<16;case 2:u^=(255&t.charCodeAt(l+1))<<8;case 1:i^=u=(65535&(u=(u=(65535&(u^=255&t.charCodeAt(l)))*o+(((u>>>16)*o&65535)<<16)&4294967295)<<15|u>>>17))*s+(((u>>>16)*s&65535)<<16)&4294967295;}return i^=t.length,i=2246822507*(65535&(i^=i>>>16))+((2246822507*(i>>>16)&65535)<<16)&4294967295,i=3266489909*(65535&(i^=i>>>13))+((3266489909*(i>>>16)&65535)<<16)&4294967295,(i^=i>>>16)>>>0};})),ca=e((function(t){t.exports=function(t,e){for(var r,n=t.length,i=e^n,a=0;n>=4;)r=1540483477*(65535&(r=255&t.charCodeAt(a)|(255&t.charCodeAt(++a))<<8|(255&t.charCodeAt(++a))<<16|(255&t.charCodeAt(++a))<<24))+((1540483477*(r>>>16)&65535)<<16),i=1540483477*(65535&i)+((1540483477*(i>>>16)&65535)<<16)^(r=1540483477*(65535&(r^=r>>>24))+((1540483477*(r>>>16)&65535)<<16)),n-=4,++a;switch(n){case 3:i^=(255&t.charCodeAt(a+2))<<16;case 2:i^=(255&t.charCodeAt(a+1))<<8;case 1:i=1540483477*(65535&(i^=255&t.charCodeAt(a)))+((1540483477*(i>>>16)&65535)<<16);}return i=1540483477*(65535&(i^=i>>>13))+((1540483477*(i>>>16)&65535)<<16),(i^=i>>>15)>>>0};})),ha=pa,fa=ca;ha.murmur3=pa,ha.murmur2=fa;var ya=function(){this.ids=[],this.positions=[],this.indexed=!1;};ya.prototype.add=function(t,e,r,n){this.ids.push(ma(t)),this.positions.push(e,r,n);},ya.prototype.getPositions=function(t){for(var e=ma(t),r=0,n=this.ids.length-1;r<n;){var i=r+n>>1;this.ids[i]>=e?n=i:r=i+1;}for(var a=[];this.ids[r]===e;)a.push({index:this.positions[3*r],start:this.positions[3*r+1],end:this.positions[3*r+2]}),r++;return a},ya.serialize=function(t,e){var r=new Float64Array(t.ids),n=new Uint32Array(t.positions);return function t(e,r,n,i){for(;n<i;){for(var a=e[n+i>>1],o=n-1,s=i+1;;){do{o++;}while(e[o]<a);do{s--;}while(e[s]>a);if(o>=s)break;va(e,o,s),va(r,3*o,3*s),va(r,3*o+1,3*s+1),va(r,3*o+2,3*s+2);}s-n<i-s?(t(e,r,n,s),n=s+1):(t(e,r,s+1,i),i=s);}}(r,n,0,r.length-1),e&&e.push(r.buffer,n.buffer),{ids:r,positions:n}},ya.deserialize=function(t){var e=new ya;return e.ids=t.ids,e.positions=t.positions,e.indexed=!0,e};var da=Math.pow(2,53)-1;function ma(t){var e=+t;return !isNaN(e)&&e<=da?e:ha(String(t))}function va(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}On("FeaturePositionMap",ya);var ga=function(t,e){this.gl=t.gl,this.location=e;},xa=function(t){function e(e,r){t.call(this,e,r),this.current=0;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){this.current!==t&&(this.current=t,this.gl.uniform1i(this.location,t));},e}(ga),ba=function(t){function e(e,r){t.call(this,e,r),this.current=0;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){this.current!==t&&(this.current=t,this.gl.uniform1f(this.location,t));},e}(ga),wa=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0];}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]||(this.current=t,this.gl.uniform2f(this.location,t[0],t[1]));},e}(ga),_a=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0,0];}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]&&t[2]===this.current[2]||(this.current=t,this.gl.uniform3f(this.location,t[0],t[1],t[2]));},e}(ga),Aa=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0,0,0];}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]&&t[2]===this.current[2]&&t[3]===this.current[3]||(this.current=t,this.gl.uniform4f(this.location,t[0],t[1],t[2],t[3]));},e}(ga),Sa=function(t){function e(e,r){t.call(this,e,r),this.current=te.transparent;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t.r===this.current.r&&t.g===this.current.g&&t.b===this.current.b&&t.a===this.current.a||(this.current=t,this.gl.uniform4f(this.location,t.r,t.g,t.b,t.a));},e}(ga),ka=new Float32Array(16),Ia=function(t){function e(e,r){t.call(this,e,r),this.current=ka;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){if(t[12]!==this.current[12]||t[0]!==this.current[0])return this.current=t,void this.gl.uniformMatrix4fv(this.location,!1,t);for(var e=1;e<16;e++)if(t[e]!==this.current[e]){this.current=t,this.gl.uniformMatrix4fv(this.location,!1,t);break}},e}(ga);function za(t){return [ua(255*t.r,255*t.g),ua(255*t.b,255*t.a)]}var Ca=function(t,e,r){this.value=t,this.uniformNames=e.map((function(t){return "u_"+t})),this.type=r;};Ca.prototype.setUniform=function(t,e,r){t.set(r.constantOr(this.value));},Ca.prototype.getBinding=function(t,e,r){return "color"===this.type?new Sa(t,e):new ba(t,e)};var Ea=function(t,e){this.uniformNames=e.map((function(t){return "u_"+t})),this.patternFrom=null,this.patternTo=null,this.pixelRatioFrom=1,this.pixelRatioTo=1;};Ea.prototype.setConstantPatternPositions=function(t,e){this.pixelRatioFrom=e.pixelRatio,this.pixelRatioTo=t.pixelRatio,this.patternFrom=e.tlbr,this.patternTo=t.tlbr;},Ea.prototype.setUniform=function(t,e,r,n){var i="u_pattern_to"===n?this.patternTo:"u_pattern_from"===n?this.patternFrom:"u_pixel_ratio_to"===n?this.pixelRatioTo:"u_pixel_ratio_from"===n?this.pixelRatioFrom:null;i&&t.set(i);},Ea.prototype.getBinding=function(t,e,r){return "u_pattern"===r.substr(0,9)?new Aa(t,e):new ba(t,e)};var Pa=function(t,e,r,n){this.expression=t,this.type=r,this.maxValue=0,this.paintVertexAttributes=e.map((function(t){return {name:"a_"+t,type:"Float32",components:"color"===r?2:1,offset:0}})),this.paintVertexArray=new n;};Pa.prototype.populatePaintArray=function(t,e,r,n,i){var a=this.paintVertexArray.length,o=this.expression.evaluate(new si(0),e,{},n,[],i);this.paintVertexArray.resize(t),this._setPaintValue(a,t,o);},Pa.prototype.updatePaintArray=function(t,e,r,n){var i=this.expression.evaluate({zoom:0},r,n);this._setPaintValue(t,e,i);},Pa.prototype._setPaintValue=function(t,e,r){if("color"===this.type)for(var n=za(r),i=t;i<e;i++)this.paintVertexArray.emplace(i,n[0],n[1]);else {for(var a=t;a<e;a++)this.paintVertexArray.emplace(a,r);this.maxValue=Math.max(this.maxValue,Math.abs(r));}},Pa.prototype.upload=function(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));},Pa.prototype.destroy=function(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();};var Ma=function(t,e,r,n,i,a){this.expression=t,this.uniformNames=e.map((function(t){return "u_"+t+"_t"})),this.type=r,this.useIntegerZoom=n,this.zoom=i,this.maxValue=0,this.paintVertexAttributes=e.map((function(t){return {name:"a_"+t,type:"Float32",components:"color"===r?4:2,offset:0}})),this.paintVertexArray=new a;};Ma.prototype.populatePaintArray=function(t,e,r,n,i){var a=this.expression.evaluate(new si(this.zoom),e,{},n,[],i),o=this.expression.evaluate(new si(this.zoom+1),e,{},n,[],i),s=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValue(s,t,a,o);},Ma.prototype.updatePaintArray=function(t,e,r,n){var i=this.expression.evaluate({zoom:this.zoom},r,n),a=this.expression.evaluate({zoom:this.zoom+1},r,n);this._setPaintValue(t,e,i,a);},Ma.prototype._setPaintValue=function(t,e,r,n){if("color"===this.type)for(var i=za(r),a=za(n),o=t;o<e;o++)this.paintVertexArray.emplace(o,i[0],i[1],a[0],a[1]);else {for(var s=t;s<e;s++)this.paintVertexArray.emplace(s,r,n);this.maxValue=Math.max(this.maxValue,Math.abs(r),Math.abs(n));}},Ma.prototype.upload=function(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));},Ma.prototype.destroy=function(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();},Ma.prototype.setUniform=function(t,e){var r=this.useIntegerZoom?Math.floor(e.zoom):e.zoom,n=p(this.expression.interpolationFactor(r,this.zoom,this.zoom+1),0,1);t.set(n);},Ma.prototype.getBinding=function(t,e,r){return new ba(t,e)};var Ba=function(t,e,r,n,i,a){this.expression=t,this.type=e,this.useIntegerZoom=r,this.zoom=n,this.layerId=a,this.zoomInPaintVertexArray=new i,this.zoomOutPaintVertexArray=new i;};Ba.prototype.populatePaintArray=function(t,e,r){var n=this.zoomInPaintVertexArray.length;this.zoomInPaintVertexArray.resize(t),this.zoomOutPaintVertexArray.resize(t),this._setPaintValues(n,t,e.patterns&&e.patterns[this.layerId],r);},Ba.prototype.updatePaintArray=function(t,e,r,n,i){this._setPaintValues(t,e,r.patterns&&r.patterns[this.layerId],i);},Ba.prototype._setPaintValues=function(t,e,r,n){if(n&&r){var i=n[r.min],a=n[r.mid],o=n[r.max];if(i&&a&&o)for(var s=t;s<e;s++)this.zoomInPaintVertexArray.emplace(s,a.tl[0],a.tl[1],a.br[0],a.br[1],i.tl[0],i.tl[1],i.br[0],i.br[1],a.pixelRatio,i.pixelRatio),this.zoomOutPaintVertexArray.emplace(s,a.tl[0],a.tl[1],a.br[0],a.br[1],o.tl[0],o.tl[1],o.br[0],o.br[1],a.pixelRatio,o.pixelRatio);}},Ba.prototype.upload=function(t){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=t.createVertexBuffer(this.zoomInPaintVertexArray,la.members,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=t.createVertexBuffer(this.zoomOutPaintVertexArray,la.members,this.expression.isStateDependent));},Ba.prototype.destroy=function(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy();};var Ta=function(t,e,r){this.binders={},this._buffers=[];var n=[];for(var i in t.paint._values)if(r(i)){var a=t.paint.get(i);if(a instanceof yi&&Tr(a.property.specification)){var o=Fa(i,t.type),s=a.value,u=a.property.specification.type,l=a.property.useIntegerZoom,p=a.property.specification["property-type"],c="cross-faded"===p||"cross-faded-data-driven"===p;if("constant"===s.kind)this.binders[i]=c?new Ea(s.value,o):new Ca(s.value,o,u),n.push("/u_"+i);else if("source"===s.kind||c){var h=Da(i,u,"source");this.binders[i]=c?new Ba(s,u,l,e,h,t.id):new Pa(s,o,u,h),n.push("/a_"+i);}else {var f=Da(i,u,"composite");this.binders[i]=new Ma(s,o,u,l,e,f),n.push("/z_"+i);}}}this.cacheKey=n.sort().join("");};Ta.prototype.getMaxValue=function(t){var e=this.binders[t];return e instanceof Pa||e instanceof Ma?e.maxValue:0},Ta.prototype.populatePaintArrays=function(t,e,r,n,i){for(var a in this.binders){var o=this.binders[a];(o instanceof Pa||o instanceof Ma||o instanceof Ba)&&o.populatePaintArray(t,e,r,n,i);}},Ta.prototype.setConstantPatternPositions=function(t,e){for(var r in this.binders){var n=this.binders[r];n instanceof Ea&&n.setConstantPatternPositions(t,e);}},Ta.prototype.updatePaintArrays=function(t,e,r,n,i){var a=!1;for(var o in t)for(var s=0,u=e.getPositions(o);s<u.length;s+=1){var l=u[s],p=r.feature(l.index);for(var c in this.binders){var h=this.binders[c];if((h instanceof Pa||h instanceof Ma||h instanceof Ba)&&!0===h.expression.isStateDependent){var f=n.paint.get(c);h.expression=f.value,h.updatePaintArray(l.start,l.end,p,t[o],i),a=!0;}}}return a},Ta.prototype.defines=function(){var t=[];for(var e in this.binders){var r=this.binders[e];(r instanceof Ca||r instanceof Ea)&&t.push.apply(t,r.uniformNames.map((function(t){return "#define HAS_UNIFORM_"+t})));}return t},Ta.prototype.getBinderAttributes=function(){var t=[];for(var e in this.binders){var r=this.binders[e];if(r instanceof Pa||r instanceof Ma)for(var n=0;n<r.paintVertexAttributes.length;n++)t.push(r.paintVertexAttributes[n].name);else if(r instanceof Ba)for(var i=0;i<la.members.length;i++)t.push(la.members[i].name);}return t},Ta.prototype.getBinderUniforms=function(){var t=[];for(var e in this.binders){var r=this.binders[e];if(r instanceof Ca||r instanceof Ea||r instanceof Ma)for(var n=0,i=r.uniformNames;n<i.length;n+=1)t.push(i[n]);}return t},Ta.prototype.getPaintVertexBuffers=function(){return this._buffers},Ta.prototype.getUniforms=function(t,e){var r=[];for(var n in this.binders){var i=this.binders[n];if(i instanceof Ca||i instanceof Ea||i instanceof Ma)for(var a=0,o=i.uniformNames;a<o.length;a+=1){var s=o[a];if(e[s]){var u=i.getBinding(t,e[s],s);r.push({name:s,property:n,binding:u});}}}return r},Ta.prototype.setUniforms=function(t,e,r,n){for(var i=0,a=e;i<a.length;i+=1){var o=a[i],s=o.name,u=o.property;this.binders[u].setUniform(o.binding,n,r.get(u),s);}},Ta.prototype.updatePaintBuffers=function(t){for(var e in this._buffers=[],this.binders){var r=this.binders[e];if(t&&r instanceof Ba){var n=2===t.fromScale?r.zoomInPaintVertexBuffer:r.zoomOutPaintVertexBuffer;n&&this._buffers.push(n);}else (r instanceof Pa||r instanceof Ma)&&r.paintVertexBuffer&&this._buffers.push(r.paintVertexBuffer);}},Ta.prototype.upload=function(t){for(var e in this.binders){var r=this.binders[e];(r instanceof Pa||r instanceof Ma||r instanceof Ba)&&r.upload(t);}this.updatePaintBuffers();},Ta.prototype.destroy=function(){for(var t in this.binders){var e=this.binders[t];(e instanceof Pa||e instanceof Ma||e instanceof Ba)&&e.destroy();}};var Va=function(t,e,r){void 0===r&&(r=function(){return !0}),this.programConfigurations={};for(var n=0,i=t;n<i.length;n+=1){var a=i[n];this.programConfigurations[a.id]=new Ta(a,e,r);}this.needsUpload=!1,this._featureMap=new ya,this._bufferOffset=0;};function Fa(t,e){return {"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-extrusion-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"]}[t]||[t.replace(e+"-","").replace(/-/g,"_")]}function Da(t,e,r){var n={color:{source:Bi,composite:Hi},number:{source:Ki,composite:Bi}},i=function(t){return {"line-pattern":{source:Ti,composite:Ti},"fill-pattern":{source:Ti,composite:Ti},"fill-extrusion-pattern":{source:Ti,composite:Ti}}[t]}(t);return i&&i[r]||n[e][r]}Va.prototype.populatePaintArrays=function(t,e,r,n,i,a){for(var o in this.programConfigurations)this.programConfigurations[o].populatePaintArrays(t,e,n,i,a);void 0!==e.id&&this._featureMap.add(e.id,r,this._bufferOffset,t),this._bufferOffset=t,this.needsUpload=!0;},Va.prototype.updatePaintArrays=function(t,e,r,n){for(var i=0,a=r;i<a.length;i+=1){var o=a[i];this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(t,this._featureMap,e,o,n)||this.needsUpload;}},Va.prototype.get=function(t){return this.programConfigurations[t]},Va.prototype.upload=function(t){if(this.needsUpload){for(var e in this.programConfigurations)this.programConfigurations[e].upload(t);this.needsUpload=!1;}},Va.prototype.destroy=function(){for(var t in this.programConfigurations)this.programConfigurations[t].destroy();},On("ConstantBinder",Ca),On("CrossFadedConstantBinder",Ea),On("SourceExpressionBinder",Pa),On("CrossFadedCompositeBinder",Ba),On("CompositeExpressionBinder",Ma),On("ProgramConfiguration",Ta,{omit:["_buffers"]}),On("ProgramConfigurationSet",Va);var La=Math.pow(2,14)-1,Oa=-La-1;function Ra(t){for(var e=8192/t.extent,r=t.loadGeometry(),n=0;n<r.length;n++)for(var i=r[n],a=0;a<i.length;a++){var o=i[a],s=Math.round(o.x*e),u=Math.round(o.y*e);o.x=p(s,Oa,La),o.y=p(u,Oa,La),(s<o.x||s>o.x+1||u<o.y||u>o.y+1)&&A("Geometry exceeds allowed extent, reduce your vector tile buffer size");}return r}function Ua(t,e){return {type:t.type,id:t.id,properties:t.properties,geometry:e?Ra(t):[]}}function ja(t,e,r,n,i){t.emplaceBack(2*e+(n+1)/2,2*r+(i+1)/2);}var qa=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new Ci,this.indexArray=new ji,this.segments=new sa,this.programConfigurations=new Va(t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};function Na(t,e){for(var r=0;r<t.length;r++)if(Wa(e,t[r]))return !0;for(var n=0;n<e.length;n++)if(Wa(t,e[n]))return !0;return !!Xa(t,e)}function Ka(t,e,r){return !!Wa(t,e)||!!Ha(e,t,r)}function Ga(t,e){if(1===t.length)return $a(e,t[0]);for(var r=0;r<e.length;r++)for(var n=e[r],i=0;i<n.length;i++)if(Wa(t,n[i]))return !0;for(var a=0;a<t.length;a++)if($a(e,t[a]))return !0;for(var o=0;o<e.length;o++)if(Xa(t,e[o]))return !0;return !1}function Za(t,e,r){if(t.length>1){if(Xa(t,e))return !0;for(var n=0;n<e.length;n++)if(Ha(e[n],t,r))return !0}for(var i=0;i<t.length;i++)if(Ha(t[i],e,r))return !0;return !1}function Xa(t,e){if(0===t.length||0===e.length)return !1;for(var r=0;r<t.length-1;r++)for(var n=t[r],i=t[r+1],a=0;a<e.length-1;a++)if(Ja(n,i,e[a],e[a+1]))return !0;return !1}function Ja(t,e,r,n){return S(t,r,n)!==S(e,r,n)&&S(t,e,r)!==S(t,e,n)}function Ha(t,e,r){var n=r*r;if(1===e.length)return t.distSqr(e[0])<n;for(var i=1;i<e.length;i++)if(Ya(t,e[i-1],e[i])<n)return !0;return !1}function Ya(t,e,r){var n=e.distSqr(r);if(0===n)return t.distSqr(e);var i=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y))/n;return t.distSqr(i<0?e:i>1?r:r.sub(e)._mult(i)._add(e))}function $a(t,e){for(var r,n,i,a=!1,o=0;o<t.length;o++)for(var s=0,u=(r=t[o]).length-1;s<r.length;u=s++)(n=r[s]).y>e.y!=(i=r[u]).y>e.y&&e.x<(i.x-n.x)*(e.y-n.y)/(i.y-n.y)+n.x&&(a=!a);return a}function Wa(t,e){for(var r=!1,n=0,i=t.length-1;n<t.length;i=n++){var a=t[n],o=t[i];a.y>e.y!=o.y>e.y&&e.x<(o.x-a.x)*(e.y-a.y)/(o.y-a.y)+a.x&&(r=!r);}return r}function Qa(t,e,r){var n=r[0],i=r[2];if(t.x<n.x&&e.x<n.x||t.x>i.x&&e.x>i.x||t.y<n.y&&e.y<n.y||t.y>i.y&&e.y>i.y)return !1;var a=S(t,e,r[0]);return a!==S(t,e,r[1])||a!==S(t,e,r[2])||a!==S(t,e,r[3])}function to(t,e,r){var n=e.paint.get(t).value;return "constant"===n.kind?n.value:r.programConfigurations.get(e.id).getMaxValue(t)}function eo(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function ro(t,e,r,n,a){if(!e[0]&&!e[1])return t;var o=i.convert(e)._mult(a);"viewport"===r&&o._rotate(-n);for(var s=[],u=0;u<t.length;u++)s.push(t[u].sub(o));return s}qa.prototype.populate=function(t,e,r){var n=this.layers[0],i=[],a=null;"circle"===n.type&&(a=n.layout.get("circle-sort-key"));for(var o=0,s=t;o<s.length;o+=1){var u=s[o],l=u.feature,p=u.id,c=u.index,h=u.sourceLayerIndex,f=this.layers[0]._featureFilter.needGeometry,y=Ua(l,f);if(this.layers[0]._featureFilter.filter(new si(this.zoom),y,r)){var d=a?a.evaluate(y,{},r):void 0,m={id:p,properties:l.properties,type:l.type,sourceLayerIndex:h,index:c,geometry:f?y.geometry:Ra(l),patterns:{},sortKey:d};i.push(m);}}a&&i.sort((function(t,e){return t.sortKey-e.sortKey}));for(var v=0,g=i;v<g.length;v+=1){var x=g[v],b=x.geometry,w=x.index,_=x.sourceLayerIndex,A=t[w].feature;this.addFeature(x,b,w,r),e.featureIndex.insert(A,b,w,_,this.index);}},qa.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},qa.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},qa.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},qa.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,oa),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},qa.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},qa.prototype.addFeature=function(t,e,r,n){for(var i=0,a=e;i<a.length;i+=1)for(var o=0,s=a[i];o<s.length;o+=1){var u=s[o],l=u.x,p=u.y;if(!(l<0||l>=8192||p<0||p>=8192)){var c=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),h=c.vertexLength;ja(this.layoutVertexArray,l,p,-1,-1),ja(this.layoutVertexArray,l,p,1,-1),ja(this.layoutVertexArray,l,p,1,1),ja(this.layoutVertexArray,l,p,-1,1),this.indexArray.emplaceBack(h,h+1,h+2),this.indexArray.emplaceBack(h,h+3,h+2),c.vertexLength+=4,c.primitiveLength+=2;}}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,{},n);},On("CircleBucket",qa,{omit:["layers"]});var no=new wi({"circle-sort-key":new vi(Et.layout_circle["circle-sort-key"])}),io={paint:new wi({"circle-radius":new vi(Et.paint_circle["circle-radius"]),"circle-color":new vi(Et.paint_circle["circle-color"]),"circle-blur":new vi(Et.paint_circle["circle-blur"]),"circle-opacity":new vi(Et.paint_circle["circle-opacity"]),"circle-translate":new mi(Et.paint_circle["circle-translate"]),"circle-translate-anchor":new mi(Et.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new mi(Et.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new mi(Et.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new vi(Et.paint_circle["circle-stroke-width"]),"circle-stroke-color":new vi(Et.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new vi(Et.paint_circle["circle-stroke-opacity"])}),layout:no},ao="undefined"!=typeof Float32Array?Float32Array:Array;function oo(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function so(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],l=e[6],p=e[7],c=e[8],h=e[9],f=e[10],y=e[11],d=e[12],m=e[13],v=e[14],g=e[15],x=r[0],b=r[1],w=r[2],_=r[3];return t[0]=x*n+b*s+w*c+_*d,t[1]=x*i+b*u+w*h+_*m,t[2]=x*a+b*l+w*f+_*v,t[3]=x*o+b*p+w*y+_*g,t[4]=(x=r[4])*n+(b=r[5])*s+(w=r[6])*c+(_=r[7])*d,t[5]=x*i+b*u+w*h+_*m,t[6]=x*a+b*l+w*f+_*v,t[7]=x*o+b*p+w*y+_*g,t[8]=(x=r[8])*n+(b=r[9])*s+(w=r[10])*c+(_=r[11])*d,t[9]=x*i+b*u+w*h+_*m,t[10]=x*a+b*l+w*f+_*v,t[11]=x*o+b*p+w*y+_*g,t[12]=(x=r[12])*n+(b=r[13])*s+(w=r[14])*c+(_=r[15])*d,t[13]=x*i+b*u+w*h+_*m,t[14]=x*a+b*l+w*f+_*v,t[15]=x*o+b*p+w*y+_*g,t}Math.hypot||(Math.hypot=function(){for(var t=arguments,e=0,r=arguments.length;r--;)e+=t[r]*t[r];return Math.sqrt(e)});var uo,lo=so;function po(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*a+r[12]*o,t[1]=r[1]*n+r[5]*i+r[9]*a+r[13]*o,t[2]=r[2]*n+r[6]*i+r[10]*a+r[14]*o,t[3]=r[3]*n+r[7]*i+r[11]*a+r[15]*o,t}uo=new ao(3),ao!=Float32Array&&(uo[0]=0,uo[1]=0,uo[2]=0),function(){var t=new ao(4);ao!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0);}();var co=(function(){var t=new ao(2);ao!=Float32Array&&(t[0]=0,t[1]=0);}(),function(t){function e(e){t.call(this,e,io);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.createBucket=function(t){return new qa(t)},e.prototype.queryRadius=function(t){var e=t;return to("circle-radius",this,e)+to("circle-stroke-width",this,e)+eo(this.paint.get("circle-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,i,a,o,s){for(var u=ro(t,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),a.angle,o),l=this.paint.get("circle-radius").evaluate(e,r)+this.paint.get("circle-stroke-width").evaluate(e,r),p="map"===this.paint.get("circle-pitch-alignment"),c=p?u:function(t,e){return t.map((function(t){return ho(t,e)}))}(u,s),h=p?l*o:l,f=0,y=n;f<y.length;f+=1)for(var d=0,m=y[f];d<m.length;d+=1){var v=m[d],g=p?v:ho(v,s),x=h,b=po([],[v.x,v.y,0,1],s);if("viewport"===this.paint.get("circle-pitch-scale")&&"map"===this.paint.get("circle-pitch-alignment")?x*=b[3]/a.cameraToCenterDistance:"map"===this.paint.get("circle-pitch-scale")&&"viewport"===this.paint.get("circle-pitch-alignment")&&(x*=a.cameraToCenterDistance/b[3]),Ka(c,g,x))return !0}return !1},e}(_i));function ho(t,e){var r=po([],[t.x,t.y,0,1],e);return new i(r[0]/r[3],r[1]/r[3])}var fo=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(qa);function yo(t,e,r,n){var i=e.width,a=e.height;if(n){if(n instanceof Uint8ClampedArray)n=new Uint8Array(n.buffer);else if(n.length!==i*a*r)throw new RangeError("mismatched image size")}else n=new Uint8Array(i*a*r);return t.width=i,t.height=a,t.data=n,t}function mo(t,e,r){var n=e.width,i=e.height;if(n!==t.width||i!==t.height){var a=yo({},{width:n,height:i},r);vo(t,a,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,n),height:Math.min(t.height,i)},r),t.width=n,t.height=i,t.data=a.data;}}function vo(t,e,r,n,i,a){if(0===i.width||0===i.height)return e;if(i.width>t.width||i.height>t.height||r.x>t.width-i.width||r.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>e.width||i.height>e.height||n.x>e.width-i.width||n.y>e.height-i.height)throw new RangeError("out of range destination coordinates for image copy");for(var o=t.data,s=e.data,u=0;u<i.height;u++)for(var l=((r.y+u)*t.width+r.x)*a,p=((n.y+u)*e.width+n.x)*a,c=0;c<i.width*a;c++)s[p+c]=o[l+c];return e}On("HeatmapBucket",fo,{omit:["layers"]});var go=function(t,e){yo(this,t,1,e);};go.prototype.resize=function(t){mo(this,t,1);},go.prototype.clone=function(){return new go({width:this.width,height:this.height},new Uint8Array(this.data))},go.copy=function(t,e,r,n,i){vo(t,e,r,n,i,1);};var xo=function(t,e){yo(this,t,4,e);};xo.prototype.resize=function(t){mo(this,t,4);},xo.prototype.replace=function(t,e){e?this.data.set(t):this.data=t instanceof Uint8ClampedArray?new Uint8Array(t.buffer):t;},xo.prototype.clone=function(){return new xo({width:this.width,height:this.height},new Uint8Array(this.data))},xo.copy=function(t,e,r,n,i){vo(t,e,r,n,i,4);},On("AlphaImage",go),On("RGBAImage",xo);var bo={paint:new wi({"heatmap-radius":new vi(Et.paint_heatmap["heatmap-radius"]),"heatmap-weight":new vi(Et.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new mi(Et.paint_heatmap["heatmap-intensity"]),"heatmap-color":new bi(Et.paint_heatmap["heatmap-color"]),"heatmap-opacity":new mi(Et.paint_heatmap["heatmap-opacity"])})};function wo(t){var e={},r=t.resolution||256,n=t.clips?t.clips.length:1,i=t.image||new xo({width:r,height:n}),a=function(r,n,a){e[t.evaluationKey]=a;var o=t.expression.evaluate(e);i.data[r+n+0]=Math.floor(255*o.r/o.a),i.data[r+n+1]=Math.floor(255*o.g/o.a),i.data[r+n+2]=Math.floor(255*o.b/o.a),i.data[r+n+3]=Math.floor(255*o.a);};if(t.clips)for(var o=0,s=0;o<n;++o,s+=4*r)for(var u=0,l=0;u<r;u++,l+=4){var p=u/(r-1),c=t.clips[o];a(s,l,c.start*(1-p)+c.end*p);}else for(var h=0,f=0;h<r;h++,f+=4)a(0,f,h/(r-1));return i}var _o=function(t){function e(e){t.call(this,e,bo),this._updateColorRamp();}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.createBucket=function(t){return new fo(t)},e.prototype._handleSpecialPaintPropertyUpdate=function(t){"heatmap-color"===t&&this._updateColorRamp();},e.prototype._updateColorRamp=function(){this.colorRamp=wo({expression:this._transitionablePaint._values["heatmap-color"].value.expression,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null;},e.prototype.resize=function(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null);},e.prototype.queryRadius=function(){return 0},e.prototype.queryIntersectsFeature=function(){return !1},e.prototype.hasOffscreenPass=function(){return 0!==this.paint.get("heatmap-opacity")&&"none"!==this.visibility},e}(_i),Ao={paint:new wi({"hillshade-illumination-direction":new mi(Et.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new mi(Et.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new mi(Et.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new mi(Et.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new mi(Et.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new mi(Et.paint_hillshade["hillshade-accent-color"])})},So=function(t){function e(e){t.call(this,e,Ao);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.hasOffscreenPass=function(){return 0!==this.paint.get("hillshade-exaggeration")&&"none"!==this.visibility},e}(_i),ko=Ii([{name:"a_pos",components:2,type:"Int16"}],4).members,Io=Co,zo=Co;function Co(t,e,r){r=r||2;var n,i,a,o,s,u,l,p=e&&e.length,c=p?e[0]*r:t.length,h=Eo(t,0,c,r,!0),f=[];if(!h||h.next===h.prev)return f;if(p&&(h=function(t,e,r,n){var i,a,o,s=[];for(i=0,a=e.length;i<a;i++)(o=Eo(t,e[i]*n,i<a-1?e[i+1]*n:t.length,n,!1))===o.next&&(o.steiner=!0),s.push(Uo(o));for(s.sort(Do),i=0;i<s.length;i++)Lo(s[i],r),r=Po(r,r.next);return r}(t,e,h,r)),t.length>80*r){n=a=t[0],i=o=t[1];for(var y=r;y<c;y+=r)(s=t[y])<n&&(n=s),(u=t[y+1])<i&&(i=u),s>a&&(a=s),u>o&&(o=u);l=0!==(l=Math.max(a-n,o-i))?1/l:0;}return Mo(h,f,r,n,i,l),f}function Eo(t,e,r,n,i){var a,o;if(i===Qo(t,e,r,n)>0)for(a=e;a<r;a+=n)o=Yo(a,t[a],t[a+1],o);else for(a=r-n;a>=e;a-=n)o=Yo(a,t[a],t[a+1],o);return o&&Ko(o,o.next)&&($o(o),o=o.next),o}function Po(t,e){if(!t)return t;e||(e=t);var r,n=t;do{if(r=!1,n.steiner||!Ko(n,n.next)&&0!==No(n.prev,n,n.next))n=n.next;else {if($o(n),(n=e=n.prev)===n.next)break;r=!0;}}while(r||n!==e);return e}function Mo(t,e,r,n,i,a,o){if(t){!o&&a&&function(t,e,r,n){var i=t;do{null===i.z&&(i.z=Ro(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){var e,r,n,i,a,o,s,u,l=1;do{for(r=t,t=null,a=null,o=0;r;){for(o++,n=r,s=0,e=0;e<l&&(s++,n=n.nextZ);e++);for(u=l;s>0||u>0&&n;)0!==s&&(0===u||!n||r.z<=n.z)?(i=r,r=r.nextZ,s--):(i=n,n=n.nextZ,u--),a?a.nextZ=i:t=i,i.prevZ=a,a=i;r=n;}a.nextZ=null,l*=2;}while(o>1)}(i);}(t,n,i,a);for(var s,u,l=t;t.prev!==t.next;)if(s=t.prev,u=t.next,a?To(t,n,i,a):Bo(t))e.push(s.i/r),e.push(t.i/r),e.push(u.i/r),$o(t),t=u.next,l=u.next;else if((t=u)===l){o?1===o?Mo(t=Vo(Po(t),e,r),e,r,n,i,a,2):2===o&&Fo(t,e,r,n,i,a):Mo(Po(t),e,r,n,i,a,1);break}}}function Bo(t){var e=t.prev,r=t,n=t.next;if(No(e,r,n)>=0)return !1;for(var i=t.next.next;i!==t.prev;){if(jo(e.x,e.y,r.x,r.y,n.x,n.y,i.x,i.y)&&No(i.prev,i,i.next)>=0)return !1;i=i.next;}return !0}function To(t,e,r,n){var i=t.prev,a=t,o=t.next;if(No(i,a,o)>=0)return !1;for(var s=i.x>a.x?i.x>o.x?i.x:o.x:a.x>o.x?a.x:o.x,u=i.y>a.y?i.y>o.y?i.y:o.y:a.y>o.y?a.y:o.y,l=Ro(i.x<a.x?i.x<o.x?i.x:o.x:a.x<o.x?a.x:o.x,i.y<a.y?i.y<o.y?i.y:o.y:a.y<o.y?a.y:o.y,e,r,n),p=Ro(s,u,e,r,n),c=t.prevZ,h=t.nextZ;c&&c.z>=l&&h&&h.z<=p;){if(c!==t.prev&&c!==t.next&&jo(i.x,i.y,a.x,a.y,o.x,o.y,c.x,c.y)&&No(c.prev,c,c.next)>=0)return !1;if(c=c.prevZ,h!==t.prev&&h!==t.next&&jo(i.x,i.y,a.x,a.y,o.x,o.y,h.x,h.y)&&No(h.prev,h,h.next)>=0)return !1;h=h.nextZ;}for(;c&&c.z>=l;){if(c!==t.prev&&c!==t.next&&jo(i.x,i.y,a.x,a.y,o.x,o.y,c.x,c.y)&&No(c.prev,c,c.next)>=0)return !1;c=c.prevZ;}for(;h&&h.z<=p;){if(h!==t.prev&&h!==t.next&&jo(i.x,i.y,a.x,a.y,o.x,o.y,h.x,h.y)&&No(h.prev,h,h.next)>=0)return !1;h=h.nextZ;}return !0}function Vo(t,e,r){var n=t;do{var i=n.prev,a=n.next.next;!Ko(i,a)&&Go(i,n,n.next,a)&&Jo(i,a)&&Jo(a,i)&&(e.push(i.i/r),e.push(n.i/r),e.push(a.i/r),$o(n),$o(n.next),n=t=a),n=n.next;}while(n!==t);return Po(n)}function Fo(t,e,r,n,i,a){var o=t;do{for(var s=o.next.next;s!==o.prev;){if(o.i!==s.i&&qo(o,s)){var u=Ho(o,s);return o=Po(o,o.next),u=Po(u,u.next),Mo(o,e,r,n,i,a),void Mo(u,e,r,n,i,a)}s=s.next;}o=o.next;}while(o!==t)}function Do(t,e){return t.x-e.x}function Lo(t,e){if(e=function(t,e){var r,n=e,i=t.x,a=t.y,o=-1/0;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){var s=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(s<=i&&s>o){if(o=s,s===i){if(a===n.y)return n;if(a===n.next.y)return n.next}r=n.x<n.next.x?n:n.next;}}n=n.next;}while(n!==e);if(!r)return null;if(i===o)return r;var u,l=r,p=r.x,c=r.y,h=1/0;n=r;do{i>=n.x&&n.x>=p&&i!==n.x&&jo(a<c?i:o,a,p,c,a<c?o:i,a,n.x,n.y)&&(u=Math.abs(a-n.y)/(i-n.x),Jo(n,t)&&(u<h||u===h&&(n.x>r.x||n.x===r.x&&Oo(r,n)))&&(r=n,h=u)),n=n.next;}while(n!==l);return r}(t,e)){var r=Ho(e,t);Po(e,e.next),Po(r,r.next);}}function Oo(t,e){return No(t.prev,t,e.prev)<0&&No(e.next,t,t.next)<0}function Ro(t,e,r,n,i){return (t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Uo(t){var e=t,r=t;do{(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;}while(e!==t);return r}function jo(t,e,r,n,i,a,o,s){return (i-o)*(e-s)-(t-o)*(a-s)>=0&&(t-o)*(n-s)-(r-o)*(e-s)>=0&&(r-o)*(a-s)-(i-o)*(n-s)>=0}function qo(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&Go(r,r.next,t,e))return !0;r=r.next;}while(r!==t);return !1}(t,e)&&(Jo(t,e)&&Jo(e,t)&&function(t,e){var r=t,n=!1,i=(t.x+e.x)/2,a=(t.y+e.y)/2;do{r.y>a!=r.next.y>a&&r.next.y!==r.y&&i<(r.next.x-r.x)*(a-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;}while(r!==t);return n}(t,e)&&(No(t.prev,t,e.prev)||No(t,e.prev,e))||Ko(t,e)&&No(t.prev,t,t.next)>0&&No(e.prev,e,e.next)>0)}function No(t,e,r){return (e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function Ko(t,e){return t.x===e.x&&t.y===e.y}function Go(t,e,r,n){var i=Xo(No(t,e,r)),a=Xo(No(t,e,n)),o=Xo(No(r,n,t)),s=Xo(No(r,n,e));return i!==a&&o!==s||!(0!==i||!Zo(t,r,e))||!(0!==a||!Zo(t,n,e))||!(0!==o||!Zo(r,t,n))||!(0!==s||!Zo(r,e,n))}function Zo(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function Xo(t){return t>0?1:t<0?-1:0}function Jo(t,e){return No(t.prev,t,t.next)<0?No(t,e,t.next)>=0&&No(t,t.prev,e)>=0:No(t,e,t.prev)<0||No(t,t.next,e)<0}function Ho(t,e){var r=new Wo(t.i,t.x,t.y),n=new Wo(e.i,e.x,e.y),i=t.next,a=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,a.next=n,n.prev=a,n}function Yo(t,e,r,n){var i=new Wo(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function $o(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ);}function Wo(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1;}function Qo(t,e,r,n){for(var i=0,a=e,o=r-n;a<r;a+=n)i+=(t[o]-t[a])*(t[a+1]+t[o+1]),o=a;return i}function ts(t,e,r,n,i){!function t(e,r,n,i,a){for(;i>n;){if(i-n>600){var o=i-n+1,s=r-n+1,u=Math.log(o),l=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*l*(o-l)/o)*(s-o/2<0?-1:1);t(e,r,Math.max(n,Math.floor(r-s*l/o+p)),Math.min(i,Math.floor(r+(o-s)*l/o+p)),a);}var c=e[r],h=n,f=i;for(es(e,n,r),a(e[i],c)>0&&es(e,n,i);h<f;){for(es(e,h,f),h++,f--;a(e[h],c)<0;)h++;for(;a(e[f],c)>0;)f--;}0===a(e[n],c)?es(e,n,f):es(e,++f,i),f<=r&&(n=f+1),r<=f&&(i=f-1);}}(t,e,r||0,n||t.length-1,i||rs);}function es(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}function rs(t,e){return t<e?-1:t>e?1:0}function ns(t,e){var r=t.length;if(r<=1)return [t];for(var n,i,a=[],o=0;o<r;o++){var s=k(t[o]);0!==s&&(t[o].area=Math.abs(s),void 0===i&&(i=s<0),i===s<0?(n&&a.push(n),n=[t[o]]):n.push(t[o]));}if(n&&a.push(n),e>1)for(var u=0;u<a.length;u++)a[u].length<=e||(ts(a[u],e,1,a[u].length-1,is),a[u]=a[u].slice(0,e));return a}function is(t,e){return e.area-t.area}function as(t,e,r){for(var n=r.patternDependencies,i=!1,a=0,o=e;a<o.length;a+=1){var s=o[a].paint.get(t+"-pattern");s.isConstant()||(i=!0);var u=s.constantOr(null);u&&(i=!0,n[u.to]=!0,n[u.from]=!0);}return i}function os(t,e,r,n,i){for(var a=i.patternDependencies,o=0,s=e;o<s.length;o+=1){var u=s[o],l=u.paint.get(t+"-pattern").value;if("constant"!==l.kind){var p=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),h=l.evaluate({zoom:n+1},r,{},i.availableImages);c=c&&c.name?c.name:c,h=h&&h.name?h.name:h,a[p=p&&p.name?p.name:p]=!0,a[c]=!0,a[h]=!0,r.patterns[u.id]={min:p,mid:c,max:h};}}return r}Co.deviation=function(t,e,r,n){var i=e&&e.length,a=Math.abs(Qo(t,0,i?e[0]*r:t.length,r));if(i)for(var o=0,s=e.length;o<s;o++)a-=Math.abs(Qo(t,e[o]*r,o<s-1?e[o+1]*r:t.length,r));var u=0;for(o=0;o<n.length;o+=3){var l=n[o]*r,p=n[o+1]*r,c=n[o+2]*r;u+=Math.abs((t[l]-t[c])*(t[p+1]-t[l+1])-(t[l]-t[p])*(t[c+1]-t[l+1]));}return 0===a&&0===u?0:Math.abs((u-a)/a)},Co.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var a=0;a<t[i].length;a++)for(var o=0;o<e;o++)r.vertices.push(t[i][a][o]);i>0&&r.holes.push(n+=t[i-1].length);}return r},Io.default=zo;var ss=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new Ci,this.indexArray=new ji,this.indexArray2=new Xi,this.programConfigurations=new Va(t.layers,t.zoom),this.segments=new sa,this.segments2=new sa,this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};ss.prototype.populate=function(t,e,r){this.hasPattern=as("fill",this.layers,e);for(var n=this.layers[0].layout.get("fill-sort-key"),i=[],a=0,o=t;a<o.length;a+=1){var s=o[a],u=s.feature,l=s.id,p=s.index,c=s.sourceLayerIndex,h=this.layers[0]._featureFilter.needGeometry,f=Ua(u,h);if(this.layers[0]._featureFilter.filter(new si(this.zoom),f,r)){var y=n?n.evaluate(f,{},r,e.availableImages):void 0,d={id:l,properties:u.properties,type:u.type,sourceLayerIndex:c,index:p,geometry:h?f.geometry:Ra(u),patterns:{},sortKey:y};i.push(d);}}n&&i.sort((function(t,e){return t.sortKey-e.sortKey}));for(var m=0,v=i;m<v.length;m+=1){var g=v[m],x=g.geometry,b=g.index,w=g.sourceLayerIndex;if(this.hasPattern){var _=os("fill",this.layers,g,this.zoom,e);this.patternFeatures.push(_);}else this.addFeature(g,x,b,r,{});e.featureIndex.insert(t[b].feature,x,b,w,this.index);}},ss.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},ss.prototype.addFeatures=function(t,e,r){for(var n=0,i=this.patternFeatures;n<i.length;n+=1){var a=i[n];this.addFeature(a,a.geometry,a.index,e,r);}},ss.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},ss.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},ss.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,ko),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0;},ss.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy());},ss.prototype.addFeature=function(t,e,r,n,i){for(var a=0,o=ns(e,500);a<o.length;a+=1){for(var s=o[a],u=0,l=0,p=s;l<p.length;l+=1)u+=p[l].length;for(var c=this.segments.prepareSegment(u,this.layoutVertexArray,this.indexArray),h=c.vertexLength,f=[],y=[],d=0,m=s;d<m.length;d+=1){var v=m[d];if(0!==v.length){v!==s[0]&&y.push(f.length/2);var g=this.segments2.prepareSegment(v.length,this.layoutVertexArray,this.indexArray2),x=g.vertexLength;this.layoutVertexArray.emplaceBack(v[0].x,v[0].y),this.indexArray2.emplaceBack(x+v.length-1,x),f.push(v[0].x),f.push(v[0].y);for(var b=1;b<v.length;b++)this.layoutVertexArray.emplaceBack(v[b].x,v[b].y),this.indexArray2.emplaceBack(x+b-1,x+b),f.push(v[b].x),f.push(v[b].y);g.vertexLength+=v.length,g.primitiveLength+=v.length;}}for(var w=Io(f,y),_=0;_<w.length;_+=3)this.indexArray.emplaceBack(h+w[_],h+w[_+1],h+w[_+2]);c.vertexLength+=u,c.primitiveLength+=w.length/3;}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,n);},On("FillBucket",ss,{omit:["layers","patternFeatures"]});var us=new wi({"fill-sort-key":new vi(Et.layout_fill["fill-sort-key"])}),ls={paint:new wi({"fill-antialias":new mi(Et.paint_fill["fill-antialias"]),"fill-opacity":new vi(Et.paint_fill["fill-opacity"]),"fill-color":new vi(Et.paint_fill["fill-color"]),"fill-outline-color":new vi(Et.paint_fill["fill-outline-color"]),"fill-translate":new mi(Et.paint_fill["fill-translate"]),"fill-translate-anchor":new mi(Et.paint_fill["fill-translate-anchor"]),"fill-pattern":new gi(Et.paint_fill["fill-pattern"])}),layout:us},ps=function(t){function e(e){t.call(this,e,ls);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.recalculate=function(e,r){t.prototype.recalculate.call(this,e,r);var n=this.paint._values["fill-outline-color"];"constant"===n.value.kind&&void 0===n.value.value&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"]);},e.prototype.createBucket=function(t){return new ss(t)},e.prototype.queryRadius=function(){return eo(this.paint.get("fill-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,i,a,o){return Ga(ro(t,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),a.angle,o),n)},e.prototype.isTileClipped=function(){return !0},e}(_i),cs=Ii([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4).members,hs=fs;function fs(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=i,t.readFields(ys,this,e);}function ys(t,e,r){1==t?e.id=r.readVarint():2==t?function(t,e){for(var r=t.readVarint()+t.pos;t.pos<r;){var n=e._keys[t.readVarint()],i=e._values[t.readVarint()];e.properties[n]=i;}}(r,e):3==t?e.type=r.readVarint():4==t&&(e._geometry=r.pos);}function ds(t){for(var e,r,n=0,i=0,a=t.length,o=a-1;i<a;o=i++)n+=((r=t[o]).x-(e=t[i]).x)*(e.y+r.y);return n}fs.types=["Unknown","Point","LineString","Polygon"],fs.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e,r=t.readVarint()+t.pos,n=1,a=0,o=0,s=0,u=[];t.pos<r;){if(a<=0){var l=t.readVarint();n=7&l,a=l>>3;}if(a--,1===n||2===n)o+=t.readSVarint(),s+=t.readSVarint(),1===n&&(e&&u.push(e),e=[]),e.push(new i(o,s));else {if(7!==n)throw new Error("unknown command "+n);e&&e.push(e[0].clone());}}return e&&u.push(e),u},fs.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,a=0,o=1/0,s=-1/0,u=1/0,l=-1/0;t.pos<e;){if(n<=0){var p=t.readVarint();r=7&p,n=p>>3;}if(n--,1===r||2===r)(i+=t.readSVarint())<o&&(o=i),i>s&&(s=i),(a+=t.readSVarint())<u&&(u=a),a>l&&(l=a);else if(7!==r)throw new Error("unknown command "+r)}return [o,u,s,l]},fs.prototype.toGeoJSON=function(t,e,r){var n,i,a=this.extent*Math.pow(2,r),o=this.extent*t,s=this.extent*e,u=this.loadGeometry(),l=fs.types[this.type];function p(t){for(var e=0;e<t.length;e++){var r=t[e];t[e]=[360*(r.x+o)/a-180,360/Math.PI*Math.atan(Math.exp((180-360*(r.y+s)/a)*Math.PI/180))-90];}}switch(this.type){case 1:var c=[];for(n=0;n<u.length;n++)c[n]=u[n][0];p(u=c);break;case 2:for(n=0;n<u.length;n++)p(u[n]);break;case 3:for(u=function(t){var e=t.length;if(e<=1)return [t];for(var r,n,i=[],a=0;a<e;a++){var o=ds(t[a]);0!==o&&(void 0===n&&(n=o<0),n===o<0?(r&&i.push(r),r=[t[a]]):r.push(t[a]));}return r&&i.push(r),i}(u),n=0;n<u.length;n++)for(i=0;i<u[n].length;i++)p(u[n][i]);}1===u.length?u=u[0]:l="Multi"+l;var h={type:"Feature",geometry:{type:l,coordinates:u},properties:this.properties};return "id"in this&&(h.id=this.id),h};var ms=vs;function vs(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(gs,this,e),this.length=this._features.length;}function gs(t,e,r){15===t?e.version=r.readVarint():1===t?e.name=r.readString():5===t?e.extent=r.readVarint():2===t?e._features.push(r.pos):3===t?e._keys.push(r.readString()):4===t&&e._values.push(function(t){for(var e=null,r=t.readVarint()+t.pos;t.pos<r;){var n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null;}return e}(r));}function xs(t,e,r){if(3===t){var n=new ms(r,r.readVarint()+r.pos);n.length&&(e[n.name]=n);}}vs.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new hs(this._pbf,e,this.extent,this._keys,this._values)};var bs={VectorTile:function(t,e){this.layers=t.readFields(xs,{},e);},VectorTileFeature:hs,VectorTileLayer:ms},ws=bs.VectorTileFeature.types,_s=Math.pow(2,13);function As(t,e,r,n,i,a,o,s){t.emplaceBack(e,r,2*Math.floor(n*_s)+o,i*_s*2,a*_s*2,Math.round(s));}var Ss=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new Pi,this.indexArray=new ji,this.programConfigurations=new Va(t.layers,t.zoom),this.segments=new sa,this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};function ks(t,e){return t.x===e.x&&(t.x<0||t.x>8192)||t.y===e.y&&(t.y<0||t.y>8192)}Ss.prototype.populate=function(t,e,r){this.features=[],this.hasPattern=as("fill-extrusion",this.layers,e);for(var n=0,i=t;n<i.length;n+=1){var a=i[n],o=a.feature,s=a.id,u=a.index,l=a.sourceLayerIndex,p=this.layers[0]._featureFilter.needGeometry,c=Ua(o,p);if(this.layers[0]._featureFilter.filter(new si(this.zoom),c,r)){var h={id:s,sourceLayerIndex:l,index:u,geometry:p?c.geometry:Ra(o),properties:o.properties,type:o.type,patterns:{}};this.hasPattern?this.features.push(os("fill-extrusion",this.layers,h,this.zoom,e)):this.addFeature(h,h.geometry,u,r,{}),e.featureIndex.insert(o,h.geometry,u,l,this.index,!0);}}},Ss.prototype.addFeatures=function(t,e,r){for(var n=0,i=this.features;n<i.length;n+=1){var a=i[n];this.addFeature(a,a.geometry,a.index,e,r);}},Ss.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},Ss.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},Ss.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},Ss.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,cs),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},Ss.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},Ss.prototype.addFeature=function(t,e,r,n,i){for(var a=0,o=ns(e,500);a<o.length;a+=1){for(var s=o[a],u=0,l=0,p=s;l<p.length;l+=1)u+=p[l].length;for(var c=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray),h=0,f=s;h<f.length;h+=1){var y=f[h];if(0!==y.length&&!((B=y).every((function(t){return t.x<0}))||B.every((function(t){return t.x>8192}))||B.every((function(t){return t.y<0}))||B.every((function(t){return t.y>8192}))))for(var d=0,m=0;m<y.length;m++){var v=y[m];if(m>=1){var g=y[m-1];if(!ks(v,g)){c.vertexLength+4>sa.MAX_VERTEX_ARRAY_LENGTH&&(c=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));var x=v.sub(g)._perp()._unit(),b=g.dist(v);d+b>32768&&(d=0),As(this.layoutVertexArray,v.x,v.y,x.x,x.y,0,0,d),As(this.layoutVertexArray,v.x,v.y,x.x,x.y,0,1,d),As(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,0,d+=b),As(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,1,d);var w=c.vertexLength;this.indexArray.emplaceBack(w,w+2,w+1),this.indexArray.emplaceBack(w+1,w+2,w+3),c.vertexLength+=4,c.primitiveLength+=2;}}}}if(c.vertexLength+u>sa.MAX_VERTEX_ARRAY_LENGTH&&(c=this.segments.prepareSegment(u,this.layoutVertexArray,this.indexArray)),"Polygon"===ws[t.type]){for(var _=[],A=[],S=c.vertexLength,k=0,I=s;k<I.length;k+=1){var z=I[k];if(0!==z.length){z!==s[0]&&A.push(_.length/2);for(var C=0;C<z.length;C++){var E=z[C];As(this.layoutVertexArray,E.x,E.y,0,0,1,1,0),_.push(E.x),_.push(E.y);}}}for(var P=Io(_,A),M=0;M<P.length;M+=3)this.indexArray.emplaceBack(S+P[M],S+P[M+2],S+P[M+1]);c.primitiveLength+=P.length/3,c.vertexLength+=u;}}var B;this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,n);},On("FillExtrusionBucket",Ss,{omit:["layers","features"]});var Is={paint:new wi({"fill-extrusion-opacity":new mi(Et["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new vi(Et["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new gi(Et["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new vi(Et["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new vi(Et["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new mi(Et["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])})},zs=function(t){function e(e){t.call(this,e,Is);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.createBucket=function(t){return new Ss(t)},e.prototype.queryRadius=function(){return eo(this.paint.get("fill-extrusion-translate"))},e.prototype.is3D=function(){return !0},e.prototype.queryIntersectsFeature=function(t,e,r,n,a,o,s,u){var l=ro(t,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),o.angle,s),p=this.paint.get("fill-extrusion-height").evaluate(e,r),c=this.paint.get("fill-extrusion-base").evaluate(e,r),h=function(t,e,r,n){for(var a=[],o=0,s=t;o<s.length;o+=1){var u=s[o],l=[u.x,u.y,0,1];po(l,l,e),a.push(new i(l[0]/l[3],l[1]/l[3]));}return a}(l,u),f=function(t,e,r,n){for(var a=[],o=[],s=n[8]*e,u=n[9]*e,l=n[10]*e,p=n[11]*e,c=n[8]*r,h=n[9]*r,f=n[10]*r,y=n[11]*r,d=0,m=t;d<m.length;d+=1){for(var v=[],g=[],x=0,b=m[d];x<b.length;x+=1){var w=b[x],_=w.x,A=w.y,S=n[0]*_+n[4]*A+n[12],k=n[1]*_+n[5]*A+n[13],I=n[2]*_+n[6]*A+n[14],z=n[3]*_+n[7]*A+n[15],C=I+l,E=z+p,P=S+c,M=k+h,B=I+f,T=z+y,V=new i((S+s)/E,(k+u)/E);V.z=C/E,v.push(V);var F=new i(P/T,M/T);F.z=B/T,g.push(F);}a.push(v),o.push(g);}return [a,o]}(n,c,p,u);return function(t,e,r){var n=1/0;Ga(r,e)&&(n=Es(r,e[0]));for(var i=0;i<e.length;i++)for(var a=e[i],o=t[i],s=0;s<a.length-1;s++){var u=a[s],l=[u,a[s+1],o[s+1],o[s],u];Na(r,l)&&(n=Math.min(n,Es(r,l)));}return n!==1/0&&n}(f[0],f[1],h)},e}(_i);function Cs(t,e){return t.x*e.x+t.y*e.y}function Es(t,e){if(1===t.length){for(var r,n=0,i=e[n++];!r||i.equals(r);)if(!(r=e[n++]))return 1/0;for(;n<e.length;n++){var a=e[n],o=t[0],s=r.sub(i),u=a.sub(i),l=o.sub(i),p=Cs(s,s),c=Cs(s,u),h=Cs(u,u),f=Cs(l,s),y=Cs(l,u),d=p*h-c*c,m=(h*f-c*y)/d,v=(p*y-c*f)/d,g=i.z*(1-m-v)+r.z*m+a.z*v;if(isFinite(g))return g}return 1/0}for(var x=1/0,b=0,w=e;b<w.length;b+=1)x=Math.min(x,w[b].z);return x}var Ps=Ii([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4).members,Ms=Ii([{name:"a_uv_x",components:1,type:"Float32"},{name:"a_split_index",components:1,type:"Float32"}]).members,Bs=bs.VectorTileFeature.types,Ts=Math.cos(Math.PI/180*37.5),Vs=Math.pow(2,14)/.5,Fs=function(t){var e=this;this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach((function(t){e.gradients[t.id]={};})),this.layoutVertexArray=new Mi,this.layoutVertexArray2=new Bi,this.indexArray=new ji,this.programConfigurations=new Va(t.layers,t.zoom),this.segments=new sa,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};Fs.prototype.populate=function(t,e,r){this.hasPattern=as("line",this.layers,e);for(var n=this.layers[0].layout.get("line-sort-key"),i=[],a=0,o=t;a<o.length;a+=1){var s=o[a],u=s.feature,l=s.id,p=s.index,c=s.sourceLayerIndex,h=this.layers[0]._featureFilter.needGeometry,f=Ua(u,h);if(this.layers[0]._featureFilter.filter(new si(this.zoom),f,r)){var y=n?n.evaluate(f,{},r):void 0,d={id:l,properties:u.properties,type:u.type,sourceLayerIndex:c,index:p,geometry:h?f.geometry:Ra(u),patterns:{},sortKey:y};i.push(d);}}n&&i.sort((function(t,e){return t.sortKey-e.sortKey}));for(var m=0,v=i;m<v.length;m+=1){var g=v[m],x=g.geometry,b=g.index,w=g.sourceLayerIndex;if(this.hasPattern){var _=os("line",this.layers,g,this.zoom,e);this.patternFeatures.push(_);}else this.addFeature(g,x,b,r,{});e.featureIndex.insert(t[b].feature,x,b,w,this.index);}},Fs.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},Fs.prototype.addFeatures=function(t,e,r){for(var n=0,i=this.patternFeatures;n<i.length;n+=1){var a=i[n];this.addFeature(a,a.geometry,a.index,e,r);}},Fs.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},Fs.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},Fs.prototype.upload=function(t){this.uploaded||(0!==this.layoutVertexArray2.length&&(this.layoutVertexBuffer2=t.createVertexBuffer(this.layoutVertexArray2,Ms)),this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Ps),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},Fs.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},Fs.prototype.lineFeatureClips=function(t){if(t.properties&&t.properties.hasOwnProperty("mapbox_clip_start")&&t.properties.hasOwnProperty("mapbox_clip_end"))return {start:+t.properties.mapbox_clip_start,end:+t.properties.mapbox_clip_end}},Fs.prototype.addFeature=function(t,e,r,n,i){var a=this.layers[0].layout,o=a.get("line-join").evaluate(t,{}),s=a.get("line-cap"),u=a.get("line-miter-limit"),l=a.get("line-round-limit");this.lineClips=this.lineFeatureClips(t);for(var p=0,c=e;p<c.length;p+=1)this.addLine(c[p],t,o,s,u,l);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,n);},Fs.prototype.addLine=function(t,e,r,n,i,a){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.lineClips){this.lineClipsArray.push(this.lineClips);for(var o=0;o<t.length-1;o++)this.totalDistance+=t[o].dist(t[o+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance);}for(var s="Polygon"===Bs[e.type],u=t.length;u>=2&&t[u-1].equals(t[u-2]);)u--;for(var l=0;l<u-1&&t[l].equals(t[l+1]);)l++;if(!(u<(s?3:2))){"bevel"===r&&(i=1.05);var p,c=this.overscaling<=16?122880/(512*this.overscaling):0,h=this.segments.prepareSegment(10*u,this.layoutVertexArray,this.indexArray),f=void 0,y=void 0,d=void 0,m=void 0;this.e1=this.e2=-1,s&&(m=t[l].sub(p=t[u-2])._unit()._perp());for(var v=l;v<u;v++)if(!(y=v===u-1?s?t[l+1]:void 0:t[v+1])||!t[v].equals(y)){m&&(d=m),p&&(f=p),p=t[v],m=y?y.sub(p)._unit()._perp():d;var g=(d=d||m).add(m);0===g.x&&0===g.y||g._unit();var x=d.x*m.x+d.y*m.y,b=g.x*m.x+g.y*m.y,w=0!==b?1/b:1/0,_=2*Math.sqrt(2-2*b),A=b<Ts&&f&&y,S=d.x*m.y-d.y*m.x>0;if(A&&v>l){var k=p.dist(f);if(k>2*c){var I=p.sub(p.sub(f)._mult(c/k)._round());this.updateDistance(f,I),this.addCurrentVertex(I,d,0,0,h),f=I;}}var z=f&&y,C=z?r:s?"butt":n;if(z&&"round"===C&&(w<a?C="miter":w<=2&&(C="fakeround")),"miter"===C&&w>i&&(C="bevel"),"bevel"===C&&(w>2&&(C="flipbevel"),w<i&&(C="miter")),f&&this.updateDistance(f,p),"miter"===C)g._mult(w),this.addCurrentVertex(p,g,0,0,h);else if("flipbevel"===C){if(w>100)g=m.mult(-1);else {var E=w*d.add(m).mag()/d.sub(m).mag();g._perp()._mult(E*(S?-1:1));}this.addCurrentVertex(p,g,0,0,h),this.addCurrentVertex(p,g.mult(-1),0,0,h);}else if("bevel"===C||"fakeround"===C){var P=-Math.sqrt(w*w-1),M=S?P:0,B=S?0:P;if(f&&this.addCurrentVertex(p,d,M,B,h),"fakeround"===C)for(var T=Math.round(180*_/Math.PI/20),V=1;V<T;V++){var F=V/T;if(.5!==F){var D=F-.5;F+=F*D*(F-1)*((1.0904+x*(x*(3.55645-1.43519*x)-3.2452))*D*D+(.848013+x*(.215638*x-1.06021)));}var L=m.sub(d)._mult(F)._add(d)._unit()._mult(S?-1:1);this.addHalfVertex(p,L.x,L.y,!1,S,0,h);}y&&this.addCurrentVertex(p,m,-M,-B,h);}else if("butt"===C)this.addCurrentVertex(p,g,0,0,h);else if("square"===C){var O=f?1:-1;this.addCurrentVertex(p,g,O,O,h);}else "round"===C&&(f&&(this.addCurrentVertex(p,d,0,0,h),this.addCurrentVertex(p,d,1,1,h,!0)),y&&(this.addCurrentVertex(p,m,-1,-1,h,!0),this.addCurrentVertex(p,m,0,0,h)));if(A&&v<u-1){var R=p.dist(y);if(R>2*c){var U=p.add(y.sub(p)._mult(c/R)._round());this.updateDistance(p,U),this.addCurrentVertex(U,m,0,0,h),p=U;}}}}},Fs.prototype.addCurrentVertex=function(t,e,r,n,i,a){void 0===a&&(a=!1);var o=e.y*n-e.x,s=-e.y-e.x*n;this.addHalfVertex(t,e.x+e.y*r,e.y-e.x*r,a,!1,r,i),this.addHalfVertex(t,o,s,a,!0,-n,i),this.distance>Vs/2&&0===this.totalDistance&&(this.distance=0,this.addCurrentVertex(t,e,r,n,i,a));},Fs.prototype.addHalfVertex=function(t,e,r,n,i,a,o){var s=.5*(this.lineClips?this.scaledDistance*(Vs-1):this.scaledDistance);this.layoutVertexArray.emplaceBack((t.x<<1)+(n?1:0),(t.y<<1)+(i?1:0),Math.round(63*e)+128,Math.round(63*r)+128,1+(0===a?0:a<0?-1:1)|(63&s)<<2,s>>6),this.lineClips&&this.layoutVertexArray2.emplaceBack((this.scaledDistance-this.lineClips.start)/(this.lineClips.end-this.lineClips.start),this.lineClipsArray.length);var u=o.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,u),o.primitiveLength++),i?this.e2=u:this.e1=u;},Fs.prototype.updateScaledDistance=function(){this.scaledDistance=this.lineClips?this.lineClips.start+(this.lineClips.end-this.lineClips.start)*this.distance/this.totalDistance:this.distance;},Fs.prototype.updateDistance=function(t,e){this.distance+=t.dist(e),this.updateScaledDistance();},On("LineBucket",Fs,{omit:["layers","patternFeatures"]});var Ds=new wi({"line-cap":new mi(Et.layout_line["line-cap"]),"line-join":new vi(Et.layout_line["line-join"]),"line-miter-limit":new mi(Et.layout_line["line-miter-limit"]),"line-round-limit":new mi(Et.layout_line["line-round-limit"]),"line-sort-key":new vi(Et.layout_line["line-sort-key"])}),Ls={paint:new wi({"line-opacity":new vi(Et.paint_line["line-opacity"]),"line-color":new vi(Et.paint_line["line-color"]),"line-translate":new mi(Et.paint_line["line-translate"]),"line-translate-anchor":new mi(Et.paint_line["line-translate-anchor"]),"line-width":new vi(Et.paint_line["line-width"]),"line-gap-width":new vi(Et.paint_line["line-gap-width"]),"line-offset":new vi(Et.paint_line["line-offset"]),"line-blur":new vi(Et.paint_line["line-blur"]),"line-dasharray":new xi(Et.paint_line["line-dasharray"]),"line-pattern":new gi(Et.paint_line["line-pattern"]),"line-gradient":new bi(Et.paint_line["line-gradient"])}),layout:Ds},Os=new(function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.possiblyEvaluate=function(e,r){return r=new si(Math.floor(r.zoom),{now:r.now,fadeDuration:r.fadeDuration,zoomHistory:r.zoomHistory,transition:r.transition}),t.prototype.possiblyEvaluate.call(this,e,r)},e.prototype.evaluate=function(e,r,n,i){return r=h({},r,{zoom:Math.floor(r.zoom)}),t.prototype.evaluate.call(this,e,r,n,i)},e}(vi))(Ls.paint.properties["line-width"].specification);Os.useIntegerZoom=!0;var Rs=function(t){function e(e){t.call(this,e,Ls),this.gradientVersion=0;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._handleSpecialPaintPropertyUpdate=function(t){"line-gradient"===t&&(this.stepInterpolant=this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ne,this.gradientVersion=(this.gradientVersion+1)%s);},e.prototype.gradientExpression=function(){return this._transitionablePaint._values["line-gradient"].value.expression},e.prototype.recalculate=function(e,r){t.prototype.recalculate.call(this,e,r),this.paint._values["line-floorwidth"]=Os.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,e);},e.prototype.createBucket=function(t){return new Fs(t)},e.prototype.queryRadius=function(t){var e=t,r=Us(to("line-width",this,e),to("line-gap-width",this,e)),n=to("line-offset",this,e);return r/2+Math.abs(n)+eo(this.paint.get("line-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,a,o,s){var u=ro(t,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),o.angle,s),l=s/2*Us(this.paint.get("line-width").evaluate(e,r),this.paint.get("line-gap-width").evaluate(e,r)),p=this.paint.get("line-offset").evaluate(e,r);return p&&(n=function(t,e){for(var r=[],n=new i(0,0),a=0;a<t.length;a++){for(var o=t[a],s=[],u=0;u<o.length;u++){var l=o[u],p=o[u+1],c=0===u?n:l.sub(o[u-1])._unit()._perp(),h=u===o.length-1?n:p.sub(l)._unit()._perp(),f=c._add(h)._unit();f._mult(1/(f.x*h.x+f.y*h.y)),s.push(f._mult(e)._add(l));}r.push(s);}return r}(n,p*s)),function(t,e,r){for(var n=0;n<e.length;n++){var i=e[n];if(t.length>=3)for(var a=0;a<i.length;a++)if(Wa(t,i[a]))return !0;if(Za(t,i,r))return !0}return !1}(u,n,l)},e.prototype.isTileClipped=function(){return !0},e}(_i);function Us(t,e){return e>0?e+2*t:t}var js=Ii([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),qs=Ii([{name:"a_projected_pos",components:3,type:"Float32"}],4),Ns=(Ii([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),Ii([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}])),Ks=(Ii([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]),Ii([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4)),Gs=Ii([{name:"a_pos",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4);function Zs(t,e,r){return t.sections.forEach((function(t){t.text=function(t,e,r){var n=e.layout.get("text-transform").evaluate(r,{});return "uppercase"===n?t=t.toLocaleUpperCase():"lowercase"===n&&(t=t.toLocaleLowerCase()),oi.applyArabicShaping&&(t=oi.applyArabicShaping(t)),t}(t.text,e,r);})),t}Ii([{name:"triangle",components:3,type:"Uint16"}]),Ii([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),Ii([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",components:2,name:"textOffset"},{type:"Float32",name:"collisionCircleDiameter"}]),Ii([{type:"Float32",name:"offsetX"}]),Ii([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]);var Xs={"!":"︕","#":"＃",$:"＄","%":"％","&":"＆","(":"︵",")":"︶","*":"＊","+":"＋",",":"︐","-":"︲",".":"・","/":"／",":":"︓",";":"︔","<":"︿","=":"＝",">":"﹀","?":"︖","@":"＠","[":"﹇","\\":"＼","]":"﹈","^":"＾",_:"︳","`":"｀","{":"︷","|":"―","}":"︸","~":"～","¢":"￠","£":"￡","¥":"￥","¦":"￤","¬":"￢","¯":"￣","–":"︲","—":"︱","‘":"﹃","’":"﹄","“":"﹁","”":"﹂","…":"︙","‧":"・","₩":"￦","、":"︑","。":"︒","〈":"︿","〉":"﹀","《":"︽","》":"︾","「":"﹁","」":"﹂","『":"﹃","』":"﹄","【":"︻","】":"︼","〔":"︹","〕":"︺","〖":"︗","〗":"︘","！":"︕","（":"︵","）":"︶","，":"︐","－":"︲","．":"・","：":"︓","；":"︔","＜":"︿","＞":"﹀","？":"︖","［":"﹇","］":"﹈","＿":"︳","｛":"︷","｜":"―","｝":"︸","｟":"︵","｠":"︶","｡":"︒","｢":"﹁","｣":"﹂"},Js=function(t,e,r,n,i){var a,o,s=8*i-n-1,u=(1<<s)-1,l=u>>1,p=-7,c=r?i-1:0,h=r?-1:1,f=t[e+c];for(c+=h,a=f&(1<<-p)-1,f>>=-p,p+=s;p>0;a=256*a+t[e+c],c+=h,p-=8);for(o=a&(1<<-p)-1,a>>=-p,p+=n;p>0;o=256*o+t[e+c],c+=h,p-=8);if(0===a)a=1-l;else {if(a===u)return o?NaN:1/0*(f?-1:1);o+=Math.pow(2,n),a-=l;}return (f?-1:1)*o*Math.pow(2,a-n)},Hs=function(t,e,r,n,i,a){var o,s,u,l=8*a-i-1,p=(1<<l)-1,c=p>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:a-1,y=n?1:-1,d=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=p):(o=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-o))<1&&(o--,u*=2),(e+=o+c>=1?h/u:h*Math.pow(2,1-c))*u>=2&&(o++,u/=2),o+c>=p?(s=0,o=p):o+c>=1?(s=(e*u-1)*Math.pow(2,i),o+=c):(s=e*Math.pow(2,c-1)*Math.pow(2,i),o=0));i>=8;t[r+f]=255&s,f+=y,s/=256,i-=8);for(o=o<<i|s,l+=i;l>0;t[r+f]=255&o,f+=y,o/=256,l-=8);t[r+f-y]|=128*d;},Ys=$s;function $s(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length;}$s.Varint=0,$s.Fixed64=1,$s.Bytes=2,$s.Fixed32=5;var Ws="undefined"==typeof TextDecoder?null:new TextDecoder("utf8");function Qs(t){return t.type===$s.Bytes?t.readVarint()+t.pos:t.pos+1}function tu(t,e,r){return r?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function eu(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(7*Math.LN2));r.realloc(n);for(var i=r.pos-1;i>=t;i--)r.buf[i+n]=r.buf[i];}function ru(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r]);}function nu(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r]);}function iu(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r]);}function au(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r]);}function ou(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r]);}function su(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r]);}function uu(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r]);}function lu(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r]);}function pu(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r]);}function cu(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function hu(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24;}function fu(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}function yu(t,e,r){1===t&&r.readMessage(du,e);}function du(t,e,r){if(3===t){var n=r.readMessage(mu,{}),i=n.width,a=n.height,o=n.left,s=n.top,u=n.advance;e.push({id:n.id,bitmap:new go({width:i+6,height:a+6},n.bitmap),metrics:{width:i,height:a,left:o,top:s,advance:u}});}}function mu(t,e,r){1===t?e.id=r.readVarint():2===t?e.bitmap=r.readBytes():3===t?e.width=r.readVarint():4===t?e.height=r.readVarint():5===t?e.left=r.readSVarint():6===t?e.top=r.readSVarint():7===t&&(e.advance=r.readVarint());}function vu(t){for(var e=0,r=0,n=0,i=t;n<i.length;n+=1){var a=i[n];e+=a.w*a.h,r=Math.max(r,a.w);}t.sort((function(t,e){return e.h-t.h}));for(var o=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),r),h:1/0}],s=0,u=0,l=0,p=t;l<p.length;l+=1)for(var c=p[l],h=o.length-1;h>=0;h--){var f=o[h];if(!(c.w>f.w||c.h>f.h)){if(c.x=f.x,c.y=f.y,u=Math.max(u,c.y+c.h),s=Math.max(s,c.x+c.w),c.w===f.w&&c.h===f.h){var y=o.pop();h<o.length&&(o[h]=y);}else c.h===f.h?(f.x+=c.w,f.w-=c.w):c.w===f.w?(f.y+=c.h,f.h-=c.h):(o.push({x:f.x+c.w,y:f.y,w:f.w-c.w,h:c.h}),f.y+=c.h,f.h-=c.h);break}}return {w:s,h:u,fill:e/(s*u)||0}}$s.prototype={destroy:function(){this.buf=null;},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,a=this.pos;this.type=7&n,t(i,e,this),this.pos===a&&this.skip(n);}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=cu(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=fu(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=cu(this.buf,this.pos)+4294967296*cu(this.buf,this.pos+4);return this.pos+=8,t},readSFixed64:function(){var t=cu(this.buf,this.pos)+4294967296*fu(this.buf,this.pos+4);return this.pos+=8,t},readFloat:function(){var t=Js(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=Js(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e,r,n=this.buf;return e=127&(r=n[this.pos++]),r<128?e:(e|=(127&(r=n[this.pos++]))<<7,r<128?e:(e|=(127&(r=n[this.pos++]))<<14,r<128?e:(e|=(127&(r=n[this.pos++]))<<21,r<128?e:function(t,e,r){var n,i,a=r.buf;if(n=(112&(i=a[r.pos++]))>>4,i<128)return tu(t,n,e);if(n|=(127&(i=a[r.pos++]))<<3,i<128)return tu(t,n,e);if(n|=(127&(i=a[r.pos++]))<<10,i<128)return tu(t,n,e);if(n|=(127&(i=a[r.pos++]))<<17,i<128)return tu(t,n,e);if(n|=(127&(i=a[r.pos++]))<<24,i<128)return tu(t,n,e);if(n|=(1&(i=a[r.pos++]))<<31,i<128)return tu(t,n,e);throw new Error("Expected varint not more than 10 bytes")}(e|=(15&(r=n[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,e=this.pos;return this.pos=t,t-e>=12&&Ws?function(t,e,r){return Ws.decode(t.subarray(e,r))}(this.buf,e,t):function(t,e,r){for(var n="",i=e;i<r;){var a,o,s,u=t[i],l=null,p=u>239?4:u>223?3:u>191?2:1;if(i+p>r)break;1===p?u<128&&(l=u):2===p?128==(192&(a=t[i+1]))&&(l=(31&u)<<6|63&a)<=127&&(l=null):3===p?(o=t[i+2],128==(192&(a=t[i+1]))&&128==(192&o)&&((l=(15&u)<<12|(63&a)<<6|63&o)<=2047||l>=55296&&l<=57343)&&(l=null)):4===p&&(o=t[i+2],s=t[i+3],128==(192&(a=t[i+1]))&&128==(192&o)&&128==(192&s)&&((l=(15&u)<<18|(63&a)<<12|(63&o)<<6|63&s)<=65535||l>=1114112)&&(l=null)),null===l?(l=65533,p=1):l>65535&&(l-=65536,n+=String.fromCharCode(l>>>10&1023|55296),l=56320|1023&l),n+=String.fromCharCode(l),i+=p;}return n}(this.buf,e,t)},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==$s.Bytes)return t.push(this.readVarint(e));var r=Qs(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==$s.Bytes)return t.push(this.readSVarint());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==$s.Bytes)return t.push(this.readBoolean());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==$s.Bytes)return t.push(this.readFloat());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==$s.Bytes)return t.push(this.readDouble());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==$s.Bytes)return t.push(this.readFixed32());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==$s.Bytes)return t.push(this.readSFixed32());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==$s.Bytes)return t.push(this.readFixed64());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==$s.Bytes)return t.push(this.readSFixed64());var e=Qs(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=7&t;if(e===$s.Varint)for(;this.buf[this.pos++]>127;);else if(e===$s.Bytes)this.pos=this.readVarint()+this.pos;else if(e===$s.Fixed32)this.pos+=4;else {if(e!==$s.Fixed64)throw new Error("Unimplemented type: "+e);this.pos+=8;}},writeTag:function(t,e){this.writeVarint(t<<3|e);},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e;}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),hu(this.buf,t,this.pos),this.pos+=4;},writeSFixed32:function(t){this.realloc(4),hu(this.buf,t,this.pos),this.pos+=4;},writeFixed64:function(t){this.realloc(8),hu(this.buf,-1&t,this.pos),hu(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8;},writeSFixed64:function(t){this.realloc(8),hu(this.buf,-1&t,this.pos),hu(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8;},writeVarint:function(t){(t=+t||0)>268435455||t<0?function(t,e){var r,n;if(t>=0?(r=t%4294967296|0,n=t/4294967296|0):(n=~(-t/4294967296),4294967295^(r=~(-t%4294967296))?r=r+1|0:(r=0,n=n+1|0)),t>=0x10000000000000000||t<-0x10000000000000000)throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10),function(t,e,r){r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,r.buf[r.pos]=127&(t>>>=7);}(r,0,e),function(t,e){var r=(7&t)<<4;e.buf[e.pos++]|=r|((t>>>=3)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t)))));}(n,e);}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))));},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t);},writeBoolean:function(t){this.writeVarint(Boolean(t));},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var e=this.pos;this.pos=function(t,e,r){for(var n,i,a=0;a<e.length;a++){if((n=e.charCodeAt(a))>55295&&n<57344){if(!i){n>56319||a+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):i=n;continue}if(n<56320){t[r++]=239,t[r++]=191,t[r++]=189,i=n;continue}n=i-55296<<10|n-56320|65536,i=null;}else i&&(t[r++]=239,t[r++]=191,t[r++]=189,i=null);n<128?t[r++]=n:(n<2048?t[r++]=n>>6|192:(n<65536?t[r++]=n>>12|224:(t[r++]=n>>18|240,t[r++]=n>>12&63|128),t[r++]=n>>6&63|128),t[r++]=63&n|128);}return r}(this.buf,t,this.pos);var r=this.pos-e;r>=128&&eu(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r;},writeFloat:function(t){this.realloc(4),Hs(this.buf,t,this.pos,!0,23,4),this.pos+=4;},writeDouble:function(t){this.realloc(8),Hs(this.buf,t,this.pos,!0,52,8),this.pos+=8;},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r];},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&eu(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n;},writeMessage:function(t,e,r){this.writeTag(t,$s.Bytes),this.writeRawMessage(e,r);},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,ru,e);},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,nu,e);},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,ou,e);},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,iu,e);},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,au,e);},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,su,e);},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,uu,e);},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,lu,e);},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,pu,e);},writeBytesField:function(t,e){this.writeTag(t,$s.Bytes),this.writeBytes(e);},writeFixed32Field:function(t,e){this.writeTag(t,$s.Fixed32),this.writeFixed32(e);},writeSFixed32Field:function(t,e){this.writeTag(t,$s.Fixed32),this.writeSFixed32(e);},writeFixed64Field:function(t,e){this.writeTag(t,$s.Fixed64),this.writeFixed64(e);},writeSFixed64Field:function(t,e){this.writeTag(t,$s.Fixed64),this.writeSFixed64(e);},writeVarintField:function(t,e){this.writeTag(t,$s.Varint),this.writeVarint(e);},writeSVarintField:function(t,e){this.writeTag(t,$s.Varint),this.writeSVarint(e);},writeStringField:function(t,e){this.writeTag(t,$s.Bytes),this.writeString(e);},writeFloatField:function(t,e){this.writeTag(t,$s.Fixed32),this.writeFloat(e);},writeDoubleField:function(t,e){this.writeTag(t,$s.Fixed64),this.writeDouble(e);},writeBooleanField:function(t,e){this.writeVarintField(t,Boolean(e));}};var gu=function(t,e){var r=e.pixelRatio,n=e.version,i=e.stretchX,a=e.stretchY,o=e.content;this.paddedRect=t,this.pixelRatio=r,this.stretchX=i,this.stretchY=a,this.content=o,this.version=n;},xu={tl:{configurable:!0},br:{configurable:!0},tlbr:{configurable:!0},displaySize:{configurable:!0}};xu.tl.get=function(){return [this.paddedRect.x+1,this.paddedRect.y+1]},xu.br.get=function(){return [this.paddedRect.x+this.paddedRect.w-1,this.paddedRect.y+this.paddedRect.h-1]},xu.tlbr.get=function(){return this.tl.concat(this.br)},xu.displaySize.get=function(){return [(this.paddedRect.w-2)/this.pixelRatio,(this.paddedRect.h-2)/this.pixelRatio]},Object.defineProperties(gu.prototype,xu);var bu=function(t,e){var r={},n={};this.haveRenderCallbacks=[];var i=[];this.addImages(t,r,i),this.addImages(e,n,i);var a=vu(i),o=new xo({width:a.w||1,height:a.h||1});for(var s in t){var u=t[s],l=r[s].paddedRect;xo.copy(u.data,o,{x:0,y:0},{x:l.x+1,y:l.y+1},u.data);}for(var p in e){var c=e[p],h=n[p].paddedRect,f=h.x+1,y=h.y+1,d=c.data.width,m=c.data.height;xo.copy(c.data,o,{x:0,y:0},{x:f,y:y},c.data),xo.copy(c.data,o,{x:0,y:m-1},{x:f,y:y-1},{width:d,height:1}),xo.copy(c.data,o,{x:0,y:0},{x:f,y:y+m},{width:d,height:1}),xo.copy(c.data,o,{x:d-1,y:0},{x:f-1,y:y},{width:1,height:m}),xo.copy(c.data,o,{x:0,y:0},{x:f+d,y:y},{width:1,height:m});}this.image=o,this.iconPositions=r,this.patternPositions=n;};bu.prototype.addImages=function(t,e,r){for(var n in t){var i=t[n],a={x:0,y:0,w:i.data.width+2,h:i.data.height+2};r.push(a),e[n]=new gu(a,i),i.hasRenderCallback&&this.haveRenderCallbacks.push(n);}},bu.prototype.patchUpdatedImages=function(t,e){for(var r in t.dispatchRenderCallbacks(this.haveRenderCallbacks),t.updatedImages)this.patchUpdatedImage(this.iconPositions[r],t.getImage(r),e),this.patchUpdatedImage(this.patternPositions[r],t.getImage(r),e);},bu.prototype.patchUpdatedImage=function(t,e,r){if(t&&e&&t.version!==e.version){t.version=e.version;var n=t.tl;r.update(e.data,void 0,{x:n[0],y:n[1]});}},On("ImagePosition",gu),On("ImageAtlas",bu);var wu={horizontal:1,vertical:2,horizontalOnly:3},_u=function(){this.scale=1,this.fontStack="",this.imageName=null;};_u.forText=function(t,e){var r=new _u;return r.scale=t||1,r.fontStack=e,r},_u.forImage=function(t){var e=new _u;return e.imageName=t,e};var Au=function(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null;};function Su(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d){var m,v=Au.fromFeature(t,i);c===wu.vertical&&v.verticalizePunctuation();var g=oi.processBidirectionalText,x=oi.processStyledBidirectionalText;if(g&&1===v.sections.length){m=[];for(var b=0,w=g(v.toString(),Mu(v,l,a,e,n,f,y));b<w.length;b+=1){var _=w[b],A=new Au;A.text=_,A.sections=v.sections;for(var S=0;S<_.length;S++)A.sectionIndex.push(0);m.push(A);}}else if(x){m=[];for(var k=0,I=x(v.text,v.sectionIndex,Mu(v,l,a,e,n,f,y));k<I.length;k+=1){var z=I[k],C=new Au;C.text=z[0],C.sectionIndex=z[1],C.sections=v.sections,m.push(C);}}else m=function(t,e){for(var r=[],n=t.text,i=0,a=0,o=e;a<o.length;a+=1){var s=o[a];r.push(t.substring(i,s)),i=s;}return i<n.length&&r.push(t.substring(i,n.length)),r}(v,Mu(v,l,a,e,n,f,y));var E=[],P={positionedLines:E,text:v.toString(),top:p[1],bottom:p[1],left:p[0],right:p[0],writingMode:c,iconsInText:!1,verticalizable:!1};return function(t,e,r,n,i,a,o,s,u,l,p,c){for(var h=0,f=-17,y=0,d=0,m="right"===s?1:"left"===s?0:.5,v=0,g=0,x=i;g<x.length;g+=1){var b=x[g];b.trim();var w=b.getMaxScale(),_=24*(w-1),A={positionedGlyphs:[],lineOffset:0};t.positionedLines[v]=A;var S=A.positionedGlyphs,k=0;if(b.length()){for(var I=0;I<b.length();I++){var z=b.getSection(I),C=b.getSectionIndex(I),E=b.getCharCode(I),P=0,M=null,B=null,T=null,V=24,F=!(u===wu.horizontal||!p&&!Xn(E)||p&&(ku[E]||(K=E,Gn.Arabic(K)||Gn["Arabic Supplement"](K)||Gn["Arabic Extended-A"](K)||Gn["Arabic Presentation Forms-A"](K)||Gn["Arabic Presentation Forms-B"](K))));if(z.imageName){var D=n[z.imageName];if(!D)continue;T=z.imageName,t.iconsInText=t.iconsInText||!0,B=D.paddedRect;var L=D.displaySize;z.scale=24*z.scale/c,P=_+(24-L[1]*z.scale),V=(M={width:L[0],height:L[1],left:1,top:-3,advance:F?L[1]:L[0]}).advance;var O=F?L[0]*z.scale-24*w:L[1]*z.scale-24*w;O>0&&O>k&&(k=O);}else {var R=r[z.fontStack],U=R&&R[E];if(U&&U.rect)B=U.rect,M=U.metrics;else {var j=e[z.fontStack],q=j&&j[E];if(!q)continue;M=q.metrics;}P=24*(w-z.scale);}F?(t.verticalizable=!0,S.push({glyph:E,imageName:T,x:h,y:f+P,vertical:F,scale:z.scale,fontStack:z.fontStack,sectionIndex:C,metrics:M,rect:B}),h+=V*z.scale+l):(S.push({glyph:E,imageName:T,x:h,y:f+P,vertical:F,scale:z.scale,fontStack:z.fontStack,sectionIndex:C,metrics:M,rect:B}),h+=M.advance*z.scale+l);}0!==S.length&&(y=Math.max(h-l,y),Tu(S,0,S.length-1,m,k)),h=0;var N=a*w+k;A.lineOffset=Math.max(k,_),f+=N,d=Math.max(N,d),++v;}else f+=a,++v;}var K,G=f- -17,Z=Bu(o),X=Z.horizontalAlign,J=Z.verticalAlign;((function(t,e,r,n,i,a,o,s,u){var l,p=(e-r)*i;l=a!==o?-s*n- -17:(-n*u+.5)*o;for(var c=0,h=t;c<h.length;c+=1)for(var f=0,y=h[c].positionedGlyphs;f<y.length;f+=1){var d=y[f];d.x+=p,d.y+=l;}}))(t.positionedLines,m,X,J,y,d,a,G,i.length),t.top+=-J*G,t.bottom=t.top+G,t.left+=-X*y,t.right=t.left+y;}(P,e,r,n,m,o,s,u,c,l,h,d),!function(t){for(var e=0,r=t;e<r.length;e+=1)if(0!==r[e].positionedGlyphs.length)return !1;return !0}(E)&&P}Au.fromFeature=function(t,e){for(var r=new Au,n=0;n<t.sections.length;n++){var i=t.sections[n];i.image?r.addImageSection(i):r.addTextSection(i,e);}return r},Au.prototype.length=function(){return this.text.length},Au.prototype.getSection=function(t){return this.sections[this.sectionIndex[t]]},Au.prototype.getSectionIndex=function(t){return this.sectionIndex[t]},Au.prototype.getCharCode=function(t){return this.text.charCodeAt(t)},Au.prototype.verticalizePunctuation=function(){this.text=function(t){for(var e="",r=0;r<t.length;r++){var n=t.charCodeAt(r+1)||null,i=t.charCodeAt(r-1)||null;e+=n&&Jn(n)&&!Xs[t[r+1]]||i&&Jn(i)&&!Xs[t[r-1]]||!Xs[t[r]]?t[r]:Xs[t[r]];}return e}(this.text);},Au.prototype.trim=function(){for(var t=0,e=0;e<this.text.length&&ku[this.text.charCodeAt(e)];e++)t++;for(var r=this.text.length,n=this.text.length-1;n>=0&&n>=t&&ku[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(t,r),this.sectionIndex=this.sectionIndex.slice(t,r);},Au.prototype.substring=function(t,e){var r=new Au;return r.text=this.text.substring(t,e),r.sectionIndex=this.sectionIndex.slice(t,e),r.sections=this.sections,r},Au.prototype.toString=function(){return this.text},Au.prototype.getMaxScale=function(){var t=this;return this.sectionIndex.reduce((function(e,r){return Math.max(e,t.sections[r].scale)}),0)},Au.prototype.addTextSection=function(t,e){this.text+=t.text,this.sections.push(_u.forText(t.scale,t.fontStack||e));for(var r=this.sections.length-1,n=0;n<t.text.length;++n)this.sectionIndex.push(r);},Au.prototype.addImageSection=function(t){var e=t.image?t.image.name:"";if(0!==e.length){var r=this.getNextImageSectionCharCode();r?(this.text+=String.fromCharCode(r),this.sections.push(_u.forImage(e)),this.sectionIndex.push(this.sections.length-1)):A("Reached maximum number of images 6401");}else A("Can't add FormattedSection with an empty image.");},Au.prototype.getNextImageSectionCharCode=function(){return this.imageSectionID?this.imageSectionID>=63743?null:++this.imageSectionID:(this.imageSectionID=57344,this.imageSectionID)};var ku={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},Iu={};function zu(t,e,r,n,i,a){if(e.imageName){var o=n[e.imageName];return o?o.displaySize[0]*e.scale*24/a+i:0}var s=r[e.fontStack],u=s&&s[t];return u?u.metrics.advance*e.scale+i:0}function Cu(t,e,r,n){var i=Math.pow(t-e,2);return n?t<e?i/2:2*i:i+Math.abs(r)*r}function Eu(t,e,r){var n=0;return 10===t&&(n-=1e4),r&&(n+=150),40!==t&&65288!==t||(n+=50),41!==e&&65289!==e||(n+=50),n}function Pu(t,e,r,n,i,a){for(var o=null,s=Cu(e,r,i,a),u=0,l=n;u<l.length;u+=1){var p=l[u],c=Cu(e-p.x,r,i,a)+p.badness;c<=s&&(o=p,s=c);}return {index:t,x:e,priorBreak:o,badness:s}}function Mu(t,e,r,n,i,a,o){if("point"!==a)return [];if(!t)return [];for(var s,u=[],l=function(t,e,r,n,i,a){for(var o=0,s=0;s<t.length();s++){var u=t.getSection(s);o+=zu(t.getCharCode(s),u,n,i,e,a);}return o/Math.max(1,Math.ceil(o/r))}(t,e,r,n,i,o),p=t.text.indexOf("​")>=0,c=0,h=0;h<t.length();h++){var f=t.getSection(h),y=t.getCharCode(h);if(ku[y]||(c+=zu(y,f,n,i,e,o)),h<t.length()-1){var d=!((s=y)<11904||!(Gn["Bopomofo Extended"](s)||Gn.Bopomofo(s)||Gn["CJK Compatibility Forms"](s)||Gn["CJK Compatibility Ideographs"](s)||Gn["CJK Compatibility"](s)||Gn["CJK Radicals Supplement"](s)||Gn["CJK Strokes"](s)||Gn["CJK Symbols and Punctuation"](s)||Gn["CJK Unified Ideographs Extension A"](s)||Gn["CJK Unified Ideographs"](s)||Gn["Enclosed CJK Letters and Months"](s)||Gn["Halfwidth and Fullwidth Forms"](s)||Gn.Hiragana(s)||Gn["Ideographic Description Characters"](s)||Gn["Kangxi Radicals"](s)||Gn["Katakana Phonetic Extensions"](s)||Gn.Katakana(s)||Gn["Vertical Forms"](s)||Gn["Yi Radicals"](s)||Gn["Yi Syllables"](s)));(Iu[y]||d||f.imageName)&&u.push(Pu(h+1,c,l,u,Eu(y,t.getCharCode(h+1),d&&p),!1));}}return function t(e){return e?t(e.priorBreak).concat(e.index):[]}(Pu(t.length(),c,l,u,0,!0))}function Bu(t){var e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=1;break;case"left":case"top-left":case"bottom-left":e=0;}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;}return {horizontalAlign:e,verticalAlign:r}}function Tu(t,e,r,n,i){if(n||i)for(var a=t[r],o=(t[r].x+a.metrics.advance*a.scale)*n,s=e;s<=r;s++)t[s].x-=o,t[s].y+=i;}function Vu(t,e,r,n,i,a){var o,s=t.image;if(s.content){var u=s.content,l=s.pixelRatio||1;o=[u[0]/l,u[1]/l,s.displaySize[0]-u[2]/l,s.displaySize[1]-u[3]/l];}var p,c,h,f,y=e.left*a,d=e.right*a;"width"===r||"both"===r?(f=i[0]+y-n[3],c=i[0]+d+n[1]):c=(f=i[0]+(y+d-s.displaySize[0])/2)+s.displaySize[0];var m=e.top*a,v=e.bottom*a;return "height"===r||"both"===r?(p=i[1]+m-n[0],h=i[1]+v+n[2]):h=(p=i[1]+(m+v-s.displaySize[1])/2)+s.displaySize[1],{image:s,top:p,right:c,bottom:h,left:f,collisionPadding:o}}Iu[10]=!0,Iu[32]=!0,Iu[38]=!0,Iu[40]=!0,Iu[41]=!0,Iu[43]=!0,Iu[45]=!0,Iu[47]=!0,Iu[173]=!0,Iu[183]=!0,Iu[8203]=!0,Iu[8208]=!0,Iu[8211]=!0,Iu[8231]=!0;var Fu=function(t){function e(e,r,n,i){t.call(this,e,r),this.angle=n,void 0!==i&&(this.segment=i);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.clone=function(){return new e(this.x,this.y,this.angle,this.segment)},e}(i);function Du(t,e){var r=e.expression;if("constant"===r.kind)return {kind:"constant",layoutSize:r.evaluate(new si(t+1))};if("source"===r.kind)return {kind:"source"};for(var n=r.zoomStops,i=r.interpolationType,a=0;a<n.length&&n[a]<=t;)a++;for(var o=a=Math.max(0,a-1);o<n.length&&n[o]<t+1;)o++;o=Math.min(n.length-1,o);var s=n[a],u=n[o];return "composite"===r.kind?{kind:"composite",minZoom:s,maxZoom:u,interpolationType:i}:{kind:"camera",minZoom:s,maxZoom:u,minSize:r.evaluate(new si(s)),maxSize:r.evaluate(new si(u)),interpolationType:i}}function Lu(t,e,r){var n=e.uSize,i=r.lowerSize;return "source"===t.kind?i/128:"composite"===t.kind?Ke(i/128,r.upperSize/128,e.uSizeT):n}function Ou(t,e){var r=0,n=0;if("constant"===t.kind)n=t.layoutSize;else if("source"!==t.kind){var i=t.interpolationType,a=i?p(ar.interpolationFactor(i,e,t.minZoom,t.maxZoom),0,1):0;"camera"===t.kind?n=Ke(t.minSize,t.maxSize,a):r=a;}return {uSizeT:r,uSize:n}}On("Anchor",Fu);var Ru=Object.freeze({__proto__:null,getSizeData:Du,evaluateSizeForFeature:Lu,evaluateSizeForZoom:Ou,SIZE_PACK_FACTOR:128});function Uu(t,e,r,n,i){if(void 0===e.segment)return !0;for(var a=e,o=e.segment+1,s=0;s>-r/2;){if(--o<0)return !1;s-=t[o].dist(a),a=t[o];}s+=t[o].dist(t[o+1]),o++;for(var u=[],l=0;s<r/2;){var p=t[o],c=t[o+1];if(!c)return !1;var h=t[o-1].angleTo(p)-p.angleTo(c);for(h=Math.abs((h+3*Math.PI)%(2*Math.PI)-Math.PI),u.push({distance:s,angleDelta:h}),l+=h;s-u[0].distance>n;)l-=u.shift().angleDelta;if(l>i)return !1;o++,s+=p.dist(c);}return !0}function ju(t){for(var e=0,r=0;r<t.length-1;r++)e+=t[r].dist(t[r+1]);return e}function qu(t,e,r){return t?.6*e*r:0}function Nu(t,e){return Math.max(t?t.right-t.left:0,e?e.right-e.left:0)}function Ku(t,e,r,n,i,a){for(var o=qu(r,i,a),s=Nu(r,n)*a,u=0,l=ju(t)/2,p=0;p<t.length-1;p++){var c=t[p],h=t[p+1],f=c.dist(h);if(u+f>l){var y=(l-u)/f,d=Ke(c.x,h.x,y),m=Ke(c.y,h.y,y),v=new Fu(d,m,h.angleTo(c),p);return v._round(),!o||Uu(t,v,s,o,e)?v:void 0}u+=f;}}function Gu(t,e,r,n,i,a,o,s,u){var l=qu(n,a,o),p=Nu(n,i),c=p*o,h=0===t[0].x||t[0].x===u||0===t[0].y||t[0].y===u;return e-c<e/4&&(e=c+e/4),function t(e,r,n,i,a,o,s,u,l){for(var p=o/2,c=ju(e),h=0,f=r-n,y=[],d=0;d<e.length-1;d++){for(var m=e[d],v=e[d+1],g=m.dist(v),x=v.angleTo(m);f+n<h+g;){var b=((f+=n)-h)/g,w=Ke(m.x,v.x,b),_=Ke(m.y,v.y,b);if(w>=0&&w<l&&_>=0&&_<l&&f-p>=0&&f+p<=c){var A=new Fu(w,_,x,d);A._round(),i&&!Uu(e,A,o,i,a)||y.push(A);}}h+=g;}return u||y.length||s||(y=t(e,h/2,n,i,a,o,s,!0,l)),y}(t,h?e/2*s%e:(p/2+2*a)*o*s%e,e,l,r,c,h,!1,u)}function Zu(t,e,r,n,a){for(var o=[],s=0;s<t.length;s++)for(var u=t[s],l=void 0,p=0;p<u.length-1;p++){var c=u[p],h=u[p+1];c.x<e&&h.x<e||(c.x<e?c=new i(e,c.y+(e-c.x)/(h.x-c.x)*(h.y-c.y))._round():h.x<e&&(h=new i(e,c.y+(e-c.x)/(h.x-c.x)*(h.y-c.y))._round()),c.y<r&&h.y<r||(c.y<r?c=new i(c.x+(r-c.y)/(h.y-c.y)*(h.x-c.x),r)._round():h.y<r&&(h=new i(c.x+(r-c.y)/(h.y-c.y)*(h.x-c.x),r)._round()),c.x>=n&&h.x>=n||(c.x>=n?c=new i(n,c.y+(n-c.x)/(h.x-c.x)*(h.y-c.y))._round():h.x>=n&&(h=new i(n,c.y+(n-c.x)/(h.x-c.x)*(h.y-c.y))._round()),c.y>=a&&h.y>=a||(c.y>=a?c=new i(c.x+(a-c.y)/(h.y-c.y)*(h.x-c.x),a)._round():h.y>=a&&(h=new i(c.x+(a-c.y)/(h.y-c.y)*(h.x-c.x),a)._round()),l&&c.equals(l[l.length-1])||o.push(l=[c]),l.push(h)))));}return o}function Xu(t,e,r,n){var a=[],o=t.image,s=o.pixelRatio,u=o.paddedRect.w-2,l=o.paddedRect.h-2,p=t.right-t.left,c=t.bottom-t.top,h=o.stretchX||[[0,u]],f=o.stretchY||[[0,l]],y=function(t,e){return t+e[1]-e[0]},d=h.reduce(y,0),m=f.reduce(y,0),v=u-d,g=l-m,x=0,b=d,w=0,_=m,A=0,S=v,k=0,I=g;if(o.content&&n){var z=o.content;x=Ju(h,0,z[0]),w=Ju(f,0,z[1]),b=Ju(h,z[0],z[2]),_=Ju(f,z[1],z[3]),A=z[0]-x,k=z[1]-w,S=z[2]-z[0]-b,I=z[3]-z[1]-_;}var C=function(n,a,u,l){var h=Yu(n.stretch-x,b,p,t.left),f=$u(n.fixed-A,S,n.stretch,d),y=Yu(a.stretch-w,_,c,t.top),v=$u(a.fixed-k,I,a.stretch,m),g=Yu(u.stretch-x,b,p,t.left),z=$u(u.fixed-A,S,u.stretch,d),C=Yu(l.stretch-w,_,c,t.top),E=$u(l.fixed-k,I,l.stretch,m),P=new i(h,y),M=new i(g,y),B=new i(g,C),T=new i(h,C),V=new i(f/s,v/s),F=new i(z/s,E/s),D=e*Math.PI/180;if(D){var L=Math.sin(D),O=Math.cos(D),R=[O,-L,L,O];P._matMult(R),M._matMult(R),T._matMult(R),B._matMult(R);}var U=n.stretch+n.fixed,j=a.stretch+a.fixed;return {tl:P,tr:M,bl:T,br:B,tex:{x:o.paddedRect.x+1+U,y:o.paddedRect.y+1+j,w:u.stretch+u.fixed-U,h:l.stretch+l.fixed-j},writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:V,pixelOffsetBR:F,minFontScaleX:S/s/p,minFontScaleY:I/s/c,isSDF:r}};if(n&&(o.stretchX||o.stretchY))for(var E=Hu(h,v,d),P=Hu(f,g,m),M=0;M<E.length-1;M++)for(var B=E[M],T=E[M+1],V=0;V<P.length-1;V++)a.push(C(B,P[V],T,P[V+1]));else a.push(C({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:u+1},{fixed:0,stretch:l+1}));return a}function Ju(t,e,r){for(var n=0,i=0,a=t;i<a.length;i+=1){var o=a[i];n+=Math.max(e,Math.min(r,o[1]))-Math.max(e,Math.min(r,o[0]));}return n}function Hu(t,e,r){for(var n=[{fixed:-1,stretch:0}],i=0,a=t;i<a.length;i+=1){var o=a[i],s=o[0],u=o[1],l=n[n.length-1];n.push({fixed:s-l.stretch,stretch:l.stretch}),n.push({fixed:s-l.stretch,stretch:l.stretch+(u-s)});}return n.push({fixed:e+1,stretch:r}),n}function Yu(t,e,r,n){return t/e*r+n}function $u(t,e,r,n){return t-e*r/n}var Wu=function(t,e,r,n,a,o,s,u,l,p){if(this.boxStartIndex=t.length,l){var c=o.top,h=o.bottom,f=o.collisionPadding;f&&(c-=f[1],h+=f[3]);var y=h-c;y>0&&(y=Math.max(10,y),this.circleDiameter=y);}else {var d=o.top*s-u,m=o.bottom*s+u,v=o.left*s-u,g=o.right*s+u,x=o.collisionPadding;if(x&&(v-=x[0]*s,d-=x[1]*s,g+=x[2]*s,m+=x[3]*s),p){var b=new i(v,d),w=new i(g,d),_=new i(v,m),A=new i(g,m),S=p*Math.PI/180;b._rotate(S),w._rotate(S),_._rotate(S),A._rotate(S),v=Math.min(b.x,w.x,_.x,A.x),g=Math.max(b.x,w.x,_.x,A.x),d=Math.min(b.y,w.y,_.y,A.y),m=Math.max(b.y,w.y,_.y,A.y);}t.emplaceBack(e.x,e.y,v,d,g,m,r,n,a);}this.boxEndIndex=t.length;},Qu=function(t,e){if(void 0===t&&(t=[]),void 0===e&&(e=tl),this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(var r=(this.length>>1)-1;r>=0;r--)this._down(r);};function tl(t,e){return t<e?-1:t>e?1:0}function el(t,e,r){void 0===e&&(e=1),void 0===r&&(r=!1);for(var n=1/0,a=1/0,o=-1/0,s=-1/0,u=t[0],l=0;l<u.length;l++){var p=u[l];(!l||p.x<n)&&(n=p.x),(!l||p.y<a)&&(a=p.y),(!l||p.x>o)&&(o=p.x),(!l||p.y>s)&&(s=p.y);}var c=Math.min(o-n,s-a),h=c/2,f=new Qu([],rl);if(0===c)return new i(n,a);for(var y=n;y<o;y+=c)for(var d=a;d<s;d+=c)f.push(new nl(y+h,d+h,h,t));for(var m=function(t){for(var e=0,r=0,n=0,i=t[0],a=0,o=i.length,s=o-1;a<o;s=a++){var u=i[a],l=i[s],p=u.x*l.y-l.x*u.y;r+=(u.x+l.x)*p,n+=(u.y+l.y)*p,e+=3*p;}return new nl(r/e,n/e,0,t)}(t),v=f.length;f.length;){var g=f.pop();(g.d>m.d||!m.d)&&(m=g,r&&console.log("found best %d after %d probes",Math.round(1e4*g.d)/1e4,v)),g.max-m.d<=e||(f.push(new nl(g.p.x-(h=g.h/2),g.p.y-h,h,t)),f.push(new nl(g.p.x+h,g.p.y-h,h,t)),f.push(new nl(g.p.x-h,g.p.y+h,h,t)),f.push(new nl(g.p.x+h,g.p.y+h,h,t)),v+=4);}return r&&(console.log("num probes: "+v),console.log("best distance: "+m.d)),m.p}function rl(t,e){return e.max-t.max}function nl(t,e,r,n){this.p=new i(t,e),this.h=r,this.d=function(t,e){for(var r=!1,n=1/0,i=0;i<e.length;i++)for(var a=e[i],o=0,s=a.length,u=s-1;o<s;u=o++){var l=a[o],p=a[u];l.y>t.y!=p.y>t.y&&t.x<(p.x-l.x)*(t.y-l.y)/(p.y-l.y)+l.x&&(r=!r),n=Math.min(n,Ya(t,l,p));}return (r?1:-1)*Math.sqrt(n)}(this.p,n),this.max=this.d+this.h*Math.SQRT2;}Qu.prototype.push=function(t){this.data.push(t),this.length++,this._up(this.length-1);},Qu.prototype.pop=function(){if(0!==this.length){var t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}},Qu.prototype.peek=function(){return this.data[0]},Qu.prototype._up=function(t){for(var e=this.data,r=this.compare,n=e[t];t>0;){var i=t-1>>1,a=e[i];if(r(n,a)>=0)break;e[t]=a,t=i;}e[t]=n;},Qu.prototype._down=function(t){for(var e=this.data,r=this.compare,n=this.length>>1,i=e[t];t<n;){var a=1+(t<<1),o=e[a],s=a+1;if(s<this.length&&r(e[s],o)<0&&(a=s,o=e[s]),r(o,i)>=0)break;e[t]=o,t=a;}e[t]=i;};var il=Number.POSITIVE_INFINITY;function al(t,e){return e[1]!==il?function(t,e,r){var n=0,i=0;switch(e=Math.abs(e),r=Math.abs(r),t){case"top-right":case"top-left":case"top":i=r-7;break;case"bottom-right":case"bottom-left":case"bottom":i=7-r;}switch(t){case"top-right":case"bottom-right":case"right":n=-e;break;case"top-left":case"bottom-left":case"left":n=e;}return [n,i]}(t,e[0],e[1]):function(t,e){var r=0,n=0;e<0&&(e=0);var i=e/Math.sqrt(2);switch(t){case"top-right":case"top-left":n=i-7;break;case"bottom-right":case"bottom-left":n=7-i;break;case"bottom":n=7-e;break;case"top":n=e-7;}switch(t){case"top-right":case"bottom-right":r=-i;break;case"top-left":case"bottom-left":r=i;break;case"left":r=e;break;case"right":r=-e;}return [r,n]}(t,e[0])}function ol(t){switch(t){case"right":case"top-right":case"bottom-right":return "right";case"left":case"top-left":case"bottom-left":return "left"}return "center"}function sl(t,e,r,n,a,o,s,u,l,p,c,h,f,y,d){var m=function(t,e,r,n,a,o,s,u){for(var l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,p=[],c=0,h=e.positionedLines;c<h.length;c+=1)for(var f=h[c],y=0,d=f.positionedGlyphs;y<d.length;y+=1){var m=d[y];if(m.rect){var v=m.rect||{},g=4,x=!0,b=1,w=0,_=(a||u)&&m.vertical,A=m.metrics.advance*m.scale/2;if(u&&e.verticalizable&&(w=f.lineOffset/2-(m.imageName?-(24-m.metrics.width*m.scale)/2:24*(m.scale-1))),m.imageName){var S=s[m.imageName];x=S.sdf,g=1/(b=S.pixelRatio);}var k=a?[m.x+A,m.y]:[0,0],I=a?[0,0]:[m.x+A+r[0],m.y+r[1]-w],z=[0,0];_&&(z=I,I=[0,0]);var C=(m.metrics.left-g)*m.scale-A+I[0],E=(-m.metrics.top-g)*m.scale+I[1],P=C+v.w*m.scale/b,M=E+v.h*m.scale/b,B=new i(C,E),T=new i(P,E),V=new i(C,M),F=new i(P,M);if(_){var D=new i(-A,A- -17),L=-Math.PI/2,O=12-A,R=new i(22-O,-(m.imageName?O:0)),U=new(Function.prototype.bind.apply(i,[null].concat(z)));B._rotateAround(L,D)._add(R)._add(U),T._rotateAround(L,D)._add(R)._add(U),V._rotateAround(L,D)._add(R)._add(U),F._rotateAround(L,D)._add(R)._add(U);}if(l){var j=Math.sin(l),q=Math.cos(l),N=[q,-j,j,q];B._matMult(N),T._matMult(N),V._matMult(N),F._matMult(N);}var K=new i(0,0),G=new i(0,0);p.push({tl:B,tr:T,bl:V,br:F,tex:v,writingMode:e.writingMode,glyphOffset:k,sectionIndex:m.sectionIndex,isSDF:x,pixelOffsetTL:K,pixelOffsetBR:G,minFontScaleX:0,minFontScaleY:0});}}return p}(0,r,u,a,o,s,n,t.allowVerticalPlacement),v=t.textSizeData,g=null;"source"===v.kind?(g=[128*a.layout.get("text-size").evaluate(s,{})])[0]>32640&&A(t.layerIds[0]+': Value for "text-size" is >= 255. Reduce your "text-size".'):"composite"===v.kind&&((g=[128*y.compositeTextSizes[0].evaluate(s,{},d),128*y.compositeTextSizes[1].evaluate(s,{},d)])[0]>32640||g[1]>32640)&&A(t.layerIds[0]+': Value for "text-size" is >= 255. Reduce your "text-size".'),t.addSymbols(t.text,m,g,u,o,s,p,e,l.lineStartIndex,l.lineLength,f,d);for(var x=0,b=c;x<b.length;x+=1)h[b[x]]=t.text.placedSymbolArray.length-1;return 4*m.length}function ul(t){for(var e in t)return t[e];return null}function ll(t,e,r,n){var i=t.compareText;if(e in i){for(var a=i[e],o=a.length-1;o>=0;o--)if(n.dist(a[o])<r)return !0}else i[e]=[];return i[e].push(n),!1}var pl=bs.VectorTileFeature.types,cl=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function hl(t,e,r,n,i,a,o,s,u,l,p,c,h){var f=s?Math.min(32640,Math.round(s[0])):0,y=s?Math.min(32640,Math.round(s[1])):0;t.emplaceBack(e,r,Math.round(32*n),Math.round(32*i),a,o,(f<<1)+(u?1:0),y,16*l,16*p,256*c,256*h);}function fl(t,e,r){t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r);}function yl(t){for(var e=0,r=t.sections;e<r.length;e+=1)if($n(r[e].text))return !0;return !1}var dl=function(t){this.layoutVertexArray=new Vi,this.indexArray=new ji,this.programConfigurations=t,this.segments=new sa,this.dynamicLayoutVertexArray=new Fi,this.opacityVertexArray=new Di,this.placedSymbolArray=new Qi;};dl.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length&&0===this.indexArray.length&&0===this.dynamicLayoutVertexArray.length&&0===this.opacityVertexArray.length},dl.prototype.upload=function(t,e,r,n){this.isEmpty()||(r&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,js.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,e),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,qs.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,cl,!0),this.opacityVertexBuffer.itemSize=1),(r||n)&&this.programConfigurations.upload(t));},dl.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy());},On("SymbolBuffers",dl);var ml=function(t,e,r){this.layoutVertexArray=new t,this.layoutAttributes=e,this.indexArray=new r,this.segments=new sa,this.collisionVertexArray=new Ui;};ml.prototype.upload=function(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,Ns.members,!0);},ml.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy());},On("CollisionBuffers",ml);var vl=function(t){this.collisionBoxArray=t.collisionBoxArray,this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.pixelRatio=t.pixelRatio,this.sourceLayerIndex=t.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.sortKeyRanges=[],this.collisionCircleArray=[],this.placementInvProjMatrix=oo([]),this.placementViewportMatrix=oo([]);var e=this.layers[0]._unevaluatedLayout._values;this.textSizeData=Du(this.zoom,e["text-size"]),this.iconSizeData=Du(this.zoom,e["icon-size"]);var r=this.layers[0].layout,n=r.get("symbol-sort-key"),i=r.get("symbol-z-order");this.canOverlap=r.get("text-allow-overlap")||r.get("icon-allow-overlap")||r.get("text-ignore-placement")||r.get("icon-ignore-placement"),this.sortFeaturesByKey="viewport-y"!==i&&void 0!==n.constantOr(1),this.sortFeaturesByY=("viewport-y"===i||"auto"===i&&!this.sortFeaturesByKey)&&this.canOverlap,"point"===r.get("symbol-placement")&&(this.writingModes=r.get("text-writing-mode").map((function(t){return wu[t]}))),this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id})),this.sourceID=t.sourceID;};vl.prototype.createArrays=function(){this.text=new dl(new Va(this.layers,this.zoom,(function(t){return /^text/.test(t)}))),this.icon=new dl(new Va(this.layers,this.zoom,(function(t){return /^icon/.test(t)}))),this.glyphOffsetArray=new ra,this.lineVertexArray=new na,this.symbolInstances=new ea;},vl.prototype.calculateGlyphDependencies=function(t,e,r,n,i){for(var a=0;a<t.length;a++)if(e[t.charCodeAt(a)]=!0,(r||n)&&i){var o=Xs[t.charAt(a)];o&&(e[o.charCodeAt(0)]=!0);}},vl.prototype.populate=function(t,e,r){var n=this.layers[0],i=n.layout,a=i.get("text-font"),o=i.get("text-field"),s=i.get("icon-image"),u=("constant"!==o.value.kind||o.value.value instanceof ne&&!o.value.value.isEmpty()||o.value.value.toString().length>0)&&("constant"!==a.value.kind||a.value.value.length>0),l="constant"!==s.value.kind||!!s.value.value||Object.keys(s.parameters).length>0,p=i.get("symbol-sort-key");if(this.features=[],u||l){for(var c=e.iconDependencies,h=e.glyphDependencies,f=e.availableImages,y=new si(this.zoom),d=0,m=t;d<m.length;d+=1){var v=m[d],g=v.feature,x=v.id,b=v.index,w=v.sourceLayerIndex,_=n._featureFilter.needGeometry,A=Ua(g,_);if(n._featureFilter.filter(y,A,r)){_||(A.geometry=Ra(g));var S=void 0;if(u){var k=n.getValueAndResolveTokens("text-field",A,r,f),I=ne.factory(k);yl(I)&&(this.hasRTLText=!0),(!this.hasRTLText||"unavailable"===ii()||this.hasRTLText&&oi.isParsed())&&(S=Zs(I,n,A));}var z=void 0;if(l){var C=n.getValueAndResolveTokens("icon-image",A,r,f);z=C instanceof ie?C:ie.fromString(C);}if(S||z){var E=this.sortFeaturesByKey?p.evaluate(A,{},r):void 0;if(this.features.push({id:x,text:S,icon:z,index:b,sourceLayerIndex:w,geometry:A.geometry,properties:g.properties,type:pl[g.type],sortKey:E}),z&&(c[z.name]=!0),S){var P=a.evaluate(A,{},r).join(","),M="map"===i.get("text-rotation-alignment")&&"point"!==i.get("symbol-placement");this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(wu.vertical)>=0;for(var B=0,T=S.sections;B<T.length;B+=1){var V=T[B];if(V.image)c[V.image.name]=!0;else {var F=Zn(S.toString()),D=V.fontStack||P,L=h[D]=h[D]||{};this.calculateGlyphDependencies(V.text,L,M,this.allowVerticalPlacement,F);}}}}}}"line"===i.get("symbol-placement")&&(this.features=function(t){var e={},r={},n=[],i=0;function a(e){n.push(t[e]),i++;}function o(t,e,i){var a=r[t];return delete r[t],r[e]=a,n[a].geometry[0].pop(),n[a].geometry[0]=n[a].geometry[0].concat(i[0]),a}function s(t,r,i){var a=e[r];return delete e[r],e[t]=a,n[a].geometry[0].shift(),n[a].geometry[0]=i[0].concat(n[a].geometry[0]),a}function u(t,e,r){var n=r?e[0][e[0].length-1]:e[0][0];return t+":"+n.x+":"+n.y}for(var l=0;l<t.length;l++){var p=t[l],c=p.geometry,h=p.text?p.text.toString():null;if(h){var f=u(h,c),y=u(h,c,!0);if(f in r&&y in e&&r[f]!==e[y]){var d=s(f,y,c),m=o(f,y,n[d].geometry);delete e[f],delete r[y],r[u(h,n[m].geometry,!0)]=m,n[d].geometry=null;}else f in r?o(f,y,c):y in e?s(f,y,c):(a(l),e[f]=i-1,r[y]=i-1);}else a(l);}return n.filter((function(t){return t.geometry}))}(this.features)),this.sortFeaturesByKey&&this.features.sort((function(t,e){return t.sortKey-e.sortKey}));}},vl.prototype.update=function(t,e,r){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(t,e,this.layers,r),this.icon.programConfigurations.updatePaintArrays(t,e,this.layers,r));},vl.prototype.isEmpty=function(){return 0===this.symbolInstances.length&&!this.hasRTLText},vl.prototype.uploadPending=function(){return !this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload},vl.prototype.upload=function(t){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0;},vl.prototype.destroyDebugData=function(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy();},vl.prototype.destroy=function(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData();},vl.prototype.addToLineVertexArray=function(t,e){var r=this.lineVertexArray.length;if(void 0!==t.segment){for(var n=t.dist(e[t.segment+1]),i=t.dist(e[t.segment]),a={},o=t.segment+1;o<e.length;o++)a[o]={x:e[o].x,y:e[o].y,tileUnitDistanceFromAnchor:n},o<e.length-1&&(n+=e[o+1].dist(e[o]));for(var s=t.segment||0;s>=0;s--)a[s]={x:e[s].x,y:e[s].y,tileUnitDistanceFromAnchor:i},s>0&&(i+=e[s-1].dist(e[s]));for(var u=0;u<e.length;u++){var l=a[u];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor);}}return {lineStartIndex:r,lineLength:this.lineVertexArray.length-r}},vl.prototype.addSymbols=function(t,e,r,n,i,a,o,s,u,l,p,c){for(var h=t.indexArray,f=t.layoutVertexArray,y=t.segments.prepareSegment(4*e.length,f,h,this.canOverlap?a.sortKey:void 0),d=this.glyphOffsetArray.length,m=y.vertexLength,v=this.allowVerticalPlacement&&o===wu.vertical?Math.PI/2:0,g=a.text&&a.text.sections,x=0;x<e.length;x++){var b=e[x],w=b.tl,_=b.tr,A=b.bl,S=b.br,k=b.tex,I=b.pixelOffsetTL,z=b.pixelOffsetBR,C=b.minFontScaleX,E=b.minFontScaleY,P=b.glyphOffset,M=b.isSDF,B=b.sectionIndex,T=y.vertexLength,V=P[1];hl(f,s.x,s.y,w.x,V+w.y,k.x,k.y,r,M,I.x,I.y,C,E),hl(f,s.x,s.y,_.x,V+_.y,k.x+k.w,k.y,r,M,z.x,I.y,C,E),hl(f,s.x,s.y,A.x,V+A.y,k.x,k.y+k.h,r,M,I.x,z.y,C,E),hl(f,s.x,s.y,S.x,V+S.y,k.x+k.w,k.y+k.h,r,M,z.x,z.y,C,E),fl(t.dynamicLayoutVertexArray,s,v),h.emplaceBack(T,T+1,T+2),h.emplaceBack(T+1,T+2,T+3),y.vertexLength+=4,y.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(P[0]),x!==e.length-1&&B===e[x+1].sectionIndex||t.programConfigurations.populatePaintArrays(f.length,a,a.index,{},c,g&&g[B]);}t.placedSymbolArray.emplaceBack(s.x,s.y,d,this.glyphOffsetArray.length-d,m,u,l,s.segment,r?r[0]:0,r?r[1]:0,n[0],n[1],o,0,!1,0,p);},vl.prototype._addCollisionDebugVertex=function(t,e,r,n,i,a){return e.emplaceBack(0,0),t.emplaceBack(r.x,r.y,n,i,Math.round(a.x),Math.round(a.y))},vl.prototype.addCollisionDebugVertices=function(t,e,r,n,a,o,s){var u=a.segments.prepareSegment(4,a.layoutVertexArray,a.indexArray),l=u.vertexLength,p=a.layoutVertexArray,c=a.collisionVertexArray,h=s.anchorX,f=s.anchorY;this._addCollisionDebugVertex(p,c,o,h,f,new i(t,e)),this._addCollisionDebugVertex(p,c,o,h,f,new i(r,e)),this._addCollisionDebugVertex(p,c,o,h,f,new i(r,n)),this._addCollisionDebugVertex(p,c,o,h,f,new i(t,n)),u.vertexLength+=4;var y=a.indexArray;y.emplaceBack(l,l+1),y.emplaceBack(l+1,l+2),y.emplaceBack(l+2,l+3),y.emplaceBack(l+3,l),u.primitiveLength+=4;},vl.prototype.addDebugCollisionBoxes=function(t,e,r,n){for(var i=t;i<e;i++){var a=this.collisionBoxArray.get(i);this.addCollisionDebugVertices(a.x1,a.y1,a.x2,a.y2,n?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,r);}},vl.prototype.generateCollisionDebugBuffers=function(){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new ml(Oi,Ks.members,Xi),this.iconCollisionBox=new ml(Oi,Ks.members,Xi);for(var t=0;t<this.symbolInstances.length;t++){var e=this.symbolInstances.get(t);this.addDebugCollisionBoxes(e.textBoxStartIndex,e.textBoxEndIndex,e,!0),this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex,e.verticalTextBoxEndIndex,e,!0),this.addDebugCollisionBoxes(e.iconBoxStartIndex,e.iconBoxEndIndex,e,!1),this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex,e.verticalIconBoxEndIndex,e,!1);}},vl.prototype._deserializeCollisionBoxesForSymbol=function(t,e,r,n,i,a,o,s,u){for(var l={},p=e;p<r;p++){var c=t.get(p);l.textBox={x1:c.x1,y1:c.y1,x2:c.x2,y2:c.y2,anchorPointX:c.anchorPointX,anchorPointY:c.anchorPointY},l.textFeatureIndex=c.featureIndex;break}for(var h=n;h<i;h++){var f=t.get(h);l.verticalTextBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},l.verticalTextFeatureIndex=f.featureIndex;break}for(var y=a;y<o;y++){var d=t.get(y);l.iconBox={x1:d.x1,y1:d.y1,x2:d.x2,y2:d.y2,anchorPointX:d.anchorPointX,anchorPointY:d.anchorPointY},l.iconFeatureIndex=d.featureIndex;break}for(var m=s;m<u;m++){var v=t.get(m);l.verticalIconBox={x1:v.x1,y1:v.y1,x2:v.x2,y2:v.y2,anchorPointX:v.anchorPointX,anchorPointY:v.anchorPointY},l.verticalIconFeatureIndex=v.featureIndex;break}return l},vl.prototype.deserializeCollisionBoxes=function(t){this.collisionArrays=[];for(var e=0;e<this.symbolInstances.length;e++){var r=this.symbolInstances.get(e);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,r.textBoxStartIndex,r.textBoxEndIndex,r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r.iconBoxStartIndex,r.iconBoxEndIndex,r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex));}},vl.prototype.hasTextData=function(){return this.text.segments.get().length>0},vl.prototype.hasIconData=function(){return this.icon.segments.get().length>0},vl.prototype.hasDebugData=function(){return this.textCollisionBox&&this.iconCollisionBox},vl.prototype.hasTextCollisionBoxData=function(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0},vl.prototype.hasIconCollisionBoxData=function(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0},vl.prototype.addIndicesForPlacedSymbol=function(t,e){for(var r=t.placedSymbolArray.get(e),n=r.vertexStartIndex+4*r.numGlyphs,i=r.vertexStartIndex;i<n;i+=4)t.indexArray.emplaceBack(i,i+1,i+2),t.indexArray.emplaceBack(i+1,i+2,i+3);},vl.prototype.getSortedSymbolIndexes=function(t){if(this.sortedAngle===t&&void 0!==this.symbolInstanceIndexes)return this.symbolInstanceIndexes;for(var e=Math.sin(t),r=Math.cos(t),n=[],i=[],a=[],o=0;o<this.symbolInstances.length;++o){a.push(o);var s=this.symbolInstances.get(o);n.push(0|Math.round(e*s.anchorX+r*s.anchorY)),i.push(s.featureIndex);}return a.sort((function(t,e){return n[t]-n[e]||i[e]-i[t]})),a},vl.prototype.addToSortKeyRanges=function(t,e){var r=this.sortKeyRanges[this.sortKeyRanges.length-1];r&&r.sortKey===e?r.symbolInstanceEnd=t+1:this.sortKeyRanges.push({sortKey:e,symbolInstanceStart:t,symbolInstanceEnd:t+1});},vl.prototype.sortFeatures=function(t){var e=this;if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(var r=0,n=this.symbolInstanceIndexes;r<n.length;r+=1){var i=this.symbolInstances.get(n[r]);this.featureSortOrder.push(i.featureIndex),[i.rightJustifiedTextSymbolIndex,i.centerJustifiedTextSymbolIndex,i.leftJustifiedTextSymbolIndex].forEach((function(t,r,n){t>=0&&n.indexOf(t)===r&&e.addIndicesForPlacedSymbol(e.text,t);})),i.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.text,i.verticalPlacedTextSymbolIndex),i.placedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,i.placedIconSymbolIndex),i.verticalPlacedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,i.verticalPlacedIconSymbolIndex);}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray);}},On("SymbolBucket",vl,{omit:["layers","collisionBoxArray","features","compareText"]}),vl.MAX_GLYPHS=65535,vl.addDynamicAttributes=fl;var gl=new wi({"symbol-placement":new mi(Et.layout_symbol["symbol-placement"]),"symbol-spacing":new mi(Et.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new mi(Et.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new vi(Et.layout_symbol["symbol-sort-key"]),"symbol-z-order":new mi(Et.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new mi(Et.layout_symbol["icon-allow-overlap"]),"icon-ignore-placement":new mi(Et.layout_symbol["icon-ignore-placement"]),"icon-optional":new mi(Et.layout_symbol["icon-optional"]),"icon-rotation-alignment":new mi(Et.layout_symbol["icon-rotation-alignment"]),"icon-size":new vi(Et.layout_symbol["icon-size"]),"icon-text-fit":new mi(Et.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new mi(Et.layout_symbol["icon-text-fit-padding"]),"icon-image":new vi(Et.layout_symbol["icon-image"]),"icon-rotate":new vi(Et.layout_symbol["icon-rotate"]),"icon-padding":new mi(Et.layout_symbol["icon-padding"]),"icon-keep-upright":new mi(Et.layout_symbol["icon-keep-upright"]),"icon-offset":new vi(Et.layout_symbol["icon-offset"]),"icon-anchor":new vi(Et.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new mi(Et.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new mi(Et.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new mi(Et.layout_symbol["text-rotation-alignment"]),"text-field":new vi(Et.layout_symbol["text-field"]),"text-font":new vi(Et.layout_symbol["text-font"]),"text-size":new vi(Et.layout_symbol["text-size"]),"text-max-width":new vi(Et.layout_symbol["text-max-width"]),"text-line-height":new mi(Et.layout_symbol["text-line-height"]),"text-letter-spacing":new vi(Et.layout_symbol["text-letter-spacing"]),"text-justify":new vi(Et.layout_symbol["text-justify"]),"text-radial-offset":new vi(Et.layout_symbol["text-radial-offset"]),"text-variable-anchor":new mi(Et.layout_symbol["text-variable-anchor"]),"text-anchor":new vi(Et.layout_symbol["text-anchor"]),"text-max-angle":new mi(Et.layout_symbol["text-max-angle"]),"text-writing-mode":new mi(Et.layout_symbol["text-writing-mode"]),"text-rotate":new vi(Et.layout_symbol["text-rotate"]),"text-padding":new mi(Et.layout_symbol["text-padding"]),"text-keep-upright":new mi(Et.layout_symbol["text-keep-upright"]),"text-transform":new vi(Et.layout_symbol["text-transform"]),"text-offset":new vi(Et.layout_symbol["text-offset"]),"text-allow-overlap":new mi(Et.layout_symbol["text-allow-overlap"]),"text-ignore-placement":new mi(Et.layout_symbol["text-ignore-placement"]),"text-optional":new mi(Et.layout_symbol["text-optional"])}),xl={paint:new wi({"icon-opacity":new vi(Et.paint_symbol["icon-opacity"]),"icon-color":new vi(Et.paint_symbol["icon-color"]),"icon-halo-color":new vi(Et.paint_symbol["icon-halo-color"]),"icon-halo-width":new vi(Et.paint_symbol["icon-halo-width"]),"icon-halo-blur":new vi(Et.paint_symbol["icon-halo-blur"]),"icon-translate":new mi(Et.paint_symbol["icon-translate"]),"icon-translate-anchor":new mi(Et.paint_symbol["icon-translate-anchor"]),"text-opacity":new vi(Et.paint_symbol["text-opacity"]),"text-color":new vi(Et.paint_symbol["text-color"],{runtimeType:jt,getOverride:function(t){return t.textColor},hasOverride:function(t){return !!t.textColor}}),"text-halo-color":new vi(Et.paint_symbol["text-halo-color"]),"text-halo-width":new vi(Et.paint_symbol["text-halo-width"]),"text-halo-blur":new vi(Et.paint_symbol["text-halo-blur"]),"text-translate":new mi(Et.paint_symbol["text-translate"]),"text-translate-anchor":new mi(Et.paint_symbol["text-translate-anchor"])}),layout:gl},bl=function(t){this.type=t.property.overrides?t.property.overrides.runtimeType:Lt,this.defaultValue=t;};bl.prototype.evaluate=function(t){if(t.formattedSection){var e=this.defaultValue.property.overrides;if(e&&e.hasOverride(t.formattedSection))return e.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default},bl.prototype.eachChild=function(t){this.defaultValue.isConstant()||t(this.defaultValue.value._styleExpression.expression);},bl.prototype.outputDefined=function(){return !1},bl.prototype.serialize=function(){return null},On("FormatSectionOverride",bl,{omit:["defaultValue"]});var wl=function(t){function e(e){t.call(this,e,xl);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.recalculate=function(e,r){if(t.prototype.recalculate.call(this,e,r),"auto"===this.layout.get("icon-rotation-alignment")&&(this.layout._values["icon-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-rotation-alignment")&&(this.layout._values["text-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-pitch-alignment")&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")),"auto"===this.layout.get("icon-pitch-alignment")&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),"point"===this.layout.get("symbol-placement")){var n=this.layout.get("text-writing-mode");if(n){for(var i=[],a=0,o=n;a<o.length;a+=1){var s=o[a];i.indexOf(s)<0&&i.push(s);}this.layout._values["text-writing-mode"]=i;}else this.layout._values["text-writing-mode"]=["horizontal"];}this._setPaintOverrides();},e.prototype.getValueAndResolveTokens=function(t,e,r,n){var i=this.layout.get(t).evaluate(e,{},r,n),a=this._unevaluatedLayout._values[t];return a.isDataDriven()||Gr(a.value)||!i?i:function(t,e){return e.replace(/{([^{}]+)}/g,(function(e,r){return r in t?String(t[r]):""}))}(e.properties,i)},e.prototype.createBucket=function(t){return new vl(t)},e.prototype.queryRadius=function(){return 0},e.prototype.queryIntersectsFeature=function(){return !1},e.prototype._setPaintOverrides=function(){for(var t=0,r=xl.paint.overridableProperties;t<r.length;t+=1){var n=r[t];if(e.hasPaintOverride(this.layout,n)){var i,a=this.paint.get(n),o=new bl(a),s=new Kr(o,a.property.specification);i="constant"===a.value.kind||"source"===a.value.kind?new Xr("source",s):new Jr("composite",s,a.value.zoomStops,a.value._interpolationType),this.paint._values[n]=new yi(a.property,i,a.parameters);}}},e.prototype._handleOverridablePaintPropertyUpdate=function(t,r,n){return !(!this.layout||r.isDataDriven()||n.isDataDriven())&&e.hasPaintOverride(this.layout,t)},e.hasPaintOverride=function(t,e){var r=t.get("text-field"),n=xl.paint.properties[e],i=!1,a=function(t){for(var e=0,r=t;e<r.length;e+=1)if(n.overrides&&n.overrides.hasOverride(r[e]))return void(i=!0)};if("constant"===r.value.kind&&r.value.value instanceof ne)a(r.value.value.sections);else if("source"===r.value.kind){var o=function(t){i||(t instanceof le&&se(t.value)===Gt?a(t.value.sections):t instanceof fe?a(t.sections):t.eachChild(o));},s=r.value;s._styleExpression&&o(s._styleExpression.expression);}return i},e}(_i),_l={paint:new wi({"background-color":new mi(Et.paint_background["background-color"]),"background-pattern":new xi(Et.paint_background["background-pattern"]),"background-opacity":new mi(Et.paint_background["background-opacity"])})},Al=function(t){function e(e){t.call(this,e,_l);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(_i),Sl={paint:new wi({"raster-opacity":new mi(Et.paint_raster["raster-opacity"]),"raster-hue-rotate":new mi(Et.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new mi(Et.paint_raster["raster-brightness-min"]),"raster-brightness-max":new mi(Et.paint_raster["raster-brightness-max"]),"raster-saturation":new mi(Et.paint_raster["raster-saturation"]),"raster-contrast":new mi(Et.paint_raster["raster-contrast"]),"raster-resampling":new mi(Et.paint_raster["raster-resampling"]),"raster-fade-duration":new mi(Et.paint_raster["raster-fade-duration"])})},kl=function(t){function e(e){t.call(this,e,Sl);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(_i),Il=function(t){function e(e){t.call(this,e,{}),this.implementation=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.is3D=function(){return "3d"===this.implementation.renderingMode},e.prototype.hasOffscreenPass=function(){return void 0!==this.implementation.prerender},e.prototype.recalculate=function(){},e.prototype.updateTransitions=function(){},e.prototype.hasTransition=function(){},e.prototype.serialize=function(){},e.prototype.onAdd=function(t){this.implementation.onAdd&&this.implementation.onAdd(t,t.painter.context.gl);},e.prototype.onRemove=function(t){this.implementation.onRemove&&this.implementation.onRemove(t,t.painter.context.gl);},e}(_i),zl={circle:co,heatmap:_o,hillshade:So,fill:ps,"fill-extrusion":zs,line:Rs,symbol:wl,background:Al,raster:kl},Cl=o.HTMLImageElement,El=o.HTMLCanvasElement,Pl=o.HTMLVideoElement,Ml=o.ImageData,Bl=o.ImageBitmap,Tl=function(t,e,r,n){this.context=t,this.format=r,this.texture=t.gl.createTexture(),this.update(e,n);};Tl.prototype.update=function(t,e,r){var n=t.width,i=t.height,a=!(this.size&&this.size[0]===n&&this.size[1]===i||r),o=this.context,s=o.gl;if(this.useMipmap=Boolean(e&&e.useMipmap),s.bindTexture(s.TEXTURE_2D,this.texture),o.pixelStoreUnpackFlipY.set(!1),o.pixelStoreUnpack.set(1),o.pixelStoreUnpackPremultiplyAlpha.set(this.format===s.RGBA&&(!e||!1!==e.premultiply)),a)this.size=[n,i],t instanceof Cl||t instanceof El||t instanceof Pl||t instanceof Ml||Bl&&t instanceof Bl?s.texImage2D(s.TEXTURE_2D,0,this.format,this.format,s.UNSIGNED_BYTE,t):s.texImage2D(s.TEXTURE_2D,0,this.format,n,i,0,this.format,s.UNSIGNED_BYTE,t.data);else {var u=r||{x:0,y:0},l=u.x,p=u.y;t instanceof Cl||t instanceof El||t instanceof Pl||t instanceof Ml||Bl&&t instanceof Bl?s.texSubImage2D(s.TEXTURE_2D,0,l,p,s.RGBA,s.UNSIGNED_BYTE,t):s.texSubImage2D(s.TEXTURE_2D,0,l,p,n,i,s.RGBA,s.UNSIGNED_BYTE,t.data);}this.useMipmap&&this.isSizePowerOfTwo()&&s.generateMipmap(s.TEXTURE_2D);},Tl.prototype.bind=function(t,e,r){var n=this.context.gl;n.bindTexture(n.TEXTURE_2D,this.texture),r!==n.LINEAR_MIPMAP_NEAREST||this.isSizePowerOfTwo()||(r=n.LINEAR),t!==this.filter&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,r||t),this.filter=t),e!==this.wrap&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,e),this.wrap=e);},Tl.prototype.isSizePowerOfTwo=function(){return this.size[0]===this.size[1]&&Math.log(this.size[0])/Math.LN2%1==0},Tl.prototype.destroy=function(){this.context.gl.deleteTexture(this.texture),this.texture=null;};var Vl=function(t){var e=this;this._callback=t,this._triggered=!1,"undefined"!=typeof MessageChannel&&(this._channel=new MessageChannel,this._channel.port2.onmessage=function(){e._triggered=!1,e._callback();});};Vl.prototype.trigger=function(){var t=this;this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout((function(){t._triggered=!1,t._callback();}),0));},Vl.prototype.remove=function(){delete this._channel,this._callback=function(){};};var Fl=function(t,e,r){this.target=t,this.parent=e,this.mapId=r,this.callbacks={},this.tasks={},this.taskQueue=[],this.cancelCallbacks={},v(["receive","process"],this),this.invoker=new Vl(this.process),this.target.addEventListener("message",this.receive,!1),this.globalScope=I()?t:o;};function Dl(t,e,r){var n=2*Math.PI*6378137/256/Math.pow(2,r);return [t*n-2*Math.PI*6378137/2,e*n-2*Math.PI*6378137/2]}Fl.prototype.send=function(t,e,r,n,i){var a=this;void 0===i&&(i=!1);var o=Math.round(1e18*Math.random()).toString(36).substring(0,10);r&&(this.callbacks[o]=r);var s=E(this.globalScope)?void 0:[];return this.target.postMessage({id:o,type:t,hasCallback:!!r,targetMapId:n,mustQueue:i,sourceMapId:this.mapId,data:qn(e,s)},s),{cancel:function(){r&&delete a.callbacks[o],a.target.postMessage({id:o,type:"<cancel>",targetMapId:n,sourceMapId:a.mapId});}}},Fl.prototype.receive=function(t){var e=t.data,r=e.id;if(r&&(!e.targetMapId||this.mapId===e.targetMapId))if("<cancel>"===e.type){delete this.tasks[r];var n=this.cancelCallbacks[r];delete this.cancelCallbacks[r],n&&n();}else I()||e.mustQueue?(this.tasks[r]=e,this.taskQueue.push(r),this.invoker.trigger()):this.processTask(r,e);},Fl.prototype.process=function(){if(this.taskQueue.length){var t=this.taskQueue.shift(),e=this.tasks[t];delete this.tasks[t],this.taskQueue.length&&this.invoker.trigger(),e&&this.processTask(t,e);}},Fl.prototype.processTask=function(t,e){var r=this;if("<response>"===e.type){var n=this.callbacks[t];delete this.callbacks[t],n&&(e.error?n(Nn(e.error)):n(null,Nn(e.data)));}else {var i=!1,a=E(this.globalScope)?void 0:[],o=e.hasCallback?function(e,n){i=!0,delete r.cancelCallbacks[t],r.target.postMessage({id:t,type:"<response>",sourceMapId:r.mapId,error:e?qn(e):null,data:qn(n,a)},a);}:function(t){i=!0;},s=null,u=Nn(e.data);if(this.parent[e.type])s=this.parent[e.type](e.sourceMapId,u,o);else if(this.parent.getWorkerSource){var l=e.type.split(".");s=this.parent.getWorkerSource(e.sourceMapId,l[0],u.source)[l[1]](u,o);}else o(new Error("Could not find function "+e.type));!i&&s&&s.cancel&&(this.cancelCallbacks[t]=s.cancel);}},Fl.prototype.remove=function(){this.invoker.remove(),this.target.removeEventListener("message",this.receive,!1);};var Ll=function(t,e){t&&(e?this.setSouthWest(t).setNorthEast(e):4===t.length?this.setSouthWest([t[0],t[1]]).setNorthEast([t[2],t[3]]):this.setSouthWest(t[0]).setNorthEast(t[1]));};Ll.prototype.setNorthEast=function(t){return this._ne=t instanceof Ol?new Ol(t.lng,t.lat):Ol.convert(t),this},Ll.prototype.setSouthWest=function(t){return this._sw=t instanceof Ol?new Ol(t.lng,t.lat):Ol.convert(t),this},Ll.prototype.extend=function(t){var e,r,n=this._sw,i=this._ne;if(t instanceof Ol)e=t,r=t;else {if(!(t instanceof Ll))return Array.isArray(t)?4===t.length||t.every(Array.isArray)?this.extend(Ll.convert(t)):this.extend(Ol.convert(t)):this;if(r=t._ne,!(e=t._sw)||!r)return this}return n||i?(n.lng=Math.min(e.lng,n.lng),n.lat=Math.min(e.lat,n.lat),i.lng=Math.max(r.lng,i.lng),i.lat=Math.max(r.lat,i.lat)):(this._sw=new Ol(e.lng,e.lat),this._ne=new Ol(r.lng,r.lat)),this},Ll.prototype.getCenter=function(){return new Ol((this._sw.lng+this._ne.lng)/2,(this._sw.lat+this._ne.lat)/2)},Ll.prototype.getSouthWest=function(){return this._sw},Ll.prototype.getNorthEast=function(){return this._ne},Ll.prototype.getNorthWest=function(){return new Ol(this.getWest(),this.getNorth())},Ll.prototype.getSouthEast=function(){return new Ol(this.getEast(),this.getSouth())},Ll.prototype.getWest=function(){return this._sw.lng},Ll.prototype.getSouth=function(){return this._sw.lat},Ll.prototype.getEast=function(){return this._ne.lng},Ll.prototype.getNorth=function(){return this._ne.lat},Ll.prototype.toArray=function(){return [this._sw.toArray(),this._ne.toArray()]},Ll.prototype.toString=function(){return "LngLatBounds("+this._sw.toString()+", "+this._ne.toString()+")"},Ll.prototype.isEmpty=function(){return !(this._sw&&this._ne)},Ll.prototype.contains=function(t){var e=Ol.convert(t),r=e.lng,n=e.lat,i=this._sw.lng<=r&&r<=this._ne.lng;return this._sw.lng>this._ne.lng&&(i=this._sw.lng>=r&&r>=this._ne.lng),this._sw.lat<=n&&n<=this._ne.lat&&i},Ll.convert=function(t){return !t||t instanceof Ll?t:new Ll(t)};var Ol=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid LngLat object: ("+t+", "+e+")");if(this.lng=+t,this.lat=+e,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")};Ol.prototype.wrap=function(){return new Ol(c(this.lng,-180,180),this.lat)},Ol.prototype.toArray=function(){return [this.lng,this.lat]},Ol.prototype.toString=function(){return "LngLat("+this.lng+", "+this.lat+")"},Ol.prototype.distanceTo=function(t){var e=Math.PI/180,r=this.lat*e,n=t.lat*e,i=Math.sin(r)*Math.sin(n)+Math.cos(r)*Math.cos(n)*Math.cos((t.lng-this.lng)*e);return 6371008.8*Math.acos(Math.min(i,1))},Ol.prototype.toBounds=function(t){void 0===t&&(t=0);var e=360*t/40075017,r=e/Math.cos(Math.PI/180*this.lat);return new Ll(new Ol(this.lng-r,this.lat-e),new Ol(this.lng+r,this.lat+e))},Ol.convert=function(t){if(t instanceof Ol)return t;if(Array.isArray(t)&&(2===t.length||3===t.length))return new Ol(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&"object"==typeof t&&null!==t)return new Ol(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")};var Rl=2*Math.PI*6371008.8;function Ul(t){return Rl*Math.cos(t*Math.PI/180)}function jl(t){return (180+t)/360}function ql(t){return (180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function Nl(t,e){return t/Ul(e)}function Kl(t){return 360/Math.PI*Math.atan(Math.exp((180-360*t)*Math.PI/180))-90}var Gl=function(t,e,r){void 0===r&&(r=0),this.x=+t,this.y=+e,this.z=+r;};Gl.fromLngLat=function(t,e){void 0===e&&(e=0);var r=Ol.convert(t);return new Gl(jl(r.lng),ql(r.lat),Nl(e,r.lat))},Gl.prototype.toLngLat=function(){return new Ol(360*this.x-180,Kl(this.y))},Gl.prototype.toAltitude=function(){return this.z*Ul(Kl(this.y))},Gl.prototype.meterInMercatorCoordinateUnits=function(){return 1/Rl*(t=Kl(this.y),1/Math.cos(t*Math.PI/180));var t;};var Zl=function(t,e,r){this.z=t,this.x=e,this.y=r,this.key=Hl(0,t,t,e,r);};Zl.prototype.equals=function(t){return this.z===t.z&&this.x===t.x&&this.y===t.y},Zl.prototype.url=function(t,e){var r,n,i,a,o,s=(n=this.y,i=this.z,a=Dl(256*(r=this.x),256*(n=Math.pow(2,i)-n-1),i),o=Dl(256*(r+1),256*(n+1),i),a[0]+","+a[1]+","+o[0]+","+o[1]),u=function(t,e,r){for(var n,i="",a=t;a>0;a--)i+=(e&(n=1<<a-1)?1:0)+(r&n?2:0);return i}(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace("{prefix}",(this.x%16).toString(16)+(this.y%16).toString(16)).replace("{z}",String(this.z)).replace("{x}",String(this.x)).replace("{y}",String("tms"===e?Math.pow(2,this.z)-this.y-1:this.y)).replace("{quadkey}",u).replace("{bbox-epsg-3857}",s)},Zl.prototype.getTilePoint=function(t){var e=Math.pow(2,this.z);return new i(8192*(t.x*e-this.x),8192*(t.y*e-this.y))},Zl.prototype.toString=function(){return this.z+"/"+this.x+"/"+this.y};var Xl=function(t,e){this.wrap=t,this.canonical=e,this.key=Hl(t,e.z,e.z,e.x,e.y);},Jl=function(t,e,r,n,i){this.overscaledZ=t,this.wrap=e,this.canonical=new Zl(r,+n,+i),this.key=Hl(e,t,r,n,i);};function Hl(t,e,r,n,i){(t*=2)<0&&(t=-1*t-1);var a=1<<r;return (a*a*t+a*i+n).toString(36)+r.toString(36)+e.toString(36)}Jl.prototype.equals=function(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)},Jl.prototype.scaledTo=function(t){var e=this.canonical.z-t;return t>this.canonical.z?new Jl(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new Jl(t,this.wrap,t,this.canonical.x>>e,this.canonical.y>>e)},Jl.prototype.calculateScaledKey=function(t,e){var r=this.canonical.z-t;return t>this.canonical.z?Hl(this.wrap*+e,t,this.canonical.z,this.canonical.x,this.canonical.y):Hl(this.wrap*+e,t,t,this.canonical.x>>r,this.canonical.y>>r)},Jl.prototype.isChildOf=function(t){if(t.wrap!==this.wrap)return !1;var e=this.canonical.z-t.canonical.z;return 0===t.overscaledZ||t.overscaledZ<this.overscaledZ&&t.canonical.x===this.canonical.x>>e&&t.canonical.y===this.canonical.y>>e},Jl.prototype.children=function(t){if(this.overscaledZ>=t)return [new Jl(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];var e=this.canonical.z+1,r=2*this.canonical.x,n=2*this.canonical.y;return [new Jl(e,this.wrap,e,r,n),new Jl(e,this.wrap,e,r+1,n),new Jl(e,this.wrap,e,r,n+1),new Jl(e,this.wrap,e,r+1,n+1)]},Jl.prototype.isLessThan=function(t){return this.wrap<t.wrap||!(this.wrap>t.wrap)&&(this.overscaledZ<t.overscaledZ||!(this.overscaledZ>t.overscaledZ)&&(this.canonical.x<t.canonical.x||!(this.canonical.x>t.canonical.x)&&this.canonical.y<t.canonical.y))},Jl.prototype.wrapped=function(){return new Jl(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)},Jl.prototype.unwrapTo=function(t){return new Jl(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)},Jl.prototype.overscaleFactor=function(){return Math.pow(2,this.overscaledZ-this.canonical.z)},Jl.prototype.toUnwrapped=function(){return new Xl(this.wrap,this.canonical)},Jl.prototype.toString=function(){return this.overscaledZ+"/"+this.canonical.x+"/"+this.canonical.y},Jl.prototype.getTilePoint=function(t){return this.canonical.getTilePoint(new Gl(t.x-this.wrap,t.y))},On("CanonicalTileID",Zl),On("OverscaledTileID",Jl,{omit:["posMatrix"]});var Yl=function(t,e,r){if(this.uid=t,e.height!==e.width)throw new RangeError("DEM tiles must be square");if(r&&"mapbox"!==r&&"terrarium"!==r)return A('"'+r+'" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');this.stride=e.height;var n=this.dim=e.height-2;this.data=new Uint32Array(e.data.buffer),this.encoding=r||"mapbox";for(var i=0;i<n;i++)this.data[this._idx(-1,i)]=this.data[this._idx(0,i)],this.data[this._idx(n,i)]=this.data[this._idx(n-1,i)],this.data[this._idx(i,-1)]=this.data[this._idx(i,0)],this.data[this._idx(i,n)]=this.data[this._idx(i,n-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(n,-1)]=this.data[this._idx(n-1,0)],this.data[this._idx(-1,n)]=this.data[this._idx(0,n-1)],this.data[this._idx(n,n)]=this.data[this._idx(n-1,n-1)];};Yl.prototype.get=function(t,e){var r=new Uint8Array(this.data.buffer),n=4*this._idx(t,e);return ("terrarium"===this.encoding?this._unpackTerrarium:this._unpackMapbox)(r[n],r[n+1],r[n+2])},Yl.prototype.getUnpackVector=function(){return "terrarium"===this.encoding?[256,1,1/256,32768]:[6553.6,25.6,.1,1e4]},Yl.prototype._idx=function(t,e){if(t<-1||t>=this.dim+1||e<-1||e>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return (e+1)*this.stride+(t+1)},Yl.prototype._unpackMapbox=function(t,e,r){return (256*t*256+256*e+r)/10-1e4},Yl.prototype._unpackTerrarium=function(t,e,r){return 256*t+e+r/256-32768},Yl.prototype.getPixels=function(){return new xo({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))},Yl.prototype.backfillBorder=function(t,e,r){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");var n=e*this.dim,i=e*this.dim+this.dim,a=r*this.dim,o=r*this.dim+this.dim;switch(e){case-1:n=i-1;break;case 1:i=n+1;}switch(r){case-1:a=o-1;break;case 1:o=a+1;}for(var s=-e*this.dim,u=-r*this.dim,l=a;l<o;l++)for(var p=n;p<i;p++)this.data[this._idx(p,l)]=t.data[this._idx(p+s,l+u)];},On("DEMData",Yl);var $l=function(t){this._stringToNumber={},this._numberToString=[];for(var e=0;e<t.length;e++){var r=t[e];this._stringToNumber[r]=e,this._numberToString[e]=r;}};$l.prototype.encode=function(t){return this._stringToNumber[t]},$l.prototype.decode=function(t){return this._numberToString[t]};var Wl=function(t,e,r,n,i){this.type="Feature",this._vectorTileFeature=t,t._z=e,t._x=r,t._y=n,this.properties=t.properties,this.id=i;},Ql={geometry:{configurable:!0}};Ql.geometry.get=function(){return void 0===this._geometry&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry},Ql.geometry.set=function(t){this._geometry=t;},Wl.prototype.toJSON=function(){var t={geometry:this.geometry};for(var e in this)"_geometry"!==e&&"_vectorTileFeature"!==e&&(t[e]=this[e]);return t},Object.defineProperties(Wl.prototype,Ql);var tp=function(){this.state={},this.stateChanges={},this.deletedStates={};};tp.prototype.updateState=function(t,e,r){var n=String(e);if(this.stateChanges[t]=this.stateChanges[t]||{},this.stateChanges[t][n]=this.stateChanges[t][n]||{},h(this.stateChanges[t][n],r),null===this.deletedStates[t])for(var i in this.deletedStates[t]={},this.state[t])i!==n&&(this.deletedStates[t][i]=null);else if(this.deletedStates[t]&&null===this.deletedStates[t][n])for(var a in this.deletedStates[t][n]={},this.state[t][n])r[a]||(this.deletedStates[t][n][a]=null);else for(var o in r)this.deletedStates[t]&&this.deletedStates[t][n]&&null===this.deletedStates[t][n][o]&&delete this.deletedStates[t][n][o];},tp.prototype.removeFeatureState=function(t,e,r){if(null!==this.deletedStates[t]){var n=String(e);if(this.deletedStates[t]=this.deletedStates[t]||{},r&&void 0!==e)null!==this.deletedStates[t][n]&&(this.deletedStates[t][n]=this.deletedStates[t][n]||{},this.deletedStates[t][n][r]=null);else if(void 0!==e)if(this.stateChanges[t]&&this.stateChanges[t][n])for(r in this.deletedStates[t][n]={},this.stateChanges[t][n])this.deletedStates[t][n][r]=null;else this.deletedStates[t][n]=null;else this.deletedStates[t]=null;}},tp.prototype.getState=function(t,e){var r=String(e),n=h({},(this.state[t]||{})[r],(this.stateChanges[t]||{})[r]);if(null===this.deletedStates[t])return {};if(this.deletedStates[t]){var i=this.deletedStates[t][e];if(null===i)return {};for(var a in i)delete n[a];}return n},tp.prototype.initializeTileState=function(t,e){t.setFeatureState(this.state,e);},tp.prototype.coalesceChanges=function(t,e){var r={};for(var n in this.stateChanges){this.state[n]=this.state[n]||{};var i={};for(var a in this.stateChanges[n])this.state[n][a]||(this.state[n][a]={}),h(this.state[n][a],this.stateChanges[n][a]),i[a]=this.state[n][a];r[n]=i;}for(var o in this.deletedStates){this.state[o]=this.state[o]||{};var s={};if(null===this.deletedStates[o])for(var u in this.state[o])s[u]={},this.state[o][u]={};else for(var l in this.deletedStates[o]){if(null===this.deletedStates[o][l])this.state[o][l]={};else for(var p=0,c=Object.keys(this.deletedStates[o][l]);p<c.length;p+=1)delete this.state[o][l][c[p]];s[l]=this.state[o][l];}r[o]=r[o]||{},h(r[o],s);}if(this.stateChanges={},this.deletedStates={},0!==Object.keys(r).length)for(var f in t)t[f].setFeatureState(r,e);};var ep=function(t,e){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=new Tn(8192,16,0),this.grid3D=new Tn(8192,16,0),this.featureIndexArray=new aa,this.promoteId=e;};function rp(t,e,r,n,i){return x(t,(function(t,a){var o=e instanceof di?e.get(a):null;return o&&o.evaluate?o.evaluate(r,n,i):o}))}function np(t){for(var e=1/0,r=1/0,n=-1/0,i=-1/0,a=0,o=t;a<o.length;a+=1){var s=o[a];e=Math.min(e,s.x),r=Math.min(r,s.y),n=Math.max(n,s.x),i=Math.max(i,s.y);}return {minX:e,minY:r,maxX:n,maxY:i}}function ip(t,e){return e-t}ep.prototype.insert=function(t,e,r,n,i,a){var o=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(r,n,i);for(var s=a?this.grid3D:this.grid,u=0;u<e.length;u++){for(var l=e[u],p=[1/0,1/0,-1/0,-1/0],c=0;c<l.length;c++){var h=l[c];p[0]=Math.min(p[0],h.x),p[1]=Math.min(p[1],h.y),p[2]=Math.max(p[2],h.x),p[3]=Math.max(p[3],h.y);}p[0]<8192&&p[1]<8192&&p[2]>=0&&p[3]>=0&&s.insert(o,p[0],p[1],p[2],p[3]);}},ep.prototype.loadVTLayers=function(){return this.vtLayers||(this.vtLayers=new bs.VectorTile(new Ys(this.rawTileData)).layers,this.sourceLayerCoder=new $l(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers},ep.prototype.query=function(t,e,r,n){var a=this;this.loadVTLayers();for(var o=t.params||{},s=8192/t.tileSize/t.scale,u=on(o.filter),l=t.queryGeometry,p=t.queryPadding*s,c=np(l),h=this.grid.query(c.minX-p,c.minY-p,c.maxX+p,c.maxY+p),f=np(t.cameraQueryGeometry),y=this.grid3D.query(f.minX-p,f.minY-p,f.maxX+p,f.maxY+p,(function(e,r,n,a){return function(t,e,r,n,a){for(var o=0,s=t;o<s.length;o+=1){var u=s[o];if(e<=u.x&&r<=u.y&&n>=u.x&&a>=u.y)return !0}var l=[new i(e,r),new i(e,a),new i(n,a),new i(n,r)];if(t.length>2)for(var p=0,c=l;p<c.length;p+=1)if(Wa(t,c[p]))return !0;for(var h=0;h<t.length-1;h++)if(Qa(t[h],t[h+1],l))return !0;return !1}(t.cameraQueryGeometry,e-p,r-p,n+p,a+p)})),d=0,m=y;d<m.length;d+=1)h.push(m[d]);h.sort(ip);for(var v,g={},x=function(i){var p=h[i];if(p!==v){v=p;var c=a.featureIndexArray.get(p),f=null;a.loadMatchingFeature(g,c.bucketIndex,c.sourceLayerIndex,c.featureIndex,u,o.layers,o.availableImages,e,r,n,(function(e,r,n){return f||(f=Ra(e)),r.queryIntersectsFeature(l,e,n,f,a.z,t.transform,s,t.pixelPosMatrix)}));}},b=0;b<h.length;b++)x(b);return g},ep.prototype.loadMatchingFeature=function(t,e,r,n,i,a,o,s,u,l,p){var c=this.bucketLayerIDs[e];if(!a||function(t,e){for(var r=0;r<t.length;r++)if(e.indexOf(t[r])>=0)return !0;return !1}(a,c)){var f=this.sourceLayerCoder.decode(r),y=this.vtLayers[f].feature(n);if(i.needGeometry){var d=Ua(y,!0);if(!i.filter(new si(this.tileID.overscaledZ),d,this.tileID.canonical))return}else if(!i.filter(new si(this.tileID.overscaledZ),y))return;for(var m=this.getId(y,f),v=0;v<c.length;v++){var g=c[v];if(!(a&&a.indexOf(g)<0)){var x=s[g];if(x){var b={};void 0!==m&&l&&(b=l.getState(x.sourceLayer||"_geojsonTileLayer",m));var w=h({},u[g]);w.paint=rp(w.paint,x.paint,y,b,o),w.layout=rp(w.layout,x.layout,y,b,o);var _=!p||p(y,x,b);if(_){var A=new Wl(y,this.z,this.x,this.y,m);A.layer=w;var S=t[g];void 0===S&&(S=t[g]=[]),S.push({featureIndex:n,feature:A,intersectionZ:_});}}}}}},ep.prototype.lookupSymbolFeatures=function(t,e,r,n,i,a,o,s){var u={};this.loadVTLayers();for(var l=on(i),p=0,c=t;p<c.length;p+=1)this.loadMatchingFeature(u,r,n,c[p],l,a,o,s,e);return u},ep.prototype.hasLayer=function(t){for(var e=0,r=this.bucketLayerIDs;e<r.length;e+=1)for(var n=0,i=r[e];n<i.length;n+=1)if(t===i[n])return !0;return !1},ep.prototype.getId=function(t,e){var r=t.id;return this.promoteId&&"boolean"==typeof(r=t.properties["string"==typeof this.promoteId?this.promoteId:this.promoteId[e]])&&(r=Number(r)),r},On("FeatureIndex",ep,{omit:["rawTileData","sourceLayerCoder"]});var ap=function(t,e){this.tileID=t,this.uid=y(),this.uses=0,this.tileSize=e,this.buckets={},this.expirationTime=null,this.queryPadding=0,this.hasSymbolBuckets=!1,this.hasRTLText=!1,this.dependencies={},this.expiredRequestCount=0,this.state="loading";};ap.prototype.registerFadeDuration=function(t){var e=t+this.timeAdded;e<O.now()||this.fadeEndTime&&e<this.fadeEndTime||(this.fadeEndTime=e);},ap.prototype.wasRequested=function(){return "errored"===this.state||"loaded"===this.state||"reloading"===this.state},ap.prototype.loadVectorData=function(t,e,r){if(this.hasData()&&this.unloadVectorData(),this.state="loaded",t){for(var n in t.featureIndex&&(this.latestFeatureIndex=t.featureIndex,t.rawTileData?(this.latestRawTileData=t.rawTileData,this.latestFeatureIndex.rawTileData=t.rawTileData):this.latestRawTileData&&(this.latestFeatureIndex.rawTileData=this.latestRawTileData)),this.collisionBoxArray=t.collisionBoxArray,this.buckets=function(t,e){var r={};if(!e)return r;for(var n=function(){var t=a[i],n=t.layerIds.map((function(t){return e.getLayer(t)})).filter(Boolean);if(0!==n.length){t.layers=n,t.stateDependentLayerIds&&(t.stateDependentLayers=t.stateDependentLayerIds.map((function(t){return n.filter((function(e){return e.id===t}))[0]})));for(var o=0,s=n;o<s.length;o+=1)r[s[o].id]=t;}},i=0,a=t;i<a.length;i+=1)n();return r}(t.buckets,e.style),this.hasSymbolBuckets=!1,this.buckets){var i=this.buckets[n];if(i instanceof vl){if(this.hasSymbolBuckets=!0,!r)break;i.justReloaded=!0;}}if(this.hasRTLText=!1,this.hasSymbolBuckets)for(var a in this.buckets){var o=this.buckets[a];if(o instanceof vl&&o.hasRTLText){this.hasRTLText=!0,oi.isLoading()||oi.isLoaded()||"deferred"!==ii()||ai();break}}for(var s in this.queryPadding=0,this.buckets){var u=this.buckets[s];this.queryPadding=Math.max(this.queryPadding,e.style.getLayer(s).queryRadius(u));}t.imageAtlas&&(this.imageAtlas=t.imageAtlas),t.glyphAtlasImage&&(this.glyphAtlasImage=t.glyphAtlasImage);}else this.collisionBoxArray=new $i;},ap.prototype.unloadVectorData=function(){for(var t in this.buckets)this.buckets[t].destroy();this.buckets={},this.imageAtlasTexture&&this.imageAtlasTexture.destroy(),this.imageAtlas&&(this.imageAtlas=null),this.glyphAtlasTexture&&this.glyphAtlasTexture.destroy(),this.latestFeatureIndex=null,this.state="unloaded";},ap.prototype.getBucket=function(t){return this.buckets[t.id]},ap.prototype.upload=function(t){for(var e in this.buckets){var r=this.buckets[e];r.uploadPending()&&r.upload(t);}var n=t.gl;this.imageAtlas&&!this.imageAtlas.uploaded&&(this.imageAtlasTexture=new Tl(t,this.imageAtlas.image,n.RGBA),this.imageAtlas.uploaded=!0),this.glyphAtlasImage&&(this.glyphAtlasTexture=new Tl(t,this.glyphAtlasImage,n.ALPHA),this.glyphAtlasImage=null);},ap.prototype.prepare=function(t){this.imageAtlas&&this.imageAtlas.patchUpdatedImages(t,this.imageAtlasTexture);},ap.prototype.queryRenderedFeatures=function(t,e,r,n,i,a,o,s,u,l){return this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData?this.latestFeatureIndex.query({queryGeometry:n,cameraQueryGeometry:i,scale:a,tileSize:this.tileSize,pixelPosMatrix:l,transform:s,params:o,queryPadding:this.queryPadding*u},t,e,r):{}},ap.prototype.querySourceFeatures=function(t,e){var r=this.latestFeatureIndex;if(r&&r.rawTileData){var n=r.loadVTLayers(),i=e?e.sourceLayer:"",a=n._geojsonTileLayer||n[i];if(a)for(var o=on(e&&e.filter),s=this.tileID.canonical,u=s.z,l=s.x,p=s.y,c={z:u,x:l,y:p},h=0;h<a.length;h++){var f=a.feature(h);if(o.needGeometry){var y=Ua(f,!0);if(!o.filter(new si(this.tileID.overscaledZ),y,this.tileID.canonical))continue}else if(!o.filter(new si(this.tileID.overscaledZ),f))continue;var d=r.getId(f,i),m=new Wl(f,u,l,p,d);m.tile=c,t.push(m);}}},ap.prototype.hasData=function(){return "loaded"===this.state||"reloading"===this.state||"expired"===this.state},ap.prototype.patternsLoaded=function(){return this.imageAtlas&&!!Object.keys(this.imageAtlas.patternPositions).length},ap.prototype.setExpiryData=function(t){var e=this.expirationTime;if(t.cacheControl){var r=z(t.cacheControl);r["max-age"]&&(this.expirationTime=Date.now()+1e3*r["max-age"]);}else t.expires&&(this.expirationTime=new Date(t.expires).getTime());if(this.expirationTime){var n=Date.now(),i=!1;if(this.expirationTime>n)i=!1;else if(e)if(this.expirationTime<e)i=!0;else {var a=this.expirationTime-e;a?this.expirationTime=n+Math.max(a,3e4):i=!0;}else i=!0;i?(this.expiredRequestCount++,this.state="expired"):this.expiredRequestCount=0;}},ap.prototype.getExpiryTimeout=function(){if(this.expirationTime)return this.expiredRequestCount?1e3*(1<<Math.min(this.expiredRequestCount-1,31)):Math.min(this.expirationTime-(new Date).getTime(),Math.pow(2,31)-1)},ap.prototype.setFeatureState=function(t,e){if(this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData&&0!==Object.keys(t).length){var r=this.latestFeatureIndex.loadVTLayers();for(var n in this.buckets)if(e.style.hasLayer(n)){var i=this.buckets[n],a=i.layers[0].sourceLayer||"_geojsonTileLayer",o=r[a],s=t[a];if(o&&s&&0!==Object.keys(s).length){i.update(s,o,this.imageAtlas&&this.imageAtlas.patternPositions||{});var u=e&&e.style&&e.style.getLayer(n);u&&(this.queryPadding=Math.max(this.queryPadding,u.queryRadius(i)));}}}},ap.prototype.holdingForFade=function(){return void 0!==this.symbolFadeHoldUntil},ap.prototype.symbolFadeFinished=function(){return !this.symbolFadeHoldUntil||this.symbolFadeHoldUntil<O.now()},ap.prototype.clearFadeHold=function(){this.symbolFadeHoldUntil=void 0;},ap.prototype.setHoldDuration=function(t){this.symbolFadeHoldUntil=O.now()+t;},ap.prototype.setDependencies=function(t,e){for(var r={},n=0,i=e;n<i.length;n+=1)r[i[n]]=!0;this.dependencies[t]=r;},ap.prototype.hasDependency=function(t,e){for(var r=0,n=t;r<n.length;r+=1){var i=this.dependencies[n[r]];if(i)for(var a=0,o=e;a<o.length;a+=1)if(i[o[a]])return !0}return !1};var op=o.performance,sp=function(t){this._marks={start:[t.url,"start"].join("#"),end:[t.url,"end"].join("#"),measure:t.url.toString()},op.mark(this._marks.start);};sp.prototype.finish=function(){op.mark(this._marks.end);var t=op.getEntriesByName(this._marks.measure);return 0===t.length&&(op.measure(this._marks.measure,this._marks.start,this._marks.end),t=op.getEntriesByName(this._marks.measure),op.clearMarks(this._marks.start),op.clearMarks(this._marks.end),op.clearMeasures(this._marks.measure)),t},t.Actor=Fl,t.AlphaImage=go,t.CanonicalTileID=Zl,t.CollisionBoxArray=$i,t.Color=te,t.DEMData=Yl,t.DataConstantProperty=mi,t.DictionaryCoder=$l,t.EXTENT=8192,t.ErrorEvent=zt,t.EvaluationParameters=si,t.Event=It,t.Evented=Ct,t.FeatureIndex=ep,t.FillBucket=ss,t.FillExtrusionBucket=Ss,t.ImageAtlas=bu,t.ImagePosition=gu,t.LineBucket=Fs,t.LngLat=Ol,t.LngLatBounds=Ll,t.MercatorCoordinate=Gl,t.ONE_EM=24,t.OverscaledTileID=Jl,t.Point=i,t.Point$1=i,t.Properties=wi,t.Protobuf=Ys,t.RGBAImage=xo,t.RequestManager=G,t.RequestPerformance=sp,t.ResourceType=yt,t.SegmentVector=sa,t.SourceFeatureState=tp,t.StructArrayLayout1ui2=Ji,t.StructArrayLayout2f1f2i16=Ri,t.StructArrayLayout2i4=Ci,t.StructArrayLayout3ui6=ji,t.StructArrayLayout4i8=Ei,t.SymbolBucket=vl,t.Texture=Tl,t.Tile=ap,t.Transitionable=pi,t.Uniform1f=ba,t.Uniform1i=xa,t.Uniform2f=wa,t.Uniform3f=_a,t.Uniform4f=Aa,t.UniformColor=Sa,t.UniformMatrix4f=Ia,t.UnwrappedTileID=Xl,t.ValidationError=Pt,t.WritingMode=wu,t.ZoomHistory=Kn,t.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t},t.addDynamicAttributes=fl,t.asyncAll=function(t,e,r){if(!t.length)return r(null,[]);var n=t.length,i=new Array(t.length),a=null;t.forEach((function(t,o){e(t,(function(t,e){t&&(a=t),i[o]=e,0==--n&&r(a,i);}));}));},t.bezier=u,t.bindAll=v,t.browser=O,t.cacheEntryPossiblyAdded=function(t){++ht>ut&&(t.getActor().send("enforceCacheSizeLimit",st),ht=0);},t.clamp=p,t.clearTileCache=function(t){var e=o.caches.delete("mapbox-tiles");t&&e.catch(t).then((function(){return t()}));},t.clipLine=Zu,t.clone=function(t){var e=new ao(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},t.clone$1=w,t.clone$2=function(t){var e=new ao(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},t.collisionCircleLayout=Gs,t.config=R,t.create=function(){var t=new ao(16);return ao!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},t.create$1=function(){var t=new ao(9);return ao!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t},t.create$2=function(){var t=new ao(4);return ao!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t},t.createCommonjsModule=e,t.createExpression=Zr,t.createLayout=Ii,t.createStyleLayer=function(t){return "custom"===t.type?new Il(t):new zl[t.type](t)},t.cross=function(t,e,r){var n=e[0],i=e[1],a=e[2],o=r[0],s=r[1],u=r[2];return t[0]=i*u-a*s,t[1]=a*o-n*u,t[2]=n*s-i*o,t},t.deepEqual=function t(e,r){if(Array.isArray(e)){if(!Array.isArray(r)||e.length!==r.length)return !1;for(var n=0;n<e.length;n++)if(!t(e[n],r[n]))return !1;return !0}if("object"==typeof e&&null!==e&&null!==r){if("object"!=typeof r)return !1;if(Object.keys(e).length!==Object.keys(r).length)return !1;for(var i in e)if(!t(e[i],r[i]))return !1;return !0}return e===r},t.dot=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]},t.dot$1=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]},t.ease=l,t.emitValidationErrors=Bn,t.endsWith=g,t.enforceCacheSizeLimit=function(t){lt(),tt&&tt.then((function(e){e.keys().then((function(r){for(var n=0;n<r.length-t;n++)e.delete(r[n]);}));}));},t.evaluateSizeForFeature=Lu,t.evaluateSizeForZoom=Ou,t.evaluateVariableOffset=al,t.evented=ni,t.extend=h,t.featureFilter=on,t.filterObject=b,t.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=-r,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},t.getAnchorAlignment=Bu,t.getAnchorJustification=ol,t.getArrayBuffer=bt,t.getImage=At,t.getJSON=function(t,e){return xt(h(t,{type:"json"}),e)},t.getRTLTextPluginStatus=ii,t.getReferrer=mt,t.getVideo=function(t,e){var r,n,i=o.document.createElement("video");i.muted=!0,i.onloadstart=function(){e(null,i);};for(var a=0;a<t.length;a++){var s=o.document.createElement("source");r=t[a],n=void 0,(n=o.document.createElement("a")).href=r,(n.protocol!==o.document.location.protocol||n.host!==o.document.location.host)&&(i.crossOrigin="Anonymous"),s.src=t[a],i.appendChild(s);}return {cancel:function(){}}},t.identity=oo,t.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],o=e[4],s=e[5],u=e[6],l=e[7],p=e[8],c=e[9],h=e[10],f=e[11],y=e[12],d=e[13],m=e[14],v=e[15],g=r*s-n*o,x=r*u-i*o,b=r*l-a*o,w=n*u-i*s,_=n*l-a*s,A=i*l-a*u,S=p*d-c*y,k=p*m-h*y,I=p*v-f*y,z=c*m-h*d,C=c*v-f*d,E=h*v-f*m,P=g*E-x*C+b*z+w*I-_*k+A*S;return P?(t[0]=(s*E-u*C+l*z)*(P=1/P),t[1]=(i*C-n*E-a*z)*P,t[2]=(d*A-m*_+v*w)*P,t[3]=(h*_-c*A-f*w)*P,t[4]=(u*I-o*E-l*k)*P,t[5]=(r*E-i*I+a*k)*P,t[6]=(m*b-y*A-v*x)*P,t[7]=(p*A-h*b+f*x)*P,t[8]=(o*C-s*I+l*S)*P,t[9]=(n*I-r*C-a*S)*P,t[10]=(y*_-d*b+v*g)*P,t[11]=(c*b-p*_-f*g)*P,t[12]=(s*k-o*z-u*S)*P,t[13]=(r*z-n*k+i*S)*P,t[14]=(d*x-y*w-m*g)*P,t[15]=(p*w-c*x+h*g)*P,t):null},t.isChar=Gn,t.isMapboxURL=Z,t.keysDifference=function(t,e){var r=[];for(var n in t)n in e||r.push(n);return r},t.makeRequest=xt,t.mapObject=x,t.mercatorXfromLng=jl,t.mercatorYfromLat=ql,t.mercatorZfromAltitude=Nl,t.mul=lo,t.multiply=so,t.mvt=bs,t.nextPowerOfTwo=function(t){return t<=1?1:Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},t.normalize=function(t,e){var r=e[0],n=e[1],i=e[2],a=r*r+n*n+i*i;return a>0&&(a=1/Math.sqrt(a)),t[0]=e[0]*a,t[1]=e[1]*a,t[2]=e[2]*a,t},t.number=Ke,t.offscreenCanvasSupported=ft,t.ortho=function(t,e,r,n,i,a,o){var s=1/(e-r),u=1/(n-i),l=1/(a-o);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*l,t[11]=0,t[12]=(e+r)*s,t[13]=(i+n)*u,t[14]=(o+a)*l,t[15]=1,t},t.parseGlyphPBF=function(t){return new Ys(t).readFields(yu,[])},t.pbf=Ys,t.performSymbolLayout=function(t,e,r,n,i,a,o){t.createArrays(),t.tilePixelRatio=8192/(512*t.overscaling),t.compareText={},t.iconsNeedLinear=!1;var s=t.layers[0].layout,u=t.layers[0]._unevaluatedLayout._values,l={};if("composite"===t.textSizeData.kind){var p=t.textSizeData,c=p.maxZoom;l.compositeTextSizes=[u["text-size"].possiblyEvaluate(new si(p.minZoom),o),u["text-size"].possiblyEvaluate(new si(c),o)];}if("composite"===t.iconSizeData.kind){var h=t.iconSizeData,f=h.maxZoom;l.compositeIconSizes=[u["icon-size"].possiblyEvaluate(new si(h.minZoom),o),u["icon-size"].possiblyEvaluate(new si(f),o)];}l.layoutTextSize=u["text-size"].possiblyEvaluate(new si(t.zoom+1),o),l.layoutIconSize=u["icon-size"].possiblyEvaluate(new si(t.zoom+1),o),l.textMaxSize=u["text-size"].possiblyEvaluate(new si(18));for(var y=24*s.get("text-line-height"),d="map"===s.get("text-rotation-alignment")&&"point"!==s.get("symbol-placement"),m=s.get("text-keep-upright"),v=s.get("text-size"),g=function(){var a=b[x],u=s.get("text-font").evaluate(a,{},o).join(","),p=v.evaluate(a,{},o),c=l.layoutTextSize.evaluate(a,{},o),h=l.layoutIconSize.evaluate(a,{},o),f={horizontal:{},vertical:void 0},g=a.text,w=[0,0];if(g){var _=g.toString(),S=24*s.get("text-letter-spacing").evaluate(a,{},o),k=function(t){for(var e=0,r=t;e<r.length;e+=1)if(n=r[e].charCodeAt(0),Gn.Arabic(n)||Gn["Arabic Supplement"](n)||Gn["Arabic Extended-A"](n)||Gn["Arabic Presentation Forms-A"](n)||Gn["Arabic Presentation Forms-B"](n))return !1;var n;return !0}(_)?S:0,I=s.get("text-anchor").evaluate(a,{},o),z=s.get("text-variable-anchor");if(!z){var C=s.get("text-radial-offset").evaluate(a,{},o);w=C?al(I,[24*C,il]):s.get("text-offset").evaluate(a,{},o).map((function(t){return 24*t}));}var E=d?"center":s.get("text-justify").evaluate(a,{},o),P=s.get("symbol-placement"),M="point"===P?24*s.get("text-max-width").evaluate(a,{},o):0,B=function(){t.allowVerticalPlacement&&Zn(_)&&(f.vertical=Su(g,e,r,i,u,M,y,I,"left",k,w,wu.vertical,!0,P,c,p));};if(!d&&z){for(var T="auto"===E?z.map((function(t){return ol(t)})):[E],V=!1,F=0;F<T.length;F++){var D=T[F];if(!f.horizontal[D])if(V)f.horizontal[D]=f.horizontal[0];else {var L=Su(g,e,r,i,u,M,y,"center",D,k,w,wu.horizontal,!1,P,c,p);L&&(f.horizontal[D]=L,V=1===L.positionedLines.length);}}B();}else {"auto"===E&&(E=ol(I));var O=Su(g,e,r,i,u,M,y,I,E,k,w,wu.horizontal,!1,P,c,p);O&&(f.horizontal[E]=O),B(),Zn(_)&&d&&m&&(f.vertical=Su(g,e,r,i,u,M,y,I,E,k,w,wu.vertical,!1,P,c,p));}}var R=void 0,U=!1;if(a.icon&&a.icon.name){var j=n[a.icon.name];j&&(R=function(t,e,r){var n=Bu(r),i=e[0]-t.displaySize[0]*n.horizontalAlign,a=e[1]-t.displaySize[1]*n.verticalAlign;return {image:t,top:a,bottom:a+t.displaySize[1],left:i,right:i+t.displaySize[0]}}(i[a.icon.name],s.get("icon-offset").evaluate(a,{},o),s.get("icon-anchor").evaluate(a,{},o)),U=j.sdf,void 0===t.sdfIcons?t.sdfIcons=j.sdf:t.sdfIcons!==j.sdf&&A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(j.pixelRatio!==t.pixelRatio||0!==s.get("icon-rotate").constantOr(1))&&(t.iconsNeedLinear=!0));}var q=ul(f.horizontal)||f.vertical;t.iconsInText=!!q&&q.iconsInText,(q||R)&&function(t,e,r,n,i,a,o,s,u,l,p){var c=a.textMaxSize.evaluate(e,{});void 0===c&&(c=o);var h,f=t.layers[0].layout,y=f.get("icon-offset").evaluate(e,{},p),d=ul(r.horizontal),m=o/24,v=t.tilePixelRatio*m,g=t.tilePixelRatio*c/24,x=t.tilePixelRatio*s,b=t.tilePixelRatio*f.get("symbol-spacing"),w=f.get("text-padding")*t.tilePixelRatio,_=f.get("icon-padding")*t.tilePixelRatio,S=f.get("text-max-angle")/180*Math.PI,k="map"===f.get("text-rotation-alignment")&&"point"!==f.get("symbol-placement"),I="map"===f.get("icon-rotation-alignment")&&"point"!==f.get("symbol-placement"),z=f.get("symbol-placement"),C=b/2,E=f.get("icon-text-fit");n&&"none"!==E&&(t.allowVerticalPlacement&&r.vertical&&(h=Vu(n,r.vertical,E,f.get("icon-text-fit-padding"),y,m)),d&&(n=Vu(n,d,E,f.get("icon-text-fit-padding"),y,m)));var P=function(s,c){c.x<0||c.x>=8192||c.y<0||c.y>=8192||function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,w,_,S,k){var I,z,C,E,P,M=t.addToLineVertexArray(e,r),B=0,T=0,V=0,F=0,D=-1,L=-1,O={},R=ha(""),U=0,j=0;if(void 0===s._unevaluatedLayout.getValue("text-radial-offset")?(U=(I=s.layout.get("text-offset").evaluate(b,{},S).map((function(t){return 24*t})))[0],j=I[1]):(U=24*s.layout.get("text-radial-offset").evaluate(b,{},S),j=il),t.allowVerticalPlacement&&n.vertical){var q=s.layout.get("text-rotate").evaluate(b,{},S)+90;E=new Wu(u,e,l,p,c,n.vertical,h,f,y,q),o&&(P=new Wu(u,e,l,p,c,o,m,v,y,q));}if(i){var N=s.layout.get("icon-rotate").evaluate(b,{}),K="none"!==s.layout.get("icon-text-fit"),G=Xu(i,N,_,K),Z=o?Xu(o,N,_,K):void 0;C=new Wu(u,e,l,p,c,i,m,v,!1,N),B=4*G.length;var X=t.iconSizeData,J=null;"source"===X.kind?(J=[128*s.layout.get("icon-size").evaluate(b,{})])[0]>32640&&A(t.layerIds[0]+': Value for "icon-size" is >= 255. Reduce your "icon-size".'):"composite"===X.kind&&((J=[128*w.compositeIconSizes[0].evaluate(b,{},S),128*w.compositeIconSizes[1].evaluate(b,{},S)])[0]>32640||J[1]>32640)&&A(t.layerIds[0]+': Value for "icon-size" is >= 255. Reduce your "icon-size".'),t.addSymbols(t.icon,G,J,x,g,b,!1,e,M.lineStartIndex,M.lineLength,-1,S),D=t.icon.placedSymbolArray.length-1,Z&&(T=4*Z.length,t.addSymbols(t.icon,Z,J,x,g,b,wu.vertical,e,M.lineStartIndex,M.lineLength,-1,S),L=t.icon.placedSymbolArray.length-1);}for(var H in n.horizontal){var Y=n.horizontal[H];if(!z){R=ha(Y.text);var $=s.layout.get("text-rotate").evaluate(b,{},S);z=new Wu(u,e,l,p,c,Y,h,f,y,$);}var W=1===Y.positionedLines.length;if(V+=sl(t,e,Y,a,s,y,b,d,M,n.vertical?wu.horizontal:wu.horizontalOnly,W?Object.keys(n.horizontal):[H],O,D,w,S),W)break}n.vertical&&(F+=sl(t,e,n.vertical,a,s,y,b,d,M,wu.vertical,["vertical"],O,L,w,S));var Q=z?z.boxStartIndex:t.collisionBoxArray.length,tt=z?z.boxEndIndex:t.collisionBoxArray.length,et=E?E.boxStartIndex:t.collisionBoxArray.length,rt=E?E.boxEndIndex:t.collisionBoxArray.length,nt=C?C.boxStartIndex:t.collisionBoxArray.length,it=C?C.boxEndIndex:t.collisionBoxArray.length,at=P?P.boxStartIndex:t.collisionBoxArray.length,ot=P?P.boxEndIndex:t.collisionBoxArray.length,st=-1,ut=function(t,e){return t&&t.circleDiameter?Math.max(t.circleDiameter,e):e};st=ut(z,st),st=ut(E,st),st=ut(C,st);var lt=(st=ut(P,st))>-1?1:0;lt&&(st*=k/24),t.glyphOffsetArray.length>=vl.MAX_GLYPHS&&A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),void 0!==b.sortKey&&t.addToSortKeyRanges(t.symbolInstances.length,b.sortKey),t.symbolInstances.emplaceBack(e.x,e.y,O.right>=0?O.right:-1,O.center>=0?O.center:-1,O.left>=0?O.left:-1,O.vertical||-1,D,L,R,Q,tt,et,rt,nt,it,at,ot,l,V,F,B,T,lt,0,h,U,j,st);}(t,c,s,r,n,i,h,t.layers[0],t.collisionBoxArray,e.index,e.sourceLayerIndex,t.index,v,w,k,u,x,_,I,y,e,a,l,p,o);};if("line"===z)for(var M=0,B=Zu(e.geometry,0,0,8192,8192);M<B.length;M+=1)for(var T=B[M],V=0,F=Gu(T,b,S,r.vertical||d,n,24,g,t.overscaling,8192);V<F.length;V+=1){var D=F[V];d&&ll(t,d.text,C,D)||P(T,D);}else if("line-center"===z)for(var L=0,O=e.geometry;L<O.length;L+=1){var R=O[L];if(R.length>1){var U=Ku(R,S,r.vertical||d,n,24,g);U&&P(R,U);}}else if("Polygon"===e.type)for(var j=0,q=ns(e.geometry,0);j<q.length;j+=1){var N=q[j],K=el(N,16);P(N[0],new Fu(K.x,K.y,0));}else if("LineString"===e.type)for(var G=0,Z=e.geometry;G<Z.length;G+=1){var X=Z[G];P(X,new Fu(X[0].x,X[0].y,0));}else if("Point"===e.type)for(var J=0,H=e.geometry;J<H.length;J+=1)for(var Y=0,$=H[J];Y<$.length;Y+=1){var W=$[Y];P([W],new Fu(W.x,W.y,0));}}(t,a,f,R,n,l,c,h,w,U,o);},x=0,b=t.features;x<b.length;x+=1)g();a&&t.generateCollisionDebugBuffers();},t.perspective=function(t,e,r,n,i){var a,o=1/Math.tan(e/2);return t[0]=o/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(t[10]=(i+n)*(a=1/(n-i)),t[14]=2*i*n*a):(t[10]=-1,t[14]=-2*n),t},t.pick=function(t,e){for(var r={},n=0;n<e.length;n++){var i=e[n];i in t&&(r[i]=t[i]);}return r},t.plugin=oi,t.polygonIntersectsPolygon=Na,t.postMapLoadEvent=ot,t.postTurnstileEvent=it,t.potpack=vu,t.refProperties=["type","source","source-layer","minzoom","maxzoom","filter","layout"],t.register=On,t.registerForPluginStateChange=function(t){return t({pluginStatus:Qn,pluginURL:ti}),ni.on("pluginStateChange",t),t},t.renderColorRamp=wo,t.rotate=function(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3],s=Math.sin(r),u=Math.cos(r);return t[0]=n*u+a*s,t[1]=i*u+o*s,t[2]=n*-s+a*u,t[3]=i*-s+o*u,t},t.rotateX=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[4],o=e[5],s=e[6],u=e[7],l=e[8],p=e[9],c=e[10],h=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=a*i+l*n,t[5]=o*i+p*n,t[6]=s*i+c*n,t[7]=u*i+h*n,t[8]=l*i-a*n,t[9]=p*i-o*n,t[10]=c*i-s*n,t[11]=h*i-u*n,t},t.rotateZ=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[0],o=e[1],s=e[2],u=e[3],l=e[4],p=e[5],c=e[6],h=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=a*i+l*n,t[1]=o*i+p*n,t[2]=s*i+c*n,t[3]=u*i+h*n,t[4]=l*i-a*n,t[5]=p*i-o*n,t[6]=c*i-s*n,t[7]=h*i-u*n,t},t.scale=function(t,e,r){var n=r[0],i=r[1],a=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*a,t[9]=e[9]*a,t[10]=e[10]*a,t[11]=e[11]*a,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},t.scale$1=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t},t.scale$2=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t},t.setCacheLimits=function(t,e){st=t,ut=e;},t.setRTLTextPlugin=function(t,e,r){if(void 0===r&&(r=!1),"deferred"===Qn||"loading"===Qn||"loaded"===Qn)throw new Error("setRTLTextPlugin cannot be called multiple times.");ti=O.resolveURL(t),Qn="deferred",Wn=e,ri(),r||ai();},t.sphericalToCartesian=function(t){var e=t[0],r=t[1],n=t[2];return r+=90,r*=Math.PI/180,n*=Math.PI/180,{x:e*Math.cos(r)*Math.sin(n),y:e*Math.sin(r)*Math.sin(n),z:e*Math.cos(n)}},t.sqrLen=function(t){var e=t[0],r=t[1];return e*e+r*r},t.styleSpec=Et,t.sub=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t},t.symbolSize=Ru,t.transformMat3=function(t,e,r){var n=e[0],i=e[1],a=e[2];return t[0]=n*r[0]+i*r[3]+a*r[6],t[1]=n*r[1]+i*r[4]+a*r[7],t[2]=n*r[2]+i*r[5]+a*r[8],t},t.transformMat4=po,t.translate=function(t,e,r){var n,i,a,o,s,u,l,p,c,h,f,y,d=r[0],m=r[1],v=r[2];return e===t?(t[12]=e[0]*d+e[4]*m+e[8]*v+e[12],t[13]=e[1]*d+e[5]*m+e[9]*v+e[13],t[14]=e[2]*d+e[6]*m+e[10]*v+e[14],t[15]=e[3]*d+e[7]*m+e[11]*v+e[15]):(i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],l=e[6],p=e[7],c=e[8],h=e[9],f=e[10],y=e[11],t[0]=n=e[0],t[1]=i,t[2]=a,t[3]=o,t[4]=s,t[5]=u,t[6]=l,t[7]=p,t[8]=c,t[9]=h,t[10]=f,t[11]=y,t[12]=n*d+s*m+c*v+e[12],t[13]=i*d+u*m+h*v+e[13],t[14]=a*d+l*m+f*v+e[14],t[15]=o*d+p*m+y*v+e[15]),t},t.triggerPluginCompletionEvent=ei,t.uniqueId=y,t.validateCustomStyleLayer=function(t){var e=[],r=t.id;return void 0===r&&e.push({message:"layers."+r+': missing required property "id"'}),void 0===t.render&&e.push({message:"layers."+r+': missing required method "render"'}),t.renderingMode&&"2d"!==t.renderingMode&&"3d"!==t.renderingMode&&e.push({message:"layers."+r+': property "renderingMode" must be either "2d" or "3d"'}),e},t.validateLight=En,t.validateStyle=Cn,t.values=function(t){var e=[];for(var r in t)e.push(t[r]);return e},t.vectorTile=bs,t.version="1.13.2",t.warnOnce=A,t.webpSupported=U,t.window=o,t.wrap=c;}));

    define(["./shared"],(function(e){function t(e){var r=typeof e;if("number"===r||"boolean"===r||"string"===r||null==e)return JSON.stringify(e);if(Array.isArray(e)){for(var i="[",o=0,n=e;o<n.length;o+=1)i+=t(n[o])+",";return i+"]"}for(var s=Object.keys(e).sort(),a="{",l=0;l<s.length;l++)a+=JSON.stringify(s[l])+":"+t(e[s[l]])+",";return a+"}"}function r(r){for(var i="",o=0,n=e.refProperties;o<n.length;o+=1)i+="/"+t(r[n[o]]);return i}var i=function(e){this.keyCache={},e&&this.replace(e);};i.prototype.replace=function(e){this._layerConfigs={},this._layers={},this.update(e,[]);},i.prototype.update=function(t,i){for(var o=this,n=0,s=t;n<s.length;n+=1){var a=s[n];this._layerConfigs[a.id]=a;var l=this._layers[a.id]=e.createStyleLayer(a);l._featureFilter=e.featureFilter(l.filter),this.keyCache[a.id]&&delete this.keyCache[a.id];}for(var u=0,h=i;u<h.length;u+=1){var c=h[u];delete this.keyCache[c],delete this._layerConfigs[c],delete this._layers[c];}this.familiesBySource={};for(var p=0,f=function(e,t){for(var i={},o=0;o<e.length;o++){var n=t&&t[e[o].id]||r(e[o]);t&&(t[e[o].id]=n);var s=i[n];s||(s=i[n]=[]),s.push(e[o]);}var a=[];for(var l in i)a.push(i[l]);return a}(e.values(this._layerConfigs),this.keyCache);p<f.length;p+=1){var d=f[p].map((function(e){return o._layers[e.id]})),g=d[0];if("none"!==g.visibility){var v=g.source||"",m=this.familiesBySource[v];m||(m=this.familiesBySource[v]={});var y=g.sourceLayer||"_geojsonTileLayer",x=m[y];x||(x=m[y]=[]),x.push(d);}}};var o=function(t){var r={},i=[];for(var o in t){var n=t[o],s=r[o]={};for(var a in n){var l=n[+a];if(l&&0!==l.bitmap.width&&0!==l.bitmap.height){var u={x:0,y:0,w:l.bitmap.width+2,h:l.bitmap.height+2};i.push(u),s[a]={rect:u,metrics:l.metrics};}}}var h=e.potpack(i),c=new e.AlphaImage({width:h.w||1,height:h.h||1});for(var p in t){var f=t[p];for(var d in f){var g=f[+d];if(g&&0!==g.bitmap.width&&0!==g.bitmap.height){var v=r[p][d].rect;e.AlphaImage.copy(g.bitmap,c,{x:0,y:0},{x:v.x+1,y:v.y+1},g.bitmap);}}}this.image=c,this.positions=r;};e.register("GlyphAtlas",o);var n=function(t){this.tileID=new e.OverscaledTileID(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.uid=t.uid,this.zoom=t.zoom,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.returnDependencies=!!t.returnDependencies,this.promoteId=t.promoteId;};function s(t,r,i){for(var o=new e.EvaluationParameters(r),n=0,s=t;n<s.length;n+=1)s[n].recalculate(o,i);}function a(t,r){var i=e.getArrayBuffer(t.request,(function(t,i,o,n){t?r(t):i&&r(null,{vectorTile:new e.vectorTile.VectorTile(new e.pbf(i)),rawData:i,cacheControl:o,expires:n});}));return function(){i.cancel(),r();}}n.prototype.parse=function(t,r,i,n,a){var l=this;this.status="parsing",this.data=t,this.collisionBoxArray=new e.CollisionBoxArray;var u=new e.DictionaryCoder(Object.keys(t.layers).sort()),h=new e.FeatureIndex(this.tileID,this.promoteId);h.bucketLayerIDs=[];var c,p,f,d,g={},v={featureIndex:h,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:i},m=r.familiesBySource[this.source];for(var y in m){var x=t.layers[y];if(x){1===x.version&&e.warnOnce('Vector tile source "'+this.source+'" layer "'+y+'" does not use vector tile spec v2 and therefore may have some rendering errors.');for(var w=u.encode(y),S=[],I=0;I<x.length;I++){var M=x.feature(I),b=h.getId(M,y);S.push({feature:M,id:b,index:I,sourceLayerIndex:w});}for(var _=0,k=m[y];_<k.length;_+=1){var P=k[_],T=P[0];T.minzoom&&this.zoom<Math.floor(T.minzoom)||T.maxzoom&&this.zoom>=T.maxzoom||"none"!==T.visibility&&(s(P,this.zoom,i),(g[T.id]=T.createBucket({index:h.bucketLayerIDs.length,layers:P,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:w,sourceID:this.source})).populate(S,v,this.tileID.canonical),h.bucketLayerIDs.push(P.map((function(e){return e.id}))));}}}var C=e.mapObject(v.glyphDependencies,(function(e){return Object.keys(e).map(Number)}));Object.keys(C).length?n.send("getGlyphs",{uid:this.uid,stacks:C},(function(e,t){c||(c=e,p=t,z.call(l));})):p={};var D=Object.keys(v.iconDependencies);D.length?n.send("getImages",{icons:D,source:this.source,tileID:this.tileID,type:"icons"},(function(e,t){c||(c=e,f=t,z.call(l));})):f={};var L=Object.keys(v.patternDependencies);function z(){if(c)return a(c);if(p&&f&&d){var t=new o(p),r=new e.ImageAtlas(f,d);for(var n in g){var l=g[n];l instanceof e.SymbolBucket?(s(l.layers,this.zoom,i),e.performSymbolLayout(l,p,t.positions,f,r.iconPositions,this.showCollisionBoxes,this.tileID.canonical)):l.hasPattern&&(l instanceof e.LineBucket||l instanceof e.FillBucket||l instanceof e.FillExtrusionBucket)&&(s(l.layers,this.zoom,i),l.addFeatures(v,this.tileID.canonical,r.patternPositions));}this.status="done",a(null,{buckets:e.values(g).filter((function(e){return !e.isEmpty()})),featureIndex:h,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:t.image,imageAtlas:r,glyphMap:this.returnDependencies?p:null,iconMap:this.returnDependencies?f:null,glyphPositions:this.returnDependencies?t.positions:null});}}L.length?n.send("getImages",{icons:L,source:this.source,tileID:this.tileID,type:"patterns"},(function(e,t){c||(c=e,d=t,z.call(l));})):d={},z.call(this);};var l=function(e,t,r,i){this.actor=e,this.layerIndex=t,this.availableImages=r,this.loadVectorData=i||a,this.loading={},this.loaded={};};l.prototype.loadTile=function(t,r){var i=this,o=t.uid;this.loading||(this.loading={});var s=!!(t&&t.request&&t.request.collectResourceTiming)&&new e.RequestPerformance(t.request),a=this.loading[o]=new n(t);a.abort=this.loadVectorData(t,(function(t,n){if(delete i.loading[o],t||!n)return a.status="done",i.loaded[o]=a,r(t);var l=n.rawData,u={};n.expires&&(u.expires=n.expires),n.cacheControl&&(u.cacheControl=n.cacheControl);var h={};if(s){var c=s.finish();c&&(h.resourceTiming=JSON.parse(JSON.stringify(c)));}a.vectorTile=n.vectorTile,a.parse(n.vectorTile,i.layerIndex,i.availableImages,i.actor,(function(t,i){if(t||!i)return r(t);r(null,e.extend({rawTileData:l.slice(0)},i,u,h));})),i.loaded=i.loaded||{},i.loaded[o]=a;}));},l.prototype.reloadTile=function(e,t){var r=this,i=this.loaded,o=e.uid,n=this;if(i&&i[o]){var s=i[o];s.showCollisionBoxes=e.showCollisionBoxes;var a=function(e,i){var o=s.reloadCallback;o&&(delete s.reloadCallback,s.parse(s.vectorTile,n.layerIndex,r.availableImages,n.actor,o)),t(e,i);};"parsing"===s.status?s.reloadCallback=a:"done"===s.status&&(s.vectorTile?s.parse(s.vectorTile,this.layerIndex,this.availableImages,this.actor,a):a());}},l.prototype.abortTile=function(e,t){var r=this.loading,i=e.uid;r&&r[i]&&r[i].abort&&(r[i].abort(),delete r[i]),t();},l.prototype.removeTile=function(e,t){var r=this.loaded,i=e.uid;r&&r[i]&&delete r[i],t();};var u=e.window.ImageBitmap,h=function(){this.loaded={};};function c(e,t){if(0!==e.length){p(e[0],t);for(var r=1;r<e.length;r++)p(e[r],!t);}}function p(e,t){for(var r=0,i=0,o=e.length,n=o-1;i<o;n=i++)r+=(e[i][0]-e[n][0])*(e[n][1]+e[i][1]);r>=0!=!!t&&e.reverse();}h.prototype.loadTile=function(t,r){var i=t.uid,o=t.encoding,n=t.rawImageData,s=u&&n instanceof u?this.getImageData(n):n,a=new e.DEMData(i,s,o);this.loaded=this.loaded||{},this.loaded[i]=a,r(null,a);},h.prototype.getImageData=function(t){this.offscreenCanvas&&this.offscreenCanvasContext||(this.offscreenCanvas=new OffscreenCanvas(t.width,t.height),this.offscreenCanvasContext=this.offscreenCanvas.getContext("2d")),this.offscreenCanvas.width=t.width,this.offscreenCanvas.height=t.height,this.offscreenCanvasContext.drawImage(t,0,0,t.width,t.height);var r=this.offscreenCanvasContext.getImageData(-1,-1,t.width+2,t.height+2);return this.offscreenCanvasContext.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),new e.RGBAImage({width:r.width,height:r.height},r.data)},h.prototype.removeTile=function(e){var t=this.loaded,r=e.uid;t&&t[r]&&delete t[r];};var f=e.vectorTile.VectorTileFeature.prototype.toGeoJSON,d=function(t){this._feature=t,this.extent=e.EXTENT,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10));};d.prototype.loadGeometry=function(){if(1===this._feature.type){for(var t=[],r=0,i=this._feature.geometry;r<i.length;r+=1){var o=i[r];t.push([new e.Point$1(o[0],o[1])]);}return t}for(var n=[],s=0,a=this._feature.geometry;s<a.length;s+=1){for(var l=[],u=0,h=a[s];u<h.length;u+=1){var c=h[u];l.push(new e.Point$1(c[0],c[1]));}n.push(l);}return n},d.prototype.toGeoJSON=function(e,t,r){return f.call(this,e,t,r)};var g=function(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=e.EXTENT,this.length=t.length,this._features=t;};g.prototype.feature=function(e){return new d(this._features[e])};var v=e.vectorTile.VectorTileFeature,m=y;function y(e,t){this.options=t||{},this.features=e,this.length=e.length;}function x(e,t){this.id="number"==typeof e.id?e.id:void 0,this.type=e.type,this.rawGeometry=1===e.type?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096;}y.prototype.feature=function(e){return new x(this.features[e],this.options.extent)},x.prototype.loadGeometry=function(){var t=this.rawGeometry;this.geometry=[];for(var r=0;r<t.length;r++){for(var i=t[r],o=[],n=0;n<i.length;n++)o.push(new e.Point$1(i[n][0],i[n][1]));this.geometry.push(o);}return this.geometry},x.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-1/0,i=1/0,o=-1/0,n=0;n<e.length;n++)for(var s=e[n],a=0;a<s.length;a++){var l=s[a];t=Math.min(t,l.x),r=Math.max(r,l.x),i=Math.min(i,l.y),o=Math.max(o,l.y);}return [t,i,r,o]},x.prototype.toGeoJSON=v.prototype.toGeoJSON;var w=I,S=m;function I(t){var r=new e.pbf;return function(e,t){for(var r in e.layers)t.writeMessage(3,M,e.layers[r]);}(t,r),r.finish()}function M(e,t){var r;t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var i={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<e.length;r++)i.feature=e.feature(r),t.writeMessage(2,b,i);var o=i.keys;for(r=0;r<o.length;r++)t.writeStringField(3,o[r]);var n=i.values;for(r=0;r<n.length;r++)t.writeMessage(4,C,n[r]);}function b(e,t){var r=e.feature;void 0!==r.id&&t.writeVarintField(1,r.id),t.writeMessage(2,_,e),t.writeVarintField(3,r.type),t.writeMessage(4,T,r);}function _(e,t){var r=e.feature,i=e.keys,o=e.values,n=e.keycache,s=e.valuecache;for(var a in r.properties){var l=n[a];void 0===l&&(i.push(a),n[a]=l=i.length-1),t.writeVarint(l);var u=r.properties[a],h=typeof u;"string"!==h&&"boolean"!==h&&"number"!==h&&(u=JSON.stringify(u));var c=h+":"+u,p=s[c];void 0===p&&(o.push(u),s[c]=p=o.length-1),t.writeVarint(p);}}function k(e,t){return (t<<3)+(7&e)}function P(e){return e<<1^e>>31}function T(e,t){for(var r=e.loadGeometry(),i=e.type,o=0,n=0,s=r.length,a=0;a<s;a++){var l=r[a],u=1;1===i&&(u=l.length),t.writeVarint(k(1,u));for(var h=3===i?l.length-1:l.length,c=0;c<h;c++){1===c&&1!==i&&t.writeVarint(k(2,h-1));var p=l[c].x-o,f=l[c].y-n;t.writeVarint(P(p)),t.writeVarint(P(f)),o+=p,n+=f;}3===i&&t.writeVarint(k(7,1));}}function C(e,t){var r=typeof e;"string"===r?t.writeStringField(1,e):"boolean"===r?t.writeBooleanField(7,e):"number"===r&&(e%1!=0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e));}function D(e,t,r,i){L(e,r,i),L(t,2*r,2*i),L(t,2*r+1,2*i+1);}function L(e,t,r){var i=e[t];e[t]=e[r],e[r]=i;}function z(e,t,r,i){var o=e-r,n=t-i;return o*o+n*n}w.fromVectorTileJs=I,w.fromGeojsonVt=function(e,t){t=t||{};var r={};for(var i in e)r[i]=new m(e[i].features,t),r[i].name=i,r[i].version=t.version,r[i].extent=t.extent;return I({layers:r})},w.GeoJSONWrapper=S;var O=function(e){return e[0]},E=function(e){return e[1]},F=function(e,t,r,i,o){void 0===t&&(t=O),void 0===r&&(r=E),void 0===i&&(i=64),void 0===o&&(o=Float64Array),this.nodeSize=i,this.points=e;for(var n=e.length<65536?Uint16Array:Uint32Array,s=this.ids=new n(e.length),a=this.coords=new o(2*e.length),l=0;l<e.length;l++)s[l]=l,a[2*l]=t(e[l]),a[2*l+1]=r(e[l]);!function e(t,r,i,o,n,s){if(!(n-o<=i)){var a=o+n>>1;!function e(t,r,i,o,n,s){for(;n>o;){if(n-o>600){var a=n-o+1,l=i-o+1,u=Math.log(a),h=.5*Math.exp(2*u/3),c=.5*Math.sqrt(u*h*(a-h)/a)*(l-a/2<0?-1:1);e(t,r,i,Math.max(o,Math.floor(i-l*h/a+c)),Math.min(n,Math.floor(i+(a-l)*h/a+c)),s);}var p=r[2*i+s],f=o,d=n;for(D(t,r,o,i),r[2*n+s]>p&&D(t,r,o,n);f<d;){for(D(t,r,f,d),f++,d--;r[2*f+s]<p;)f++;for(;r[2*d+s]>p;)d--;}r[2*o+s]===p?D(t,r,o,d):D(t,r,++d,n),d<=i&&(o=d+1),i<=d&&(n=d-1);}}(t,r,a,o,n,s%2),e(t,r,i,o,a-1,s+1),e(t,r,i,a+1,n,s+1);}}(s,a,i,0,s.length-1,0);};F.prototype.range=function(e,t,r,i){return function(e,t,r,i,o,n,s){for(var a,l,u=[0,e.length-1,0],h=[];u.length;){var c=u.pop(),p=u.pop(),f=u.pop();if(p-f<=s)for(var d=f;d<=p;d++)l=t[2*d+1],(a=t[2*d])>=r&&a<=o&&l>=i&&l<=n&&h.push(e[d]);else {var g=Math.floor((f+p)/2);l=t[2*g+1],(a=t[2*g])>=r&&a<=o&&l>=i&&l<=n&&h.push(e[g]);var v=(c+1)%2;(0===c?r<=a:i<=l)&&(u.push(f),u.push(g-1),u.push(v)),(0===c?o>=a:n>=l)&&(u.push(g+1),u.push(p),u.push(v));}}return h}(this.ids,this.coords,e,t,r,i,this.nodeSize)},F.prototype.within=function(e,t,r){return function(e,t,r,i,o,n){for(var s=[0,e.length-1,0],a=[],l=o*o;s.length;){var u=s.pop(),h=s.pop(),c=s.pop();if(h-c<=n)for(var p=c;p<=h;p++)z(t[2*p],t[2*p+1],r,i)<=l&&a.push(e[p]);else {var f=Math.floor((c+h)/2),d=t[2*f],g=t[2*f+1];z(d,g,r,i)<=l&&a.push(e[f]);var v=(u+1)%2;(0===u?r-o<=d:i-o<=g)&&(s.push(c),s.push(f-1),s.push(v)),(0===u?r+o>=d:i+o>=g)&&(s.push(f+1),s.push(h),s.push(v));}}return a}(this.ids,this.coords,e,t,r,this.nodeSize)};var N={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:function(e){return e}},J=function(e){this.options=V(Object.create(N),e),this.trees=new Array(this.options.maxZoom+1);};function Z(e,t,r,i,o){return {x:e,y:t,zoom:1/0,id:r,parentId:-1,numPoints:i,properties:o}}function A(e,t){var r=e.geometry.coordinates,i=r[1];return {x:Y(r[0]),y:j(i),zoom:1/0,index:t,parentId:-1}}function B(e){return {type:"Feature",id:e.id,properties:G(e),geometry:{type:"Point",coordinates:[(i=e.x,360*(i-.5)),(t=e.y,r=(180-360*t)*Math.PI/180,360*Math.atan(Math.exp(r))/Math.PI-90)]}};var t,r,i;}function G(e){var t=e.numPoints,r=t>=1e4?Math.round(t/1e3)+"k":t>=1e3?Math.round(t/100)/10+"k":t;return V(V({},e.properties),{cluster:!0,cluster_id:e.id,point_count:t,point_count_abbreviated:r})}function Y(e){return e/360+.5}function j(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function V(e,t){for(var r in t)e[r]=t[r];return e}function X(e){return e.x}function W(e){return e.y}function R(e,t,r,i,o,n){var s=o-r,a=n-i;if(0!==s||0!==a){var l=((e-r)*s+(t-i)*a)/(s*s+a*a);l>1?(r=o,i=n):l>0&&(r+=s*l,i+=a*l);}return (s=e-r)*s+(a=t-i)*a}function q(e,t,r,i){var o={id:void 0===e?null:e,type:t,geometry:r,tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return function(e){var t=e.geometry,r=e.type;if("Point"===r||"MultiPoint"===r||"LineString"===r)U(e,t);else if("Polygon"===r||"MultiLineString"===r)for(var i=0;i<t.length;i++)U(e,t[i]);else if("MultiPolygon"===r)for(i=0;i<t.length;i++)for(var o=0;o<t[i].length;o++)U(e,t[i][o]);}(o),o}function U(e,t){for(var r=0;r<t.length;r+=3)e.minX=Math.min(e.minX,t[r]),e.minY=Math.min(e.minY,t[r+1]),e.maxX=Math.max(e.maxX,t[r]),e.maxY=Math.max(e.maxY,t[r+1]);}function $(e,t,r,i){if(t.geometry){var o=t.geometry.coordinates,n=t.geometry.type,s=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),a=[],l=t.id;if(r.promoteId?l=t.properties[r.promoteId]:r.generateId&&(l=i||0),"Point"===n)H(o,a);else if("MultiPoint"===n)for(var u=0;u<o.length;u++)H(o[u],a);else if("LineString"===n)K(o,a,s,!1);else if("MultiLineString"===n){if(r.lineMetrics){for(u=0;u<o.length;u++)K(o[u],a=[],s,!1),e.push(q(l,"LineString",a,t.properties));return}Q(o,a,s,!1);}else if("Polygon"===n)Q(o,a,s,!0);else {if("MultiPolygon"!==n){if("GeometryCollection"===n){for(u=0;u<t.geometry.geometries.length;u++)$(e,{id:l,geometry:t.geometry.geometries[u],properties:t.properties},r,i);return}throw new Error("Input data is not a valid GeoJSON object.")}for(u=0;u<o.length;u++){var h=[];Q(o[u],h,s,!0),a.push(h);}}e.push(q(l,n,a,t.properties));}}function H(e,t){t.push(ee(e[0])),t.push(te(e[1])),t.push(0);}function K(e,t,r,i){for(var o,n,s=0,a=0;a<e.length;a++){var l=ee(e[a][0]),u=te(e[a][1]);t.push(l),t.push(u),t.push(0),a>0&&(s+=i?(o*u-l*n)/2:Math.sqrt(Math.pow(l-o,2)+Math.pow(u-n,2))),o=l,n=u;}var h=t.length-3;t[2]=1,function e(t,r,i,o){for(var n,s=o,a=i-r>>1,l=i-r,u=t[r],h=t[r+1],c=t[i],p=t[i+1],f=r+3;f<i;f+=3){var d=R(t[f],t[f+1],u,h,c,p);if(d>s)n=f,s=d;else if(d===s){var g=Math.abs(f-a);g<l&&(n=f,l=g);}}s>o&&(n-r>3&&e(t,r,n,o),t[n+2]=s,i-n>3&&e(t,n,i,o));}(t,0,h,r),t[h+2]=1,t.size=Math.abs(s),t.start=0,t.end=t.size;}function Q(e,t,r,i){for(var o=0;o<e.length;o++){var n=[];K(e[o],n,r,i),t.push(n);}}function ee(e){return e/360+.5}function te(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function re(e,t,r,i,o,n,s,a){if(i/=t,n>=(r/=t)&&s<i)return e;if(s<r||n>=i)return null;for(var l=[],u=0;u<e.length;u++){var h=e[u],c=h.geometry,p=h.type,f=0===o?h.minX:h.minY,d=0===o?h.maxX:h.maxY;if(f>=r&&d<i)l.push(h);else if(!(d<r||f>=i)){var g=[];if("Point"===p||"MultiPoint"===p)ie(c,g,r,i,o);else if("LineString"===p)oe(c,g,r,i,o,!1,a.lineMetrics);else if("MultiLineString"===p)se(c,g,r,i,o,!1);else if("Polygon"===p)se(c,g,r,i,o,!0);else if("MultiPolygon"===p)for(var v=0;v<c.length;v++){var m=[];se(c[v],m,r,i,o,!0),m.length&&g.push(m);}if(g.length){if(a.lineMetrics&&"LineString"===p){for(v=0;v<g.length;v++)l.push(q(h.id,p,g[v],h.tags));continue}"LineString"!==p&&"MultiLineString"!==p||(1===g.length?(p="LineString",g=g[0]):p="MultiLineString"),"Point"!==p&&"MultiPoint"!==p||(p=3===g.length?"Point":"MultiPoint"),l.push(q(h.id,p,g,h.tags));}}}return l.length?l:null}function ie(e,t,r,i,o){for(var n=0;n<e.length;n+=3){var s=e[n+o];s>=r&&s<=i&&(t.push(e[n]),t.push(e[n+1]),t.push(e[n+2]));}}function oe(e,t,r,i,o,n,s){for(var a,l,u=ne(e),h=0===o?le:ue,c=e.start,p=0;p<e.length-3;p+=3){var f=e[p],d=e[p+1],g=e[p+2],v=e[p+3],m=e[p+4],y=0===o?f:d,x=0===o?v:m,w=!1;s&&(a=Math.sqrt(Math.pow(f-v,2)+Math.pow(d-m,2))),y<r?x>r&&(l=h(u,f,d,v,m,r),s&&(u.start=c+a*l)):y>i?x<i&&(l=h(u,f,d,v,m,i),s&&(u.start=c+a*l)):ae(u,f,d,g),x<r&&y>=r&&(l=h(u,f,d,v,m,r),w=!0),x>i&&y<=i&&(l=h(u,f,d,v,m,i),w=!0),!n&&w&&(s&&(u.end=c+a*l),t.push(u),u=ne(e)),s&&(c+=a);}var S=e.length-3;f=e[S],d=e[S+1],g=e[S+2],(y=0===o?f:d)>=r&&y<=i&&ae(u,f,d,g),S=u.length-3,n&&S>=3&&(u[S]!==u[0]||u[S+1]!==u[1])&&ae(u,u[0],u[1],u[2]),u.length&&t.push(u);}function ne(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function se(e,t,r,i,o,n){for(var s=0;s<e.length;s++)oe(e[s],t,r,i,o,n,!1);}function ae(e,t,r,i){e.push(t),e.push(r),e.push(i);}function le(e,t,r,i,o,n){var s=(n-t)/(i-t);return e.push(n),e.push(r+(o-r)*s),e.push(1),s}function ue(e,t,r,i,o,n){var s=(n-r)/(o-r);return e.push(t+(i-t)*s),e.push(n),e.push(1),s}function he(e,t){for(var r=[],i=0;i<e.length;i++){var o,n=e[i],s=n.type;if("Point"===s||"MultiPoint"===s||"LineString"===s)o=ce(n.geometry,t);else if("MultiLineString"===s||"Polygon"===s){o=[];for(var a=0;a<n.geometry.length;a++)o.push(ce(n.geometry[a],t));}else if("MultiPolygon"===s)for(o=[],a=0;a<n.geometry.length;a++){for(var l=[],u=0;u<n.geometry[a].length;u++)l.push(ce(n.geometry[a][u],t));o.push(l);}r.push(q(n.id,s,o,n.tags));}return r}function ce(e,t){var r=[];r.size=e.size,void 0!==e.start&&(r.start=e.start,r.end=e.end);for(var i=0;i<e.length;i+=3)r.push(e[i]+t,e[i+1],e[i+2]);return r}function pe(e,t){if(e.transformed)return e;var r,i,o,n=1<<e.z,s=e.x,a=e.y;for(r=0;r<e.features.length;r++){var l=e.features[r],u=l.geometry,h=l.type;if(l.geometry=[],1===h)for(i=0;i<u.length;i+=2)l.geometry.push(fe(u[i],u[i+1],t,n,s,a));else for(i=0;i<u.length;i++){var c=[];for(o=0;o<u[i].length;o+=2)c.push(fe(u[i][o],u[i][o+1],t,n,s,a));l.geometry.push(c);}}return e.transformed=!0,e}function fe(e,t,r,i,o,n){return [Math.round(r*(e*i-o)),Math.round(r*(t*i-n))]}function de(e,t,r,i,o){for(var n=t===o.maxZoom?0:o.tolerance/((1<<t)*o.extent),s={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:i,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},a=0;a<e.length;a++){s.numFeatures++,ge(s,e[a],n,o);var l=e[a].minX,u=e[a].minY,h=e[a].maxX,c=e[a].maxY;l<s.minX&&(s.minX=l),u<s.minY&&(s.minY=u),h>s.maxX&&(s.maxX=h),c>s.maxY&&(s.maxY=c);}return s}function ge(e,t,r,i){var o=t.geometry,n=t.type,s=[];if("Point"===n||"MultiPoint"===n)for(var a=0;a<o.length;a+=3)s.push(o[a]),s.push(o[a+1]),e.numPoints++,e.numSimplified++;else if("LineString"===n)ve(s,o,e,r,!1,!1);else if("MultiLineString"===n||"Polygon"===n)for(a=0;a<o.length;a++)ve(s,o[a],e,r,"Polygon"===n,0===a);else if("MultiPolygon"===n)for(var l=0;l<o.length;l++){var u=o[l];for(a=0;a<u.length;a++)ve(s,u[a],e,r,!0,0===a);}if(s.length){var h=t.tags||null;if("LineString"===n&&i.lineMetrics){for(var c in h={},t.tags)h[c]=t.tags[c];h.mapbox_clip_start=o.start/o.size,h.mapbox_clip_end=o.end/o.size;}var p={geometry:s,type:"Polygon"===n||"MultiPolygon"===n?3:"LineString"===n||"MultiLineString"===n?2:1,tags:h};null!==t.id&&(p.id=t.id),e.features.push(p);}}function ve(e,t,r,i,o,n){var s=i*i;if(i>0&&t.size<(o?s:i))r.numPoints+=t.length/3;else {for(var a=[],l=0;l<t.length;l+=3)(0===i||t[l+2]>s)&&(r.numSimplified++,a.push(t[l]),a.push(t[l+1])),r.numPoints++;o&&function(e,t){for(var r=0,i=0,o=e.length,n=o-2;i<o;n=i,i+=2)r+=(e[i]-e[n])*(e[i+1]+e[n+1]);if(r>0===t)for(i=0,o=e.length;i<o/2;i+=2){var s=e[i],a=e[i+1];e[i]=e[o-2-i],e[i+1]=e[o-1-i],e[o-2-i]=s,e[o-1-i]=a;}}(a,n),e.push(a);}}function me(e,t){var r=(t=this.options=function(e,t){for(var r in t)e[r]=t[r];return e}(Object.create(this.options),t)).debug;if(r&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var i=function(e,t){var r=[];if("FeatureCollection"===e.type)for(var i=0;i<e.features.length;i++)$(r,e.features[i],t,i);else $(r,"Feature"===e.type?e:{geometry:e},t);return r}(e,t);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),(i=function(e,t){var r=t.buffer/t.extent,i=e,o=re(e,1,-1-r,r,0,-1,2,t),n=re(e,1,1-r,2+r,0,-1,2,t);return (o||n)&&(i=re(e,1,-r,1+r,0,-1,2,t)||[],o&&(i=he(o,1).concat(i)),n&&(i=i.concat(he(n,-1)))),i}(i,t)).length&&this.splitTile(i,0,0,0),r&&(i.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)));}function ye(e,t,r){return 32*((1<<e)*r+t)+e}function xe(e,t){var r=e.tileID.canonical;if(!this._geoJSONIndex)return t(null,null);var i=this._geoJSONIndex.getTile(r.z,r.x,r.y);if(!i)return t(null,null);var o=new g(i.features),n=w(o);0===n.byteOffset&&n.byteLength===n.buffer.byteLength||(n=new Uint8Array(n)),t(null,{vectorTile:o,rawData:n.buffer});}J.prototype.load=function(e){var t=this.options,r=t.log,i=t.minZoom,o=t.maxZoom,n=t.nodeSize;r&&console.time("total time");var s="prepare "+e.length+" points";r&&console.time(s),this.points=e;for(var a=[],l=0;l<e.length;l++)e[l].geometry&&a.push(A(e[l],l));this.trees[o+1]=new F(a,X,W,n,Float32Array),r&&console.timeEnd(s);for(var u=o;u>=i;u--){var h=+Date.now();a=this._cluster(a,u),this.trees[u]=new F(a,X,W,n,Float32Array),r&&console.log("z%d: %d clusters in %dms",u,a.length,+Date.now()-h);}return r&&console.timeEnd("total time"),this},J.prototype.getClusters=function(e,t){var r=((e[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,e[1])),o=180===e[2]?180:((e[2]+180)%360+360)%360-180,n=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)r=-180,o=180;else if(r>o){var s=this.getClusters([r,i,180,n],t),a=this.getClusters([-180,i,o,n],t);return s.concat(a)}for(var l=this.trees[this._limitZoom(t)],u=[],h=0,c=l.range(Y(r),j(n),Y(o),j(i));h<c.length;h+=1){var p=l.points[c[h]];u.push(p.numPoints?B(p):this.points[p.index]);}return u},J.prototype.getChildren=function(e){var t=this._getOriginId(e),r=this._getOriginZoom(e),i="No cluster with the specified id.",o=this.trees[r];if(!o)throw new Error(i);var n=o.points[t];if(!n)throw new Error(i);for(var s=this.options.radius/(this.options.extent*Math.pow(2,r-1)),a=[],l=0,u=o.within(n.x,n.y,s);l<u.length;l+=1){var h=o.points[u[l]];h.parentId===e&&a.push(h.numPoints?B(h):this.points[h.index]);}if(0===a.length)throw new Error(i);return a},J.prototype.getLeaves=function(e,t,r){var i=[];return this._appendLeaves(i,e,t=t||10,r=r||0,0),i},J.prototype.getTile=function(e,t,r){var i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),n=this.options,s=n.radius/n.extent,a=(r-s)/o,l=(r+1+s)/o,u={features:[]};return this._addTileFeatures(i.range((t-s)/o,a,(t+1+s)/o,l),i.points,t,r,o,u),0===t&&this._addTileFeatures(i.range(1-s/o,a,1,l),i.points,o,r,o,u),t===o-1&&this._addTileFeatures(i.range(0,a,s/o,l),i.points,-1,r,o,u),u.features.length?u:null},J.prototype.getClusterExpansionZoom=function(e){for(var t=this._getOriginZoom(e)-1;t<=this.options.maxZoom;){var r=this.getChildren(e);if(t++,1!==r.length)break;e=r[0].properties.cluster_id;}return t},J.prototype._appendLeaves=function(e,t,r,i,o){for(var n=0,s=this.getChildren(t);n<s.length;n+=1){var a=s[n],l=a.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(e,l.cluster_id,r,i,o):o<i?o++:e.push(a),e.length===r)break}return o},J.prototype._addTileFeatures=function(e,t,r,i,o,n){for(var s=0,a=e;s<a.length;s+=1){var l=t[a[s]],u=l.numPoints,h={type:1,geometry:[[Math.round(this.options.extent*(l.x*o-r)),Math.round(this.options.extent*(l.y*o-i))]],tags:u?G(l):this.points[l.index].properties},c=void 0;u?c=l.id:this.options.generateId?c=l.index:this.points[l.index].id&&(c=this.points[l.index].id),void 0!==c&&(h.id=c),n.features.push(h);}},J.prototype._limitZoom=function(e){return Math.max(this.options.minZoom,Math.min(+e,this.options.maxZoom+1))},J.prototype._cluster=function(e,t){for(var r=[],i=this.options,o=i.reduce,n=i.minPoints,s=i.radius/(i.extent*Math.pow(2,t)),a=0;a<e.length;a++){var l=e[a];if(!(l.zoom<=t)){l.zoom=t;for(var u=this.trees[t+1],h=u.within(l.x,l.y,s),c=l.numPoints||1,p=c,f=0,d=h;f<d.length;f+=1){var g=u.points[d[f]];g.zoom>t&&(p+=g.numPoints||1);}if(p>=n){for(var v=l.x*c,m=l.y*c,y=o&&c>1?this._map(l,!0):null,x=(a<<5)+(t+1)+this.points.length,w=0,S=h;w<S.length;w+=1){var I=u.points[S[w]];if(!(I.zoom<=t)){I.zoom=t;var M=I.numPoints||1;v+=I.x*M,m+=I.y*M,I.parentId=x,o&&(y||(y=this._map(l,!0)),o(y,this._map(I)));}}l.parentId=x,r.push(Z(v/p,m/p,x,p,y));}else if(r.push(l),p>1)for(var b=0,_=h;b<_.length;b+=1){var k=u.points[_[b]];k.zoom<=t||(k.zoom=t,r.push(k));}}}return r},J.prototype._getOriginId=function(e){return e-this.points.length>>5},J.prototype._getOriginZoom=function(e){return (e-this.points.length)%32},J.prototype._map=function(e,t){if(e.numPoints)return t?V({},e.properties):e.properties;var r=this.points[e.index].properties,i=this.options.map(r);return t&&i===r?V({},i):i},me.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0},me.prototype.splitTile=function(e,t,r,i,o,n,s){for(var a=[e,t,r,i],l=this.options,u=l.debug;a.length;){i=a.pop(),r=a.pop(),t=a.pop(),e=a.pop();var h=1<<t,c=ye(t,r,i),p=this.tiles[c];if(!p&&(u>1&&console.time("creation"),p=this.tiles[c]=de(e,t,r,i,l),this.tileCoords.push({z:t,x:r,y:i}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,r,i,p.numFeatures,p.numPoints,p.numSimplified),console.timeEnd("creation"));var f="z"+t;this.stats[f]=(this.stats[f]||0)+1,this.total++;}if(p.source=e,o){if(t===l.maxZoom||t===o)continue;var d=1<<o-t;if(r!==Math.floor(n/d)||i!==Math.floor(s/d))continue}else if(t===l.indexMaxZoom||p.numPoints<=l.indexMaxPoints)continue;if(p.source=null,0!==e.length){u>1&&console.time("clipping");var g,v,m,y,x,w,S=.5*l.buffer/l.extent,I=.5-S,M=.5+S,b=1+S;g=v=m=y=null,x=re(e,h,r-S,r+M,0,p.minX,p.maxX,l),w=re(e,h,r+I,r+b,0,p.minX,p.maxX,l),e=null,x&&(g=re(x,h,i-S,i+M,1,p.minY,p.maxY,l),v=re(x,h,i+I,i+b,1,p.minY,p.maxY,l),x=null),w&&(m=re(w,h,i-S,i+M,1,p.minY,p.maxY,l),y=re(w,h,i+I,i+b,1,p.minY,p.maxY,l),w=null),u>1&&console.timeEnd("clipping"),a.push(g||[],t+1,2*r,2*i),a.push(v||[],t+1,2*r,2*i+1),a.push(m||[],t+1,2*r+1,2*i),a.push(y||[],t+1,2*r+1,2*i+1);}}},me.prototype.getTile=function(e,t,r){var i=this.options,o=i.extent,n=i.debug;if(e<0||e>24)return null;var s=1<<e,a=ye(e,t=(t%s+s)%s,r);if(this.tiles[a])return pe(this.tiles[a],o);n>1&&console.log("drilling down to z%d-%d-%d",e,t,r);for(var l,u=e,h=t,c=r;!l&&u>0;)u--,h=Math.floor(h/2),c=Math.floor(c/2),l=this.tiles[ye(u,h,c)];return l&&l.source?(n>1&&console.log("found parent tile z%d-%d-%d",u,h,c),n>1&&console.time("drilling down"),this.splitTile(l.source,u,h,c,e,t,r),n>1&&console.timeEnd("drilling down"),this.tiles[a]?pe(this.tiles[a],o):null):null};var we=function(t){function r(e,r,i,o){t.call(this,e,r,i,xe),o&&(this.loadGeoJSON=o);}return t&&(r.__proto__=t),(r.prototype=Object.create(t&&t.prototype)).constructor=r,r.prototype.loadData=function(e,t){this._pendingCallback&&this._pendingCallback(null,{abandoned:!0}),this._pendingCallback=t,this._pendingLoadDataParams=e,this._state&&"Idle"!==this._state?this._state="NeedsLoadData":(this._state="Coalescing",this._loadData());},r.prototype._loadData=function(){var t=this;if(this._pendingCallback&&this._pendingLoadDataParams){var r=this._pendingCallback,i=this._pendingLoadDataParams;delete this._pendingCallback,delete this._pendingLoadDataParams;var o=!!(i&&i.request&&i.request.collectResourceTiming)&&new e.RequestPerformance(i.request);this.loadGeoJSON(i,(function(n,s){if(n||!s)return r(n);if("object"!=typeof s)return r(new Error("Input data given to '"+i.source+"' is not a valid GeoJSON object."));!function e(t,r){var i,o=t&&t.type;if("FeatureCollection"===o)for(i=0;i<t.features.length;i++)e(t.features[i],r);else if("GeometryCollection"===o)for(i=0;i<t.geometries.length;i++)e(t.geometries[i],r);else if("Feature"===o)e(t.geometry,r);else if("Polygon"===o)c(t.coordinates,r);else if("MultiPolygon"===o)for(i=0;i<t.coordinates.length;i++)c(t.coordinates[i],r);return t}(s,!0);try{if(i.filter){var a=e.createExpression(i.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if("error"===a.result)throw new Error(a.value.map((function(e){return e.key+": "+e.message})).join(", "));var l=s.features.filter((function(e){return a.value.evaluate({zoom:0},e)}));s={type:"FeatureCollection",features:l};}t._geoJSONIndex=i.cluster?new J(function(t){var r=t.superclusterOptions,i=t.clusterProperties;if(!i||!r)return r;for(var o={},n={},s={accumulated:null,zoom:0},a={properties:null},l=Object.keys(i),u=0,h=l;u<h.length;u+=1){var c=h[u],p=i[c],f=p[0],d=e.createExpression(p[1]),g=e.createExpression("string"==typeof f?[f,["accumulated"],["get",c]]:f);o[c]=d.value,n[c]=g.value;}return r.map=function(e){a.properties=e;for(var t={},r=0,i=l;r<i.length;r+=1){var n=i[r];t[n]=o[n].evaluate(s,a);}return t},r.reduce=function(e,t){a.properties=t;for(var r=0,i=l;r<i.length;r+=1){var o=i[r];s.accumulated=e[o],e[o]=n[o].evaluate(s,a);}},r}(i)).load(s.features):function(e,t){return new me(e,t)}(s,i.geojsonVtOptions);}catch(n){return r(n)}t.loaded={};var u={};if(o){var h=o.finish();h&&(u.resourceTiming={},u.resourceTiming[i.source]=JSON.parse(JSON.stringify(h)));}r(null,u);}));}},r.prototype.coalesce=function(){"Coalescing"===this._state?this._state="Idle":"NeedsLoadData"===this._state&&(this._state="Coalescing",this._loadData());},r.prototype.reloadTile=function(e,r){var i=this.loaded;return i&&i[e.uid]?t.prototype.reloadTile.call(this,e,r):this.loadTile(e,r)},r.prototype.loadGeoJSON=function(t,r){if(t.request)e.getJSON(t.request,r);else {if("string"!=typeof t.data)return r(new Error("Input data given to '"+t.source+"' is not a valid GeoJSON object."));try{return r(null,JSON.parse(t.data))}catch(e){return r(new Error("Input data given to '"+t.source+"' is not a valid GeoJSON object."))}}},r.prototype.removeSource=function(e,t){this._pendingCallback&&this._pendingCallback(null,{abandoned:!0}),t();},r.prototype.getClusterExpansionZoom=function(e,t){try{t(null,this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));}catch(e){t(e);}},r.prototype.getClusterChildren=function(e,t){try{t(null,this._geoJSONIndex.getChildren(e.clusterId));}catch(e){t(e);}},r.prototype.getClusterLeaves=function(e,t){try{t(null,this._geoJSONIndex.getLeaves(e.clusterId,e.limit,e.offset));}catch(e){t(e);}},r}(l),Se=function(t){var r=this;this.self=t,this.actor=new e.Actor(t,this),this.layerIndexes={},this.availableImages={},this.workerSourceTypes={vector:l,geojson:we},this.workerSources={},this.demWorkerSources={},this.self.registerWorkerSource=function(e,t){if(r.workerSourceTypes[e])throw new Error('Worker source with name "'+e+'" already registered.');r.workerSourceTypes[e]=t;},this.self.registerRTLTextPlugin=function(t){if(e.plugin.isParsed())throw new Error("RTL text plugin already registered.");e.plugin.applyArabicShaping=t.applyArabicShaping,e.plugin.processBidirectionalText=t.processBidirectionalText,e.plugin.processStyledBidirectionalText=t.processStyledBidirectionalText;};};return Se.prototype.setReferrer=function(e,t){this.referrer=t;},Se.prototype.setImages=function(e,t,r){for(var i in this.availableImages[e]=t,this.workerSources[e]){var o=this.workerSources[e][i];for(var n in o)o[n].availableImages=t;}r();},Se.prototype.setLayers=function(e,t,r){this.getLayerIndex(e).replace(t),r();},Se.prototype.updateLayers=function(e,t,r){this.getLayerIndex(e).update(t.layers,t.removedIds),r();},Se.prototype.loadTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).loadTile(t,r);},Se.prototype.loadDEMTile=function(e,t,r){this.getDEMWorkerSource(e,t.source).loadTile(t,r);},Se.prototype.reloadTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).reloadTile(t,r);},Se.prototype.abortTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).abortTile(t,r);},Se.prototype.removeTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).removeTile(t,r);},Se.prototype.removeDEMTile=function(e,t){this.getDEMWorkerSource(e,t.source).removeTile(t);},Se.prototype.removeSource=function(e,t,r){if(this.workerSources[e]&&this.workerSources[e][t.type]&&this.workerSources[e][t.type][t.source]){var i=this.workerSources[e][t.type][t.source];delete this.workerSources[e][t.type][t.source],void 0!==i.removeSource?i.removeSource(t,r):r();}},Se.prototype.loadWorkerSource=function(e,t,r){try{this.self.importScripts(t.url),r();}catch(e){r(e.toString());}},Se.prototype.syncRTLPluginState=function(t,r,i){try{e.plugin.setState(r);var o=e.plugin.getPluginURL();if(e.plugin.isLoaded()&&!e.plugin.isParsed()&&null!=o){this.self.importScripts(o);var n=e.plugin.isParsed();i(n?void 0:new Error("RTL Text Plugin failed to import scripts from "+o),n);}}catch(e){i(e.toString());}},Se.prototype.getAvailableImages=function(e){var t=this.availableImages[e];return t||(t=[]),t},Se.prototype.getLayerIndex=function(e){var t=this.layerIndexes[e];return t||(t=this.layerIndexes[e]=new i),t},Se.prototype.getWorkerSource=function(e,t,r){var i=this;return this.workerSources[e]||(this.workerSources[e]={}),this.workerSources[e][t]||(this.workerSources[e][t]={}),this.workerSources[e][t][r]||(this.workerSources[e][t][r]=new this.workerSourceTypes[t]({send:function(t,r,o){i.actor.send(t,r,o,e);}},this.getLayerIndex(e),this.getAvailableImages(e))),this.workerSources[e][t][r]},Se.prototype.getDEMWorkerSource=function(e,t){return this.demWorkerSources[e]||(this.demWorkerSources[e]={}),this.demWorkerSources[e][t]||(this.demWorkerSources[e][t]=new h),this.demWorkerSources[e][t]},Se.prototype.enforceCacheSizeLimit=function(t,r){e.enforceCacheSizeLimit(r);},"undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope&&(self.worker=new Se(self)),Se}));

    define(["./shared"],(function(t){var e=t.createCommonjsModule((function(t){function e(t){return !i(t)}function i(t){return "undefined"==typeof window||"undefined"==typeof document?"not a browser":Array.prototype&&Array.prototype.every&&Array.prototype.filter&&Array.prototype.forEach&&Array.prototype.indexOf&&Array.prototype.lastIndexOf&&Array.prototype.map&&Array.prototype.some&&Array.prototype.reduce&&Array.prototype.reduceRight&&Array.isArray?Function.prototype&&Function.prototype.bind?Object.keys&&Object.create&&Object.getPrototypeOf&&Object.getOwnPropertyNames&&Object.isSealed&&Object.isFrozen&&Object.isExtensible&&Object.getOwnPropertyDescriptor&&Object.defineProperty&&Object.defineProperties&&Object.seal&&Object.freeze&&Object.preventExtensions?"JSON"in window&&"parse"in JSON&&"stringify"in JSON?function(){if(!("Worker"in window&&"Blob"in window&&"URL"in window))return !1;var t,e,i=new Blob([""],{type:"text/javascript"}),o=URL.createObjectURL(i);try{e=new Worker(o),t=!0;}catch(e){t=!1;}return e&&e.terminate(),URL.revokeObjectURL(o),t}()?"Uint8ClampedArray"in window?ArrayBuffer.isView?function(){var t=document.createElement("canvas");t.width=t.height=1;var e=t.getContext("2d");if(!e)return !1;var i=e.getImageData(0,0,1,1);return i&&i.width===t.width}()?(void 0===o[i=t&&t.failIfMajorPerformanceCaveat]&&(o[i]=function(t){var i=function(t){var i=document.createElement("canvas"),o=Object.create(e.webGLContextAttributes);return o.failIfMajorPerformanceCaveat=t,i.probablySupportsContext?i.probablySupportsContext("webgl",o)||i.probablySupportsContext("experimental-webgl",o):i.supportsContext?i.supportsContext("webgl",o)||i.supportsContext("experimental-webgl",o):i.getContext("webgl",o)||i.getContext("experimental-webgl",o)}(t);if(!i)return !1;var o=i.createShader(i.VERTEX_SHADER);return !(!o||i.isContextLost())&&(i.shaderSource(o,"void main() {}"),i.compileShader(o),!0===i.getShaderParameter(o,i.COMPILE_STATUS))}(i)),o[i]?void 0:"insufficient WebGL support"):"insufficient Canvas/getImageData support":"insufficient ArrayBuffer support":"insufficient Uint8ClampedArray support":"insufficient worker support":"insufficient JSON support":"insufficient Object support":"insufficient Function support":"insufficent Array support";var i;}t.exports?t.exports=e:window&&(window.mapboxgl=window.mapboxgl||{},window.mapboxgl.supported=e,window.mapboxgl.notSupportedReason=i);var o={};e.webGLContextAttributes={antialias:!1,alpha:!0,stencil:!0,depth:!0};})),i={create:function(e,i,o){var r=t.window.document.createElement(e);return void 0!==i&&(r.className=i),o&&o.appendChild(r),r},createNS:function(e,i){return t.window.document.createElementNS(e,i)}},o=t.window.document&&t.window.document.documentElement.style;function r(t){if(!o)return t[0];for(var e=0;e<t.length;e++)if(t[e]in o)return t[e];return t[0]}var a,n=r(["userSelect","MozUserSelect","WebkitUserSelect","msUserSelect"]);i.disableDrag=function(){o&&n&&(a=o[n],o[n]="none");},i.enableDrag=function(){o&&n&&(o[n]=a);};var s=r(["transform","WebkitTransform"]);i.setTransform=function(t,e){t.style[s]=e;};var l=!1;try{var c=Object.defineProperty({},"passive",{get:function(){l=!0;}});t.window.addEventListener("test",c,c),t.window.removeEventListener("test",c,c);}catch(t){l=!1;}i.addEventListener=function(t,e,i,o){void 0===o&&(o={}),t.addEventListener(e,i,"passive"in o&&l?o:o.capture);},i.removeEventListener=function(t,e,i,o){void 0===o&&(o={}),t.removeEventListener(e,i,"passive"in o&&l?o:o.capture);};var u=function(e){e.preventDefault(),e.stopPropagation(),t.window.removeEventListener("click",u,!0);};function h(t){var e=t.userImage;return !!(e&&e.render&&e.render())&&(t.data.replace(new Uint8Array(e.data.buffer)),!0)}i.suppressClick=function(){t.window.addEventListener("click",u,!0),t.window.setTimeout((function(){t.window.removeEventListener("click",u,!0);}),0);},i.mousePos=function(e,i){var o=e.getBoundingClientRect();return new t.Point(i.clientX-o.left-e.clientLeft,i.clientY-o.top-e.clientTop)},i.touchPos=function(e,i){for(var o=e.getBoundingClientRect(),r=[],a=0;a<i.length;a++)r.push(new t.Point(i[a].clientX-o.left-e.clientLeft,i[a].clientY-o.top-e.clientTop));return r},i.mouseButton=function(e){return void 0!==t.window.InstallTrigger&&2===e.button&&e.ctrlKey&&t.window.navigator.platform.toUpperCase().indexOf("MAC")>=0?0:e.button},i.remove=function(t){t.parentNode&&t.parentNode.removeChild(t);};var p=function(e){function i(){e.call(this),this.images={},this.updatedImages={},this.callbackDispatchedThisFrame={},this.loaded=!1,this.requestors=[],this.patterns={},this.atlasImage=new t.RGBAImage({width:1,height:1}),this.dirty=!0;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.isLoaded=function(){return this.loaded},i.prototype.setLoaded=function(t){if(this.loaded!==t&&(this.loaded=t,t)){for(var e=0,i=this.requestors;e<i.length;e+=1){var o=i[e];this._notify(o.ids,o.callback);}this.requestors=[];}},i.prototype.getImage=function(t){return this.images[t]},i.prototype.addImage=function(t,e){this._validate(t,e)&&(this.images[t]=e);},i.prototype._validate=function(e,i){var o=!0;return this._validateStretch(i.stretchX,i.data&&i.data.width)||(this.fire(new t.ErrorEvent(new Error('Image "'+e+'" has invalid "stretchX" value'))),o=!1),this._validateStretch(i.stretchY,i.data&&i.data.height)||(this.fire(new t.ErrorEvent(new Error('Image "'+e+'" has invalid "stretchY" value'))),o=!1),this._validateContent(i.content,i)||(this.fire(new t.ErrorEvent(new Error('Image "'+e+'" has invalid "content" value'))),o=!1),o},i.prototype._validateStretch=function(t,e){if(!t)return !0;for(var i=0,o=0,r=t;o<r.length;o+=1){var a=r[o];if(a[0]<i||a[1]<a[0]||e<a[1])return !1;i=a[1];}return !0},i.prototype._validateContent=function(t,e){return !(t&&(4!==t.length||t[0]<0||e.data.width<t[0]||t[1]<0||e.data.height<t[1]||t[2]<0||e.data.width<t[2]||t[3]<0||e.data.height<t[3]||t[2]<t[0]||t[3]<t[1]))},i.prototype.updateImage=function(t,e){e.version=this.images[t].version+1,this.images[t]=e,this.updatedImages[t]=!0;},i.prototype.removeImage=function(t){var e=this.images[t];delete this.images[t],delete this.patterns[t],e.userImage&&e.userImage.onRemove&&e.userImage.onRemove();},i.prototype.listImages=function(){return Object.keys(this.images)},i.prototype.getImages=function(t,e){var i=!0;if(!this.isLoaded())for(var o=0,r=t;o<r.length;o+=1)this.images[r[o]]||(i=!1);this.isLoaded()||i?this._notify(t,e):this.requestors.push({ids:t,callback:e});},i.prototype._notify=function(e,i){for(var o={},r=0,a=e;r<a.length;r+=1){var n=a[r];this.images[n]||this.fire(new t.Event("styleimagemissing",{id:n}));var s=this.images[n];s?o[n]={data:s.data.clone(),pixelRatio:s.pixelRatio,sdf:s.sdf,version:s.version,stretchX:s.stretchX,stretchY:s.stretchY,content:s.content,hasRenderCallback:Boolean(s.userImage&&s.userImage.render)}:t.warnOnce('Image "'+n+'" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');}i(null,o);},i.prototype.getPixelSize=function(){var t=this.atlasImage;return {width:t.width,height:t.height}},i.prototype.getPattern=function(e){var i=this.patterns[e],o=this.getImage(e);if(!o)return null;if(i&&i.position.version===o.version)return i.position;if(i)i.position.version=o.version;else {var r={w:o.data.width+2,h:o.data.height+2,x:0,y:0},a=new t.ImagePosition(r,o);this.patterns[e]={bin:r,position:a};}return this._updatePatternAtlas(),this.patterns[e].position},i.prototype.bind=function(e){var i=e.gl;this.atlasTexture?this.dirty&&(this.atlasTexture.update(this.atlasImage),this.dirty=!1):this.atlasTexture=new t.Texture(e,this.atlasImage,i.RGBA),this.atlasTexture.bind(i.LINEAR,i.CLAMP_TO_EDGE);},i.prototype._updatePatternAtlas=function(){var e=[];for(var i in this.patterns)e.push(this.patterns[i].bin);var o=t.potpack(e),r=o.w,a=o.h,n=this.atlasImage;for(var s in n.resize({width:r||1,height:a||1}),this.patterns){var l=this.patterns[s].bin,c=l.x+1,u=l.y+1,h=this.images[s].data,p=h.width,d=h.height;t.RGBAImage.copy(h,n,{x:0,y:0},{x:c,y:u},{width:p,height:d}),t.RGBAImage.copy(h,n,{x:0,y:d-1},{x:c,y:u-1},{width:p,height:1}),t.RGBAImage.copy(h,n,{x:0,y:0},{x:c,y:u+d},{width:p,height:1}),t.RGBAImage.copy(h,n,{x:p-1,y:0},{x:c-1,y:u},{width:1,height:d}),t.RGBAImage.copy(h,n,{x:0,y:0},{x:c+p,y:u},{width:1,height:d});}this.dirty=!0;},i.prototype.beginFrame=function(){this.callbackDispatchedThisFrame={};},i.prototype.dispatchRenderCallbacks=function(t){for(var e=0,i=t;e<i.length;e+=1){var o=i[e];if(!this.callbackDispatchedThisFrame[o]){this.callbackDispatchedThisFrame[o]=!0;var r=this.images[o];h(r)&&this.updateImage(o,r);}}},i}(t.Evented),d=m,_=m,f=1e20;function m(t,e,i,o,r,a){this.fontSize=t||24,this.buffer=void 0===e?3:e,this.cutoff=o||.25,this.fontFamily=r||"sans-serif",this.fontWeight=a||"normal",this.radius=i||8;var n=this.size=this.fontSize+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=n,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(n*n),this.gridInner=new Float64Array(n*n),this.f=new Float64Array(n),this.d=new Float64Array(n),this.z=new Float64Array(n+1),this.v=new Int16Array(n),this.middle=Math.round(n/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1));}function g(t,e,i,o,r,a,n){for(var s=0;s<e;s++){for(var l=0;l<i;l++)o[l]=t[l*e+s];for(v(o,r,a,n,i),l=0;l<i;l++)t[l*e+s]=r[l];}for(l=0;l<i;l++){for(s=0;s<e;s++)o[s]=t[l*e+s];for(v(o,r,a,n,e),s=0;s<e;s++)t[l*e+s]=Math.sqrt(r[s]);}}function v(t,e,i,o,r){i[0]=0,o[0]=-f,o[1]=+f;for(var a=1,n=0;a<r;a++){for(var s=(t[a]+a*a-(t[i[n]]+i[n]*i[n]))/(2*a-2*i[n]);s<=o[n];)n--,s=(t[a]+a*a-(t[i[n]]+i[n]*i[n]))/(2*a-2*i[n]);i[++n]=a,o[n]=s,o[n+1]=+f;}for(a=0,n=0;a<r;a++){for(;o[n+1]<a;)n++;e[a]=(a-i[n])*(a-i[n])+t[i[n]];}}m.prototype.draw=function(t){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.fillText(t,this.buffer,this.middle);for(var e=this.ctx.getImageData(0,0,this.size,this.size),i=new Uint8ClampedArray(this.size*this.size),o=0;o<this.size*this.size;o++){var r=e.data[4*o+3]/255;this.gridOuter[o]=1===r?0:0===r?f:Math.pow(Math.max(0,.5-r),2),this.gridInner[o]=1===r?f:0===r?0:Math.pow(Math.max(0,r-.5),2);}for(g(this.gridOuter,this.size,this.size,this.f,this.d,this.v,this.z),g(this.gridInner,this.size,this.size,this.f,this.d,this.v,this.z),o=0;o<this.size*this.size;o++)i[o]=Math.max(0,Math.min(255,Math.round(255-255*((this.gridOuter[o]-this.gridInner[o])/this.radius+this.cutoff))));return i},d.default=_;var y=function(t,e){this.requestManager=t,this.localIdeographFontFamily=e,this.entries={};};y.prototype.setURL=function(t){this.url=t;},y.prototype.getGlyphs=function(e,i){var o=this,r=[];for(var a in e)for(var n=0,s=e[a];n<s.length;n+=1)r.push({stack:a,id:s[n]});t.asyncAll(r,(function(t,e){var i=t.stack,r=t.id,a=o.entries[i];a||(a=o.entries[i]={glyphs:{},requests:{},ranges:{}});var n=a.glyphs[r];if(void 0===n){if(n=o._tinySDF(a,i,r))return a.glyphs[r]=n,void e(null,{stack:i,id:r,glyph:n});var s=Math.floor(r/256);if(256*s>65535)e(new Error("glyphs > 65535 not supported"));else if(a.ranges[s])e(null,{stack:i,id:r,glyph:n});else {var l=a.requests[s];l||(l=a.requests[s]=[],y.loadGlyphRange(i,s,o.url,o.requestManager,(function(t,e){if(e){for(var i in e)o._doesCharSupportLocalGlyph(+i)||(a.glyphs[+i]=e[+i]);a.ranges[s]=!0;}for(var r=0,n=l;r<n.length;r+=1)(0, n[r])(t,e);delete a.requests[s];}))),l.push((function(t,o){t?e(t):o&&e(null,{stack:i,id:r,glyph:o[r]||null});}));}}else e(null,{stack:i,id:r,glyph:n});}),(function(t,e){if(t)i(t);else if(e){for(var o={},r=0,a=e;r<a.length;r+=1){var n=a[r],s=n.stack,l=n.id,c=n.glyph;(o[s]||(o[s]={}))[l]=c&&{id:c.id,bitmap:c.bitmap.clone(),metrics:c.metrics};}i(null,o);}}));},y.prototype._doesCharSupportLocalGlyph=function(e){return !!this.localIdeographFontFamily&&(t.isChar["CJK Unified Ideographs"](e)||t.isChar["Hangul Syllables"](e)||t.isChar.Hiragana(e)||t.isChar.Katakana(e))},y.prototype._tinySDF=function(e,i,o){var r=this.localIdeographFontFamily;if(r&&this._doesCharSupportLocalGlyph(o)){var a=e.tinySDF;if(!a){var n="400";/bold/i.test(i)?n="900":/medium/i.test(i)?n="500":/light/i.test(i)&&(n="200"),a=e.tinySDF=new y.TinySDF(24,3,8,.25,r,n);}return {id:o,bitmap:new t.AlphaImage({width:30,height:30},a.draw(String.fromCharCode(o))),metrics:{width:24,height:24,left:0,top:-8,advance:24}}}},y.loadGlyphRange=function(e,i,o,r,a){var n=256*i,s=n+255,l=r.transformRequest(r.normalizeGlyphsURL(o).replace("{fontstack}",e).replace("{range}",n+"-"+s),t.ResourceType.Glyphs);t.getArrayBuffer(l,(function(e,i){if(e)a(e);else if(i){for(var o={},r=0,n=t.parseGlyphPBF(i);r<n.length;r+=1){var s=n[r];o[s.id]=s;}a(null,o);}}));},y.TinySDF=d;var x=function(){this.specification=t.styleSpec.light.position;};x.prototype.possiblyEvaluate=function(e,i){return t.sphericalToCartesian(e.expression.evaluate(i))},x.prototype.interpolate=function(e,i,o){return {x:t.number(e.x,i.x,o),y:t.number(e.y,i.y,o),z:t.number(e.z,i.z,o)}};var b=new t.Properties({anchor:new t.DataConstantProperty(t.styleSpec.light.anchor),position:new x,color:new t.DataConstantProperty(t.styleSpec.light.color),intensity:new t.DataConstantProperty(t.styleSpec.light.intensity)}),w=function(e){function i(i){e.call(this),this._transitionable=new t.Transitionable(b),this.setLight(i),this._transitioning=this._transitionable.untransitioned();}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getLight=function(){return this._transitionable.serialize()},i.prototype.setLight=function(e,i){if(void 0===i&&(i={}),!this._validate(t.validateLight,e,i))for(var o in e){var r=e[o];t.endsWith(o,"-transition")?this._transitionable.setTransition(o.slice(0,-"-transition".length),r):this._transitionable.setValue(o,r);}},i.prototype.updateTransitions=function(t){this._transitioning=this._transitionable.transitioned(t,this._transitioning);},i.prototype.hasTransition=function(){return this._transitioning.hasTransition()},i.prototype.recalculate=function(t){this.properties=this._transitioning.possiblyEvaluate(t);},i.prototype._validate=function(e,i,o){return (!o||!1!==o.validate)&&t.emitValidationErrors(this,e.call(t.validateStyle,t.extend({value:i,style:{glyphs:!0,sprite:!0},styleSpec:t.styleSpec})))},i}(t.Evented),T=function(t,e){this.width=t,this.height=e,this.nextRow=0,this.data=new Uint8Array(this.width*this.height),this.dashEntry={};};T.prototype.getDash=function(t,e){var i=t.join(",")+String(e);return this.dashEntry[i]||(this.dashEntry[i]=this.addDash(t,e)),this.dashEntry[i]},T.prototype.getDashRanges=function(t,e,i){var o=[],r=t.length%2==1?-t[t.length-1]*i:0,a=t[0]*i,n=!0;o.push({left:r,right:a,isDash:n,zeroLength:0===t[0]});for(var s=t[0],l=1;l<t.length;l++){var c=t[l];o.push({left:r=s*i,right:a=(s+=c)*i,isDash:n=!n,zeroLength:0===c});}return o},T.prototype.addRoundDash=function(t,e,i){for(var o=e/2,r=-i;r<=i;r++)for(var a=this.width*(this.nextRow+i+r),n=0,s=t[n],l=0;l<this.width;l++){l/s.right>1&&(s=t[++n]);var c=Math.abs(l-s.left),u=Math.abs(l-s.right),h=Math.min(c,u),p=void 0,d=r/i*(o+1);if(s.isDash){var _=o-Math.abs(d);p=Math.sqrt(h*h+_*_);}else p=o-Math.sqrt(h*h+d*d);this.data[a+l]=Math.max(0,Math.min(255,p+128));}},T.prototype.addRegularDash=function(t){for(var e=t.length-1;e>=0;--e){var i=t[e],o=t[e+1];i.zeroLength?t.splice(e,1):o&&o.isDash===i.isDash&&(o.left=i.left,t.splice(e,1));}var r=t[0],a=t[t.length-1];r.isDash===a.isDash&&(r.left=a.left-this.width,a.right=r.right+this.width);for(var n=this.width*this.nextRow,s=0,l=t[s],c=0;c<this.width;c++){c/l.right>1&&(l=t[++s]);var u=Math.abs(c-l.left),h=Math.abs(c-l.right),p=Math.min(u,h);this.data[n+c]=Math.max(0,Math.min(255,(l.isDash?p:-p)+128));}},T.prototype.addDash=function(e,i){var o=i?7:0,r=2*o+1;if(this.nextRow+r>this.height)return t.warnOnce("LineAtlas out of space"),null;for(var a=0,n=0;n<e.length;n++)a+=e[n];if(0!==a){var s=this.width/a,l=this.getDashRanges(e,this.width,s);i?this.addRoundDash(l,s,o):this.addRegularDash(l);}var c={y:(this.nextRow+o+.5)/this.height,height:2*o/this.height,width:a};return this.nextRow+=r,this.dirty=!0,c},T.prototype.bind=function(t){var e=t.gl;this.texture?(e.bindTexture(e.TEXTURE_2D,this.texture),this.dirty&&(this.dirty=!1,e.texSubImage2D(e.TEXTURE_2D,0,0,0,this.width,this.height,e.ALPHA,e.UNSIGNED_BYTE,this.data))):(this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texImage2D(e.TEXTURE_2D,0,e.ALPHA,this.width,this.height,0,e.ALPHA,e.UNSIGNED_BYTE,this.data));};var E=function e(i,o){this.workerPool=i,this.actors=[],this.currentActor=0,this.id=t.uniqueId();for(var r=this.workerPool.acquire(this.id),a=0;a<r.length;a++){var n=new e.Actor(r[a],o,this.id);n.name="Worker "+a,this.actors.push(n);}};function I(e,i,o){var r=function(r,a){if(r)return o(r);if(a){var n=t.pick(t.extend(a,e),["tiles","minzoom","maxzoom","attribution","mapbox_logo","bounds","scheme","tileSize","encoding"]);a.vector_layers&&(n.vectorLayers=a.vector_layers,n.vectorLayerIds=n.vectorLayers.map((function(t){return t.id}))),n.tiles=i.canonicalizeTileset(n,e.url),o(null,n);}};return e.url?t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url),t.ResourceType.Source),r):t.browser.frame((function(){return r(null,e)}))}E.prototype.broadcast=function(e,i,o){t.asyncAll(this.actors,(function(t,o){t.send(e,i,o);}),o=o||function(){});},E.prototype.getActor=function(){return this.currentActor=(this.currentActor+1)%this.actors.length,this.actors[this.currentActor]},E.prototype.remove=function(){this.actors.forEach((function(t){t.remove();})),this.actors=[],this.workerPool.release(this.id);},E.Actor=t.Actor;var P=function(e,i,o){this.bounds=t.LngLatBounds.convert(this.validateBounds(e)),this.minzoom=i||0,this.maxzoom=o||24;};P.prototype.validateBounds=function(t){return Array.isArray(t)&&4===t.length?[Math.max(-180,t[0]),Math.max(-90,t[1]),Math.min(180,t[2]),Math.min(90,t[3])]:[-180,-90,180,90]},P.prototype.contains=function(e){var i=Math.pow(2,e.z),o=Math.floor(t.mercatorXfromLng(this.bounds.getWest())*i),r=Math.floor(t.mercatorYfromLat(this.bounds.getNorth())*i),a=Math.ceil(t.mercatorXfromLng(this.bounds.getEast())*i),n=Math.ceil(t.mercatorYfromLat(this.bounds.getSouth())*i);return e.x>=o&&e.x<a&&e.y>=r&&e.y<n};var S=function(e){function i(i,o,r,a){if(e.call(this),this.id=i,this.dispatcher=r,this.type="vector",this.minzoom=0,this.maxzoom=22,this.scheme="xyz",this.tileSize=512,this.reparseOverscaled=!0,this.isTileClipped=!0,this._loaded=!1,t.extend(this,t.pick(o,["url","scheme","tileSize","promoteId"])),this._options=t.extend({type:"vector"},o),this._collectResourceTiming=o.collectResourceTiming,512!==this.tileSize)throw new Error("vector tile sources must have a tileSize of 512");this.setEventedParent(a);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this._tileJSONRequest=I(this._options,this.map._requestManager,(function(i,o){e._tileJSONRequest=null,e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(t.extend(e,o),o.bounds&&(e.tileBounds=new P(o.bounds,e.minzoom,e.maxzoom)),t.postTurnstileEvent(o.tiles,e.map._requestManager._customAccessToken),t.postMapLoadEvent(o.tiles,e.map._getMapId(),e.map._requestManager._skuToken,e.map._requestManager._customAccessToken),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})));}));},i.prototype.loaded=function(){return this._loaded},i.prototype.hasTile=function(t){return !this.tileBounds||this.tileBounds.contains(t.canonical)},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.setSourceProperty=function(t){this._tileJSONRequest&&this._tileJSONRequest.cancel(),t(),this.map.style.sourceCaches[this.id].clearTiles(),this.load();},i.prototype.setTiles=function(t){var e=this;return this.setSourceProperty((function(){e._options.tiles=t;})),this},i.prototype.setUrl=function(t){var e=this;return this.setSourceProperty((function(){e.url=t,e._options.url=t;})),this},i.prototype.onRemove=function(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);},i.prototype.serialize=function(){return t.extend({},this._options)},i.prototype.loadTile=function(e,i){var o=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme)),r={request:this.map._requestManager.transformRequest(o,t.ResourceType.Tile),uid:e.uid,tileID:e.tileID,zoom:e.tileID.overscaledZ,tileSize:this.tileSize*e.tileID.overscaleFactor(),type:this.type,source:this.id,pixelRatio:t.browser.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId};function a(o,r){return delete e.request,e.aborted?i(null):o&&404!==o.status?i(o):(r&&r.resourceTiming&&(e.resourceTiming=r.resourceTiming),this.map._refreshExpiredTiles&&r&&e.setExpiryData(r),e.loadVectorData(r,this.map.painter),t.cacheEntryPossiblyAdded(this.dispatcher),i(null),void(e.reloadCallback&&(this.loadTile(e,e.reloadCallback),e.reloadCallback=null)))}r.request.collectResourceTiming=this._collectResourceTiming,e.actor&&"expired"!==e.state?"loading"===e.state?e.reloadCallback=i:e.request=e.actor.send("reloadTile",r,a.bind(this)):(e.actor=this.dispatcher.getActor(),e.request=e.actor.send("loadTile",r,a.bind(this)));},i.prototype.abortTile=function(t){t.request&&(t.request.cancel(),delete t.request),t.actor&&t.actor.send("abortTile",{uid:t.uid,type:this.type,source:this.id},void 0);},i.prototype.unloadTile=function(t){t.unloadVectorData(),t.actor&&t.actor.send("removeTile",{uid:t.uid,type:this.type,source:this.id},void 0);},i.prototype.hasTransition=function(){return !1},i}(t.Evented),C=function(e){function i(i,o,r,a){e.call(this),this.id=i,this.dispatcher=r,this.setEventedParent(a),this.type="raster",this.minzoom=0,this.maxzoom=22,this.roundZoom=!0,this.scheme="xyz",this.tileSize=512,this._loaded=!1,this._options=t.extend({type:"raster"},o),t.extend(this,t.pick(o,["url","scheme","tileSize"]));}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this._tileJSONRequest=I(this._options,this.map._requestManager,(function(i,o){e._tileJSONRequest=null,e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(t.extend(e,o),o.bounds&&(e.tileBounds=new P(o.bounds,e.minzoom,e.maxzoom)),t.postTurnstileEvent(o.tiles),t.postMapLoadEvent(o.tiles,e.map._getMapId(),e.map._requestManager._skuToken),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})));}));},i.prototype.loaded=function(){return this._loaded},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.onRemove=function(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);},i.prototype.serialize=function(){return t.extend({},this._options)},i.prototype.hasTile=function(t){return !this.tileBounds||this.tileBounds.contains(t.canonical)},i.prototype.loadTile=function(e,i){var o=this,r=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme),this.tileSize);e.request=t.getImage(this.map._requestManager.transformRequest(r,t.ResourceType.Tile),(function(r,a){if(delete e.request,e.aborted)e.state="unloaded",i(null);else if(r)e.state="errored",i(r);else if(a){o.map._refreshExpiredTiles&&e.setExpiryData(a),delete a.cacheControl,delete a.expires;var n=o.map.painter.context,s=n.gl;e.texture=o.map.painter.getTileTexture(a.width),e.texture?e.texture.update(a,{useMipmap:!0}):(e.texture=new t.Texture(n,a,s.RGBA,{useMipmap:!0}),e.texture.bind(s.LINEAR,s.CLAMP_TO_EDGE,s.LINEAR_MIPMAP_NEAREST),n.extTextureFilterAnisotropic&&s.texParameterf(s.TEXTURE_2D,n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,n.extTextureFilterAnisotropicMax)),e.state="loaded",t.cacheEntryPossiblyAdded(o.dispatcher),i(null);}}));},i.prototype.abortTile=function(t,e){t.request&&(t.request.cancel(),delete t.request),e();},i.prototype.unloadTile=function(t,e){t.texture&&this.map.painter.saveTileTexture(t.texture),e();},i.prototype.hasTransition=function(){return !1},i}(t.Evented),z=function(e){function i(i,o,r,a){e.call(this,i,o,r,a),this.type="raster-dem",this.maxzoom=22,this._options=t.extend({type:"raster-dem"},o),this.encoding=o.encoding||"mapbox";}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.serialize=function(){return {type:"raster-dem",url:this.url,tileSize:this.tileSize,tiles:this.tiles,bounds:this.bounds,encoding:this.encoding}},i.prototype.loadTile=function(e,i){var o=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme),this.tileSize);function r(t,o){t&&(e.state="errored",i(t)),o&&(e.dem=o,e.needsHillshadePrepare=!0,e.state="loaded",i(null));}e.request=t.getImage(this.map._requestManager.transformRequest(o,t.ResourceType.Tile),function(o,a){if(delete e.request,e.aborted)e.state="unloaded",i(null);else if(o)e.state="errored",i(o);else if(a){this.map._refreshExpiredTiles&&e.setExpiryData(a),delete a.cacheControl,delete a.expires;var n=t.window.ImageBitmap&&a instanceof t.window.ImageBitmap&&t.offscreenCanvasSupported()?a:t.browser.getImageData(a,1),s={uid:e.uid,coord:e.tileID,source:this.id,rawImageData:n,encoding:this.encoding};e.actor&&"expired"!==e.state||(e.actor=this.dispatcher.getActor(),e.actor.send("loadDEMTile",s,r.bind(this)));}}.bind(this)),e.neighboringTiles=this._getNeighboringTiles(e.tileID);},i.prototype._getNeighboringTiles=function(e){var i=e.canonical,o=Math.pow(2,i.z),r=(i.x-1+o)%o,a=0===i.x?e.wrap-1:e.wrap,n=(i.x+1+o)%o,s=i.x+1===o?e.wrap+1:e.wrap,l={};return l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y).key]={backfilled:!1},i.y>0&&(l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y-1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y-1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y-1).key]={backfilled:!1}),i.y+1<o&&(l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y+1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y+1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y+1).key]={backfilled:!1}),l},i.prototype.unloadTile=function(t){t.demTexture&&this.map.painter.saveTileTexture(t.demTexture),t.fbo&&(t.fbo.destroy(),delete t.fbo),t.dem&&delete t.dem,delete t.neighboringTiles,t.state="unloaded",t.actor&&t.actor.send("removeDEMTile",{uid:t.uid,source:this.id});},i}(C),D=function(e){function i(i,o,r,a){e.call(this),this.id=i,this.type="geojson",this.minzoom=0,this.maxzoom=18,this.tileSize=512,this.isTileClipped=!0,this.reparseOverscaled=!0,this._removed=!1,this._loaded=!1,this.actor=r.getActor(),this.setEventedParent(a),this._data=o.data,this._options=t.extend({},o),this._collectResourceTiming=o.collectResourceTiming,this._resourceTiming=[],void 0!==o.maxzoom&&(this.maxzoom=o.maxzoom),o.type&&(this.type=o.type),o.attribution&&(this.attribution=o.attribution),this.promoteId=o.promoteId;var n=t.EXTENT/this.tileSize;this.workerOptions=t.extend({source:this.id,cluster:o.cluster||!1,geojsonVtOptions:{buffer:(void 0!==o.buffer?o.buffer:128)*n,tolerance:(void 0!==o.tolerance?o.tolerance:.375)*n,extent:t.EXTENT,maxZoom:this.maxzoom,lineMetrics:o.lineMetrics||!1,generateId:o.generateId||!1},superclusterOptions:{maxZoom:void 0!==o.clusterMaxZoom?Math.min(o.clusterMaxZoom,this.maxzoom-1):this.maxzoom-1,minPoints:Math.max(2,o.clusterMinPoints||2),extent:t.EXTENT,radius:(o.clusterRadius||50)*n,log:!1,generateId:o.generateId||!1},clusterProperties:o.clusterProperties,filter:o.filter},o.workerOptions);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this.fire(new t.Event("dataloading",{dataType:"source"})),this._updateWorkerData((function(i){if(i)e.fire(new t.ErrorEvent(i));else {var o={dataType:"source",sourceDataType:"metadata"};e._collectResourceTiming&&e._resourceTiming&&e._resourceTiming.length>0&&(o.resourceTiming=e._resourceTiming,e._resourceTiming=[]),e.fire(new t.Event("data",o));}}));},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.setData=function(e){var i=this;return this._data=e,this.fire(new t.Event("dataloading",{dataType:"source"})),this._updateWorkerData((function(e){if(e)i.fire(new t.ErrorEvent(e));else {var o={dataType:"source",sourceDataType:"content"};i._collectResourceTiming&&i._resourceTiming&&i._resourceTiming.length>0&&(o.resourceTiming=i._resourceTiming,i._resourceTiming=[]),i.fire(new t.Event("data",o));}})),this},i.prototype.getClusterExpansionZoom=function(t,e){return this.actor.send("geojson.getClusterExpansionZoom",{clusterId:t,source:this.id},e),this},i.prototype.getClusterChildren=function(t,e){return this.actor.send("geojson.getClusterChildren",{clusterId:t,source:this.id},e),this},i.prototype.getClusterLeaves=function(t,e,i,o){return this.actor.send("geojson.getClusterLeaves",{source:this.id,clusterId:t,limit:e,offset:i},o),this},i.prototype._updateWorkerData=function(e){var i=this;this._loaded=!1;var o=t.extend({},this.workerOptions),r=this._data;"string"==typeof r?(o.request=this.map._requestManager.transformRequest(t.browser.resolveURL(r),t.ResourceType.Source),o.request.collectResourceTiming=this._collectResourceTiming):o.data=JSON.stringify(r),this.actor.send(this.type+".loadData",o,(function(t,r){i._removed||r&&r.abandoned||(i._loaded=!0,r&&r.resourceTiming&&r.resourceTiming[i.id]&&(i._resourceTiming=r.resourceTiming[i.id].slice(0)),i.actor.send(i.type+".coalesce",{source:o.source},null),e(t));}));},i.prototype.loaded=function(){return this._loaded},i.prototype.loadTile=function(e,i){var o=this,r=e.actor?"reloadTile":"loadTile";e.actor=this.actor,e.request=this.actor.send(r,{type:this.type,uid:e.uid,tileID:e.tileID,zoom:e.tileID.overscaledZ,maxZoom:this.maxzoom,tileSize:this.tileSize,source:this.id,pixelRatio:t.browser.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId},(function(t,a){return delete e.request,e.unloadVectorData(),e.aborted?i(null):t?i(t):(e.loadVectorData(a,o.map.painter,"reloadTile"===r),i(null))}));},i.prototype.abortTile=function(t){t.request&&(t.request.cancel(),delete t.request),t.aborted=!0;},i.prototype.unloadTile=function(t){t.unloadVectorData(),this.actor.send("removeTile",{uid:t.uid,type:this.type,source:this.id});},i.prototype.onRemove=function(){this._removed=!0,this.actor.send("removeSource",{type:this.type,source:this.id});},i.prototype.serialize=function(){return t.extend({},this._options,{type:this.type,data:this._data})},i.prototype.hasTransition=function(){return !1},i}(t.Evented),A=t.createLayout([{name:"a_pos",type:"Int16",components:2},{name:"a_texture_pos",type:"Int16",components:2}]),M=function(e){function i(t,i,o,r){e.call(this),this.id=t,this.dispatcher=o,this.coordinates=i.coordinates,this.type="image",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this.tiles={},this._loaded=!1,this.setEventedParent(r),this.options=i;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(e,i){var o=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this.url=this.options.url,t.getImage(this.map._requestManager.transformRequest(this.url,t.ResourceType.Image),(function(r,a){o._loaded=!0,r?o.fire(new t.ErrorEvent(r)):a&&(o.image=a,e&&(o.coordinates=e),i&&i(),o._finishLoading());}));},i.prototype.loaded=function(){return this._loaded},i.prototype.updateImage=function(t){var e=this;return this.image&&t.url?(this.options.url=t.url,this.load(t.coordinates,(function(){e.texture=null;})),this):this},i.prototype._finishLoading=function(){this.map&&(this.setCoordinates(this.coordinates),this.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})));},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.setCoordinates=function(e){var i=this;this.coordinates=e;var o=e.map(t.MercatorCoordinate.fromLngLat);this.tileID=function(e){for(var i=1/0,o=1/0,r=-1/0,a=-1/0,n=0,s=e;n<s.length;n+=1){var l=s[n];i=Math.min(i,l.x),o=Math.min(o,l.y),r=Math.max(r,l.x),a=Math.max(a,l.y);}var c=Math.max(r-i,a-o),u=Math.max(0,Math.floor(-Math.log(c)/Math.LN2)),h=Math.pow(2,u);return new t.CanonicalTileID(u,Math.floor((i+r)/2*h),Math.floor((o+a)/2*h))}(o),this.minzoom=this.maxzoom=this.tileID.z;var r=o.map((function(t){return i.tileID.getTilePoint(t)._round()}));return this._boundsArray=new t.StructArrayLayout4i8,this._boundsArray.emplaceBack(r[0].x,r[0].y,0,0),this._boundsArray.emplaceBack(r[1].x,r[1].y,t.EXTENT,0),this._boundsArray.emplaceBack(r[3].x,r[3].y,0,t.EXTENT),this._boundsArray.emplaceBack(r[2].x,r[2].y,t.EXTENT,t.EXTENT),this.boundsBuffer&&(this.boundsBuffer.destroy(),delete this.boundsBuffer),this.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})),this},i.prototype.prepare=function(){if(0!==Object.keys(this.tiles).length&&this.image){var e=this.map.painter.context,i=e.gl;for(var o in this.boundsBuffer||(this.boundsBuffer=e.createVertexBuffer(this._boundsArray,A.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture||(this.texture=new t.Texture(e,this.image,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE)),this.tiles){var r=this.tiles[o];"loaded"!==r.state&&(r.state="loaded",r.texture=this.texture);}}},i.prototype.loadTile=function(t,e){this.tileID&&this.tileID.equals(t.tileID.canonical)?(this.tiles[String(t.tileID.wrap)]=t,t.buckets={},e(null)):(t.state="errored",e(null));},i.prototype.serialize=function(){return {type:"image",url:this.options.url,coordinates:this.coordinates}},i.prototype.hasTransition=function(){return !1},i}(t.Evented),L=function(e){function i(t,i,o,r){e.call(this,t,i,o,r),this.roundZoom=!0,this.type="video",this.options=i;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1;var i=this.options;this.urls=[];for(var o=0,r=i.urls;o<r.length;o+=1)this.urls.push(this.map._requestManager.transformRequest(r[o],t.ResourceType.Source).url);t.getVideo(this.urls,(function(i,o){e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(e.video=o,e.video.loop=!0,e.video.addEventListener("playing",(function(){e.map.triggerRepaint();})),e.map&&e.video.play(),e._finishLoading());}));},i.prototype.pause=function(){this.video&&this.video.pause();},i.prototype.play=function(){this.video&&this.video.play();},i.prototype.seek=function(e){if(this.video){var i=this.video.seekable;e<i.start(0)||e>i.end(0)?this.fire(new t.ErrorEvent(new t.ValidationError("sources."+this.id,null,"Playback for this video can be set only between the "+i.start(0)+" and "+i.end(0)+"-second mark."))):this.video.currentTime=e;}},i.prototype.getVideo=function(){return this.video},i.prototype.onAdd=function(t){this.map||(this.map=t,this.load(),this.video&&(this.video.play(),this.setCoordinates(this.coordinates)));},i.prototype.prepare=function(){if(!(0===Object.keys(this.tiles).length||this.video.readyState<2)){var e=this.map.painter.context,i=e.gl;for(var o in this.boundsBuffer||(this.boundsBuffer=e.createVertexBuffer(this._boundsArray,A.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture?this.video.paused||(this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE),i.texSubImage2D(i.TEXTURE_2D,0,0,0,i.RGBA,i.UNSIGNED_BYTE,this.video)):(this.texture=new t.Texture(e,this.video,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE)),this.tiles){var r=this.tiles[o];"loaded"!==r.state&&(r.state="loaded",r.texture=this.texture);}}},i.prototype.serialize=function(){return {type:"video",urls:this.urls,coordinates:this.coordinates}},i.prototype.hasTransition=function(){return this.video&&!this.video.paused},i}(M),R=function(e){function i(i,o,r,a){e.call(this,i,o,r,a),o.coordinates?Array.isArray(o.coordinates)&&4===o.coordinates.length&&!o.coordinates.some((function(t){return !Array.isArray(t)||2!==t.length||t.some((function(t){return "number"!=typeof t}))}))||this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))):this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'missing required property "coordinates"'))),o.animate&&"boolean"!=typeof o.animate&&this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'optional "animate" property must be a boolean value'))),o.canvas?"string"==typeof o.canvas||o.canvas instanceof t.window.HTMLCanvasElement||this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))):this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'missing required property "canvas"'))),this.options=o,this.animate=void 0===o.animate||o.animate;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){this._loaded=!0,this.canvas||(this.canvas=this.options.canvas instanceof t.window.HTMLCanvasElement?this.options.canvas:t.window.document.getElementById(this.options.canvas)),this.width=this.canvas.width,this.height=this.canvas.height,this._hasInvalidDimensions()?this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))):(this.play=function(){this._playing=!0,this.map.triggerRepaint();},this.pause=function(){this._playing&&(this.prepare(),this._playing=!1);},this._finishLoading());},i.prototype.getCanvas=function(){return this.canvas},i.prototype.onAdd=function(t){this.map=t,this.load(),this.canvas&&this.animate&&this.play();},i.prototype.onRemove=function(){this.pause();},i.prototype.prepare=function(){var e=!1;if(this.canvas.width!==this.width&&(this.width=this.canvas.width,e=!0),this.canvas.height!==this.height&&(this.height=this.canvas.height,e=!0),!this._hasInvalidDimensions()&&0!==Object.keys(this.tiles).length){var i=this.map.painter.context,o=i.gl;for(var r in this.boundsBuffer||(this.boundsBuffer=i.createVertexBuffer(this._boundsArray,A.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture?(e||this._playing)&&this.texture.update(this.canvas,{premultiply:!0}):this.texture=new t.Texture(i,this.canvas,o.RGBA,{premultiply:!0}),this.tiles){var a=this.tiles[r];"loaded"!==a.state&&(a.state="loaded",a.texture=this.texture);}}},i.prototype.serialize=function(){return {type:"canvas",coordinates:this.coordinates}},i.prototype.hasTransition=function(){return this._playing},i.prototype._hasInvalidDimensions=function(){for(var t=0,e=[this.canvas.width,this.canvas.height];t<e.length;t+=1){var i=e[t];if(isNaN(i)||i<=0)return !0}return !1},i}(M),k={vector:S,raster:C,"raster-dem":z,geojson:D,video:L,image:M,canvas:R};function B(e,i){var o=t.identity([]);return t.translate(o,o,[1,1,0]),t.scale(o,o,[.5*e.width,.5*e.height,1]),t.multiply(o,o,e.calculatePosMatrix(i.toUnwrapped()))}function O(t,e,i,o,r,a){var n=function(t,e,i){if(t)for(var o=0,r=t;o<r.length;o+=1){var a=e[r[o]];if(a&&a.source===i&&"fill-extrusion"===a.type)return !0}else for(var n in e){var s=e[n];if(s.source===i&&"fill-extrusion"===s.type)return !0}return !1}(r&&r.layers,e,t.id),s=a.maxPitchScaleFactor(),l=t.tilesIn(o,s,n);l.sort(F);for(var c=[],u=0,h=l;u<h.length;u+=1){var p=h[u];c.push({wrappedTileID:p.tileID.wrapped().key,queryResults:p.tile.queryRenderedFeatures(e,i,t._state,p.queryGeometry,p.cameraQueryGeometry,p.scale,r,a,s,B(t.transform,p.tileID))});}var d=function(t){for(var e={},i={},o=0,r=t;o<r.length;o+=1){var a=r[o],n=a.queryResults,s=a.wrappedTileID,l=i[s]=i[s]||{};for(var c in n)for(var u=n[c],h=l[c]=l[c]||{},p=e[c]=e[c]||[],d=0,_=u;d<_.length;d+=1){var f=_[d];h[f.featureIndex]||(h[f.featureIndex]=!0,p.push(f));}}return e}(c);for(var _ in d)d[_].forEach((function(e){var i=e.feature,o=t.getFeatureState(i.layer["source-layer"],i.id);i.source=i.layer.source,i.layer["source-layer"]&&(i.sourceLayer=i.layer["source-layer"]),i.state=o;}));return d}function F(t,e){var i=t.tileID,o=e.tileID;return i.overscaledZ-o.overscaledZ||i.canonical.y-o.canonical.y||i.wrap-o.wrap||i.canonical.x-o.canonical.x}var U=function(t,e){this.max=t,this.onRemove=e,this.reset();};U.prototype.reset=function(){for(var t in this.data)for(var e=0,i=this.data[t];e<i.length;e+=1){var o=i[e];o.timeout&&clearTimeout(o.timeout),this.onRemove(o.value);}return this.data={},this.order=[],this},U.prototype.add=function(t,e,i){var o=this,r=t.wrapped().key;void 0===this.data[r]&&(this.data[r]=[]);var a={value:e,timeout:void 0};if(void 0!==i&&(a.timeout=setTimeout((function(){o.remove(t,a);}),i)),this.data[r].push(a),this.order.push(r),this.order.length>this.max){var n=this._getAndRemoveByKey(this.order[0]);n&&this.onRemove(n);}return this},U.prototype.has=function(t){return t.wrapped().key in this.data},U.prototype.getAndRemove=function(t){return this.has(t)?this._getAndRemoveByKey(t.wrapped().key):null},U.prototype._getAndRemoveByKey=function(t){var e=this.data[t].shift();return e.timeout&&clearTimeout(e.timeout),0===this.data[t].length&&delete this.data[t],this.order.splice(this.order.indexOf(t),1),e.value},U.prototype.getByKey=function(t){var e=this.data[t];return e?e[0].value:null},U.prototype.get=function(t){return this.has(t)?this.data[t.wrapped().key][0].value:null},U.prototype.remove=function(t,e){if(!this.has(t))return this;var i=t.wrapped().key,o=void 0===e?0:this.data[i].indexOf(e),r=this.data[i][o];return this.data[i].splice(o,1),r.timeout&&clearTimeout(r.timeout),0===this.data[i].length&&delete this.data[i],this.onRemove(r.value),this.order.splice(this.order.indexOf(i),1),this},U.prototype.setMaxSize=function(t){for(this.max=t;this.order.length>this.max;){var e=this._getAndRemoveByKey(this.order[0]);e&&this.onRemove(e);}return this},U.prototype.filter=function(t){var e=[];for(var i in this.data)for(var o=0,r=this.data[i];o<r.length;o+=1){var a=r[o];t(a.value)||e.push(a);}for(var n=0,s=e;n<s.length;n+=1){var l=s[n];this.remove(l.value.tileID,l);}};var N=function(t,e,i){this.context=t;var o=t.gl;this.buffer=o.createBuffer(),this.dynamicDraw=Boolean(i),this.context.unbindVAO(),t.bindElementBuffer.set(this.buffer),o.bufferData(o.ELEMENT_ARRAY_BUFFER,e.arrayBuffer,this.dynamicDraw?o.DYNAMIC_DRAW:o.STATIC_DRAW),this.dynamicDraw||delete e.arrayBuffer;};N.prototype.bind=function(){this.context.bindElementBuffer.set(this.buffer);},N.prototype.updateData=function(t){var e=this.context.gl;this.context.unbindVAO(),this.bind(),e.bufferSubData(e.ELEMENT_ARRAY_BUFFER,0,t.arrayBuffer);},N.prototype.destroy=function(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);};var Z={Int8:"BYTE",Uint8:"UNSIGNED_BYTE",Int16:"SHORT",Uint16:"UNSIGNED_SHORT",Int32:"INT",Uint32:"UNSIGNED_INT",Float32:"FLOAT"},q=function(t,e,i,o){this.length=e.length,this.attributes=i,this.itemSize=e.bytesPerElement,this.dynamicDraw=o,this.context=t;var r=t.gl;this.buffer=r.createBuffer(),t.bindVertexBuffer.set(this.buffer),r.bufferData(r.ARRAY_BUFFER,e.arrayBuffer,this.dynamicDraw?r.DYNAMIC_DRAW:r.STATIC_DRAW),this.dynamicDraw||delete e.arrayBuffer;};q.prototype.bind=function(){this.context.bindVertexBuffer.set(this.buffer);},q.prototype.updateData=function(t){var e=this.context.gl;this.bind(),e.bufferSubData(e.ARRAY_BUFFER,0,t.arrayBuffer);},q.prototype.enableAttributes=function(t,e){for(var i=0;i<this.attributes.length;i++){var o=e.attributes[this.attributes[i].name];void 0!==o&&t.enableVertexAttribArray(o);}},q.prototype.setVertexAttribPointers=function(t,e,i){for(var o=0;o<this.attributes.length;o++){var r=this.attributes[o],a=e.attributes[r.name];void 0!==a&&t.vertexAttribPointer(a,r.components,t[Z[r.type]],!1,this.itemSize,r.offset+this.itemSize*(i||0));}},q.prototype.destroy=function(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);};var j=function(t){this.gl=t.gl,this.default=this.getDefault(),this.current=this.default,this.dirty=!1;};j.prototype.get=function(){return this.current},j.prototype.set=function(t){},j.prototype.getDefault=function(){return this.default},j.prototype.setDefault=function(){this.set(this.default);};var V=function(e){function i(){e.apply(this,arguments);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getDefault=function(){return t.Color.transparent},i.prototype.set=function(t){var e=this.current;(t.r!==e.r||t.g!==e.g||t.b!==e.b||t.a!==e.a||this.dirty)&&(this.gl.clearColor(t.r,t.g,t.b,t.a),this.current=t,this.dirty=!1);},i}(j),G=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 1},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.clearDepth(t),this.current=t,this.dirty=!1);},e}(j),W=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.clearStencil(t),this.current=t,this.dirty=!1);},e}(j),X=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return [!0,!0,!0,!0]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||t[3]!==e[3]||this.dirty)&&(this.gl.colorMask(t[0],t[1],t[2],t[3]),this.current=t,this.dirty=!1);},e}(j),H=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.depthMask(t),this.current=t,this.dirty=!1);},e}(j),K=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 255},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.stencilMask(t),this.current=t,this.dirty=!1);},e}(j),Y=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return {func:this.gl.ALWAYS,ref:0,mask:255}},e.prototype.set=function(t){var e=this.current;(t.func!==e.func||t.ref!==e.ref||t.mask!==e.mask||this.dirty)&&(this.gl.stencilFunc(t.func,t.ref,t.mask),this.current=t,this.dirty=!1);},e}(j),J=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [t.KEEP,t.KEEP,t.KEEP]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||this.dirty)&&(this.gl.stencilOp(t[0],t[1],t[2]),this.current=t,this.dirty=!1);},e}(j),Q=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.STENCIL_TEST):e.disable(e.STENCIL_TEST),this.current=t,this.dirty=!1;}},e}(j),$=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return [0,1]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||this.dirty)&&(this.gl.depthRange(t[0],t[1]),this.current=t,this.dirty=!1);},e}(j),tt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.DEPTH_TEST):e.disable(e.DEPTH_TEST),this.current=t,this.dirty=!1;}},e}(j),et=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.LESS},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.depthFunc(t),this.current=t,this.dirty=!1);},e}(j),it=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.BLEND):e.disable(e.BLEND),this.current=t,this.dirty=!1;}},e}(j),ot=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [t.ONE,t.ZERO]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||this.dirty)&&(this.gl.blendFunc(t[0],t[1]),this.current=t,this.dirty=!1);},e}(j),rt=function(e){function i(){e.apply(this,arguments);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getDefault=function(){return t.Color.transparent},i.prototype.set=function(t){var e=this.current;(t.r!==e.r||t.g!==e.g||t.b!==e.b||t.a!==e.a||this.dirty)&&(this.gl.blendColor(t.r,t.g,t.b,t.a),this.current=t,this.dirty=!1);},i}(j),at=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.FUNC_ADD},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.blendEquation(t),this.current=t,this.dirty=!1);},e}(j),nt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.CULL_FACE):e.disable(e.CULL_FACE),this.current=t,this.dirty=!1;}},e}(j),st=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.BACK},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.cullFace(t),this.current=t,this.dirty=!1);},e}(j),lt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.CCW},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.frontFace(t),this.current=t,this.dirty=!1);},e}(j),ct=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.useProgram(t),this.current=t,this.dirty=!1);},e}(j),ut=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.TEXTURE0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.activeTexture(t),this.current=t,this.dirty=!1);},e}(j),ht=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [0,0,t.drawingBufferWidth,t.drawingBufferHeight]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||t[3]!==e[3]||this.dirty)&&(this.gl.viewport(t[0],t[1],t[2],t[3]),this.current=t,this.dirty=!1);},e}(j),pt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,t),this.current=t,this.dirty=!1;}},e}(j),dt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindRenderbuffer(e.RENDERBUFFER,t),this.current=t,this.dirty=!1;}},e}(j),_t=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindTexture(e.TEXTURE_2D,t),this.current=t,this.dirty=!1;}},e}(j),ft=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindBuffer(e.ARRAY_BUFFER,t),this.current=t,this.dirty=!1;}},e}(j),mt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){var e=this.gl;e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),this.current=t,this.dirty=!1;},e}(j),gt=function(t){function e(e){t.call(this,e),this.vao=e.extVertexArrayObject;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){this.vao&&(t!==this.current||this.dirty)&&(this.vao.bindVertexArrayOES(t),this.current=t,this.dirty=!1);},e}(j),vt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 4},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_ALIGNMENT,t),this.current=t,this.dirty=!1;}},e}(j),yt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t),this.current=t,this.dirty=!1;}},e}(j),xt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,t),this.current=t,this.dirty=!1;}},e}(j),bt=function(t){function e(e,i){t.call(this,e),this.context=e,this.parent=i;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e}(j),wt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.setDirty=function(){this.dirty=!0;},e.prototype.set=function(t){if(t!==this.current||this.dirty){this.context.bindFramebuffer.set(this.parent);var e=this.gl;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),this.current=t,this.dirty=!1;}},e}(bt),Tt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){if(t!==this.current||this.dirty){this.context.bindFramebuffer.set(this.parent);var e=this.gl;e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,t),this.current=t,this.dirty=!1;}},e}(bt),Et=function(t,e,i,o){this.context=t,this.width=e,this.height=i;var r=this.framebuffer=t.gl.createFramebuffer();this.colorAttachment=new wt(t,r),o&&(this.depthAttachment=new Tt(t,r));};Et.prototype.destroy=function(){var t=this.context.gl,e=this.colorAttachment.get();if(e&&t.deleteTexture(e),this.depthAttachment){var i=this.depthAttachment.get();i&&t.deleteRenderbuffer(i);}t.deleteFramebuffer(this.framebuffer);};var It=function(t,e,i){this.func=t,this.mask=e,this.range=i;};It.ReadOnly=!1,It.ReadWrite=!0,It.disabled=new It(519,It.ReadOnly,[0,1]);var Pt=function(t,e,i,o,r,a){this.test=t,this.ref=e,this.mask=i,this.fail=o,this.depthFail=r,this.pass=a;};Pt.disabled=new Pt({func:519,mask:0},0,0,7680,7680,7680);var St=function(t,e,i){this.blendFunction=t,this.blendColor=e,this.mask=i;};St.disabled=new St(St.Replace=[1,0],t.Color.transparent,[!1,!1,!1,!1]),St.unblended=new St(St.Replace,t.Color.transparent,[!0,!0,!0,!0]),St.alphaBlended=new St([1,771],t.Color.transparent,[!0,!0,!0,!0]);var Ct=function(t,e,i){this.enable=t,this.mode=e,this.frontFace=i;};Ct.disabled=new Ct(!1,1029,2305),Ct.backCCW=new Ct(!0,1029,2305);var zt=function(t){this.gl=t,this.extVertexArrayObject=this.gl.getExtension("OES_vertex_array_object"),this.clearColor=new V(this),this.clearDepth=new G(this),this.clearStencil=new W(this),this.colorMask=new X(this),this.depthMask=new H(this),this.stencilMask=new K(this),this.stencilFunc=new Y(this),this.stencilOp=new J(this),this.stencilTest=new Q(this),this.depthRange=new $(this),this.depthTest=new tt(this),this.depthFunc=new et(this),this.blend=new it(this),this.blendFunc=new ot(this),this.blendColor=new rt(this),this.blendEquation=new at(this),this.cullFace=new nt(this),this.cullFaceSide=new st(this),this.frontFace=new lt(this),this.program=new ct(this),this.activeTexture=new ut(this),this.viewport=new ht(this),this.bindFramebuffer=new pt(this),this.bindRenderbuffer=new dt(this),this.bindTexture=new _t(this),this.bindVertexBuffer=new ft(this),this.bindElementBuffer=new mt(this),this.bindVertexArrayOES=this.extVertexArrayObject&&new gt(this),this.pixelStoreUnpack=new vt(this),this.pixelStoreUnpackPremultiplyAlpha=new yt(this),this.pixelStoreUnpackFlipY=new xt(this),this.extTextureFilterAnisotropic=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.extTextureFilterAnisotropic&&(this.extTextureFilterAnisotropicMax=t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),this.extTextureHalfFloat=t.getExtension("OES_texture_half_float"),this.extTextureHalfFloat&&(t.getExtension("OES_texture_half_float_linear"),this.extRenderToTextureHalfFloat=t.getExtension("EXT_color_buffer_half_float")),this.extTimerQuery=t.getExtension("EXT_disjoint_timer_query"),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE);};zt.prototype.setDefault=function(){this.unbindVAO(),this.clearColor.setDefault(),this.clearDepth.setDefault(),this.clearStencil.setDefault(),this.colorMask.setDefault(),this.depthMask.setDefault(),this.stencilMask.setDefault(),this.stencilFunc.setDefault(),this.stencilOp.setDefault(),this.stencilTest.setDefault(),this.depthRange.setDefault(),this.depthTest.setDefault(),this.depthFunc.setDefault(),this.blend.setDefault(),this.blendFunc.setDefault(),this.blendColor.setDefault(),this.blendEquation.setDefault(),this.cullFace.setDefault(),this.cullFaceSide.setDefault(),this.frontFace.setDefault(),this.program.setDefault(),this.activeTexture.setDefault(),this.bindFramebuffer.setDefault(),this.pixelStoreUnpack.setDefault(),this.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.pixelStoreUnpackFlipY.setDefault();},zt.prototype.setDirty=function(){this.clearColor.dirty=!0,this.clearDepth.dirty=!0,this.clearStencil.dirty=!0,this.colorMask.dirty=!0,this.depthMask.dirty=!0,this.stencilMask.dirty=!0,this.stencilFunc.dirty=!0,this.stencilOp.dirty=!0,this.stencilTest.dirty=!0,this.depthRange.dirty=!0,this.depthTest.dirty=!0,this.depthFunc.dirty=!0,this.blend.dirty=!0,this.blendFunc.dirty=!0,this.blendColor.dirty=!0,this.blendEquation.dirty=!0,this.cullFace.dirty=!0,this.cullFaceSide.dirty=!0,this.frontFace.dirty=!0,this.program.dirty=!0,this.activeTexture.dirty=!0,this.viewport.dirty=!0,this.bindFramebuffer.dirty=!0,this.bindRenderbuffer.dirty=!0,this.bindTexture.dirty=!0,this.bindVertexBuffer.dirty=!0,this.bindElementBuffer.dirty=!0,this.extVertexArrayObject&&(this.bindVertexArrayOES.dirty=!0),this.pixelStoreUnpack.dirty=!0,this.pixelStoreUnpackPremultiplyAlpha.dirty=!0,this.pixelStoreUnpackFlipY.dirty=!0;},zt.prototype.createIndexBuffer=function(t,e){return new N(this,t,e)},zt.prototype.createVertexBuffer=function(t,e,i){return new q(this,t,e,i)},zt.prototype.createRenderbuffer=function(t,e,i){var o=this.gl,r=o.createRenderbuffer();return this.bindRenderbuffer.set(r),o.renderbufferStorage(o.RENDERBUFFER,t,e,i),this.bindRenderbuffer.set(null),r},zt.prototype.createFramebuffer=function(t,e,i){return new Et(this,t,e,i)},zt.prototype.clear=function(t){var e=t.color,i=t.depth,o=this.gl,r=0;e&&(r|=o.COLOR_BUFFER_BIT,this.clearColor.set(e),this.colorMask.set([!0,!0,!0,!0])),void 0!==i&&(r|=o.DEPTH_BUFFER_BIT,this.depthRange.set([0,1]),this.clearDepth.set(i),this.depthMask.set(!0)),o.clear(r);},zt.prototype.setCullFace=function(t){!1===t.enable?this.cullFace.set(!1):(this.cullFace.set(!0),this.cullFaceSide.set(t.mode),this.frontFace.set(t.frontFace));},zt.prototype.setDepthMode=function(t){t.func!==this.gl.ALWAYS||t.mask?(this.depthTest.set(!0),this.depthFunc.set(t.func),this.depthMask.set(t.mask),this.depthRange.set(t.range)):this.depthTest.set(!1);},zt.prototype.setStencilMode=function(t){t.test.func!==this.gl.ALWAYS||t.mask?(this.stencilTest.set(!0),this.stencilMask.set(t.mask),this.stencilOp.set([t.fail,t.depthFail,t.pass]),this.stencilFunc.set({func:t.test.func,ref:t.ref,mask:t.test.mask})):this.stencilTest.set(!1);},zt.prototype.setColorMode=function(e){t.deepEqual(e.blendFunction,St.Replace)?this.blend.set(!1):(this.blend.set(!0),this.blendFunc.set(e.blendFunction),this.blendColor.set(e.blendColor)),this.colorMask.set(e.mask);},zt.prototype.unbindVAO=function(){this.extVertexArrayObject&&this.bindVertexArrayOES.set(null);};var Dt=function(e){function i(i,o,r){var a=this;e.call(this),this.id=i,this.dispatcher=r,this.on("data",(function(t){"source"===t.dataType&&"metadata"===t.sourceDataType&&(a._sourceLoaded=!0),a._sourceLoaded&&!a._paused&&"source"===t.dataType&&"content"===t.sourceDataType&&(a.reload(),a.transform&&a.update(a.transform));})),this.on("error",(function(){a._sourceErrored=!0;})),this._source=function(e,i,o,r){var a=new k[i.type](e,i,o,r);if(a.id!==e)throw new Error("Expected Source id to be "+e+" instead of "+a.id);return t.bindAll(["load","abort","unload","serialize","prepare"],a),a}(i,o,r,this),this._tiles={},this._cache=new U(0,this._unloadTile.bind(this)),this._timers={},this._cacheTimers={},this._maxTileCacheSize=null,this._loadedParentTiles={},this._coveredTiles={},this._state=new t.SourceFeatureState;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.onAdd=function(t){this.map=t,this._maxTileCacheSize=t?t._maxTileCacheSize:null,this._source&&this._source.onAdd&&this._source.onAdd(t);},i.prototype.onRemove=function(t){this._source&&this._source.onRemove&&this._source.onRemove(t);},i.prototype.loaded=function(){if(this._sourceErrored)return !0;if(!this._sourceLoaded)return !1;if(!this._source.loaded())return !1;for(var t in this._tiles){var e=this._tiles[t];if("loaded"!==e.state&&"errored"!==e.state)return !1}return !0},i.prototype.getSource=function(){return this._source},i.prototype.pause=function(){this._paused=!0;},i.prototype.resume=function(){if(this._paused){var t=this._shouldReloadOnResume;this._paused=!1,this._shouldReloadOnResume=!1,t&&this.reload(),this.transform&&this.update(this.transform);}},i.prototype._loadTile=function(t,e){return this._source.loadTile(t,e)},i.prototype._unloadTile=function(t){if(this._source.unloadTile)return this._source.unloadTile(t,(function(){}))},i.prototype._abortTile=function(t){if(this._source.abortTile)return this._source.abortTile(t,(function(){}))},i.prototype.serialize=function(){return this._source.serialize()},i.prototype.prepare=function(t){for(var e in this._source.prepare&&this._source.prepare(),this._state.coalesceChanges(this._tiles,this.map?this.map.painter:null),this._tiles){var i=this._tiles[e];i.upload(t),i.prepare(this.map.style.imageManager);}},i.prototype.getIds=function(){return t.values(this._tiles).map((function(t){return t.tileID})).sort(At).map((function(t){return t.key}))},i.prototype.getRenderableIds=function(e){var i=this,o=[];for(var r in this._tiles)this._isIdRenderable(r,e)&&o.push(this._tiles[r]);return e?o.sort((function(e,o){var r=e.tileID,a=o.tileID,n=new t.Point(r.canonical.x,r.canonical.y)._rotate(i.transform.angle),s=new t.Point(a.canonical.x,a.canonical.y)._rotate(i.transform.angle);return r.overscaledZ-a.overscaledZ||s.y-n.y||s.x-n.x})).map((function(t){return t.tileID.key})):o.map((function(t){return t.tileID})).sort(At).map((function(t){return t.key}))},i.prototype.hasRenderableParent=function(t){var e=this.findLoadedParent(t,0);return !!e&&this._isIdRenderable(e.tileID.key)},i.prototype._isIdRenderable=function(t,e){return this._tiles[t]&&this._tiles[t].hasData()&&!this._coveredTiles[t]&&(e||!this._tiles[t].holdingForFade())},i.prototype.reload=function(){if(this._paused)this._shouldReloadOnResume=!0;else for(var t in this._cache.reset(),this._tiles)"errored"!==this._tiles[t].state&&this._reloadTile(t,"reloading");},i.prototype._reloadTile=function(t,e){var i=this._tiles[t];i&&("loading"!==i.state&&(i.state=e),this._loadTile(i,this._tileLoaded.bind(this,i,t,e)));},i.prototype._tileLoaded=function(e,i,o,r){if(r)return e.state="errored",void(404!==r.status?this._source.fire(new t.ErrorEvent(r,{tile:e})):this.update(this.transform));e.timeAdded=t.browser.now(),"expired"===o&&(e.refreshedUponExpiration=!0),this._setTileReloadTimer(i,e),"raster-dem"===this.getSource().type&&e.dem&&this._backfillDEM(e),this._state.initializeTileState(e,this.map?this.map.painter:null),this._source.fire(new t.Event("data",{dataType:"source",tile:e,coord:e.tileID}));},i.prototype._backfillDEM=function(t){for(var e=this.getRenderableIds(),i=0;i<e.length;i++){var o=e[i];if(t.neighboringTiles&&t.neighboringTiles[o]){var r=this.getTileByID(o);a(t,r),a(r,t);}}function a(t,e){t.needsHillshadePrepare=!0;var i=e.tileID.canonical.x-t.tileID.canonical.x,o=e.tileID.canonical.y-t.tileID.canonical.y,r=Math.pow(2,t.tileID.canonical.z),a=e.tileID.key;0===i&&0===o||Math.abs(o)>1||(Math.abs(i)>1&&(1===Math.abs(i+r)?i+=r:1===Math.abs(i-r)&&(i-=r)),e.dem&&t.dem&&(t.dem.backfillBorder(e.dem,i,o),t.neighboringTiles&&t.neighboringTiles[a]&&(t.neighboringTiles[a].backfilled=!0)));}},i.prototype.getTile=function(t){return this.getTileByID(t.key)},i.prototype.getTileByID=function(t){return this._tiles[t]},i.prototype._retainLoadedChildren=function(t,e,i,o){for(var r in this._tiles){var a=this._tiles[r];if(!(o[r]||!a.hasData()||a.tileID.overscaledZ<=e||a.tileID.overscaledZ>i)){for(var n=a.tileID;a&&a.tileID.overscaledZ>e+1;){var s=a.tileID.scaledTo(a.tileID.overscaledZ-1);(a=this._tiles[s.key])&&a.hasData()&&(n=s);}for(var l=n;l.overscaledZ>e;)if(t[(l=l.scaledTo(l.overscaledZ-1)).key]){o[n.key]=n;break}}}},i.prototype.findLoadedParent=function(t,e){if(t.key in this._loadedParentTiles){var i=this._loadedParentTiles[t.key];return i&&i.tileID.overscaledZ>=e?i:null}for(var o=t.overscaledZ-1;o>=e;o--){var r=t.scaledTo(o),a=this._getLoadedTile(r);if(a)return a}},i.prototype._getLoadedTile=function(t){var e=this._tiles[t.key];return e&&e.hasData()?e:this._cache.getByKey(t.wrapped().key)},i.prototype.updateCacheSize=function(t){var e=Math.ceil(t.width/this._source.tileSize)+1,i=Math.ceil(t.height/this._source.tileSize)+1,o=Math.floor(e*i*5),r="number"==typeof this._maxTileCacheSize?Math.min(this._maxTileCacheSize,o):o;this._cache.setMaxSize(r);},i.prototype.handleWrapJump=function(t){var e=Math.round((t-(void 0===this._prevLng?t:this._prevLng))/360);if(this._prevLng=t,e){var i={};for(var o in this._tiles){var r=this._tiles[o];r.tileID=r.tileID.unwrapTo(r.tileID.wrap+e),i[r.tileID.key]=r;}for(var a in this._tiles=i,this._timers)clearTimeout(this._timers[a]),delete this._timers[a];for(var n in this._tiles)this._setTileReloadTimer(n,this._tiles[n]);}},i.prototype.update=function(e){var o=this;if(this.transform=e,this._sourceLoaded&&!this._paused){var r;this.updateCacheSize(e),this.handleWrapJump(this.transform.center.lng),this._coveredTiles={},this.used?this._source.tileID?r=e.getVisibleUnwrappedCoordinates(this._source.tileID).map((function(e){return new t.OverscaledTileID(e.canonical.z,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y)})):(r=e.coveringTiles({tileSize:this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom,reparseOverscaled:this._source.reparseOverscaled}),this._source.hasTile&&(r=r.filter((function(t){return o._source.hasTile(t)})))):r=[];var a=e.coveringZoomLevel(this._source),n=Math.max(a-i.maxOverzooming,this._source.minzoom),s=Math.max(a+i.maxUnderzooming,this._source.minzoom),l=this._updateRetainedTiles(r,a);if(Mt(this._source.type)){for(var c={},u={},h=0,p=Object.keys(l);h<p.length;h+=1){var d=p[h],_=l[d],f=this._tiles[d];if(f&&!(f.fadeEndTime&&f.fadeEndTime<=t.browser.now())){var m=this.findLoadedParent(_,n);m&&(this._addTile(m.tileID),c[m.tileID.key]=m.tileID),u[d]=_;}}for(var g in this._retainLoadedChildren(u,a,s,l),c)l[g]||(this._coveredTiles[g]=!0,l[g]=c[g]);}for(var v in l)this._tiles[v].clearFadeHold();for(var y=0,x=t.keysDifference(this._tiles,l);y<x.length;y+=1){var b=x[y],w=this._tiles[b];w.hasSymbolBuckets&&!w.holdingForFade()?w.setHoldDuration(this.map._fadeDuration):w.hasSymbolBuckets&&!w.symbolFadeFinished()||this._removeTile(b);}this._updateLoadedParentTileCache();}},i.prototype.releaseSymbolFadeTiles=function(){for(var t in this._tiles)this._tiles[t].holdingForFade()&&this._removeTile(t);},i.prototype._updateRetainedTiles=function(t,e){for(var o={},r={},a=Math.max(e-i.maxOverzooming,this._source.minzoom),n=Math.max(e+i.maxUnderzooming,this._source.minzoom),s={},l=0,c=t;l<c.length;l+=1){var u=c[l],h=this._addTile(u);o[u.key]=u,h.hasData()||e<this._source.maxzoom&&(s[u.key]=u);}this._retainLoadedChildren(s,e,n,o);for(var p=0,d=t;p<d.length;p+=1){var _=d[p],f=this._tiles[_.key];if(!f.hasData()){if(e+1>this._source.maxzoom){var m=_.children(this._source.maxzoom)[0],g=this.getTile(m);if(g&&g.hasData()){o[m.key]=m;continue}}else {var v=_.children(this._source.maxzoom);if(o[v[0].key]&&o[v[1].key]&&o[v[2].key]&&o[v[3].key])continue}for(var y=f.wasRequested(),x=_.overscaledZ-1;x>=a;--x){var b=_.scaledTo(x);if(r[b.key])break;if(r[b.key]=!0,!(f=this.getTile(b))&&y&&(f=this._addTile(b)),f&&(o[b.key]=b,y=f.wasRequested(),f.hasData()))break}}}return o},i.prototype._updateLoadedParentTileCache=function(){for(var t in this._loadedParentTiles={},this._tiles){for(var e=[],i=void 0,o=this._tiles[t].tileID;o.overscaledZ>0;){if(o.key in this._loadedParentTiles){i=this._loadedParentTiles[o.key];break}e.push(o.key);var r=o.scaledTo(o.overscaledZ-1);if(i=this._getLoadedTile(r))break;o=r;}for(var a=0,n=e;a<n.length;a+=1)this._loadedParentTiles[n[a]]=i;}},i.prototype._addTile=function(e){var i=this._tiles[e.key];if(i)return i;(i=this._cache.getAndRemove(e))&&(this._setTileReloadTimer(e.key,i),i.tileID=e,this._state.initializeTileState(i,this.map?this.map.painter:null),this._cacheTimers[e.key]&&(clearTimeout(this._cacheTimers[e.key]),delete this._cacheTimers[e.key],this._setTileReloadTimer(e.key,i)));var o=Boolean(i);return o||(i=new t.Tile(e,this._source.tileSize*e.overscaleFactor()),this._loadTile(i,this._tileLoaded.bind(this,i,e.key,i.state))),i?(i.uses++,this._tiles[e.key]=i,o||this._source.fire(new t.Event("dataloading",{tile:i,coord:i.tileID,dataType:"source"})),i):null},i.prototype._setTileReloadTimer=function(t,e){var i=this;t in this._timers&&(clearTimeout(this._timers[t]),delete this._timers[t]);var o=e.getExpiryTimeout();o&&(this._timers[t]=setTimeout((function(){i._reloadTile(t,"expired"),delete i._timers[t];}),o));},i.prototype._removeTile=function(t){var e=this._tiles[t];e&&(e.uses--,delete this._tiles[t],this._timers[t]&&(clearTimeout(this._timers[t]),delete this._timers[t]),e.uses>0||(e.hasData()&&"reloading"!==e.state?this._cache.add(e.tileID,e,e.getExpiryTimeout()):(e.aborted=!0,this._abortTile(e),this._unloadTile(e))));},i.prototype.clearTiles=function(){for(var t in this._shouldReloadOnResume=!1,this._paused=!1,this._tiles)this._removeTile(t);this._cache.reset();},i.prototype.tilesIn=function(e,i,o){var r=this,a=[],n=this.transform;if(!n)return a;for(var s=o?n.getCameraQueryGeometry(e):e,l=e.map((function(t){return n.pointCoordinate(t)})),c=s.map((function(t){return n.pointCoordinate(t)})),u=this.getIds(),h=1/0,p=1/0,d=-1/0,_=-1/0,f=0,m=c;f<m.length;f+=1){var g=m[f];h=Math.min(h,g.x),p=Math.min(p,g.y),d=Math.max(d,g.x),_=Math.max(_,g.y);}for(var v=function(e){var o=r._tiles[u[e]];if(!o.holdingForFade()){var s=o.tileID,f=Math.pow(2,n.zoom-o.tileID.overscaledZ),m=i*o.queryPadding*t.EXTENT/o.tileSize/f,g=[s.getTilePoint(new t.MercatorCoordinate(h,p)),s.getTilePoint(new t.MercatorCoordinate(d,_))];if(g[0].x-m<t.EXTENT&&g[0].y-m<t.EXTENT&&g[1].x+m>=0&&g[1].y+m>=0){var v=l.map((function(t){return s.getTilePoint(t)})),y=c.map((function(t){return s.getTilePoint(t)}));a.push({tile:o,tileID:s,queryGeometry:v,cameraQueryGeometry:y,scale:f});}}},y=0;y<u.length;y++)v(y);return a},i.prototype.getVisibleCoordinates=function(t){for(var e=this,i=this.getRenderableIds(t).map((function(t){return e._tiles[t].tileID})),o=0,r=i;o<r.length;o+=1){var a=r[o];a.posMatrix=this.transform.calculatePosMatrix(a.toUnwrapped());}return i},i.prototype.hasTransition=function(){if(this._source.hasTransition())return !0;if(Mt(this._source.type))for(var e in this._tiles){var i=this._tiles[e];if(void 0!==i.fadeEndTime&&i.fadeEndTime>=t.browser.now())return !0}return !1},i.prototype.setFeatureState=function(t,e,i){this._state.updateState(t=t||"_geojsonTileLayer",e,i);},i.prototype.removeFeatureState=function(t,e,i){this._state.removeFeatureState(t=t||"_geojsonTileLayer",e,i);},i.prototype.getFeatureState=function(t,e){return this._state.getState(t=t||"_geojsonTileLayer",e)},i.prototype.setDependencies=function(t,e,i){var o=this._tiles[t];o&&o.setDependencies(e,i);},i.prototype.reloadTilesForDependencies=function(t,e){for(var i in this._tiles)this._tiles[i].hasDependency(t,e)&&this._reloadTile(i,"reloading");this._cache.filter((function(i){return !i.hasDependency(t,e)}));},i}(t.Evented);function At(t,e){var i=Math.abs(2*t.wrap)-+(t.wrap<0),o=Math.abs(2*e.wrap)-+(e.wrap<0);return t.overscaledZ-e.overscaledZ||o-i||e.canonical.y-t.canonical.y||e.canonical.x-t.canonical.x}function Mt(t){return "raster"===t||"image"===t||"video"===t}function Lt(){return new t.window.Worker(Kr.workerUrl)}Dt.maxOverzooming=10,Dt.maxUnderzooming=3;var Rt="mapboxgl_preloaded_worker_pool",kt=function(){this.active={};};kt.prototype.acquire=function(t){if(!this.workers)for(this.workers=[];this.workers.length<kt.workerCount;)this.workers.push(new Lt);return this.active[t]=!0,this.workers.slice()},kt.prototype.release=function(t){delete this.active[t],0===this.numActive()&&(this.workers.forEach((function(t){t.terminate();})),this.workers=null);},kt.prototype.isPreloaded=function(){return !!this.active[Rt]},kt.prototype.numActive=function(){return Object.keys(this.active).length};var Bt,Ot=Math.floor(t.browser.hardwareConcurrency/2);function Ft(){return Bt||(Bt=new kt),Bt}function Ut(e,i){var o={};for(var r in e)"ref"!==r&&(o[r]=e[r]);return t.refProperties.forEach((function(t){t in i&&(o[t]=i[t]);})),o}function Nt(t){t=t.slice();for(var e=Object.create(null),i=0;i<t.length;i++)e[t[i].id]=t[i];for(var o=0;o<t.length;o++)"ref"in t[o]&&(t[o]=Ut(t[o],e[t[o].ref]));return t}kt.workerCount=Math.max(Math.min(Ot,6),1);var Zt={setStyle:"setStyle",addLayer:"addLayer",removeLayer:"removeLayer",setPaintProperty:"setPaintProperty",setLayoutProperty:"setLayoutProperty",setFilter:"setFilter",addSource:"addSource",removeSource:"removeSource",setGeoJSONSourceData:"setGeoJSONSourceData",setLayerZoomRange:"setLayerZoomRange",setLayerProperty:"setLayerProperty",setCenter:"setCenter",setZoom:"setZoom",setBearing:"setBearing",setPitch:"setPitch",setSprite:"setSprite",setGlyphs:"setGlyphs",setTransition:"setTransition",setLight:"setLight"};function qt(t,e,i){i.push({command:Zt.addSource,args:[t,e[t]]});}function jt(t,e,i){e.push({command:Zt.removeSource,args:[t]}),i[t]=!0;}function Vt(t,e,i,o){jt(t,i,o),qt(t,e,i);}function Gt(e,i,o){var r;for(r in e[o])if(e[o].hasOwnProperty(r)&&"data"!==r&&!t.deepEqual(e[o][r],i[o][r]))return !1;for(r in i[o])if(i[o].hasOwnProperty(r)&&"data"!==r&&!t.deepEqual(e[o][r],i[o][r]))return !1;return !0}function Wt(e,i,o,r,a,n){var s;for(s in i=i||{},e=e||{})e.hasOwnProperty(s)&&(t.deepEqual(e[s],i[s])||o.push({command:n,args:[r,s,i[s],a]}));for(s in i)i.hasOwnProperty(s)&&!e.hasOwnProperty(s)&&(t.deepEqual(e[s],i[s])||o.push({command:n,args:[r,s,i[s],a]}));}function Xt(t){return t.id}function Ht(t,e){return t[e.id]=e,t}var Kt=function(t,e){this.reset(t,e);};Kt.prototype.reset=function(t,e){this.points=t||[],this._distances=[0];for(var i=1;i<this.points.length;i++)this._distances[i]=this._distances[i-1]+this.points[i].dist(this.points[i-1]);this.length=this._distances[this._distances.length-1],this.padding=Math.min(e||0,.5*this.length),this.paddedLength=this.length-2*this.padding;},Kt.prototype.lerp=function(e){if(1===this.points.length)return this.points[0];e=t.clamp(e,0,1);for(var i=1,o=this._distances[i],r=e*this.paddedLength+this.padding;o<r&&i<this._distances.length;)o=this._distances[++i];var a=i-1,n=this._distances[a],s=o-n,l=s>0?(r-n)/s:0;return this.points[a].mult(1-l).add(this.points[i].mult(l))};var Yt=function(t,e,i){var o=this.boxCells=[],r=this.circleCells=[];this.xCellCount=Math.ceil(t/i),this.yCellCount=Math.ceil(e/i);for(var a=0;a<this.xCellCount*this.yCellCount;a++)o.push([]),r.push([]);this.circleKeys=[],this.boxKeys=[],this.bboxes=[],this.circles=[],this.width=t,this.height=e,this.xScale=this.xCellCount/t,this.yScale=this.yCellCount/e,this.boxUid=0,this.circleUid=0;};function Jt(e,i,o,r,a){var n=t.create();return i?(t.scale(n,n,[1/a,1/a,1]),o||t.rotateZ(n,n,r.angle)):t.multiply(n,r.labelPlaneMatrix,e),n}function Qt(e,i,o,r,a){if(i){var n=t.clone(e);return t.scale(n,n,[a,a,1]),o||t.rotateZ(n,n,-r.angle),n}return r.glCoordMatrix}function $t(e,i){var o=[e.x,e.y,0,1];ue(o,o,i);var r=o[3];return {point:new t.Point(o[0]/r,o[1]/r),signedDistanceFromCamera:r}}function te(t,e){return .5+t/e*.5}function ee(t,e){var i=t[0]/t[3],o=t[1]/t[3];return i>=-e[0]&&i<=e[0]&&o>=-e[1]&&o<=e[1]}function ie(e,i,o,r,a,n,s,l){var c=r?e.textSizeData:e.iconSizeData,u=t.evaluateSizeForZoom(c,o.transform.zoom),h=[256/o.width*2+1,256/o.height*2+1],p=r?e.text.dynamicLayoutVertexArray:e.icon.dynamicLayoutVertexArray;p.clear();for(var d=e.lineVertexArray,_=r?e.text.placedSymbolArray:e.icon.placedSymbolArray,f=o.transform.width/o.transform.height,m=!1,g=0;g<_.length;g++){var v=_.get(g);if(v.hidden||v.writingMode===t.WritingMode.vertical&&!m)ce(v.numGlyphs,p);else {m=!1;var y=[v.anchorX,v.anchorY,0,1];if(t.transformMat4(y,y,i),ee(y,h)){var x=te(o.transform.cameraToCenterDistance,y[3]),b=t.evaluateSizeForFeature(c,u,v),w=s?b/x:b*x,T=new t.Point(v.anchorX,v.anchorY),E=$t(T,a).point,I={},P=ae(v,w,!1,l,i,a,n,e.glyphOffsetArray,d,p,E,T,I,f);m=P.useVertical,(P.notEnoughRoom||m||P.needsFlipping&&ae(v,w,!0,l,i,a,n,e.glyphOffsetArray,d,p,E,T,I,f).notEnoughRoom)&&ce(v.numGlyphs,p);}else ce(v.numGlyphs,p);}}r?e.text.dynamicLayoutVertexBuffer.updateData(p):e.icon.dynamicLayoutVertexBuffer.updateData(p);}function oe(t,e,i,o,r,a,n,s,l,c,u){var h=s.glyphStartIndex+s.numGlyphs,p=s.lineStartIndex,d=s.lineStartIndex+s.lineLength,_=e.getoffsetX(s.glyphStartIndex),f=e.getoffsetX(h-1),m=se(t*_,i,o,r,a,n,s.segment,p,d,l,c,u);if(!m)return null;var g=se(t*f,i,o,r,a,n,s.segment,p,d,l,c,u);return g?{first:m,last:g}:null}function re(e,i,o,r){return e===t.WritingMode.horizontal&&Math.abs(o.y-i.y)>Math.abs(o.x-i.x)*r?{useVertical:!0}:(e===t.WritingMode.vertical?i.y<o.y:i.x>o.x)?{needsFlipping:!0}:null}function ae(e,i,o,r,a,n,s,l,c,u,h,p,d,_){var f,m=i/24,g=e.lineOffsetX*m,v=e.lineOffsetY*m;if(e.numGlyphs>1){var y=e.glyphStartIndex+e.numGlyphs,x=e.lineStartIndex,b=e.lineStartIndex+e.lineLength,w=oe(m,l,g,v,o,h,p,e,c,n,d);if(!w)return {notEnoughRoom:!0};var T=$t(w.first.point,s).point,E=$t(w.last.point,s).point;if(r&&!o){var I=re(e.writingMode,T,E,_);if(I)return I}f=[w.first];for(var P=e.glyphStartIndex+1;P<y-1;P++)f.push(se(m*l.getoffsetX(P),g,v,o,h,p,e.segment,x,b,c,n,d));f.push(w.last);}else {if(r&&!o){var S=$t(p,a).point,C=e.lineStartIndex+e.segment+1,z=new t.Point(c.getx(C),c.gety(C)),D=$t(z,a),A=D.signedDistanceFromCamera>0?D.point:ne(p,z,S,1,a),M=re(e.writingMode,S,A,_);if(M)return M}var L=se(m*l.getoffsetX(e.glyphStartIndex),g,v,o,h,p,e.segment,e.lineStartIndex,e.lineStartIndex+e.lineLength,c,n,d);if(!L)return {notEnoughRoom:!0};f=[L];}for(var R=0,k=f;R<k.length;R+=1){var B=k[R];t.addDynamicAttributes(u,B.point,B.angle);}return {}}function ne(t,e,i,o,r){var a=$t(t.add(t.sub(e)._unit()),r).point,n=i.sub(a);return i.add(n._mult(o/n.mag()))}function se(e,i,o,r,a,n,s,l,c,u,h,p){var d=r?e-i:e+i,_=d>0?1:-1,f=0;r&&(_*=-1,f=Math.PI),_<0&&(f+=Math.PI);for(var m=_>0?l+s:l+s+1,g=a,v=a,y=0,x=0,b=Math.abs(d),w=[];y+x<=b;){if((m+=_)<l||m>=c)return null;if(v=g,w.push(g),void 0===(g=p[m])){var T=new t.Point(u.getx(m),u.gety(m)),E=$t(T,h);if(E.signedDistanceFromCamera>0)g=p[m]=E.point;else {var I=m-_;g=ne(0===y?n:new t.Point(u.getx(I),u.gety(I)),T,v,b-y+1,h);}}y+=x,x=v.dist(g);}var P=(b-y)/x,S=g.sub(v),C=S.mult(P)._add(v);C._add(S._unit()._perp()._mult(o*_));var z=f+Math.atan2(g.y-v.y,g.x-v.x);return w.push(C),{point:C,angle:z,path:w}}Yt.prototype.keysLength=function(){return this.boxKeys.length+this.circleKeys.length},Yt.prototype.insert=function(t,e,i,o,r){this._forEachCell(e,i,o,r,this._insertBoxCell,this.boxUid++),this.boxKeys.push(t),this.bboxes.push(e),this.bboxes.push(i),this.bboxes.push(o),this.bboxes.push(r);},Yt.prototype.insertCircle=function(t,e,i,o){this._forEachCell(e-o,i-o,e+o,i+o,this._insertCircleCell,this.circleUid++),this.circleKeys.push(t),this.circles.push(e),this.circles.push(i),this.circles.push(o);},Yt.prototype._insertBoxCell=function(t,e,i,o,r,a){this.boxCells[r].push(a);},Yt.prototype._insertCircleCell=function(t,e,i,o,r,a){this.circleCells[r].push(a);},Yt.prototype._query=function(t,e,i,o,r,a){if(i<0||t>this.width||o<0||e>this.height)return !r&&[];var n=[];if(t<=0&&e<=0&&this.width<=i&&this.height<=o){if(r)return !0;for(var s=0;s<this.boxKeys.length;s++)n.push({key:this.boxKeys[s],x1:this.bboxes[4*s],y1:this.bboxes[4*s+1],x2:this.bboxes[4*s+2],y2:this.bboxes[4*s+3]});for(var l=0;l<this.circleKeys.length;l++){var c=this.circles[3*l],u=this.circles[3*l+1],h=this.circles[3*l+2];n.push({key:this.circleKeys[l],x1:c-h,y1:u-h,x2:c+h,y2:u+h});}return a?n.filter(a):n}return this._forEachCell(t,e,i,o,this._queryCell,n,{hitTest:r,seenUids:{box:{},circle:{}}},a),r?n.length>0:n},Yt.prototype._queryCircle=function(t,e,i,o,r){var a=t-i,n=t+i,s=e-i,l=e+i;if(n<0||a>this.width||l<0||s>this.height)return !o&&[];var c=[];return this._forEachCell(a,s,n,l,this._queryCellCircle,c,{hitTest:o,circle:{x:t,y:e,radius:i},seenUids:{box:{},circle:{}}},r),o?c.length>0:c},Yt.prototype.query=function(t,e,i,o,r){return this._query(t,e,i,o,!1,r)},Yt.prototype.hitTest=function(t,e,i,o,r){return this._query(t,e,i,o,!0,r)},Yt.prototype.hitTestCircle=function(t,e,i,o){return this._queryCircle(t,e,i,!0,o)},Yt.prototype._queryCell=function(t,e,i,o,r,a,n,s){var l=n.seenUids,c=this.boxCells[r];if(null!==c)for(var u=this.bboxes,h=0,p=c;h<p.length;h+=1){var d=p[h];if(!l.box[d]){l.box[d]=!0;var _=4*d;if(t<=u[_+2]&&e<=u[_+3]&&i>=u[_+0]&&o>=u[_+1]&&(!s||s(this.boxKeys[d]))){if(n.hitTest)return a.push(!0),!0;a.push({key:this.boxKeys[d],x1:u[_],y1:u[_+1],x2:u[_+2],y2:u[_+3]});}}}var f=this.circleCells[r];if(null!==f)for(var m=this.circles,g=0,v=f;g<v.length;g+=1){var y=v[g];if(!l.circle[y]){l.circle[y]=!0;var x=3*y;if(this._circleAndRectCollide(m[x],m[x+1],m[x+2],t,e,i,o)&&(!s||s(this.circleKeys[y]))){if(n.hitTest)return a.push(!0),!0;var b=m[x],w=m[x+1],T=m[x+2];a.push({key:this.circleKeys[y],x1:b-T,y1:w-T,x2:b+T,y2:w+T});}}}},Yt.prototype._queryCellCircle=function(t,e,i,o,r,a,n,s){var l=n.circle,c=n.seenUids,u=this.boxCells[r];if(null!==u)for(var h=this.bboxes,p=0,d=u;p<d.length;p+=1){var _=d[p];if(!c.box[_]){c.box[_]=!0;var f=4*_;if(this._circleAndRectCollide(l.x,l.y,l.radius,h[f+0],h[f+1],h[f+2],h[f+3])&&(!s||s(this.boxKeys[_])))return a.push(!0),!0}}var m=this.circleCells[r];if(null!==m)for(var g=this.circles,v=0,y=m;v<y.length;v+=1){var x=y[v];if(!c.circle[x]){c.circle[x]=!0;var b=3*x;if(this._circlesCollide(g[b],g[b+1],g[b+2],l.x,l.y,l.radius)&&(!s||s(this.circleKeys[x])))return a.push(!0),!0}}},Yt.prototype._forEachCell=function(t,e,i,o,r,a,n,s){for(var l=this._convertToXCellCoord(t),c=this._convertToYCellCoord(e),u=this._convertToXCellCoord(i),h=this._convertToYCellCoord(o),p=l;p<=u;p++)for(var d=c;d<=h;d++)if(r.call(this,t,e,i,o,this.xCellCount*d+p,a,n,s))return},Yt.prototype._convertToXCellCoord=function(t){return Math.max(0,Math.min(this.xCellCount-1,Math.floor(t*this.xScale)))},Yt.prototype._convertToYCellCoord=function(t){return Math.max(0,Math.min(this.yCellCount-1,Math.floor(t*this.yScale)))},Yt.prototype._circlesCollide=function(t,e,i,o,r,a){var n=o-t,s=r-e,l=i+a;return l*l>n*n+s*s},Yt.prototype._circleAndRectCollide=function(t,e,i,o,r,a,n){var s=(a-o)/2,l=Math.abs(t-(o+s));if(l>s+i)return !1;var c=(n-r)/2,u=Math.abs(e-(r+c));if(u>c+i)return !1;if(l<=s||u<=c)return !0;var h=l-s,p=u-c;return h*h+p*p<=i*i};var le=new Float32Array([-1/0,-1/0,0,-1/0,-1/0,0,-1/0,-1/0,0,-1/0,-1/0,0]);function ce(t,e){for(var i=0;i<t;i++){var o=e.length;e.resize(o+4),e.float32.set(le,3*o);}}function ue(t,e,i){var o=e[0],r=e[1];return t[0]=i[0]*o+i[4]*r+i[12],t[1]=i[1]*o+i[5]*r+i[13],t[3]=i[3]*o+i[7]*r+i[15],t}var he=function(t,e,i){void 0===e&&(e=new Yt(t.width+200,t.height+200,25)),void 0===i&&(i=new Yt(t.width+200,t.height+200,25)),this.transform=t,this.grid=e,this.ignoredGrid=i,this.pitchfactor=Math.cos(t._pitch)*t.cameraToCenterDistance,this.screenRightBoundary=t.width+100,this.screenBottomBoundary=t.height+100,this.gridRightBoundary=t.width+200,this.gridBottomBoundary=t.height+200;};function pe(e,i,o){return i*(t.EXTENT/(e.tileSize*Math.pow(2,o-e.tileID.overscaledZ)))}he.prototype.placeCollisionBox=function(t,e,i,o,r){var a=this.projectAndGetPerspectiveRatio(o,t.anchorPointX,t.anchorPointY),n=i*a.perspectiveRatio,s=t.x1*n+a.point.x,l=t.y1*n+a.point.y,c=t.x2*n+a.point.x,u=t.y2*n+a.point.y;return !this.isInsideGrid(s,l,c,u)||!e&&this.grid.hitTest(s,l,c,u,r)?{box:[],offscreen:!1}:{box:[s,l,c,u],offscreen:this.isOffscreen(s,l,c,u)}},he.prototype.placeCollisionCircles=function(e,i,o,r,a,n,s,l,c,u,h,p,d){var _=[],f=new t.Point(i.anchorX,i.anchorY),m=$t(f,n),g=te(this.transform.cameraToCenterDistance,m.signedDistanceFromCamera),v=(u?a/g:a*g)/t.ONE_EM,y=$t(f,s).point,x=oe(v,r,i.lineOffsetX*v,i.lineOffsetY*v,!1,y,f,i,o,s,{}),b=!1,w=!1,T=!0;if(x){for(var E=.5*p*g+d,I=new t.Point(-100,-100),P=new t.Point(this.screenRightBoundary,this.screenBottomBoundary),S=new Kt,C=x.first,z=x.last,D=[],A=C.path.length-1;A>=1;A--)D.push(C.path[A]);for(var M=1;M<z.path.length;M++)D.push(z.path[M]);var L=2.5*E;if(l){var R=D.map((function(t){return $t(t,l)}));D=R.some((function(t){return t.signedDistanceFromCamera<=0}))?[]:R.map((function(t){return t.point}));}var k=[];if(D.length>0){for(var B=D[0].clone(),O=D[0].clone(),F=1;F<D.length;F++)B.x=Math.min(B.x,D[F].x),B.y=Math.min(B.y,D[F].y),O.x=Math.max(O.x,D[F].x),O.y=Math.max(O.y,D[F].y);k=B.x>=I.x&&O.x<=P.x&&B.y>=I.y&&O.y<=P.y?[D]:O.x<I.x||B.x>P.x||O.y<I.y||B.y>P.y?[]:t.clipLine([D],I.x,I.y,P.x,P.y);}for(var U=0,N=k;U<N.length;U+=1){var Z;S.reset(N[U],.25*E),Z=S.length<=.5*E?1:Math.ceil(S.paddedLength/L)+1;for(var q=0;q<Z;q++){var j=q/Math.max(Z-1,1),V=S.lerp(j),G=V.x+100,W=V.y+100;_.push(G,W,E,0);var X=G-E,H=W-E,K=G+E,Y=W+E;if(T=T&&this.isOffscreen(X,H,K,Y),w=w||this.isInsideGrid(X,H,K,Y),!e&&this.grid.hitTestCircle(G,W,E,h)&&(b=!0,!c))return {circles:[],offscreen:!1,collisionDetected:b}}}}return {circles:!c&&b||!w?[]:_,offscreen:T,collisionDetected:b}},he.prototype.queryRenderedSymbols=function(e){if(0===e.length||0===this.grid.keysLength()&&0===this.ignoredGrid.keysLength())return {};for(var i=[],o=1/0,r=1/0,a=-1/0,n=-1/0,s=0,l=e;s<l.length;s+=1){var c=l[s],u=new t.Point(c.x+100,c.y+100);o=Math.min(o,u.x),r=Math.min(r,u.y),a=Math.max(a,u.x),n=Math.max(n,u.y),i.push(u);}for(var h={},p={},d=0,_=this.grid.query(o,r,a,n).concat(this.ignoredGrid.query(o,r,a,n));d<_.length;d+=1){var f=_[d],m=f.key;if(void 0===h[m.bucketInstanceId]&&(h[m.bucketInstanceId]={}),!h[m.bucketInstanceId][m.featureIndex]){var g=[new t.Point(f.x1,f.y1),new t.Point(f.x2,f.y1),new t.Point(f.x2,f.y2),new t.Point(f.x1,f.y2)];t.polygonIntersectsPolygon(i,g)&&(h[m.bucketInstanceId][m.featureIndex]=!0,void 0===p[m.bucketInstanceId]&&(p[m.bucketInstanceId]=[]),p[m.bucketInstanceId].push(m.featureIndex));}}return p},he.prototype.insertCollisionBox=function(t,e,i,o,r){(e?this.ignoredGrid:this.grid).insert({bucketInstanceId:i,featureIndex:o,collisionGroupID:r},t[0],t[1],t[2],t[3]);},he.prototype.insertCollisionCircles=function(t,e,i,o,r){for(var a=e?this.ignoredGrid:this.grid,n={bucketInstanceId:i,featureIndex:o,collisionGroupID:r},s=0;s<t.length;s+=4)a.insertCircle(n,t[s],t[s+1],t[s+2]);},he.prototype.projectAndGetPerspectiveRatio=function(e,i,o){var r=[i,o,0,1];return ue(r,r,e),{point:new t.Point((r[0]/r[3]+1)/2*this.transform.width+100,(-r[1]/r[3]+1)/2*this.transform.height+100),perspectiveRatio:.5+this.transform.cameraToCenterDistance/r[3]*.5}},he.prototype.isOffscreen=function(t,e,i,o){return i<100||t>=this.screenRightBoundary||o<100||e>this.screenBottomBoundary},he.prototype.isInsideGrid=function(t,e,i,o){return i>=0&&t<this.gridRightBoundary&&o>=0&&e<this.gridBottomBoundary},he.prototype.getViewportMatrix=function(){var e=t.identity([]);return t.translate(e,e,[-100,-100,0]),e};var de=function(t,e,i,o){this.opacity=t?Math.max(0,Math.min(1,t.opacity+(t.placed?e:-e))):o&&i?1:0,this.placed=i;};de.prototype.isHidden=function(){return 0===this.opacity&&!this.placed};var _e=function(t,e,i,o,r){this.text=new de(t?t.text:null,e,i,r),this.icon=new de(t?t.icon:null,e,o,r);};_e.prototype.isHidden=function(){return this.text.isHidden()&&this.icon.isHidden()};var fe=function(t,e,i){this.text=t,this.icon=e,this.skipFade=i;},me=function(){this.invProjMatrix=t.create(),this.viewportMatrix=t.create(),this.circles=[];},ge=function(t,e,i,o,r){this.bucketInstanceId=t,this.featureIndex=e,this.sourceLayerIndex=i,this.bucketIndex=o,this.tileID=r;},ve=function(t){this.crossSourceCollisions=t,this.maxGroupID=0,this.collisionGroups={};};function ye(e,i,o,r,a){var n=t.getAnchorAlignment(e),s=-(n.horizontalAlign-.5)*i,l=-(n.verticalAlign-.5)*o,c=t.evaluateVariableOffset(e,r);return new t.Point(s+c[0]*a,l+c[1]*a)}function xe(e,i,o,r,a,n){var s=e.x1,l=e.x2,c=e.y1,u=e.y2,h=e.anchorPointX,p=e.anchorPointY,d=new t.Point(i,o);return r&&d._rotate(a?n:-n),{x1:s+d.x,y1:c+d.y,x2:l+d.x,y2:u+d.y,anchorPointX:h,anchorPointY:p}}ve.prototype.get=function(t){if(this.crossSourceCollisions)return {ID:0,predicate:null};if(!this.collisionGroups[t]){var e=++this.maxGroupID;this.collisionGroups[t]={ID:e,predicate:function(t){return t.collisionGroupID===e}};}return this.collisionGroups[t]};var be=function(t,e,i,o){this.transform=t.clone(),this.collisionIndex=new he(this.transform),this.placements={},this.opacities={},this.variableOffsets={},this.stale=!1,this.commitTime=0,this.fadeDuration=e,this.retainedQueryData={},this.collisionGroups=new ve(i),this.collisionCircleArrays={},this.prevPlacement=o,o&&(o.prevPlacement=void 0),this.placedOrientations={};};function we(t,e,i,o,r){t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0);}be.prototype.getBucketParts=function(e,i,o,r){var a=o.getBucket(i),n=o.latestFeatureIndex;if(a&&n&&i.id===a.layerIds[0]){var s=o.collisionBoxArray,l=a.layers[0].layout,c=Math.pow(2,this.transform.zoom-o.tileID.overscaledZ),u=o.tileSize/t.EXTENT,h=this.transform.calculatePosMatrix(o.tileID.toUnwrapped()),p="map"===l.get("text-pitch-alignment"),d="map"===l.get("text-rotation-alignment"),_=pe(o,1,this.transform.zoom),f=Jt(h,p,d,this.transform,_),m=null;if(p){var g=Qt(h,p,d,this.transform,_);m=t.multiply([],this.transform.labelPlaneMatrix,g);}this.retainedQueryData[a.bucketInstanceId]=new ge(a.bucketInstanceId,n,a.sourceLayerIndex,a.index,o.tileID);var v={bucket:a,layout:l,posMatrix:h,textLabelPlaneMatrix:f,labelToScreenMatrix:m,scale:c,textPixelRatio:u,holdingForFade:o.holdingForFade(),collisionBoxArray:s,partiallyEvaluatedTextSize:t.evaluateSizeForZoom(a.textSizeData,this.transform.zoom),collisionGroup:this.collisionGroups.get(a.sourceID)};if(r)for(var y=0,x=a.sortKeyRanges;y<x.length;y+=1){var b=x[y];e.push({sortKey:b.sortKey,symbolInstanceStart:b.symbolInstanceStart,symbolInstanceEnd:b.symbolInstanceEnd,parameters:v});}else e.push({symbolInstanceStart:0,symbolInstanceEnd:a.symbolInstances.length,parameters:v});}},be.prototype.attemptAnchorPlacement=function(t,e,i,o,r,a,n,s,l,c,u,h,p,d,_){var f,m=[h.textOffset0,h.textOffset1],g=ye(t,i,o,m,r),v=this.collisionIndex.placeCollisionBox(xe(e,g.x,g.y,a,n,this.transform.angle),u,s,l,c.predicate);if(!_||0!==this.collisionIndex.placeCollisionBox(xe(_,g.x,g.y,a,n,this.transform.angle),u,s,l,c.predicate).box.length)return v.box.length>0?(this.prevPlacement&&this.prevPlacement.variableOffsets[h.crossTileID]&&this.prevPlacement.placements[h.crossTileID]&&this.prevPlacement.placements[h.crossTileID].text&&(f=this.prevPlacement.variableOffsets[h.crossTileID].anchor),this.variableOffsets[h.crossTileID]={textOffset:m,width:i,height:o,anchor:t,textBoxScale:r,prevAnchor:f},this.markUsedJustification(p,t,h,d),p.allowVerticalPlacement&&(this.markUsedOrientation(p,d,h),this.placedOrientations[h.crossTileID]=d),{shift:g,placedGlyphBoxes:v}):void 0},be.prototype.placeLayerBucketPart=function(e,i,o){var r=this,a=e.parameters,n=a.bucket,s=a.layout,l=a.posMatrix,c=a.textLabelPlaneMatrix,u=a.labelToScreenMatrix,h=a.textPixelRatio,p=a.holdingForFade,d=a.collisionBoxArray,_=a.partiallyEvaluatedTextSize,f=a.collisionGroup,m=s.get("text-optional"),g=s.get("icon-optional"),v=s.get("text-allow-overlap"),y=s.get("icon-allow-overlap"),x="map"===s.get("text-rotation-alignment"),b="map"===s.get("text-pitch-alignment"),w="none"!==s.get("icon-text-fit"),T="viewport-y"===s.get("symbol-z-order"),E=v&&(y||!n.hasIconData()||g),I=y&&(v||!n.hasTextData()||m);!n.collisionArrays&&d&&n.deserializeCollisionBoxes(d);var P=function(e,a){if(!i[e.crossTileID])if(p)r.placements[e.crossTileID]=new fe(!1,!1,!1);else {var d,T=!1,P=!1,S=!0,C=null,z={box:null,offscreen:null},D={box:null,offscreen:null},A=null,M=null,L=0,R=0,k=0;a.textFeatureIndex?L=a.textFeatureIndex:e.useRuntimeCollisionCircles&&(L=e.featureIndex),a.verticalTextFeatureIndex&&(R=a.verticalTextFeatureIndex);var B=a.textBox;if(B){var O=function(i){var o=t.WritingMode.horizontal;if(n.allowVerticalPlacement&&!i&&r.prevPlacement){var a=r.prevPlacement.placedOrientations[e.crossTileID];a&&(r.placedOrientations[e.crossTileID]=a,r.markUsedOrientation(n,o=a,e));}return o},F=function(i,o){if(n.allowVerticalPlacement&&e.numVerticalGlyphVertices>0&&a.verticalTextBox)for(var r=0,s=n.writingModes;r<s.length&&(s[r]===t.WritingMode.vertical?(z=o(),D=z):z=i(),!(z&&z.box&&z.box.length));r+=1);else z=i();};if(s.get("text-variable-anchor")){var U=s.get("text-variable-anchor");if(r.prevPlacement&&r.prevPlacement.variableOffsets[e.crossTileID]){var N=r.prevPlacement.variableOffsets[e.crossTileID];U.indexOf(N.anchor)>0&&(U=U.filter((function(t){return t!==N.anchor}))).unshift(N.anchor);}var Z=function(t,i,o){for(var a=t.x2-t.x1,s=t.y2-t.y1,c=e.textBoxScale,u=w&&!y?i:null,p={box:[],offscreen:!1},d=v?2*U.length:U.length,_=0;_<d;++_){var m=r.attemptAnchorPlacement(U[_%U.length],t,a,s,c,x,b,h,l,f,_>=U.length,e,n,o,u);if(m&&(p=m.placedGlyphBoxes)&&p.box&&p.box.length){T=!0,C=m.shift;break}}return p};F((function(){return Z(B,a.iconBox,t.WritingMode.horizontal)}),(function(){var i=a.verticalTextBox;return n.allowVerticalPlacement&&!(z&&z.box&&z.box.length)&&e.numVerticalGlyphVertices>0&&i?Z(i,a.verticalIconBox,t.WritingMode.vertical):{box:null,offscreen:null}})),z&&(T=z.box,S=z.offscreen);var q=O(z&&z.box);if(!T&&r.prevPlacement){var j=r.prevPlacement.variableOffsets[e.crossTileID];j&&(r.variableOffsets[e.crossTileID]=j,r.markUsedJustification(n,j.anchor,e,q));}}else {var V=function(t,i){var o=r.collisionIndex.placeCollisionBox(t,v,h,l,f.predicate);return o&&o.box&&o.box.length&&(r.markUsedOrientation(n,i,e),r.placedOrientations[e.crossTileID]=i),o};F((function(){return V(B,t.WritingMode.horizontal)}),(function(){var i=a.verticalTextBox;return n.allowVerticalPlacement&&e.numVerticalGlyphVertices>0&&i?V(i,t.WritingMode.vertical):{box:null,offscreen:null}})),O(z&&z.box&&z.box.length);}}if(T=(d=z)&&d.box&&d.box.length>0,S=d&&d.offscreen,e.useRuntimeCollisionCircles){var G=n.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex),W=t.evaluateSizeForFeature(n.textSizeData,_,G),X=s.get("text-padding");A=r.collisionIndex.placeCollisionCircles(v,G,n.lineVertexArray,n.glyphOffsetArray,W,l,c,u,o,b,f.predicate,e.collisionCircleDiameter,X),T=v||A.circles.length>0&&!A.collisionDetected,S=S&&A.offscreen;}if(a.iconFeatureIndex&&(k=a.iconFeatureIndex),a.iconBox){var H=function(t){var e=w&&C?xe(t,C.x,C.y,x,b,r.transform.angle):t;return r.collisionIndex.placeCollisionBox(e,y,h,l,f.predicate)};P=D&&D.box&&D.box.length&&a.verticalIconBox?(M=H(a.verticalIconBox)).box.length>0:(M=H(a.iconBox)).box.length>0,S=S&&M.offscreen;}var K=m||0===e.numHorizontalGlyphVertices&&0===e.numVerticalGlyphVertices,Y=g||0===e.numIconVertices;if(K||Y?Y?K||(P=P&&T):T=P&&T:P=T=P&&T,T&&d&&d.box&&r.collisionIndex.insertCollisionBox(d.box,s.get("text-ignore-placement"),n.bucketInstanceId,D&&D.box&&R?R:L,f.ID),P&&M&&r.collisionIndex.insertCollisionBox(M.box,s.get("icon-ignore-placement"),n.bucketInstanceId,k,f.ID),A&&(T&&r.collisionIndex.insertCollisionCircles(A.circles,s.get("text-ignore-placement"),n.bucketInstanceId,L,f.ID),o)){var J=n.bucketInstanceId,Q=r.collisionCircleArrays[J];void 0===Q&&(Q=r.collisionCircleArrays[J]=new me);for(var $=0;$<A.circles.length;$+=4)Q.circles.push(A.circles[$+0]),Q.circles.push(A.circles[$+1]),Q.circles.push(A.circles[$+2]),Q.circles.push(A.collisionDetected?1:0);}r.placements[e.crossTileID]=new fe(T||E,P||I,S||n.justReloaded),i[e.crossTileID]=!0;}};if(T)for(var S=n.getSortedSymbolIndexes(this.transform.angle),C=S.length-1;C>=0;--C){var z=S[C];P(n.symbolInstances.get(z),n.collisionArrays[z]);}else for(var D=e.symbolInstanceStart;D<e.symbolInstanceEnd;D++)P(n.symbolInstances.get(D),n.collisionArrays[D]);if(o&&n.bucketInstanceId in this.collisionCircleArrays){var A=this.collisionCircleArrays[n.bucketInstanceId];t.invert(A.invProjMatrix,l),A.viewportMatrix=this.collisionIndex.getViewportMatrix();}n.justReloaded=!1;},be.prototype.markUsedJustification=function(e,i,o,r){var a;a=r===t.WritingMode.vertical?o.verticalPlacedTextSymbolIndex:{left:o.leftJustifiedTextSymbolIndex,center:o.centerJustifiedTextSymbolIndex,right:o.rightJustifiedTextSymbolIndex}[t.getAnchorJustification(i)];for(var n=0,s=[o.leftJustifiedTextSymbolIndex,o.centerJustifiedTextSymbolIndex,o.rightJustifiedTextSymbolIndex,o.verticalPlacedTextSymbolIndex];n<s.length;n+=1){var l=s[n];l>=0&&(e.text.placedSymbolArray.get(l).crossTileID=a>=0&&l!==a?0:o.crossTileID);}},be.prototype.markUsedOrientation=function(e,i,o){for(var r=i===t.WritingMode.horizontal||i===t.WritingMode.horizontalOnly?i:0,a=i===t.WritingMode.vertical?i:0,n=0,s=[o.leftJustifiedTextSymbolIndex,o.centerJustifiedTextSymbolIndex,o.rightJustifiedTextSymbolIndex];n<s.length;n+=1)e.text.placedSymbolArray.get(s[n]).placedOrientation=r;o.verticalPlacedTextSymbolIndex&&(e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation=a);},be.prototype.commit=function(t){this.commitTime=t,this.zoomAtLastRecencyCheck=this.transform.zoom;var e=this.prevPlacement,i=!1;this.prevZoomAdjustment=e?e.zoomAdjustment(this.transform.zoom):0;var o=e?e.symbolFadeChange(t):1,r=e?e.opacities:{},a=e?e.variableOffsets:{},n=e?e.placedOrientations:{};for(var s in this.placements){var l=this.placements[s],c=r[s];c?(this.opacities[s]=new _e(c,o,l.text,l.icon),i=i||l.text!==c.text.placed||l.icon!==c.icon.placed):(this.opacities[s]=new _e(null,o,l.text,l.icon,l.skipFade),i=i||l.text||l.icon);}for(var u in r){var h=r[u];if(!this.opacities[u]){var p=new _e(h,o,!1,!1);p.isHidden()||(this.opacities[u]=p,i=i||h.text.placed||h.icon.placed);}}for(var d in a)this.variableOffsets[d]||!this.opacities[d]||this.opacities[d].isHidden()||(this.variableOffsets[d]=a[d]);for(var _ in n)this.placedOrientations[_]||!this.opacities[_]||this.opacities[_].isHidden()||(this.placedOrientations[_]=n[_]);i?this.lastPlacementChangeTime=t:"number"!=typeof this.lastPlacementChangeTime&&(this.lastPlacementChangeTime=e?e.lastPlacementChangeTime:t);},be.prototype.updateLayerOpacities=function(t,e){for(var i={},o=0,r=e;o<r.length;o+=1){var a=r[o],n=a.getBucket(t);n&&a.latestFeatureIndex&&t.id===n.layerIds[0]&&this.updateBucketOpacities(n,i,a.collisionBoxArray);}},be.prototype.updateBucketOpacities=function(e,i,o){var r=this;e.hasTextData()&&e.text.opacityVertexArray.clear(),e.hasIconData()&&e.icon.opacityVertexArray.clear(),e.hasIconCollisionBoxData()&&e.iconCollisionBox.collisionVertexArray.clear(),e.hasTextCollisionBoxData()&&e.textCollisionBox.collisionVertexArray.clear();var a=e.layers[0].layout,n=new _e(null,0,!1,!1,!0),s=a.get("text-allow-overlap"),l=a.get("icon-allow-overlap"),c=a.get("text-variable-anchor"),u="map"===a.get("text-rotation-alignment"),h="map"===a.get("text-pitch-alignment"),p="none"!==a.get("icon-text-fit"),d=new _e(null,0,s&&(l||!e.hasIconData()||a.get("icon-optional")),l&&(s||!e.hasTextData()||a.get("text-optional")),!0);!e.collisionArrays&&o&&(e.hasIconCollisionBoxData()||e.hasTextCollisionBoxData())&&e.deserializeCollisionBoxes(o);for(var _=function(t,e,i){for(var o=0;o<e/4;o++)t.opacityVertexArray.emplaceBack(i);},f=function(o){var a=e.symbolInstances.get(o),s=a.numHorizontalGlyphVertices,l=a.numVerticalGlyphVertices,f=a.crossTileID,m=r.opacities[f];i[f]?m=n:m||(r.opacities[f]=m=d),i[f]=!0;var g=a.numIconVertices>0,v=r.placedOrientations[a.crossTileID],y=v===t.WritingMode.vertical,x=v===t.WritingMode.horizontal||v===t.WritingMode.horizontalOnly;if(s>0||l>0){var b=De(m.text);_(e.text,s,y?Ae:b),_(e.text,l,x?Ae:b);var w=m.text.isHidden();[a.rightJustifiedTextSymbolIndex,a.centerJustifiedTextSymbolIndex,a.leftJustifiedTextSymbolIndex].forEach((function(t){t>=0&&(e.text.placedSymbolArray.get(t).hidden=w||y?1:0);})),a.verticalPlacedTextSymbolIndex>=0&&(e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden=w||x?1:0);var T=r.variableOffsets[a.crossTileID];T&&r.markUsedJustification(e,T.anchor,a,v);var E=r.placedOrientations[a.crossTileID];E&&(r.markUsedJustification(e,"left",a,E),r.markUsedOrientation(e,E,a));}if(g){var I=De(m.icon),P=!(p&&a.verticalPlacedIconSymbolIndex&&y);a.placedIconSymbolIndex>=0&&(_(e.icon,a.numIconVertices,P?I:Ae),e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden=m.icon.isHidden()),a.verticalPlacedIconSymbolIndex>=0&&(_(e.icon,a.numVerticalIconVertices,P?Ae:I),e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden=m.icon.isHidden());}if(e.hasIconCollisionBoxData()||e.hasTextCollisionBoxData()){var S=e.collisionArrays[o];if(S){var C=new t.Point(0,0);if(S.textBox||S.verticalTextBox){var z=!0;if(c){var D=r.variableOffsets[f];D?(C=ye(D.anchor,D.width,D.height,D.textOffset,D.textBoxScale),u&&C._rotate(h?r.transform.angle:-r.transform.angle)):z=!1;}S.textBox&&we(e.textCollisionBox.collisionVertexArray,m.text.placed,!z||y,C.x,C.y),S.verticalTextBox&&we(e.textCollisionBox.collisionVertexArray,m.text.placed,!z||x,C.x,C.y);}var A=Boolean(!x&&S.verticalIconBox);S.iconBox&&we(e.iconCollisionBox.collisionVertexArray,m.icon.placed,A,p?C.x:0,p?C.y:0),S.verticalIconBox&&we(e.iconCollisionBox.collisionVertexArray,m.icon.placed,!A,p?C.x:0,p?C.y:0);}}},m=0;m<e.symbolInstances.length;m++)f(m);if(e.sortFeatures(this.transform.angle),this.retainedQueryData[e.bucketInstanceId]&&(this.retainedQueryData[e.bucketInstanceId].featureSortOrder=e.featureSortOrder),e.hasTextData()&&e.text.opacityVertexBuffer&&e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),e.hasIconData()&&e.icon.opacityVertexBuffer&&e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),e.hasIconCollisionBoxData()&&e.iconCollisionBox.collisionVertexBuffer&&e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),e.hasTextCollisionBoxData()&&e.textCollisionBox.collisionVertexBuffer&&e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),e.bucketInstanceId in this.collisionCircleArrays){var g=this.collisionCircleArrays[e.bucketInstanceId];e.placementInvProjMatrix=g.invProjMatrix,e.placementViewportMatrix=g.viewportMatrix,e.collisionCircleArray=g.circles,delete this.collisionCircleArrays[e.bucketInstanceId];}},be.prototype.symbolFadeChange=function(t){return 0===this.fadeDuration?1:(t-this.commitTime)/this.fadeDuration+this.prevZoomAdjustment},be.prototype.zoomAdjustment=function(t){return Math.max(0,(this.transform.zoom-t)/1.5)},be.prototype.hasTransitions=function(t){return this.stale||t-this.lastPlacementChangeTime<this.fadeDuration},be.prototype.stillRecent=function(t,e){var i=this.zoomAtLastRecencyCheck===e?1-this.zoomAdjustment(e):1;return this.zoomAtLastRecencyCheck=e,this.commitTime+this.fadeDuration*i>t},be.prototype.setStale=function(){this.stale=!0;};var Te=Math.pow(2,25),Ee=Math.pow(2,24),Ie=Math.pow(2,17),Pe=Math.pow(2,16),Se=Math.pow(2,9),Ce=Math.pow(2,8),ze=Math.pow(2,1);function De(t){if(0===t.opacity&&!t.placed)return 0;if(1===t.opacity&&t.placed)return 4294967295;var e=t.placed?1:0,i=Math.floor(127*t.opacity);return i*Te+e*Ee+i*Ie+e*Pe+i*Se+e*Ce+i*ze+e}var Ae=0,Me=function(t){this._sortAcrossTiles="viewport-y"!==t.layout.get("symbol-z-order")&&void 0!==t.layout.get("symbol-sort-key").constantOr(1),this._currentTileIndex=0,this._currentPartIndex=0,this._seenCrossTileIDs={},this._bucketParts=[];};Me.prototype.continuePlacement=function(t,e,i,o,r){for(var a=this._bucketParts;this._currentTileIndex<t.length;)if(e.getBucketParts(a,o,t[this._currentTileIndex],this._sortAcrossTiles),this._currentTileIndex++,r())return !0;for(this._sortAcrossTiles&&(this._sortAcrossTiles=!1,a.sort((function(t,e){return t.sortKey-e.sortKey})));this._currentPartIndex<a.length;)if(e.placeLayerBucketPart(a[this._currentPartIndex],this._seenCrossTileIDs,i),this._currentPartIndex++,r())return !0;return !1};var Le=function(t,e,i,o,r,a,n){this.placement=new be(t,r,a,n),this._currentPlacementIndex=e.length-1,this._forceFullPlacement=i,this._showCollisionBoxes=o,this._done=!1;};Le.prototype.isDone=function(){return this._done},Le.prototype.continuePlacement=function(e,i,o){for(var r=this,a=t.browser.now(),n=function(){var e=t.browser.now()-a;return !r._forceFullPlacement&&e>2};this._currentPlacementIndex>=0;){var s=i[e[this._currentPlacementIndex]],l=this.placement.collisionIndex.transform.zoom;if("symbol"===s.type&&(!s.minzoom||s.minzoom<=l)&&(!s.maxzoom||s.maxzoom>l)){if(this._inProgressLayer||(this._inProgressLayer=new Me(s)),this._inProgressLayer.continuePlacement(o[s.source],this.placement,this._showCollisionBoxes,s,n))return;delete this._inProgressLayer;}this._currentPlacementIndex--;}this._done=!0;},Le.prototype.commit=function(t){return this.placement.commit(t),this.placement};var Re=512/t.EXTENT/2,ke=function(t,e,i){this.tileID=t,this.indexedSymbolInstances={},this.bucketInstanceId=i;for(var o=0;o<e.length;o++){var r=e.get(o),a=r.key;this.indexedSymbolInstances[a]||(this.indexedSymbolInstances[a]=[]),this.indexedSymbolInstances[a].push({crossTileID:r.crossTileID,coord:this.getScaledCoordinates(r,t)});}};ke.prototype.getScaledCoordinates=function(e,i){var o=Re/Math.pow(2,i.canonical.z-this.tileID.canonical.z);return {x:Math.floor((i.canonical.x*t.EXTENT+e.anchorX)*o),y:Math.floor((i.canonical.y*t.EXTENT+e.anchorY)*o)}},ke.prototype.findMatches=function(t,e,i){for(var o=this.tileID.canonical.z<e.canonical.z?1:Math.pow(2,this.tileID.canonical.z-e.canonical.z),r=0;r<t.length;r++){var a=t.get(r);if(!a.crossTileID){var n=this.indexedSymbolInstances[a.key];if(n)for(var s=this.getScaledCoordinates(a,e),l=0,c=n;l<c.length;l+=1){var u=c[l];if(Math.abs(u.coord.x-s.x)<=o&&Math.abs(u.coord.y-s.y)<=o&&!i[u.crossTileID]){i[u.crossTileID]=!0,a.crossTileID=u.crossTileID;break}}}}};var Be=function(){this.maxCrossTileID=0;};Be.prototype.generate=function(){return ++this.maxCrossTileID};var Oe=function(){this.indexes={},this.usedCrossTileIDs={},this.lng=0;};Oe.prototype.handleWrapJump=function(t){var e=Math.round((t-this.lng)/360);if(0!==e)for(var i in this.indexes){var o=this.indexes[i],r={};for(var a in o){var n=o[a];n.tileID=n.tileID.unwrapTo(n.tileID.wrap+e),r[n.tileID.key]=n;}this.indexes[i]=r;}this.lng=t;},Oe.prototype.addBucket=function(t,e,i){if(this.indexes[t.overscaledZ]&&this.indexes[t.overscaledZ][t.key]){if(this.indexes[t.overscaledZ][t.key].bucketInstanceId===e.bucketInstanceId)return !1;this.removeBucketCrossTileIDs(t.overscaledZ,this.indexes[t.overscaledZ][t.key]);}for(var o=0;o<e.symbolInstances.length;o++)e.symbolInstances.get(o).crossTileID=0;this.usedCrossTileIDs[t.overscaledZ]||(this.usedCrossTileIDs[t.overscaledZ]={});var r=this.usedCrossTileIDs[t.overscaledZ];for(var a in this.indexes){var n=this.indexes[a];if(Number(a)>t.overscaledZ)for(var s in n){var l=n[s];l.tileID.isChildOf(t)&&l.findMatches(e.symbolInstances,t,r);}else {var c=n[t.scaledTo(Number(a)).key];c&&c.findMatches(e.symbolInstances,t,r);}}for(var u=0;u<e.symbolInstances.length;u++){var h=e.symbolInstances.get(u);h.crossTileID||(h.crossTileID=i.generate(),r[h.crossTileID]=!0);}return void 0===this.indexes[t.overscaledZ]&&(this.indexes[t.overscaledZ]={}),this.indexes[t.overscaledZ][t.key]=new ke(t,e.symbolInstances,e.bucketInstanceId),!0},Oe.prototype.removeBucketCrossTileIDs=function(t,e){for(var i in e.indexedSymbolInstances)for(var o=0,r=e.indexedSymbolInstances[i];o<r.length;o+=1)delete this.usedCrossTileIDs[t][r[o].crossTileID];},Oe.prototype.removeStaleBuckets=function(t){var e=!1;for(var i in this.indexes){var o=this.indexes[i];for(var r in o)t[o[r].bucketInstanceId]||(this.removeBucketCrossTileIDs(i,o[r]),delete o[r],e=!0);}return e};var Fe=function(){this.layerIndexes={},this.crossTileIDs=new Be,this.maxBucketInstanceId=0,this.bucketsInCurrentPlacement={};};Fe.prototype.addLayer=function(t,e,i){var o=this.layerIndexes[t.id];void 0===o&&(o=this.layerIndexes[t.id]=new Oe);var r=!1,a={};o.handleWrapJump(i);for(var n=0,s=e;n<s.length;n+=1){var l=s[n],c=l.getBucket(t);c&&t.id===c.layerIds[0]&&(c.bucketInstanceId||(c.bucketInstanceId=++this.maxBucketInstanceId),o.addBucket(l.tileID,c,this.crossTileIDs)&&(r=!0),a[c.bucketInstanceId]=!0);}return o.removeStaleBuckets(a)&&(r=!0),r},Fe.prototype.pruneUnusedLayers=function(t){var e={};for(var i in t.forEach((function(t){e[t]=!0;})),this.layerIndexes)e[i]||delete this.layerIndexes[i];};var Ue=function(e,i){return t.emitValidationErrors(e,i&&i.filter((function(t){return "source.canvas"!==t.identifier})))},Ne=t.pick(Zt,["addLayer","removeLayer","setPaintProperty","setLayoutProperty","setFilter","addSource","removeSource","setLayerZoomRange","setLight","setTransition","setGeoJSONSourceData"]),Ze=t.pick(Zt,["setCenter","setZoom","setBearing","setPitch"]),qe=function(){var e={},i=t.styleSpec.$version;for(var o in t.styleSpec.$root){var r,a=t.styleSpec.$root[o];if(a.required)null!=(r="version"===o?i:"array"===a.type?[]:{})&&(e[o]=r);}return e}(),je=function(e){function i(o,r){var a=this;void 0===r&&(r={}),e.call(this),this.map=o,this.dispatcher=new E(Ft(),this),this.imageManager=new p,this.imageManager.setEventedParent(this),this.glyphManager=new y(o._requestManager,r.localIdeographFontFamily),this.lineAtlas=new T(256,512),this.crossTileSymbolIndex=new Fe,this._layers={},this._serializedLayers={},this._order=[],this.sourceCaches={},this.zoomHistory=new t.ZoomHistory,this._loaded=!1,this._availableImages=[],this._resetUpdates(),this.dispatcher.broadcast("setReferrer",t.getReferrer());var n=this;this._rtlTextPluginCallback=i.registerForPluginStateChange((function(e){n.dispatcher.broadcast("syncRTLPluginState",{pluginStatus:e.pluginStatus,pluginURL:e.pluginURL},(function(e,i){if(t.triggerPluginCompletionEvent(e),i&&i.every((function(t){return t})))for(var o in n.sourceCaches)n.sourceCaches[o].reload();}));})),this.on("data",(function(t){if("source"===t.dataType&&"metadata"===t.sourceDataType){var e=a.sourceCaches[t.sourceId];if(e){var i=e.getSource();if(i&&i.vectorLayerIds)for(var o in a._layers){var r=a._layers[o];r.source===i.id&&a._validateLayer(r);}}}}));}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.loadURL=function(e,i){var o=this;void 0===i&&(i={}),this.fire(new t.Event("dataloading",{dataType:"style"}));var r="boolean"==typeof i.validate?i.validate:!t.isMapboxURL(e);e=this.map._requestManager.normalizeStyleURL(e,i.accessToken);var a=this.map._requestManager.transformRequest(e,t.ResourceType.Style);this._request=t.getJSON(a,(function(e,i){o._request=null,e?o.fire(new t.ErrorEvent(e)):i&&o._load(i,r);}));},i.prototype.loadJSON=function(e,i){var o=this;void 0===i&&(i={}),this.fire(new t.Event("dataloading",{dataType:"style"})),this._request=t.browser.frame((function(){o._request=null,o._load(e,!1!==i.validate);}));},i.prototype.loadEmpty=function(){this.fire(new t.Event("dataloading",{dataType:"style"})),this._load(qe,!1);},i.prototype._load=function(e,i){if(!i||!Ue(this,t.validateStyle(e))){for(var o in this._loaded=!0,this.stylesheet=e,e.sources)this.addSource(o,e.sources[o],{validate:!1});e.sprite?this._loadSprite(e.sprite):this.imageManager.setLoaded(!0),this.glyphManager.setURL(e.glyphs);var r=Nt(this.stylesheet.layers);this._order=r.map((function(t){return t.id})),this._layers={},this._serializedLayers={};for(var a=0,n=r;a<n.length;a+=1){var s=n[a];(s=t.createStyleLayer(s)).setEventedParent(this,{layer:{id:s.id}}),this._layers[s.id]=s,this._serializedLayers[s.id]=s.serialize();}this.dispatcher.broadcast("setLayers",this._serializeLayers(this._order)),this.light=new w(this.stylesheet.light),this.fire(new t.Event("data",{dataType:"style"})),this.fire(new t.Event("style.load"));}},i.prototype._loadSprite=function(e){var i=this;this._spriteRequest=function(e,i,o){var r,a,n,s=t.browser.devicePixelRatio>1?"@2x":"",l=t.getJSON(i.transformRequest(i.normalizeSpriteURL(e,s,".json"),t.ResourceType.SpriteJSON),(function(t,e){l=null,n||(n=t,r=e,u());})),c=t.getImage(i.transformRequest(i.normalizeSpriteURL(e,s,".png"),t.ResourceType.SpriteImage),(function(t,e){c=null,n||(n=t,a=e,u());}));function u(){if(n)o(n);else if(r&&a){var e=t.browser.getImageData(a),i={};for(var s in r){var l=r[s],c=l.width,u=l.height,h=l.x,p=l.y,d=l.sdf,_=l.pixelRatio,f=l.stretchX,m=l.stretchY,g=l.content,v=new t.RGBAImage({width:c,height:u});t.RGBAImage.copy(e,v,{x:h,y:p},{x:0,y:0},{width:c,height:u}),i[s]={data:v,pixelRatio:_,sdf:d,stretchX:f,stretchY:m,content:g};}o(null,i);}}return {cancel:function(){l&&(l.cancel(),l=null),c&&(c.cancel(),c=null);}}}(e,this.map._requestManager,(function(e,o){if(i._spriteRequest=null,e)i.fire(new t.ErrorEvent(e));else if(o)for(var r in o)i.imageManager.addImage(r,o[r]);i.imageManager.setLoaded(!0),i._availableImages=i.imageManager.listImages(),i.dispatcher.broadcast("setImages",i._availableImages),i.fire(new t.Event("data",{dataType:"style"}));}));},i.prototype._validateLayer=function(e){var i=this.sourceCaches[e.source];if(i){var o=e.sourceLayer;if(o){var r=i.getSource();("geojson"===r.type||r.vectorLayerIds&&-1===r.vectorLayerIds.indexOf(o))&&this.fire(new t.ErrorEvent(new Error('Source layer "'+o+'" does not exist on source "'+r.id+'" as specified by style layer "'+e.id+'"')));}}},i.prototype.loaded=function(){if(!this._loaded)return !1;if(Object.keys(this._updatedSources).length)return !1;for(var t in this.sourceCaches)if(!this.sourceCaches[t].loaded())return !1;return !!this.imageManager.isLoaded()},i.prototype._serializeLayers=function(t){for(var e=[],i=0,o=t;i<o.length;i+=1){var r=this._layers[o[i]];"custom"!==r.type&&e.push(r.serialize());}return e},i.prototype.hasTransitions=function(){if(this.light&&this.light.hasTransition())return !0;for(var t in this.sourceCaches)if(this.sourceCaches[t].hasTransition())return !0;for(var e in this._layers)if(this._layers[e].hasTransition())return !0;return !1},i.prototype._checkLoaded=function(){if(!this._loaded)throw new Error("Style is not done loading")},i.prototype.update=function(e){if(this._loaded){var i=this._changed;if(this._changed){var o=Object.keys(this._updatedLayers),r=Object.keys(this._removedLayers);for(var a in (o.length||r.length)&&this._updateWorkerLayers(o,r),this._updatedSources){var n=this._updatedSources[a];"reload"===n?this._reloadSource(a):"clear"===n&&this._clearSource(a);}for(var s in this._updateTilesForChangedImages(),this._updatedPaintProps)this._layers[s].updateTransitions(e);this.light.updateTransitions(e),this._resetUpdates();}var l={};for(var c in this.sourceCaches){var u=this.sourceCaches[c];l[c]=u.used,u.used=!1;}for(var h=0,p=this._order;h<p.length;h+=1){var d=this._layers[p[h]];d.recalculate(e,this._availableImages),!d.isHidden(e.zoom)&&d.source&&(this.sourceCaches[d.source].used=!0);}for(var _ in l){var f=this.sourceCaches[_];l[_]!==f.used&&f.fire(new t.Event("data",{sourceDataType:"visibility",dataType:"source",sourceId:_}));}this.light.recalculate(e),this.z=e.zoom,i&&this.fire(new t.Event("data",{dataType:"style"}));}},i.prototype._updateTilesForChangedImages=function(){var t=Object.keys(this._changedImages);if(t.length){for(var e in this.sourceCaches)this.sourceCaches[e].reloadTilesForDependencies(["icons","patterns"],t);this._changedImages={};}},i.prototype._updateWorkerLayers=function(t,e){this.dispatcher.broadcast("updateLayers",{layers:this._serializeLayers(t),removedIds:e});},i.prototype._resetUpdates=function(){this._changed=!1,this._updatedLayers={},this._removedLayers={},this._updatedSources={},this._updatedPaintProps={},this._changedImages={};},i.prototype.setState=function(e){var i=this;if(this._checkLoaded(),Ue(this,t.validateStyle(e)))return !1;(e=t.clone$1(e)).layers=Nt(e.layers);var o=function(e,i){if(!e)return [{command:Zt.setStyle,args:[i]}];var o=[];try{if(!t.deepEqual(e.version,i.version))return [{command:Zt.setStyle,args:[i]}];t.deepEqual(e.center,i.center)||o.push({command:Zt.setCenter,args:[i.center]}),t.deepEqual(e.zoom,i.zoom)||o.push({command:Zt.setZoom,args:[i.zoom]}),t.deepEqual(e.bearing,i.bearing)||o.push({command:Zt.setBearing,args:[i.bearing]}),t.deepEqual(e.pitch,i.pitch)||o.push({command:Zt.setPitch,args:[i.pitch]}),t.deepEqual(e.sprite,i.sprite)||o.push({command:Zt.setSprite,args:[i.sprite]}),t.deepEqual(e.glyphs,i.glyphs)||o.push({command:Zt.setGlyphs,args:[i.glyphs]}),t.deepEqual(e.transition,i.transition)||o.push({command:Zt.setTransition,args:[i.transition]}),t.deepEqual(e.light,i.light)||o.push({command:Zt.setLight,args:[i.light]});var r={},a=[];!function(e,i,o,r){var a;for(a in i=i||{},e=e||{})e.hasOwnProperty(a)&&(i.hasOwnProperty(a)||jt(a,o,r));for(a in i)i.hasOwnProperty(a)&&(e.hasOwnProperty(a)?t.deepEqual(e[a],i[a])||("geojson"===e[a].type&&"geojson"===i[a].type&&Gt(e,i,a)?o.push({command:Zt.setGeoJSONSourceData,args:[a,i[a].data]}):Vt(a,i,o,r)):qt(a,i,o));}(e.sources,i.sources,a,r);var n=[];e.layers&&e.layers.forEach((function(t){r[t.source]?o.push({command:Zt.removeLayer,args:[t.id]}):n.push(t);})),o=o.concat(a),function(e,i,o){i=i||[];var r,a,n,s,l,c,u,h=(e=e||[]).map(Xt),p=i.map(Xt),d=e.reduce(Ht,{}),_=i.reduce(Ht,{}),f=h.slice(),m=Object.create(null);for(r=0,a=0;r<h.length;r++)_.hasOwnProperty(n=h[r])?a++:(o.push({command:Zt.removeLayer,args:[n]}),f.splice(f.indexOf(n,a),1));for(r=0,a=0;r<p.length;r++)f[f.length-1-r]!==(n=p[p.length-1-r])&&(d.hasOwnProperty(n)?(o.push({command:Zt.removeLayer,args:[n]}),f.splice(f.lastIndexOf(n,f.length-a),1)):a++,o.push({command:Zt.addLayer,args:[_[n],c=f[f.length-r]]}),f.splice(f.length-r,0,n),m[n]=!0);for(r=0;r<p.length;r++)if(s=d[n=p[r]],l=_[n],!m[n]&&!t.deepEqual(s,l))if(t.deepEqual(s.source,l.source)&&t.deepEqual(s["source-layer"],l["source-layer"])&&t.deepEqual(s.type,l.type)){for(u in Wt(s.layout,l.layout,o,n,null,Zt.setLayoutProperty),Wt(s.paint,l.paint,o,n,null,Zt.setPaintProperty),t.deepEqual(s.filter,l.filter)||o.push({command:Zt.setFilter,args:[n,l.filter]}),t.deepEqual(s.minzoom,l.minzoom)&&t.deepEqual(s.maxzoom,l.maxzoom)||o.push({command:Zt.setLayerZoomRange,args:[n,l.minzoom,l.maxzoom]}),s)s.hasOwnProperty(u)&&"layout"!==u&&"paint"!==u&&"filter"!==u&&"metadata"!==u&&"minzoom"!==u&&"maxzoom"!==u&&(0===u.indexOf("paint.")?Wt(s[u],l[u],o,n,u.slice(6),Zt.setPaintProperty):t.deepEqual(s[u],l[u])||o.push({command:Zt.setLayerProperty,args:[n,u,l[u]]}));for(u in l)l.hasOwnProperty(u)&&!s.hasOwnProperty(u)&&"layout"!==u&&"paint"!==u&&"filter"!==u&&"metadata"!==u&&"minzoom"!==u&&"maxzoom"!==u&&(0===u.indexOf("paint.")?Wt(s[u],l[u],o,n,u.slice(6),Zt.setPaintProperty):t.deepEqual(s[u],l[u])||o.push({command:Zt.setLayerProperty,args:[n,u,l[u]]}));}else o.push({command:Zt.removeLayer,args:[n]}),c=f[f.lastIndexOf(n)+1],o.push({command:Zt.addLayer,args:[l,c]});}(n,i.layers,o);}catch(t){console.warn("Unable to compute style diff:",t),o=[{command:Zt.setStyle,args:[i]}];}return o}(this.serialize(),e).filter((function(t){return !(t.command in Ze)}));if(0===o.length)return !1;var r=o.filter((function(t){return !(t.command in Ne)}));if(r.length>0)throw new Error("Unimplemented: "+r.map((function(t){return t.command})).join(", ")+".");return o.forEach((function(t){"setTransition"!==t.command&&i[t.command].apply(i,t.args);})),this.stylesheet=e,!0},i.prototype.addImage=function(e,i){if(this.getImage(e))return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));this.imageManager.addImage(e,i),this._afterImageUpdated(e);},i.prototype.updateImage=function(t,e){this.imageManager.updateImage(t,e);},i.prototype.getImage=function(t){return this.imageManager.getImage(t)},i.prototype.removeImage=function(e){if(!this.getImage(e))return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));this.imageManager.removeImage(e),this._afterImageUpdated(e);},i.prototype._afterImageUpdated=function(e){this._availableImages=this.imageManager.listImages(),this._changedImages[e]=!0,this._changed=!0,this.dispatcher.broadcast("setImages",this._availableImages),this.fire(new t.Event("data",{dataType:"style"}));},i.prototype.listImages=function(){return this._checkLoaded(),this.imageManager.listImages()},i.prototype.addSource=function(e,i,o){var r=this;if(void 0===o&&(o={}),this._checkLoaded(),void 0!==this.sourceCaches[e])throw new Error("There is already a source with this ID");if(!i.type)throw new Error("The type property must be defined, but only the following properties were given: "+Object.keys(i).join(", ")+".");if(!(["vector","raster","geojson","video","image"].indexOf(i.type)>=0&&this._validate(t.validateStyle.source,"sources."+e,i,null,o))){this.map&&this.map._collectResourceTiming&&(i.collectResourceTiming=!0);var a=this.sourceCaches[e]=new Dt(e,i,this.dispatcher);a.style=this,a.setEventedParent(this,(function(){return {isSourceLoaded:r.loaded(),source:a.serialize(),sourceId:e}})),a.onAdd(this.map),this._changed=!0;}},i.prototype.removeSource=function(e){if(this._checkLoaded(),void 0===this.sourceCaches[e])throw new Error("There is no source with this ID");for(var i in this._layers)if(this._layers[i].source===e)return this.fire(new t.ErrorEvent(new Error('Source "'+e+'" cannot be removed while layer "'+i+'" is using it.')));var o=this.sourceCaches[e];delete this.sourceCaches[e],delete this._updatedSources[e],o.fire(new t.Event("data",{sourceDataType:"metadata",dataType:"source",sourceId:e})),o.setEventedParent(null),o.clearTiles(),o.onRemove&&o.onRemove(this.map),this._changed=!0;},i.prototype.setGeoJSONSourceData=function(t,e){this._checkLoaded(),this.sourceCaches[t].getSource().setData(e),this._changed=!0;},i.prototype.getSource=function(t){return this.sourceCaches[t]&&this.sourceCaches[t].getSource()},i.prototype.addLayer=function(e,i,o){void 0===o&&(o={}),this._checkLoaded();var r=e.id;if(this.getLayer(r))this.fire(new t.ErrorEvent(new Error('Layer with id "'+r+'" already exists on this map')));else {var a;if("custom"===e.type){if(Ue(this,t.validateCustomStyleLayer(e)))return;a=t.createStyleLayer(e);}else {if("object"==typeof e.source&&(this.addSource(r,e.source),e=t.clone$1(e),e=t.extend(e,{source:r})),this._validate(t.validateStyle.layer,"layers."+r,e,{arrayIndex:-1},o))return;a=t.createStyleLayer(e),this._validateLayer(a),a.setEventedParent(this,{layer:{id:r}}),this._serializedLayers[a.id]=a.serialize();}var n=i?this._order.indexOf(i):this._order.length;if(i&&-1===n)this.fire(new t.ErrorEvent(new Error('Layer with id "'+i+'" does not exist on this map.')));else {if(this._order.splice(n,0,r),this._layerOrderChanged=!0,this._layers[r]=a,this._removedLayers[r]&&a.source&&"custom"!==a.type){var s=this._removedLayers[r];delete this._removedLayers[r],s.type!==a.type?this._updatedSources[a.source]="clear":(this._updatedSources[a.source]="reload",this.sourceCaches[a.source].pause());}this._updateLayer(a),a.onAdd&&a.onAdd(this.map);}}},i.prototype.moveLayer=function(e,i){if(this._checkLoaded(),this._changed=!0,this._layers[e]){if(e!==i){var o=this._order.indexOf(e);this._order.splice(o,1);var r=i?this._order.indexOf(i):this._order.length;i&&-1===r?this.fire(new t.ErrorEvent(new Error('Layer with id "'+i+'" does not exist on this map.'))):(this._order.splice(r,0,e),this._layerOrderChanged=!0);}}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be moved.")));},i.prototype.removeLayer=function(e){this._checkLoaded();var i=this._layers[e];if(i){i.setEventedParent(null);var o=this._order.indexOf(e);this._order.splice(o,1),this._layerOrderChanged=!0,this._changed=!0,this._removedLayers[e]=i,delete this._layers[e],delete this._serializedLayers[e],delete this._updatedLayers[e],delete this._updatedPaintProps[e],i.onRemove&&i.onRemove(this.map);}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be removed.")));},i.prototype.getLayer=function(t){return this._layers[t]},i.prototype.hasLayer=function(t){return t in this._layers},i.prototype.setLayerZoomRange=function(e,i,o){this._checkLoaded();var r=this.getLayer(e);r?r.minzoom===i&&r.maxzoom===o||(null!=i&&(r.minzoom=i),null!=o&&(r.maxzoom=o),this._updateLayer(r)):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot have zoom extent.")));},i.prototype.setFilter=function(e,i,o){void 0===o&&(o={}),this._checkLoaded();var r=this.getLayer(e);if(r){if(!t.deepEqual(r.filter,i))return null==i?(r.filter=void 0,void this._updateLayer(r)):void(this._validate(t.validateStyle.filter,"layers."+r.id+".filter",i,null,o)||(r.filter=t.clone$1(i),this._updateLayer(r)))}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be filtered.")));},i.prototype.getFilter=function(e){return t.clone$1(this.getLayer(e).filter)},i.prototype.setLayoutProperty=function(e,i,o,r){void 0===r&&(r={}),this._checkLoaded();var a=this.getLayer(e);a?t.deepEqual(a.getLayoutProperty(i),o)||(a.setLayoutProperty(i,o,r),this._updateLayer(a)):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")));},i.prototype.getLayoutProperty=function(e,i){var o=this.getLayer(e);if(o)return o.getLayoutProperty(i);this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style.")));},i.prototype.setPaintProperty=function(e,i,o,r){void 0===r&&(r={}),this._checkLoaded();var a=this.getLayer(e);a?t.deepEqual(a.getPaintProperty(i),o)||(a.setPaintProperty(i,o,r)&&this._updateLayer(a),this._changed=!0,this._updatedPaintProps[e]=!0):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")));},i.prototype.getPaintProperty=function(t,e){return this.getLayer(t).getPaintProperty(e)},i.prototype.setFeatureState=function(e,i){this._checkLoaded();var o=e.source,r=e.sourceLayer,a=this.sourceCaches[o];if(void 0!==a){var n=a.getSource().type;"geojson"===n&&r?this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))):"vector"!==n||r?(void 0===e.id&&this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))),a.setFeatureState(r,e.id,i)):this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+o+"' does not exist in the map's style.")));},i.prototype.removeFeatureState=function(e,i){this._checkLoaded();var o=e.source,r=this.sourceCaches[o];if(void 0!==r){var a=r.getSource().type,n="vector"===a?e.sourceLayer:void 0;"vector"!==a||n?i&&"string"!=typeof e.id&&"number"!=typeof e.id?this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))):r.removeFeatureState(n,e.id,i):this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+o+"' does not exist in the map's style.")));},i.prototype.getFeatureState=function(e){this._checkLoaded();var i=e.source,o=e.sourceLayer,r=this.sourceCaches[i];if(void 0!==r){if("vector"!==r.getSource().type||o)return void 0===e.id&&this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))),r.getFeatureState(o,e.id);this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+i+"' does not exist in the map's style.")));},i.prototype.getTransition=function(){return t.extend({duration:300,delay:0},this.stylesheet&&this.stylesheet.transition)},i.prototype.serialize=function(){return t.filterObject({version:this.stylesheet.version,name:this.stylesheet.name,metadata:this.stylesheet.metadata,light:this.stylesheet.light,center:this.stylesheet.center,zoom:this.stylesheet.zoom,bearing:this.stylesheet.bearing,pitch:this.stylesheet.pitch,sprite:this.stylesheet.sprite,glyphs:this.stylesheet.glyphs,transition:this.stylesheet.transition,sources:t.mapObject(this.sourceCaches,(function(t){return t.serialize()})),layers:this._serializeLayers(this._order)},(function(t){return void 0!==t}))},i.prototype._updateLayer=function(t){this._updatedLayers[t.id]=!0,t.source&&!this._updatedSources[t.source]&&"raster"!==this.sourceCaches[t.source].getSource().type&&(this._updatedSources[t.source]="reload",this.sourceCaches[t.source].pause()),this._changed=!0;},i.prototype._flattenAndSortRenderedFeatures=function(t){for(var e=this,i=function(t){return "fill-extrusion"===e._layers[t].type},o={},r=[],a=this._order.length-1;a>=0;a--){var n=this._order[a];if(i(n)){o[n]=a;for(var s=0,l=t;s<l.length;s+=1){var c=l[s][n];if(c)for(var u=0,h=c;u<h.length;u+=1)r.push(h[u]);}}}r.sort((function(t,e){return e.intersectionZ-t.intersectionZ}));for(var p=[],d=this._order.length-1;d>=0;d--){var _=this._order[d];if(i(_))for(var f=r.length-1;f>=0;f--){var m=r[f].feature;if(o[m.layer.id]<d)break;p.push(m),r.pop();}else for(var g=0,v=t;g<v.length;g+=1){var y=v[g][_];if(y)for(var x=0,b=y;x<b.length;x+=1)p.push(b[x].feature);}}return p},i.prototype.queryRenderedFeatures=function(e,i,o){i&&i.filter&&this._validate(t.validateStyle.filter,"queryRenderedFeatures.filter",i.filter,null,i);var r={};if(i&&i.layers){if(!Array.isArray(i.layers))return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))),[];for(var a=0,n=i.layers;a<n.length;a+=1){var s=n[a],l=this._layers[s];if(!l)return this.fire(new t.ErrorEvent(new Error("The layer '"+s+"' does not exist in the map's style and cannot be queried for features."))),[];r[l.source]=!0;}}var c=[];for(var u in i.availableImages=this._availableImages,this.sourceCaches)i.layers&&!r[u]||c.push(O(this.sourceCaches[u],this._layers,this._serializedLayers,e,i,o));return this.placement&&c.push(function(t,e,i,o,r,a,n){for(var s={},l=a.queryRenderedSymbols(o),c=[],u=0,h=Object.keys(l).map(Number);u<h.length;u+=1)c.push(n[h[u]]);c.sort(F);for(var p=function(){var i=_[d],o=i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId],e,i.bucketIndex,i.sourceLayerIndex,r.filter,r.layers,r.availableImages,t);for(var a in o){var n=s[a]=s[a]||[],c=o[a];c.sort((function(t,e){var o=i.featureSortOrder;if(o){var r=o.indexOf(t.featureIndex);return o.indexOf(e.featureIndex)-r}return e.featureIndex-t.featureIndex}));for(var u=0,h=c;u<h.length;u+=1)n.push(h[u]);}},d=0,_=c;d<_.length;d+=1)p();var f=function(e){s[e].forEach((function(o){var r=o.feature,a=i[t[e].source].getFeatureState(r.layer["source-layer"],r.id);r.source=r.layer.source,r.layer["source-layer"]&&(r.sourceLayer=r.layer["source-layer"]),r.state=a;}));};for(var m in s)f(m);return s}(this._layers,this._serializedLayers,this.sourceCaches,e,i,this.placement.collisionIndex,this.placement.retainedQueryData)),this._flattenAndSortRenderedFeatures(c)},i.prototype.querySourceFeatures=function(e,i){i&&i.filter&&this._validate(t.validateStyle.filter,"querySourceFeatures.filter",i.filter,null,i);var o=this.sourceCaches[e];return o?function(t,e){for(var i=t.getRenderableIds().map((function(e){return t.getTileByID(e)})),o=[],r={},a=0;a<i.length;a++){var n=i[a],s=n.tileID.canonical.key;r[s]||(r[s]=!0,n.querySourceFeatures(o,e));}return o}(o,i):[]},i.prototype.addSourceType=function(t,e,o){return i.getSourceType(t)?o(new Error('A source type called "'+t+'" already exists.')):(i.setSourceType(t,e),e.workerSourceURL?void this.dispatcher.broadcast("loadWorkerSource",{name:t,url:e.workerSourceURL},o):o(null,null))},i.prototype.getLight=function(){return this.light.getLight()},i.prototype.setLight=function(e,i){void 0===i&&(i={}),this._checkLoaded();var o=this.light.getLight(),r=!1;for(var a in e)if(!t.deepEqual(e[a],o[a])){r=!0;break}if(r){var n={now:t.browser.now(),transition:t.extend({duration:300,delay:0},this.stylesheet.transition)};this.light.setLight(e,i),this.light.updateTransitions(n);}},i.prototype._validate=function(e,i,o,r,a){return void 0===a&&(a={}),(!a||!1!==a.validate)&&Ue(this,e.call(t.validateStyle,t.extend({key:i,style:this.serialize(),value:o,styleSpec:t.styleSpec},r)))},i.prototype._remove=function(){for(var e in this._request&&(this._request.cancel(),this._request=null),this._spriteRequest&&(this._spriteRequest.cancel(),this._spriteRequest=null),t.evented.off("pluginStateChange",this._rtlTextPluginCallback),this._layers)this._layers[e].setEventedParent(null);for(var i in this.sourceCaches)this.sourceCaches[i].clearTiles(),this.sourceCaches[i].setEventedParent(null);this.imageManager.setEventedParent(null),this.setEventedParent(null),this.dispatcher.remove();},i.prototype._clearSource=function(t){this.sourceCaches[t].clearTiles();},i.prototype._reloadSource=function(t){this.sourceCaches[t].resume(),this.sourceCaches[t].reload();},i.prototype._updateSources=function(t){for(var e in this.sourceCaches)this.sourceCaches[e].update(t);},i.prototype._generateCollisionBoxes=function(){for(var t in this.sourceCaches)this._reloadSource(t);},i.prototype._updatePlacement=function(e,i,o,r,a){void 0===a&&(a=!1);for(var n=!1,s=!1,l={},c=0,u=this._order;c<u.length;c+=1){var h=this._layers[u[c]];if("symbol"===h.type){if(!l[h.source]){var p=this.sourceCaches[h.source];l[h.source]=p.getRenderableIds(!0).map((function(t){return p.getTileByID(t)})).sort((function(t,e){return e.tileID.overscaledZ-t.tileID.overscaledZ||(t.tileID.isLessThan(e.tileID)?-1:1)}));}var d=this.crossTileSymbolIndex.addLayer(h,l[h.source],e.center.lng);n=n||d;}}if(this.crossTileSymbolIndex.pruneUnusedLayers(this._order),((a=a||this._layerOrderChanged||0===o)||!this.pauseablePlacement||this.pauseablePlacement.isDone()&&!this.placement.stillRecent(t.browser.now(),e.zoom))&&(this.pauseablePlacement=new Le(e,this._order,a,i,o,r,this.placement),this._layerOrderChanged=!1),this.pauseablePlacement.isDone()?this.placement.setStale():(this.pauseablePlacement.continuePlacement(this._order,this._layers,l),this.pauseablePlacement.isDone()&&(this.placement=this.pauseablePlacement.commit(t.browser.now()),s=!0),n&&this.pauseablePlacement.placement.setStale()),s||n)for(var _=0,f=this._order;_<f.length;_+=1){var m=this._layers[f[_]];"symbol"===m.type&&this.placement.updateLayerOpacities(m,l[m.source]);}return !this.pauseablePlacement.isDone()||this.placement.hasTransitions(t.browser.now())},i.prototype._releaseSymbolFadeTiles=function(){for(var t in this.sourceCaches)this.sourceCaches[t].releaseSymbolFadeTiles();},i.prototype.getImages=function(t,e,i){this.imageManager.getImages(e.icons,i),this._updateTilesForChangedImages();var o=this.sourceCaches[e.source];o&&o.setDependencies(e.tileID.key,e.type,e.icons);},i.prototype.getGlyphs=function(t,e,i){this.glyphManager.getGlyphs(e.stacks,i);},i.prototype.getResource=function(e,i,o){return t.makeRequest(i,o)},i}(t.Evented);je.getSourceType=function(t){return k[t]},je.setSourceType=function(t,e){k[t]=e;},je.registerForPluginStateChange=t.registerForPluginStateChange;var Ve=t.createLayout([{name:"a_pos",type:"Int16",components:2}]),Ge=gi("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif","#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"),We=gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),Xe=gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),He=gi("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),Ke=gi("void main() {gl_FragColor=vec4(1.0);}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),Ye=gi("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),Je=gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),Qe=gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}","attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),$e=gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}","attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),ti=gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}","attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"),ei=gi("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),ii=gi("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),oi=gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),ri=gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),ai=gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),ni=gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),si=gi("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),li=gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),ci=gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),ui=gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),hi=gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),pi=gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),di=gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),_i=gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"),fi=gi("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),mi=gi("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");function gi(t,e){var i=/#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,o=e.match(/attribute ([\w]+) ([\w]+)/g),r=t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),a=e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),n=a?a.concat(r):r,s={};return {fragmentSource:t=t.replace(i,(function(t,e,i,o,r){return s[r]=!0,"define"===e?"\n#ifndef HAS_UNIFORM_u_"+r+"\nvarying "+i+" "+o+" "+r+";\n#else\nuniform "+i+" "+o+" u_"+r+";\n#endif\n":"\n#ifdef HAS_UNIFORM_u_"+r+"\n    "+i+" "+o+" "+r+" = u_"+r+";\n#endif\n"})),vertexSource:e=e.replace(i,(function(t,e,i,o,r){var a="float"===o?"vec2":"vec4",n=r.match(/color/)?"color":a;return s[r]?"define"===e?"\n#ifndef HAS_UNIFORM_u_"+r+"\nuniform lowp float u_"+r+"_t;\nattribute "+i+" "+a+" a_"+r+";\nvarying "+i+" "+o+" "+r+";\n#else\nuniform "+i+" "+o+" u_"+r+";\n#endif\n":"vec4"===n?"\n#ifndef HAS_UNIFORM_u_"+r+"\n    "+r+" = a_"+r+";\n#else\n    "+i+" "+o+" "+r+" = u_"+r+";\n#endif\n":"\n#ifndef HAS_UNIFORM_u_"+r+"\n    "+r+" = unpack_mix_"+n+"(a_"+r+", u_"+r+"_t);\n#else\n    "+i+" "+o+" "+r+" = u_"+r+";\n#endif\n":"define"===e?"\n#ifndef HAS_UNIFORM_u_"+r+"\nuniform lowp float u_"+r+"_t;\nattribute "+i+" "+a+" a_"+r+";\n#else\nuniform "+i+" "+o+" u_"+r+";\n#endif\n":"vec4"===n?"\n#ifndef HAS_UNIFORM_u_"+r+"\n    "+i+" "+o+" "+r+" = a_"+r+";\n#else\n    "+i+" "+o+" "+r+" = u_"+r+";\n#endif\n":"\n#ifndef HAS_UNIFORM_u_"+r+"\n    "+i+" "+o+" "+r+" = unpack_mix_"+n+"(a_"+r+", u_"+r+"_t);\n#else\n    "+i+" "+o+" "+r+" = u_"+r+";\n#endif\n"})),staticAttributes:o,staticUniforms:n}}var vi=Object.freeze({__proto__:null,prelude:Ge,background:We,backgroundPattern:Xe,circle:He,clippingMask:Ke,heatmap:Ye,heatmapTexture:Je,collisionBox:Qe,collisionCircle:$e,debug:ti,fill:ei,fillOutline:ii,fillOutlinePattern:oi,fillPattern:ri,fillExtrusion:ai,fillExtrusionPattern:ni,hillshadePrepare:si,hillshade:li,line:ci,lineGradient:ui,linePattern:hi,lineSDF:pi,raster:di,symbolIcon:_i,symbolSDF:fi,symbolTextAndIcon:mi}),yi=function(){this.boundProgram=null,this.boundLayoutVertexBuffer=null,this.boundPaintVertexBuffers=[],this.boundIndexBuffer=null,this.boundVertexOffset=null,this.boundDynamicVertexBuffer=null,this.vao=null;};function xi(t){for(var e=[],i=0;i<t.length;i++)if(null!==t[i]){var o=t[i].split(" ");e.push(o.pop());}return e}yi.prototype.bind=function(t,e,i,o,r,a,n,s){this.context=t;for(var l=this.boundPaintVertexBuffers.length!==o.length,c=0;!l&&c<o.length;c++)this.boundPaintVertexBuffers[c]!==o[c]&&(l=!0);t.extVertexArrayObject&&this.vao&&this.boundProgram===e&&this.boundLayoutVertexBuffer===i&&!l&&this.boundIndexBuffer===r&&this.boundVertexOffset===a&&this.boundDynamicVertexBuffer===n&&this.boundDynamicVertexBuffer2===s?(t.bindVertexArrayOES.set(this.vao),n&&n.bind(),r&&r.dynamicDraw&&r.bind(),s&&s.bind()):this.freshBind(e,i,o,r,a,n,s);},yi.prototype.freshBind=function(t,e,i,o,r,a,n){var s,l=t.numAttributes,c=this.context,u=c.gl;if(c.extVertexArrayObject)this.vao&&this.destroy(),this.vao=c.extVertexArrayObject.createVertexArrayOES(),c.bindVertexArrayOES.set(this.vao),s=0,this.boundProgram=t,this.boundLayoutVertexBuffer=e,this.boundPaintVertexBuffers=i,this.boundIndexBuffer=o,this.boundVertexOffset=r,this.boundDynamicVertexBuffer=a,this.boundDynamicVertexBuffer2=n;else {s=c.currentNumAttributes||0;for(var h=l;h<s;h++)u.disableVertexAttribArray(h);}e.enableAttributes(u,t);for(var p=0,d=i;p<d.length;p+=1)d[p].enableAttributes(u,t);a&&a.enableAttributes(u,t),n&&n.enableAttributes(u,t),e.bind(),e.setVertexAttribPointers(u,t,r);for(var _=0,f=i;_<f.length;_+=1){var m=f[_];m.bind(),m.setVertexAttribPointers(u,t,r);}a&&(a.bind(),a.setVertexAttribPointers(u,t,r)),o&&o.bind(),n&&(n.bind(),n.setVertexAttribPointers(u,t,r)),c.currentNumAttributes=l;},yi.prototype.destroy=function(){this.vao&&(this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),this.vao=null);};var bi=function(t,e,i,o,r,a){var n=t.gl;this.program=n.createProgram();for(var s=xi(i.staticAttributes),l=o?o.getBinderAttributes():[],c=s.concat(l),u=i.staticUniforms?xi(i.staticUniforms):[],h=o?o.getBinderUniforms():[],p=[],d=0,_=u.concat(h);d<_.length;d+=1){var f=_[d];p.indexOf(f)<0&&p.push(f);}var m=o?o.defines():[];a&&m.push("#define OVERDRAW_INSPECTOR;");var g=m.concat(Ge.fragmentSource,i.fragmentSource).join("\n"),v=m.concat(Ge.vertexSource,i.vertexSource).join("\n"),y=n.createShader(n.FRAGMENT_SHADER);if(n.isContextLost())this.failedToCreate=!0;else {n.shaderSource(y,g),n.compileShader(y),n.attachShader(this.program,y);var x=n.createShader(n.VERTEX_SHADER);if(n.isContextLost())this.failedToCreate=!0;else {n.shaderSource(x,v),n.compileShader(x),n.attachShader(this.program,x),this.attributes={};var b={};this.numAttributes=c.length;for(var w=0;w<this.numAttributes;w++)c[w]&&(n.bindAttribLocation(this.program,w,c[w]),this.attributes[c[w]]=w);n.linkProgram(this.program),n.deleteShader(x),n.deleteShader(y);for(var T=0;T<p.length;T++){var E=p[T];if(E&&!b[E]){var I=n.getUniformLocation(this.program,E);I&&(b[E]=I);}}this.fixedUniforms=r(t,b),this.binderUniforms=o?o.getUniforms(t,b):[];}}};function wi(t,e,i){var o=1/pe(i,1,e.transform.tileZoom),r=Math.pow(2,i.tileID.overscaledZ),a=i.tileSize*Math.pow(2,e.transform.tileZoom)/r,n=a*(i.tileID.canonical.x+i.tileID.wrap*r),s=a*i.tileID.canonical.y;return {u_image:0,u_texsize:i.imageAtlasTexture.size,u_scale:[o,t.fromScale,t.toScale],u_fade:t.t,u_pixel_coord_upper:[n>>16,s>>16],u_pixel_coord_lower:[65535&n,65535&s]}}bi.prototype.draw=function(t,e,i,o,r,a,n,s,l,c,u,h,p,d,_,f){var m,g=t.gl;if(!this.failedToCreate){for(var v in t.program.set(this.program),t.setDepthMode(i),t.setStencilMode(o),t.setColorMode(r),t.setCullFace(a),this.fixedUniforms)this.fixedUniforms[v].set(n[v]);d&&d.setUniforms(t,this.binderUniforms,h,{zoom:p});for(var y=(m={},m[g.LINES]=2,m[g.TRIANGLES]=3,m[g.LINE_STRIP]=1,m)[e],x=0,b=u.get();x<b.length;x+=1){var w=b[x],T=w.vaos||(w.vaos={});(T[s]||(T[s]=new yi)).bind(t,this,l,d?d.getPaintVertexBuffers():[],c,w.vertexOffset,_,f),g.drawElements(e,w.primitiveLength*y,g.UNSIGNED_SHORT,w.primitiveOffset*y*2);}}};var Ti=function(e,i,o,r){var a=i.style.light,n=a.properties.get("position"),s=[n.x,n.y,n.z],l=t.create$1();"viewport"===a.properties.get("anchor")&&t.fromRotation(l,-i.transform.angle),t.transformMat3(s,s,l);var c=a.properties.get("color");return {u_matrix:e,u_lightpos:s,u_lightintensity:a.properties.get("intensity"),u_lightcolor:[c.r,c.g,c.b],u_vertical_gradient:+o,u_opacity:r}},Ei=function(e,i,o,r,a,n,s){return t.extend(Ti(e,i,o,r),wi(n,i,s),{u_height_factor:-Math.pow(2,a.overscaledZ)/s.tileSize/8})},Ii=function(t){return {u_matrix:t}},Pi=function(e,i,o,r){return t.extend(Ii(e),wi(o,i,r))},Si=function(t,e){return {u_matrix:t,u_world:e}},Ci=function(e,i,o,r,a){return t.extend(Pi(e,i,o,r),{u_world:a})},zi=function(e,i,o,r){var a,n,s=e.transform;if("map"===r.paint.get("circle-pitch-alignment")){var l=pe(o,1,s.zoom);a=!0,n=[l,l];}else a=!1,n=s.pixelsToGLUnits;return {u_camera_to_center_distance:s.cameraToCenterDistance,u_scale_with_map:+("map"===r.paint.get("circle-pitch-scale")),u_matrix:e.translatePosMatrix(i.posMatrix,o,r.paint.get("circle-translate"),r.paint.get("circle-translate-anchor")),u_pitch_with_map:+a,u_device_pixel_ratio:t.browser.devicePixelRatio,u_extrude_scale:n}},Di=function(t,e,i){var o=pe(i,1,e.zoom),r=Math.pow(2,e.zoom-i.tileID.overscaledZ),a=i.tileID.overscaleFactor();return {u_matrix:t,u_camera_to_center_distance:e.cameraToCenterDistance,u_pixels_to_tile_units:o,u_extrude_scale:[e.pixelsToGLUnits[0]/(o*r),e.pixelsToGLUnits[1]/(o*r)],u_overscale_factor:a}},Ai=function(t,e,i){return {u_matrix:t,u_inv_matrix:e,u_camera_to_center_distance:i.cameraToCenterDistance,u_viewport_size:[i.width,i.height]}},Mi=function(t,e,i){return void 0===i&&(i=1),{u_matrix:t,u_color:e,u_overlay:0,u_overlay_scale:i}},Li=function(t){return {u_matrix:t}},Ri=function(t,e,i,o){return {u_matrix:t,u_extrude_scale:pe(e,1,i),u_intensity:o}},ki=function(e,i,o){var r=e.transform;return {u_matrix:Ni(e,i,o),u_ratio:1/pe(i,1,r.zoom),u_device_pixel_ratio:t.browser.devicePixelRatio,u_units_to_pixels:[1/r.pixelsToGLUnits[0],1/r.pixelsToGLUnits[1]]}},Bi=function(e,i,o,r){return t.extend(ki(e,i,o),{u_image:0,u_image_height:r})},Oi=function(e,i,o,r){var a=e.transform,n=Ui(i,a);return {u_matrix:Ni(e,i,o),u_texsize:i.imageAtlasTexture.size,u_ratio:1/pe(i,1,a.zoom),u_device_pixel_ratio:t.browser.devicePixelRatio,u_image:0,u_scale:[n,r.fromScale,r.toScale],u_fade:r.t,u_units_to_pixels:[1/a.pixelsToGLUnits[0],1/a.pixelsToGLUnits[1]]}},Fi=function(e,i,o,r,a){var n=e.lineAtlas,s=Ui(i,e.transform),l="round"===o.layout.get("line-cap"),c=n.getDash(r.from,l),u=n.getDash(r.to,l),h=c.width*a.fromScale,p=u.width*a.toScale;return t.extend(ki(e,i,o),{u_patternscale_a:[s/h,-c.height/2],u_patternscale_b:[s/p,-u.height/2],u_sdfgamma:n.width/(256*Math.min(h,p)*t.browser.devicePixelRatio)/2,u_image:0,u_tex_y_a:c.y,u_tex_y_b:u.y,u_mix:a.t})};function Ui(t,e){return 1/pe(t,1,e.tileZoom)}function Ni(t,e,i){return t.translatePosMatrix(e.tileID.posMatrix,e,i.paint.get("line-translate"),i.paint.get("line-translate-anchor"))}var Zi=function(t,e,i,o,r){return {u_matrix:t,u_tl_parent:e,u_scale_parent:i,u_buffer_scale:1,u_fade_t:o.mix,u_opacity:o.opacity*r.paint.get("raster-opacity"),u_image0:0,u_image1:1,u_brightness_low:r.paint.get("raster-brightness-min"),u_brightness_high:r.paint.get("raster-brightness-max"),u_saturation_factor:(n=r.paint.get("raster-saturation"),n>0?1-1/(1.001-n):-n),u_contrast_factor:(a=r.paint.get("raster-contrast"),a>0?1/(1-a):1+a),u_spin_weights:qi(r.paint.get("raster-hue-rotate"))};var a,n;};function qi(t){t*=Math.PI/180;var e=Math.sin(t),i=Math.cos(t);return [(2*i+1)/3,(-Math.sqrt(3)*e-i+1)/3,(Math.sqrt(3)*e-i+1)/3]}var ji,Vi=function(t,e,i,o,r,a,n,s,l,c){var u=r.transform;return {u_is_size_zoom_constant:+("constant"===t||"source"===t),u_is_size_feature_constant:+("constant"===t||"camera"===t),u_size_t:e?e.uSizeT:0,u_size:e?e.uSize:0,u_camera_to_center_distance:u.cameraToCenterDistance,u_pitch:u.pitch/360*2*Math.PI,u_rotate_symbol:+i,u_aspect_ratio:u.width/u.height,u_fade_change:r.options.fadeDuration?r.symbolFadeChange:1,u_matrix:a,u_label_plane_matrix:n,u_coord_matrix:s,u_is_text:+l,u_pitch_with_map:+o,u_texsize:c,u_texture:0}},Gi=function(e,i,o,r,a,n,s,l,c,u,h){var p=a.transform;return t.extend(Vi(e,i,o,r,a,n,s,l,c,u),{u_gamma_scale:r?Math.cos(p._pitch)*p.cameraToCenterDistance:1,u_device_pixel_ratio:t.browser.devicePixelRatio,u_is_halo:+h})},Wi=function(e,i,o,r,a,n,s,l,c,u){return t.extend(Gi(e,i,o,r,a,n,s,l,!0,c,!0),{u_texsize_icon:u,u_texture_icon:1})},Xi=function(t,e,i){return {u_matrix:t,u_opacity:e,u_color:i}},Hi=function(e,i,o,r,a,n){return t.extend(function(t,e,i,o){var r=i.imageManager.getPattern(t.from.toString()),a=i.imageManager.getPattern(t.to.toString()),n=i.imageManager.getPixelSize(),s=n.width,l=n.height,c=Math.pow(2,o.tileID.overscaledZ),u=o.tileSize*Math.pow(2,i.transform.tileZoom)/c,h=u*(o.tileID.canonical.x+o.tileID.wrap*c),p=u*o.tileID.canonical.y;return {u_image:0,u_pattern_tl_a:r.tl,u_pattern_br_a:r.br,u_pattern_tl_b:a.tl,u_pattern_br_b:a.br,u_texsize:[s,l],u_mix:e.t,u_pattern_size_a:r.displaySize,u_pattern_size_b:a.displaySize,u_scale_a:e.fromScale,u_scale_b:e.toScale,u_tile_units_to_pixels:1/pe(o,1,i.transform.tileZoom),u_pixel_coord_upper:[h>>16,p>>16],u_pixel_coord_lower:[65535&h,65535&p]}}(r,n,o,a),{u_matrix:e,u_opacity:i})},Ki={fillExtrusion:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_lightpos:new t.Uniform3f(e,i.u_lightpos),u_lightintensity:new t.Uniform1f(e,i.u_lightintensity),u_lightcolor:new t.Uniform3f(e,i.u_lightcolor),u_vertical_gradient:new t.Uniform1f(e,i.u_vertical_gradient),u_opacity:new t.Uniform1f(e,i.u_opacity)}},fillExtrusionPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_lightpos:new t.Uniform3f(e,i.u_lightpos),u_lightintensity:new t.Uniform1f(e,i.u_lightintensity),u_lightcolor:new t.Uniform3f(e,i.u_lightcolor),u_vertical_gradient:new t.Uniform1f(e,i.u_vertical_gradient),u_height_factor:new t.Uniform1f(e,i.u_height_factor),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade),u_opacity:new t.Uniform1f(e,i.u_opacity)}},fill:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},fillPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},fillOutline:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world)}},fillOutlinePattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},circle:function(e,i){return {u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_scale_with_map:new t.Uniform1i(e,i.u_scale_with_map),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_extrude_scale:new t.Uniform2f(e,i.u_extrude_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},collisionBox:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pixels_to_tile_units:new t.Uniform1f(e,i.u_pixels_to_tile_units),u_extrude_scale:new t.Uniform2f(e,i.u_extrude_scale),u_overscale_factor:new t.Uniform1f(e,i.u_overscale_factor)}},collisionCircle:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_inv_matrix:new t.UniformMatrix4f(e,i.u_inv_matrix),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_viewport_size:new t.Uniform2f(e,i.u_viewport_size)}},debug:function(e,i){return {u_color:new t.UniformColor(e,i.u_color),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_overlay:new t.Uniform1i(e,i.u_overlay),u_overlay_scale:new t.Uniform1f(e,i.u_overlay_scale)}},clippingMask:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},heatmap:function(e,i){return {u_extrude_scale:new t.Uniform1f(e,i.u_extrude_scale),u_intensity:new t.Uniform1f(e,i.u_intensity),u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},heatmapTexture:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world),u_image:new t.Uniform1i(e,i.u_image),u_color_ramp:new t.Uniform1i(e,i.u_color_ramp),u_opacity:new t.Uniform1f(e,i.u_opacity)}},hillshade:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_latrange:new t.Uniform2f(e,i.u_latrange),u_light:new t.Uniform2f(e,i.u_light),u_shadow:new t.UniformColor(e,i.u_shadow),u_highlight:new t.UniformColor(e,i.u_highlight),u_accent:new t.UniformColor(e,i.u_accent)}},hillshadePrepare:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_dimension:new t.Uniform2f(e,i.u_dimension),u_zoom:new t.Uniform1f(e,i.u_zoom),u_unpack:new t.Uniform4f(e,i.u_unpack)}},line:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels)}},lineGradient:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_image:new t.Uniform1i(e,i.u_image),u_image_height:new t.Uniform1f(e,i.u_image_height)}},linePattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_texsize:new t.Uniform2f(e,i.u_texsize),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_image:new t.Uniform1i(e,i.u_image),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},lineSDF:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_patternscale_a:new t.Uniform2f(e,i.u_patternscale_a),u_patternscale_b:new t.Uniform2f(e,i.u_patternscale_b),u_sdfgamma:new t.Uniform1f(e,i.u_sdfgamma),u_image:new t.Uniform1i(e,i.u_image),u_tex_y_a:new t.Uniform1f(e,i.u_tex_y_a),u_tex_y_b:new t.Uniform1f(e,i.u_tex_y_b),u_mix:new t.Uniform1f(e,i.u_mix)}},raster:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_tl_parent:new t.Uniform2f(e,i.u_tl_parent),u_scale_parent:new t.Uniform1f(e,i.u_scale_parent),u_buffer_scale:new t.Uniform1f(e,i.u_buffer_scale),u_fade_t:new t.Uniform1f(e,i.u_fade_t),u_opacity:new t.Uniform1f(e,i.u_opacity),u_image0:new t.Uniform1i(e,i.u_image0),u_image1:new t.Uniform1i(e,i.u_image1),u_brightness_low:new t.Uniform1f(e,i.u_brightness_low),u_brightness_high:new t.Uniform1f(e,i.u_brightness_high),u_saturation_factor:new t.Uniform1f(e,i.u_saturation_factor),u_contrast_factor:new t.Uniform1f(e,i.u_contrast_factor),u_spin_weights:new t.Uniform3f(e,i.u_spin_weights)}},symbolIcon:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1i(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texture:new t.Uniform1i(e,i.u_texture)}},symbolSDF:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1i(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texture:new t.Uniform1i(e,i.u_texture),u_gamma_scale:new t.Uniform1f(e,i.u_gamma_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_is_halo:new t.Uniform1i(e,i.u_is_halo)}},symbolTextAndIcon:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1i(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texsize_icon:new t.Uniform2f(e,i.u_texsize_icon),u_texture:new t.Uniform1i(e,i.u_texture),u_texture_icon:new t.Uniform1i(e,i.u_texture_icon),u_gamma_scale:new t.Uniform1f(e,i.u_gamma_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_is_halo:new t.Uniform1i(e,i.u_is_halo)}},background:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_opacity:new t.Uniform1f(e,i.u_opacity),u_color:new t.UniformColor(e,i.u_color)}},backgroundPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_opacity:new t.Uniform1f(e,i.u_opacity),u_image:new t.Uniform1i(e,i.u_image),u_pattern_tl_a:new t.Uniform2f(e,i.u_pattern_tl_a),u_pattern_br_a:new t.Uniform2f(e,i.u_pattern_br_a),u_pattern_tl_b:new t.Uniform2f(e,i.u_pattern_tl_b),u_pattern_br_b:new t.Uniform2f(e,i.u_pattern_br_b),u_texsize:new t.Uniform2f(e,i.u_texsize),u_mix:new t.Uniform1f(e,i.u_mix),u_pattern_size_a:new t.Uniform2f(e,i.u_pattern_size_a),u_pattern_size_b:new t.Uniform2f(e,i.u_pattern_size_b),u_scale_a:new t.Uniform1f(e,i.u_scale_a),u_scale_b:new t.Uniform1f(e,i.u_scale_b),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_tile_units_to_pixels:new t.Uniform1f(e,i.u_tile_units_to_pixels)}}};function Yi(e,i,o,r,a,n,s){for(var l=e.context,c=l.gl,u=e.useProgram("collisionBox"),h=[],p=0,d=0,_=0;_<r.length;_++){var f=r[_],m=i.getTile(f),g=m.getBucket(o);if(g){var v=f.posMatrix;0===a[0]&&0===a[1]||(v=e.translatePosMatrix(f.posMatrix,m,a,n));var y=s?g.textCollisionBox:g.iconCollisionBox,x=g.collisionCircleArray;if(x.length>0){var b=t.create(),w=v;t.mul(b,g.placementInvProjMatrix,e.transform.glCoordMatrix),t.mul(b,b,g.placementViewportMatrix),h.push({circleArray:x,circleOffset:d,transform:w,invTransform:b}),d=p+=x.length/4;}y&&u.draw(l,c.LINES,It.disabled,Pt.disabled,e.colorModeForRenderPass(),Ct.disabled,Di(v,e.transform,m),o.id,y.layoutVertexBuffer,y.indexBuffer,y.segments,null,e.transform.zoom,null,null,y.collisionVertexBuffer);}}if(s&&h.length){var T=e.useProgram("collisionCircle"),E=new t.StructArrayLayout2f1f2i16;E.resize(4*p),E._trim();for(var I=0,P=0,S=h;P<S.length;P+=1)for(var C=S[P],z=0;z<C.circleArray.length/4;z++){var D=4*z,A=C.circleArray[D+0],M=C.circleArray[D+1],L=C.circleArray[D+2],R=C.circleArray[D+3];E.emplace(I++,A,M,L,R,0),E.emplace(I++,A,M,L,R,1),E.emplace(I++,A,M,L,R,2),E.emplace(I++,A,M,L,R,3);}(!ji||ji.length<2*p)&&(ji=function(e){var i=2*e,o=new t.StructArrayLayout3ui6;o.resize(i),o._trim();for(var r=0;r<i;r++){var a=6*r;o.uint16[a+0]=4*r+0,o.uint16[a+1]=4*r+1,o.uint16[a+2]=4*r+2,o.uint16[a+3]=4*r+2,o.uint16[a+4]=4*r+3,o.uint16[a+5]=4*r+0;}return o}(p));for(var k=l.createIndexBuffer(ji,!0),B=l.createVertexBuffer(E,t.collisionCircleLayout.members,!0),O=0,F=h;O<F.length;O+=1){var U=F[O],N=Ai(U.transform,U.invTransform,e.transform);T.draw(l,c.TRIANGLES,It.disabled,Pt.disabled,e.colorModeForRenderPass(),Ct.disabled,N,o.id,B,k,t.SegmentVector.simpleSegment(0,2*U.circleOffset,U.circleArray.length,U.circleArray.length/2),null,e.transform.zoom,null,null,null);}B.destroy(),k.destroy();}}var Ji=t.identity(new Float32Array(16));function Qi(e,i,o,r,a,n){var s=t.getAnchorAlignment(e),l=-(s.horizontalAlign-.5)*i,c=-(s.verticalAlign-.5)*o,u=t.evaluateVariableOffset(e,r);return new t.Point((l/a+u[0])*n,(c/a+u[1])*n)}function $i(e,i,o,r,a,n,s,l,c,u,h){var p=e.text.placedSymbolArray,d=e.text.dynamicLayoutVertexArray,_=e.icon.dynamicLayoutVertexArray,f={};d.clear();for(var m=0;m<p.length;m++){var g=p.get(m),v=g.hidden||!g.crossTileID||e.allowVerticalPlacement&&!g.placedOrientation?null:r[g.crossTileID];if(v){var y=new t.Point(g.anchorX,g.anchorY),x=$t(y,o?l:s),b=te(n.cameraToCenterDistance,x.signedDistanceFromCamera),w=a.evaluateSizeForFeature(e.textSizeData,u,g)*b/t.ONE_EM;o&&(w*=e.tilePixelRatio/c);for(var T=Qi(v.anchor,v.width,v.height,v.textOffset,v.textBoxScale,w),E=o?$t(y.add(T),s).point:x.point.add(i?T.rotate(-n.angle):T),I=e.allowVerticalPlacement&&g.placedOrientation===t.WritingMode.vertical?Math.PI/2:0,P=0;P<g.numGlyphs;P++)t.addDynamicAttributes(d,E,I);h&&g.associatedIconIndex>=0&&(f[g.associatedIconIndex]={shiftedAnchor:E,angle:I});}else ce(g.numGlyphs,d);}if(h){_.clear();for(var S=e.icon.placedSymbolArray,C=0;C<S.length;C++){var z=S.get(C);if(z.hidden)ce(z.numGlyphs,_);else {var D=f[C];if(D)for(var A=0;A<z.numGlyphs;A++)t.addDynamicAttributes(_,D.shiftedAnchor,D.angle);else ce(z.numGlyphs,_);}}e.icon.dynamicLayoutVertexBuffer.updateData(_);}e.text.dynamicLayoutVertexBuffer.updateData(d);}function to(t,e,i){return i.iconsInText&&e?"symbolTextAndIcon":t?"symbolSDF":"symbolIcon"}function eo(e,i,o,r,a,n,s,l,c,u,h,p){for(var d=e.context,_=d.gl,f=e.transform,m="map"===l,g="map"===c,v=m&&"point"!==o.layout.get("symbol-placement"),y=m&&!g&&!v,x=void 0!==o.layout.get("symbol-sort-key").constantOr(1),b=!1,w=e.depthModeForSublayer(0,It.ReadOnly),T=o.layout.get("text-variable-anchor"),E=[],I=0,P=r;I<P.length;I+=1){var S=P[I],C=i.getTile(S),z=C.getBucket(o);if(z){var D=a?z.text:z.icon;if(D&&D.segments.get().length){var A=D.programConfigurations.get(o.id),M=a||z.sdfIcons,L=a?z.textSizeData:z.iconSizeData,R=g||0!==f.pitch,k=e.useProgram(to(M,a,z),A),B=t.evaluateSizeForZoom(L,f.zoom),O=void 0,F=[0,0],U=void 0,N=void 0,Z=null,q=void 0;if(a)U=C.glyphAtlasTexture,N=_.LINEAR,O=C.glyphAtlasTexture.size,z.iconsInText&&(F=C.imageAtlasTexture.size,Z=C.imageAtlasTexture,q=R||e.options.rotating||e.options.zooming||"composite"===L.kind||"camera"===L.kind?_.LINEAR:_.NEAREST);else {var j=1!==o.layout.get("icon-size").constantOr(0)||z.iconsNeedLinear;U=C.imageAtlasTexture,N=M||e.options.rotating||e.options.zooming||j||R?_.LINEAR:_.NEAREST,O=C.imageAtlasTexture.size;}var V=pe(C,1,e.transform.zoom),G=Jt(S.posMatrix,g,m,e.transform,V),W=Qt(S.posMatrix,g,m,e.transform,V),X=T&&z.hasTextData(),H="none"!==o.layout.get("icon-text-fit")&&X&&z.hasIconData();v&&ie(z,S.posMatrix,e,a,G,W,g,u);var K=e.translatePosMatrix(S.posMatrix,C,n,s),Y=v||a&&T||H?Ji:G,J=e.translatePosMatrix(W,C,n,s,!0),Q=M&&0!==o.paint.get(a?"text-halo-width":"icon-halo-width").constantOr(1),$={program:k,buffers:D,uniformValues:M?z.iconsInText?Wi(L.kind,B,y,g,e,K,Y,J,O,F):Gi(L.kind,B,y,g,e,K,Y,J,a,O,!0):Vi(L.kind,B,y,g,e,K,Y,J,a,O),atlasTexture:U,atlasTextureIcon:Z,atlasInterpolation:N,atlasInterpolationIcon:q,isSDF:M,hasHalo:Q};if(x&&z.canOverlap){b=!0;for(var tt=0,et=D.segments.get();tt<et.length;tt+=1){var it=et[tt];E.push({segments:new t.SegmentVector([it]),sortKey:it.sortKey,state:$});}}else E.push({segments:D.segments,sortKey:0,state:$});}}}b&&E.sort((function(t,e){return t.sortKey-e.sortKey}));for(var ot=0,rt=E;ot<rt.length;ot+=1){var at=rt[ot],nt=at.state;if(d.activeTexture.set(_.TEXTURE0),nt.atlasTexture.bind(nt.atlasInterpolation,_.CLAMP_TO_EDGE),nt.atlasTextureIcon&&(d.activeTexture.set(_.TEXTURE1),nt.atlasTextureIcon&&nt.atlasTextureIcon.bind(nt.atlasInterpolationIcon,_.CLAMP_TO_EDGE)),nt.isSDF){var st=nt.uniformValues;nt.hasHalo&&(st.u_is_halo=1,io(nt.buffers,at.segments,o,e,nt.program,w,h,p,st)),st.u_is_halo=0;}io(nt.buffers,at.segments,o,e,nt.program,w,h,p,nt.uniformValues);}}function io(t,e,i,o,r,a,n,s,l){var c=o.context;r.draw(c,c.gl.TRIANGLES,a,n,s,Ct.disabled,l,i.id,t.layoutVertexBuffer,t.indexBuffer,e,i.paint,o.transform.zoom,t.programConfigurations.get(i.id),t.dynamicLayoutVertexBuffer,t.opacityVertexBuffer);}function oo(t,e,i,o,r,a,n){var s,l,c,u,h,p=t.context.gl,d=i.paint.get("fill-pattern"),_=d&&d.constantOr(1),f=i.getCrossfadeParameters();n?(l=_&&!i.getPaintProperty("fill-outline-color")?"fillOutlinePattern":"fillOutline",s=p.LINES):(l=_?"fillPattern":"fill",s=p.TRIANGLES);for(var m=0,g=o;m<g.length;m+=1){var v=g[m],y=e.getTile(v);if(!_||y.patternsLoaded()){var x=y.getBucket(i);if(x){var b=x.programConfigurations.get(i.id),w=t.useProgram(l,b);_&&(t.context.activeTexture.set(p.TEXTURE0),y.imageAtlasTexture.bind(p.LINEAR,p.CLAMP_TO_EDGE),b.updatePaintBuffers(f));var T=d.constantOr(null);if(T&&y.imageAtlas){var E=y.imageAtlas,I=E.patternPositions[T.to.toString()],P=E.patternPositions[T.from.toString()];I&&P&&b.setConstantPatternPositions(I,P);}var S=t.translatePosMatrix(v.posMatrix,y,i.paint.get("fill-translate"),i.paint.get("fill-translate-anchor"));if(n){u=x.indexBuffer2,h=x.segments2;var C=[p.drawingBufferWidth,p.drawingBufferHeight];c="fillOutlinePattern"===l&&_?Ci(S,t,f,y,C):Si(S,C);}else u=x.indexBuffer,h=x.segments,c=_?Pi(S,t,f,y):Ii(S);w.draw(t.context,s,r,t.stencilModeForClipping(v),a,Ct.disabled,c,i.id,x.layoutVertexBuffer,u,h,i.paint,t.transform.zoom,b);}}}}function ro(t,e,i,o,r,a,n){for(var s=t.context,l=s.gl,c=i.paint.get("fill-extrusion-pattern"),u=c.constantOr(1),h=i.getCrossfadeParameters(),p=i.paint.get("fill-extrusion-opacity"),d=0,_=o;d<_.length;d+=1){var f=_[d],m=e.getTile(f),g=m.getBucket(i);if(g){var v=g.programConfigurations.get(i.id),y=t.useProgram(u?"fillExtrusionPattern":"fillExtrusion",v);u&&(t.context.activeTexture.set(l.TEXTURE0),m.imageAtlasTexture.bind(l.LINEAR,l.CLAMP_TO_EDGE),v.updatePaintBuffers(h));var x=c.constantOr(null);if(x&&m.imageAtlas){var b=m.imageAtlas,w=b.patternPositions[x.to.toString()],T=b.patternPositions[x.from.toString()];w&&T&&v.setConstantPatternPositions(w,T);}var E=t.translatePosMatrix(f.posMatrix,m,i.paint.get("fill-extrusion-translate"),i.paint.get("fill-extrusion-translate-anchor")),I=i.paint.get("fill-extrusion-vertical-gradient"),P=u?Ei(E,t,I,p,f,h,m):Ti(E,t,I,p);y.draw(s,s.gl.TRIANGLES,r,a,n,Ct.backCCW,P,i.id,g.layoutVertexBuffer,g.indexBuffer,g.segments,i.paint,t.transform.zoom,v);}}}function ao(e,i,o,r,a,n){var s=e.context,l=s.gl,c=i.fbo;if(c){var u=e.useProgram("hillshade");s.activeTexture.set(l.TEXTURE0),l.bindTexture(l.TEXTURE_2D,c.colorAttachment.get());var h=function(e,i,o){var r=o.paint.get("hillshade-shadow-color"),a=o.paint.get("hillshade-highlight-color"),n=o.paint.get("hillshade-accent-color"),s=o.paint.get("hillshade-illumination-direction")*(Math.PI/180);"viewport"===o.paint.get("hillshade-illumination-anchor")&&(s-=e.transform.angle);var l,c,u,h=!e.options.moving;return {u_matrix:e.transform.calculatePosMatrix(i.tileID.toUnwrapped(),h),u_image:0,u_latrange:(l=i.tileID,c=Math.pow(2,l.canonical.z),u=l.canonical.y,[new t.MercatorCoordinate(0,u/c).toLngLat().lat,new t.MercatorCoordinate(0,(u+1)/c).toLngLat().lat]),u_light:[o.paint.get("hillshade-exaggeration"),s],u_shadow:r,u_highlight:a,u_accent:n}}(e,i,o);u.draw(s,l.TRIANGLES,r,a,n,Ct.disabled,h,o.id,e.rasterBoundsBuffer,e.quadTriangleIndexBuffer,e.rasterBoundsSegments);}}function no(e,i,o,r,a,n){var s=e.context,l=s.gl,c=i.dem;if(c&&c.data){var u=c.dim,h=c.stride,p=c.getPixels();if(s.activeTexture.set(l.TEXTURE1),s.pixelStoreUnpackPremultiplyAlpha.set(!1),i.demTexture=i.demTexture||e.getTileTexture(h),i.demTexture){var d=i.demTexture;d.update(p,{premultiply:!1}),d.bind(l.NEAREST,l.CLAMP_TO_EDGE);}else i.demTexture=new t.Texture(s,p,l.RGBA,{premultiply:!1}),i.demTexture.bind(l.NEAREST,l.CLAMP_TO_EDGE);s.activeTexture.set(l.TEXTURE0);var _=i.fbo;if(!_){var f=new t.Texture(s,{width:u,height:u,data:null},l.RGBA);f.bind(l.LINEAR,l.CLAMP_TO_EDGE),(_=i.fbo=s.createFramebuffer(u,u,!0)).colorAttachment.set(f.texture);}s.bindFramebuffer.set(_.framebuffer),s.viewport.set([0,0,u,u]),e.useProgram("hillshadePrepare").draw(s,l.TRIANGLES,r,a,n,Ct.disabled,function(e,i){var o=i.stride,r=t.create();return t.ortho(r,0,t.EXTENT,-t.EXTENT,0,0,1),t.translate(r,r,[0,-t.EXTENT,0]),{u_matrix:r,u_image:1,u_dimension:[o,o],u_zoom:e.overscaledZ,u_unpack:i.getUnpackVector()}}(i.tileID,c),o.id,e.rasterBoundsBuffer,e.quadTriangleIndexBuffer,e.rasterBoundsSegments),i.needsHillshadePrepare=!1;}}function so(e,i,o,r,a){var n=r.paint.get("raster-fade-duration");if(n>0){var s=t.browser.now(),l=(s-e.timeAdded)/n,c=i?(s-i.timeAdded)/n:-1,u=o.getSource(),h=a.coveringZoomLevel({tileSize:u.tileSize,roundZoom:u.roundZoom}),p=!i||Math.abs(i.tileID.overscaledZ-h)>Math.abs(e.tileID.overscaledZ-h),d=p&&e.refreshedUponExpiration?1:t.clamp(p?l:1-c,0,1);return e.refreshedUponExpiration&&l>=1&&(e.refreshedUponExpiration=!1),i?{opacity:1,mix:1-d}:{opacity:d,mix:0}}return {opacity:1,mix:0}}var lo=new t.Color(1,0,0,1),co=new t.Color(0,1,0,1),uo=new t.Color(0,0,1,1),ho=new t.Color(1,0,1,1),po=new t.Color(0,1,1,1);function _o(t,e,i,o){mo(t,0,e+i/2,t.transform.width,i,o);}function fo(t,e,i,o){mo(t,e-i/2,0,i,t.transform.height,o);}function mo(e,i,o,r,a,n){var s=e.context,l=s.gl;l.enable(l.SCISSOR_TEST),l.scissor(i*t.browser.devicePixelRatio,o*t.browser.devicePixelRatio,r*t.browser.devicePixelRatio,a*t.browser.devicePixelRatio),s.clear({color:n}),l.disable(l.SCISSOR_TEST);}function go(e,i,o){var r=e.context,a=r.gl,n=o.posMatrix,s=e.useProgram("debug"),l=It.disabled,c=Pt.disabled,u=e.colorModeForRenderPass();r.activeTexture.set(a.TEXTURE0),e.emptyTexture.bind(a.LINEAR,a.CLAMP_TO_EDGE),s.draw(r,a.LINE_STRIP,l,c,u,Ct.disabled,Mi(n,t.Color.red),"$debug",e.debugBuffer,e.tileBorderIndexBuffer,e.debugSegments);var h=i.getTileByID(o.key).latestRawTileData,p=Math.floor((h&&h.byteLength||0)/1024),d=i.getTile(o).tileSize,_=512/Math.min(d,512)*(o.overscaledZ/e.transform.zoom)*.5,f=o.canonical.toString();o.overscaledZ!==o.canonical.z&&(f+=" => "+o.overscaledZ),function(t,e){t.initDebugOverlayCanvas();var i=t.debugOverlayCanvas,o=t.context.gl,r=t.debugOverlayCanvas.getContext("2d");r.clearRect(0,0,i.width,i.height),r.shadowColor="white",r.shadowBlur=2,r.lineWidth=1.5,r.strokeStyle="white",r.textBaseline="top",r.font="bold 36px Open Sans, sans-serif",r.fillText(e,5,5),r.strokeText(e,5,5),t.debugOverlayTexture.update(i),t.debugOverlayTexture.bind(o.LINEAR,o.CLAMP_TO_EDGE);}(e,f+" "+p+"kb"),s.draw(r,a.TRIANGLES,l,c,St.alphaBlended,Ct.disabled,Mi(n,t.Color.transparent,_),"$debug",e.debugBuffer,e.quadTriangleIndexBuffer,e.debugSegments);}var vo={symbol:function(e,i,o,r,a){if("translucent"===e.renderPass){var n=Pt.disabled,s=e.colorModeForRenderPass();o.layout.get("text-variable-anchor")&&function(e,i,o,r,a,n,s){for(var l=i.transform,c="map"===a,u="map"===n,h=0,p=e;h<p.length;h+=1){var d=p[h],_=r.getTile(d),f=_.getBucket(o);if(f&&f.text&&f.text.segments.get().length){var m=t.evaluateSizeForZoom(f.textSizeData,l.zoom),g=pe(_,1,i.transform.zoom),v=Jt(d.posMatrix,u,c,i.transform,g),y="none"!==o.layout.get("icon-text-fit")&&f.hasIconData();if(m){var x=Math.pow(2,l.zoom-_.tileID.overscaledZ);$i(f,c,u,s,t.symbolSize,l,v,d.posMatrix,x,m,y);}}}}(r,e,o,i,o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),a),0!==o.paint.get("icon-opacity").constantOr(1)&&eo(e,i,o,r,!1,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),o.layout.get("icon-rotation-alignment"),o.layout.get("icon-pitch-alignment"),o.layout.get("icon-keep-upright"),n,s),0!==o.paint.get("text-opacity").constantOr(1)&&eo(e,i,o,r,!0,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),o.layout.get("text-keep-upright"),n,s),i.map.showCollisionBoxes&&(Yi(e,i,o,r,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),!0),Yi(e,i,o,r,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),!1));}},circle:function(e,i,o,r){if("translucent"===e.renderPass){var a=o.paint.get("circle-opacity"),n=o.paint.get("circle-stroke-width"),s=o.paint.get("circle-stroke-opacity"),l=void 0!==o.layout.get("circle-sort-key").constantOr(1);if(0!==a.constantOr(1)||0!==n.constantOr(1)&&0!==s.constantOr(1)){for(var c=e.context,u=c.gl,h=e.depthModeForSublayer(0,It.ReadOnly),p=Pt.disabled,d=e.colorModeForRenderPass(),_=[],f=0;f<r.length;f++){var m=r[f],g=i.getTile(m),v=g.getBucket(o);if(v){var y=v.programConfigurations.get(o.id),x={programConfiguration:y,program:e.useProgram("circle",y),layoutVertexBuffer:v.layoutVertexBuffer,indexBuffer:v.indexBuffer,uniformValues:zi(e,m,g,o)};if(l)for(var b=0,w=v.segments.get();b<w.length;b+=1){var T=w[b];_.push({segments:new t.SegmentVector([T]),sortKey:T.sortKey,state:x});}else _.push({segments:v.segments,sortKey:0,state:x});}}l&&_.sort((function(t,e){return t.sortKey-e.sortKey}));for(var E=0,I=_;E<I.length;E+=1){var P=I[E],S=P.state;S.program.draw(c,u.TRIANGLES,h,p,d,Ct.disabled,S.uniformValues,o.id,S.layoutVertexBuffer,S.indexBuffer,P.segments,o.paint,e.transform.zoom,S.programConfiguration);}}}},heatmap:function(e,i,o,r){if(0!==o.paint.get("heatmap-opacity"))if("offscreen"===e.renderPass){var a=e.context,n=a.gl,s=Pt.disabled,l=new St([n.ONE,n.ONE],t.Color.transparent,[!0,!0,!0,!0]);!function(t,e,i){var o=t.gl;t.activeTexture.set(o.TEXTURE1),t.viewport.set([0,0,e.width/4,e.height/4]);var r=i.heatmapFbo;if(r)o.bindTexture(o.TEXTURE_2D,r.colorAttachment.get()),t.bindFramebuffer.set(r.framebuffer);else {var a=o.createTexture();o.bindTexture(o.TEXTURE_2D,a),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.LINEAR),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.LINEAR),r=i.heatmapFbo=t.createFramebuffer(e.width/4,e.height/4,!1),function(t,e,i,o){var r=t.gl;r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width/4,e.height/4,0,r.RGBA,t.extRenderToTextureHalfFloat?t.extTextureHalfFloat.HALF_FLOAT_OES:r.UNSIGNED_BYTE,null),o.colorAttachment.set(i);}(t,e,a,r);}}(a,e,o),a.clear({color:t.Color.transparent});for(var c=0;c<r.length;c++){var u=r[c];if(!i.hasRenderableParent(u)){var h=i.getTile(u),p=h.getBucket(o);if(p){var d=p.programConfigurations.get(o.id);e.useProgram("heatmap",d).draw(a,n.TRIANGLES,It.disabled,s,l,Ct.disabled,Ri(u.posMatrix,h,e.transform.zoom,o.paint.get("heatmap-intensity")),o.id,p.layoutVertexBuffer,p.indexBuffer,p.segments,o.paint,e.transform.zoom,d);}}}a.viewport.set([0,0,e.width,e.height]);}else "translucent"===e.renderPass&&(e.context.setColorMode(e.colorModeForRenderPass()),function(e,i){var o=e.context,r=o.gl,a=i.heatmapFbo;if(a){o.activeTexture.set(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,a.colorAttachment.get()),o.activeTexture.set(r.TEXTURE1);var n=i.colorRampTexture;n||(n=i.colorRampTexture=new t.Texture(o,i.colorRamp,r.RGBA)),n.bind(r.LINEAR,r.CLAMP_TO_EDGE),e.useProgram("heatmapTexture").draw(o,r.TRIANGLES,It.disabled,Pt.disabled,e.colorModeForRenderPass(),Ct.disabled,function(e,i,o,r){var a=t.create();t.ortho(a,0,e.width,e.height,0,0,1);var n=e.context.gl;return {u_matrix:a,u_world:[n.drawingBufferWidth,n.drawingBufferHeight],u_image:0,u_color_ramp:1,u_opacity:i.paint.get("heatmap-opacity")}}(e,i),i.id,e.viewportBuffer,e.quadTriangleIndexBuffer,e.viewportSegments,i.paint,e.transform.zoom);}}(e,o));},line:function(e,i,o,r){if("translucent"===e.renderPass){var a=o.paint.get("line-opacity"),n=o.paint.get("line-width");if(0!==a.constantOr(1)&&0!==n.constantOr(1))for(var s=e.depthModeForSublayer(0,It.ReadOnly),l=e.colorModeForRenderPass(),c=o.paint.get("line-dasharray"),u=o.paint.get("line-pattern"),h=u.constantOr(1),p=o.paint.get("line-gradient"),d=o.getCrossfadeParameters(),_=h?"linePattern":c?"lineSDF":p?"lineGradient":"line",f=e.context,m=f.gl,g=!0,v=0,y=r;v<y.length;v+=1){var x=y[v],b=i.getTile(x);if(!h||b.patternsLoaded()){var w=b.getBucket(o);if(w){var T=w.programConfigurations.get(o.id),E=e.context.program.get(),I=e.useProgram(_,T),P=g||I.program!==E,S=u.constantOr(null);if(S&&b.imageAtlas){var C=b.imageAtlas,z=C.patternPositions[S.to.toString()],D=C.patternPositions[S.from.toString()];z&&D&&T.setConstantPatternPositions(z,D);}var A=h?Oi(e,b,o,d):c?Fi(e,b,o,c,d):p?Bi(e,b,o,w.lineClipsArray.length):ki(e,b,o);if(h)f.activeTexture.set(m.TEXTURE0),b.imageAtlasTexture.bind(m.LINEAR,m.CLAMP_TO_EDGE),T.updatePaintBuffers(d);else if(c&&(P||e.lineAtlas.dirty))f.activeTexture.set(m.TEXTURE0),e.lineAtlas.bind(f);else if(p){var M=w.gradients[o.id],L=M.texture;if(o.gradientVersion!==M.version){var R=256;if(o.stepInterpolant){var k=i.getSource().maxzoom,B=x.canonical.z===k?Math.ceil(1<<e.transform.maxZoom-x.canonical.z):1;R=t.clamp(t.nextPowerOfTwo(w.maxLineLength/t.EXTENT*1024*B),256,f.maxTextureSize);}M.gradient=t.renderColorRamp({expression:o.gradientExpression(),evaluationKey:"lineProgress",resolution:R,image:M.gradient||void 0,clips:w.lineClipsArray}),M.texture?M.texture.update(M.gradient):M.texture=new t.Texture(f,M.gradient,m.RGBA),M.version=o.gradientVersion,L=M.texture;}f.activeTexture.set(m.TEXTURE0),L.bind(o.stepInterpolant?m.NEAREST:m.LINEAR,m.CLAMP_TO_EDGE);}I.draw(f,m.TRIANGLES,s,e.stencilModeForClipping(x),l,Ct.disabled,A,o.id,w.layoutVertexBuffer,w.indexBuffer,w.segments,o.paint,e.transform.zoom,T,w.layoutVertexBuffer2),g=!1;}}}}},fill:function(e,i,o,r){var a=o.paint.get("fill-color"),n=o.paint.get("fill-opacity");if(0!==n.constantOr(1)){var s=e.colorModeForRenderPass(),l=o.paint.get("fill-pattern"),c=e.opaquePassEnabledForLayer()&&!l.constantOr(1)&&1===a.constantOr(t.Color.transparent).a&&1===n.constantOr(0)?"opaque":"translucent";if(e.renderPass===c){var u=e.depthModeForSublayer(1,"opaque"===e.renderPass?It.ReadWrite:It.ReadOnly);oo(e,i,o,r,u,s,!1);}if("translucent"===e.renderPass&&o.paint.get("fill-antialias")){var h=e.depthModeForSublayer(o.getPaintProperty("fill-outline-color")?2:0,It.ReadOnly);oo(e,i,o,r,h,s,!0);}}},"fill-extrusion":function(t,e,i,o){var r=i.paint.get("fill-extrusion-opacity");if(0!==r&&"translucent"===t.renderPass){var a=new It(t.context.gl.LEQUAL,It.ReadWrite,t.depthRangeFor3D);if(1!==r||i.paint.get("fill-extrusion-pattern").constantOr(1))ro(t,e,i,o,a,Pt.disabled,St.disabled),ro(t,e,i,o,a,t.stencilModeFor3D(),t.colorModeForRenderPass());else {var n=t.colorModeForRenderPass();ro(t,e,i,o,a,Pt.disabled,n);}}},hillshade:function(t,e,i,o){if("offscreen"===t.renderPass||"translucent"===t.renderPass){for(var r=t.context,a=t.depthModeForSublayer(0,It.ReadOnly),n=t.colorModeForRenderPass(),s="translucent"===t.renderPass?t.stencilConfigForOverlap(o):[{},o],l=s[0],c=0,u=s[1];c<u.length;c+=1){var h=u[c],p=e.getTile(h);p.needsHillshadePrepare&&"offscreen"===t.renderPass?no(t,p,i,a,Pt.disabled,n):"translucent"===t.renderPass&&ao(t,p,i,a,l[h.overscaledZ],n);}r.viewport.set([0,0,t.width,t.height]);}},raster:function(t,e,i,o){if("translucent"===t.renderPass&&0!==i.paint.get("raster-opacity")&&o.length)for(var r=t.context,a=r.gl,n=e.getSource(),s=t.useProgram("raster"),l=t.colorModeForRenderPass(),c=n instanceof M?[{},o]:t.stencilConfigForOverlap(o),u=c[0],h=c[1],p=h[h.length-1].overscaledZ,d=!t.options.moving,_=0,f=h;_<f.length;_+=1){var m=f[_],g=t.depthModeForSublayer(m.overscaledZ-p,1===i.paint.get("raster-opacity")?It.ReadWrite:It.ReadOnly,a.LESS),v=e.getTile(m),y=t.transform.calculatePosMatrix(m.toUnwrapped(),d);v.registerFadeDuration(i.paint.get("raster-fade-duration"));var x=e.findLoadedParent(m,0),b=so(v,x,e,i,t.transform),w=void 0,T=void 0,E="nearest"===i.paint.get("raster-resampling")?a.NEAREST:a.LINEAR;r.activeTexture.set(a.TEXTURE0),v.texture.bind(E,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST),r.activeTexture.set(a.TEXTURE1),x?(x.texture.bind(E,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST),w=Math.pow(2,x.tileID.overscaledZ-v.tileID.overscaledZ),T=[v.tileID.canonical.x*w%1,v.tileID.canonical.y*w%1]):v.texture.bind(E,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST);var I=Zi(y,T||[0,0],w||1,b,i);n instanceof M?s.draw(r,a.TRIANGLES,g,Pt.disabled,l,Ct.disabled,I,i.id,n.boundsBuffer,t.quadTriangleIndexBuffer,n.boundsSegments):s.draw(r,a.TRIANGLES,g,u[m.overscaledZ],l,Ct.disabled,I,i.id,t.rasterBoundsBuffer,t.quadTriangleIndexBuffer,t.rasterBoundsSegments);}},background:function(t,e,i){var o=i.paint.get("background-color"),r=i.paint.get("background-opacity");if(0!==r){var a=t.context,n=a.gl,s=t.transform,l=s.tileSize,c=i.paint.get("background-pattern");if(!t.isPatternMissing(c)){var u=!c&&1===o.a&&1===r&&t.opaquePassEnabledForLayer()?"opaque":"translucent";if(t.renderPass===u){var h=Pt.disabled,p=t.depthModeForSublayer(0,"opaque"===u?It.ReadWrite:It.ReadOnly),d=t.colorModeForRenderPass(),_=t.useProgram(c?"backgroundPattern":"background"),f=s.coveringTiles({tileSize:l});c&&(a.activeTexture.set(n.TEXTURE0),t.imageManager.bind(t.context));for(var m=i.getCrossfadeParameters(),g=0,v=f;g<v.length;g+=1){var y=v[g],x=t.transform.calculatePosMatrix(y.toUnwrapped()),b=c?Hi(x,r,t,c,{tileID:y,tileSize:l},m):Xi(x,r,o);_.draw(a,n.TRIANGLES,p,h,d,Ct.disabled,b,i.id,t.tileExtentBuffer,t.quadTriangleIndexBuffer,t.tileExtentSegments);}}}}},debug:function(t,e,i){for(var o=0;o<i.length;o++)go(t,e,i[o]);},custom:function(t,e,i){var o=t.context,r=i.implementation;if("offscreen"===t.renderPass){var a=r.prerender;a&&(t.setCustomLayerDefaults(),o.setColorMode(t.colorModeForRenderPass()),a.call(r,o.gl,t.transform.customLayerMatrix()),o.setDirty(),t.setBaseState());}else if("translucent"===t.renderPass){t.setCustomLayerDefaults(),o.setColorMode(t.colorModeForRenderPass()),o.setStencilMode(Pt.disabled);var n="3d"===r.renderingMode?new It(t.context.gl.LEQUAL,It.ReadWrite,t.depthRangeFor3D):t.depthModeForSublayer(0,It.ReadOnly);o.setDepthMode(n),r.render(o.gl,t.transform.customLayerMatrix()),o.setDirty(),t.setBaseState(),o.bindFramebuffer.set(null);}}},yo=function(t,e){this.context=new zt(t),this.transform=e,this._tileTextures={},this.setup(),this.numSublayers=Dt.maxUnderzooming+Dt.maxOverzooming+1,this.depthEpsilon=1/Math.pow(2,16),this.crossTileSymbolIndex=new Fe,this.gpuTimers={};};yo.prototype.resize=function(e,i){if(this.width=e*t.browser.devicePixelRatio,this.height=i*t.browser.devicePixelRatio,this.context.viewport.set([0,0,this.width,this.height]),this.style)for(var o=0,r=this.style._order;o<r.length;o+=1)this.style._layers[r[o]].resize();},yo.prototype.setup=function(){var e=this.context,i=new t.StructArrayLayout2i4;i.emplaceBack(0,0),i.emplaceBack(t.EXTENT,0),i.emplaceBack(0,t.EXTENT),i.emplaceBack(t.EXTENT,t.EXTENT),this.tileExtentBuffer=e.createVertexBuffer(i,Ve.members),this.tileExtentSegments=t.SegmentVector.simpleSegment(0,0,4,2);var o=new t.StructArrayLayout2i4;o.emplaceBack(0,0),o.emplaceBack(t.EXTENT,0),o.emplaceBack(0,t.EXTENT),o.emplaceBack(t.EXTENT,t.EXTENT),this.debugBuffer=e.createVertexBuffer(o,Ve.members),this.debugSegments=t.SegmentVector.simpleSegment(0,0,4,5);var r=new t.StructArrayLayout4i8;r.emplaceBack(0,0,0,0),r.emplaceBack(t.EXTENT,0,t.EXTENT,0),r.emplaceBack(0,t.EXTENT,0,t.EXTENT),r.emplaceBack(t.EXTENT,t.EXTENT,t.EXTENT,t.EXTENT),this.rasterBoundsBuffer=e.createVertexBuffer(r,A.members),this.rasterBoundsSegments=t.SegmentVector.simpleSegment(0,0,4,2);var a=new t.StructArrayLayout2i4;a.emplaceBack(0,0),a.emplaceBack(1,0),a.emplaceBack(0,1),a.emplaceBack(1,1),this.viewportBuffer=e.createVertexBuffer(a,Ve.members),this.viewportSegments=t.SegmentVector.simpleSegment(0,0,4,2);var n=new t.StructArrayLayout1ui2;n.emplaceBack(0),n.emplaceBack(1),n.emplaceBack(3),n.emplaceBack(2),n.emplaceBack(0),this.tileBorderIndexBuffer=e.createIndexBuffer(n);var s=new t.StructArrayLayout3ui6;s.emplaceBack(0,1,2),s.emplaceBack(2,1,3),this.quadTriangleIndexBuffer=e.createIndexBuffer(s),this.emptyTexture=new t.Texture(e,{width:1,height:1,data:new Uint8Array([0,0,0,0])},e.gl.RGBA);var l=this.context.gl;this.stencilClearMode=new Pt({func:l.ALWAYS,mask:0},0,255,l.ZERO,l.ZERO,l.ZERO);},yo.prototype.clearStencil=function(){var e=this.context,i=e.gl;this.nextStencilID=1,this.currentStencilSource=void 0;var o=t.create();t.ortho(o,0,this.width,this.height,0,0,1),t.scale(o,o,[i.drawingBufferWidth,i.drawingBufferHeight,0]),this.useProgram("clippingMask").draw(e,i.TRIANGLES,It.disabled,this.stencilClearMode,St.disabled,Ct.disabled,Li(o),"$clipping",this.viewportBuffer,this.quadTriangleIndexBuffer,this.viewportSegments);},yo.prototype._renderTileClippingMasks=function(t,e){if(this.currentStencilSource!==t.source&&t.isTileClipped()&&e&&e.length){this.currentStencilSource=t.source;var i=this.context,o=i.gl;this.nextStencilID+e.length>256&&this.clearStencil(),i.setColorMode(St.disabled),i.setDepthMode(It.disabled);var r=this.useProgram("clippingMask");this._tileClippingMaskIDs={};for(var a=0,n=e;a<n.length;a+=1){var s=n[a],l=this._tileClippingMaskIDs[s.key]=this.nextStencilID++;r.draw(i,o.TRIANGLES,It.disabled,new Pt({func:o.ALWAYS,mask:0},l,255,o.KEEP,o.KEEP,o.REPLACE),St.disabled,Ct.disabled,Li(s.posMatrix),"$clipping",this.tileExtentBuffer,this.quadTriangleIndexBuffer,this.tileExtentSegments);}}},yo.prototype.stencilModeFor3D=function(){this.currentStencilSource=void 0,this.nextStencilID+1>256&&this.clearStencil();var t=this.nextStencilID++,e=this.context.gl;return new Pt({func:e.NOTEQUAL,mask:255},t,255,e.KEEP,e.KEEP,e.REPLACE)},yo.prototype.stencilModeForClipping=function(t){var e=this.context.gl;return new Pt({func:e.EQUAL,mask:255},this._tileClippingMaskIDs[t.key],0,e.KEEP,e.KEEP,e.REPLACE)},yo.prototype.stencilConfigForOverlap=function(t){var e,i=this.context.gl,o=t.sort((function(t,e){return e.overscaledZ-t.overscaledZ})),r=o[o.length-1].overscaledZ,a=o[0].overscaledZ-r+1;if(a>1){this.currentStencilSource=void 0,this.nextStencilID+a>256&&this.clearStencil();for(var n={},s=0;s<a;s++)n[s+r]=new Pt({func:i.GEQUAL,mask:255},s+this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);return this.nextStencilID+=a,[n,o]}return [(e={},e[r]=Pt.disabled,e),o]},yo.prototype.colorModeForRenderPass=function(){var e=this.context.gl;return this._showOverdrawInspector?new St([e.CONSTANT_COLOR,e.ONE],new t.Color(1/8,1/8,1/8,0),[!0,!0,!0,!0]):"opaque"===this.renderPass?St.unblended:St.alphaBlended},yo.prototype.depthModeForSublayer=function(t,e,i){if(!this.opaquePassEnabledForLayer())return It.disabled;var o=1-((1+this.currentLayer)*this.numSublayers+t)*this.depthEpsilon;return new It(i||this.context.gl.LEQUAL,e,[o,o])},yo.prototype.opaquePassEnabledForLayer=function(){return this.currentLayer<this.opaquePassCutoff},yo.prototype.render=function(e,i){var o=this;this.style=e,this.options=i,this.lineAtlas=e.lineAtlas,this.imageManager=e.imageManager,this.glyphManager=e.glyphManager,this.symbolFadeChange=e.placement.symbolFadeChange(t.browser.now()),this.imageManager.beginFrame();var r=this.style._order,a=this.style.sourceCaches;for(var n in a){var s=a[n];s.used&&s.prepare(this.context);}var l,c,u={},h={},p={};for(var d in a){var _=a[d];u[d]=_.getVisibleCoordinates(),h[d]=u[d].slice().reverse(),p[d]=_.getVisibleCoordinates(!0).reverse();}this.opaquePassCutoff=1/0;for(var f=0;f<r.length;f++)if(this.style._layers[r[f]].is3D()){this.opaquePassCutoff=f;break}this.renderPass="offscreen";for(var m=0,g=r;m<g.length;m+=1){var v=this.style._layers[g[m]];if(v.hasOffscreenPass()&&!v.isHidden(this.transform.zoom)){var y=h[v.source];("custom"===v.type||y.length)&&this.renderLayer(this,a[v.source],v,y);}}for(this.context.bindFramebuffer.set(null),this.context.clear({color:i.showOverdrawInspector?t.Color.black:t.Color.transparent,depth:1}),this.clearStencil(),this._showOverdrawInspector=i.showOverdrawInspector,this.depthRangeFor3D=[0,1-(e._order.length+2)*this.numSublayers*this.depthEpsilon],this.renderPass="opaque",this.currentLayer=r.length-1;this.currentLayer>=0;this.currentLayer--){var x=this.style._layers[r[this.currentLayer]],b=a[x.source],w=u[x.source];this._renderTileClippingMasks(x,w),this.renderLayer(this,b,x,w);}for(this.renderPass="translucent",this.currentLayer=0;this.currentLayer<r.length;this.currentLayer++){var T=this.style._layers[r[this.currentLayer]],E=a[T.source],I=("symbol"===T.type?p:h)[T.source];this._renderTileClippingMasks(T,u[T.source]),this.renderLayer(this,E,T,I);}this.options.showTileBoundaries&&(t.values(this.style._layers).forEach((function(t){t.source&&!t.isHidden(o.transform.zoom)&&(t.source!==(c&&c.id)&&(c=o.style.sourceCaches[t.source]),(!l||l.getSource().maxzoom<c.getSource().maxzoom)&&(l=c));})),l&&vo.debug(this,l,l.getVisibleCoordinates())),this.options.showPadding&&function(t){var e=t.transform.padding;_o(t,t.transform.height-(e.top||0),3,lo),_o(t,e.bottom||0,3,co),fo(t,e.left||0,3,uo),fo(t,t.transform.width-(e.right||0),3,ho);var i=t.transform.centerPoint;!function(t,e,i,o){mo(t,e-1,i-10,2,20,o),mo(t,e-10,i-1,20,2,o);}(t,i.x,t.transform.height-i.y,po);}(this),this.context.setDefault();},yo.prototype.renderLayer=function(t,e,i,o){i.isHidden(this.transform.zoom)||("background"===i.type||"custom"===i.type||o.length)&&(this.id=i.id,this.gpuTimingStart(i),vo[i.type](t,e,i,o,this.style.placement.variableOffsets),this.gpuTimingEnd());},yo.prototype.gpuTimingStart=function(t){if(this.options.gpuTiming){var e=this.context.extTimerQuery,i=this.gpuTimers[t.id];i||(i=this.gpuTimers[t.id]={calls:0,cpuTime:0,query:e.createQueryEXT()}),i.calls++,e.beginQueryEXT(e.TIME_ELAPSED_EXT,i.query);}},yo.prototype.gpuTimingEnd=function(){if(this.options.gpuTiming){var t=this.context.extTimerQuery;t.endQueryEXT(t.TIME_ELAPSED_EXT);}},yo.prototype.collectGpuTimers=function(){var t=this.gpuTimers;return this.gpuTimers={},t},yo.prototype.queryGpuTimers=function(t){var e={};for(var i in t){var o=t[i],r=this.context.extTimerQuery,a=r.getQueryObjectEXT(o.query,r.QUERY_RESULT_EXT)/1e6;r.deleteQueryEXT(o.query),e[i]=a;}return e},yo.prototype.translatePosMatrix=function(e,i,o,r,a){if(!o[0]&&!o[1])return e;var n=a?"map"===r?this.transform.angle:0:"viewport"===r?-this.transform.angle:0;if(n){var s=Math.sin(n),l=Math.cos(n);o=[o[0]*l-o[1]*s,o[0]*s+o[1]*l];}var c=[a?o[0]:pe(i,o[0],this.transform.zoom),a?o[1]:pe(i,o[1],this.transform.zoom),0],u=new Float32Array(16);return t.translate(u,e,c),u},yo.prototype.saveTileTexture=function(t){var e=this._tileTextures[t.size[0]];e?e.push(t):this._tileTextures[t.size[0]]=[t];},yo.prototype.getTileTexture=function(t){var e=this._tileTextures[t];return e&&e.length>0?e.pop():null},yo.prototype.isPatternMissing=function(t){if(!t)return !1;if(!t.from||!t.to)return !0;var e=this.imageManager.getPattern(t.from.toString()),i=this.imageManager.getPattern(t.to.toString());return !e||!i},yo.prototype.useProgram=function(t,e){this.cache=this.cache||{};var i=""+t+(e?e.cacheKey:"")+(this._showOverdrawInspector?"/overdraw":"");return this.cache[i]||(this.cache[i]=new bi(this.context,t,vi[t],e,Ki[t],this._showOverdrawInspector)),this.cache[i]},yo.prototype.setCustomLayerDefaults=function(){this.context.unbindVAO(),this.context.cullFace.setDefault(),this.context.activeTexture.setDefault(),this.context.pixelStoreUnpack.setDefault(),this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.context.pixelStoreUnpackFlipY.setDefault();},yo.prototype.setBaseState=function(){var t=this.context.gl;this.context.cullFace.set(!1),this.context.viewport.set([0,0,this.width,this.height]),this.context.blendEquation.set(t.FUNC_ADD);},yo.prototype.initDebugOverlayCanvas=function(){null==this.debugOverlayCanvas&&(this.debugOverlayCanvas=t.window.document.createElement("canvas"),this.debugOverlayCanvas.width=512,this.debugOverlayCanvas.height=512,this.debugOverlayTexture=new t.Texture(this.context,this.debugOverlayCanvas,this.context.gl.RGBA));},yo.prototype.destroy=function(){this.emptyTexture.destroy(),this.debugOverlayTexture&&this.debugOverlayTexture.destroy();};var xo=function(t,e){this.points=t,this.planes=e;};xo.fromInvProjectionMatrix=function(e,i,o){var r=Math.pow(2,o),a=[[-1,1,-1,1],[1,1,-1,1],[1,-1,-1,1],[-1,-1,-1,1],[-1,1,1,1],[1,1,1,1],[1,-1,1,1],[-1,-1,1,1]].map((function(i){return t.transformMat4([],i,e)})).map((function(e){return t.scale$1([],e,1/e[3]/i*r)})),n=[[0,1,2],[6,5,4],[0,3,7],[2,1,5],[3,2,6],[0,4,5]].map((function(e){var i=t.sub([],a[e[0]],a[e[1]]),o=t.sub([],a[e[2]],a[e[1]]),r=t.normalize([],t.cross([],i,o)),n=-t.dot(r,a[e[1]]);return r.concat(n)}));return new xo(a,n)};var bo=function(e,i){this.min=e,this.max=i,this.center=t.scale$2([],t.add([],this.min,this.max),.5);};bo.prototype.quadrant=function(e){for(var i=[e%2==0,e<2],o=t.clone$2(this.min),r=t.clone$2(this.max),a=0;a<i.length;a++)o[a]=i[a]?this.min[a]:this.center[a],r[a]=i[a]?this.center[a]:this.max[a];return r[2]=this.max[2],new bo(o,r)},bo.prototype.distanceX=function(t){return Math.max(Math.min(this.max[0],t[0]),this.min[0])-t[0]},bo.prototype.distanceY=function(t){return Math.max(Math.min(this.max[1],t[1]),this.min[1])-t[1]},bo.prototype.intersects=function(e){for(var i=[[this.min[0],this.min[1],0,1],[this.max[0],this.min[1],0,1],[this.max[0],this.max[1],0,1],[this.min[0],this.max[1],0,1]],o=!0,r=0;r<e.planes.length;r++){for(var a=e.planes[r],n=0,s=0;s<i.length;s++)n+=t.dot$1(a,i[s])>=0;if(0===n)return 0;n!==i.length&&(o=!1);}if(o)return 2;for(var l=0;l<3;l++){for(var c=Number.MAX_VALUE,u=-Number.MAX_VALUE,h=0;h<e.points.length;h++){var p=e.points[h][l]-this.min[l];c=Math.min(c,p),u=Math.max(u,p);}if(u<0||c>this.max[l]-this.min[l])return 0}return 1};var wo=function(t,e,i,o){if(void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===o&&(o=0),isNaN(t)||t<0||isNaN(e)||e<0||isNaN(i)||i<0||isNaN(o)||o<0)throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");this.top=t,this.bottom=e,this.left=i,this.right=o;};wo.prototype.interpolate=function(e,i,o){return null!=i.top&&null!=e.top&&(this.top=t.number(e.top,i.top,o)),null!=i.bottom&&null!=e.bottom&&(this.bottom=t.number(e.bottom,i.bottom,o)),null!=i.left&&null!=e.left&&(this.left=t.number(e.left,i.left,o)),null!=i.right&&null!=e.right&&(this.right=t.number(e.right,i.right,o)),this},wo.prototype.getCenter=function(e,i){var o=t.clamp((this.left+e-this.right)/2,0,e),r=t.clamp((this.top+i-this.bottom)/2,0,i);return new t.Point(o,r)},wo.prototype.equals=function(t){return this.top===t.top&&this.bottom===t.bottom&&this.left===t.left&&this.right===t.right},wo.prototype.clone=function(){return new wo(this.top,this.bottom,this.left,this.right)},wo.prototype.toJSON=function(){return {top:this.top,bottom:this.bottom,left:this.left,right:this.right}};var To=function(e,i,o,r,a){this.tileSize=512,this.maxValidLatitude=85.051129,this._renderWorldCopies=void 0===a||a,this._minZoom=e||0,this._maxZoom=i||22,this._minPitch=null==o?0:o,this._maxPitch=null==r?60:r,this.setMaxBounds(),this.width=0,this.height=0,this._center=new t.LngLat(0,0),this.zoom=0,this.angle=0,this._fov=.6435011087932844,this._pitch=0,this._unmodified=!0,this._edgeInsets=new wo,this._posMatrixCache={},this._alignedPosMatrixCache={};},Eo={minZoom:{configurable:!0},maxZoom:{configurable:!0},minPitch:{configurable:!0},maxPitch:{configurable:!0},renderWorldCopies:{configurable:!0},worldSize:{configurable:!0},centerOffset:{configurable:!0},size:{configurable:!0},bearing:{configurable:!0},pitch:{configurable:!0},fov:{configurable:!0},zoom:{configurable:!0},center:{configurable:!0},padding:{configurable:!0},centerPoint:{configurable:!0},unmodified:{configurable:!0},point:{configurable:!0}};To.prototype.clone=function(){var t=new To(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies);return t.tileSize=this.tileSize,t.latRange=this.latRange,t.width=this.width,t.height=this.height,t._center=this._center,t.zoom=this.zoom,t.angle=this.angle,t._fov=this._fov,t._pitch=this._pitch,t._unmodified=this._unmodified,t._edgeInsets=this._edgeInsets.clone(),t._calcMatrices(),t},Eo.minZoom.get=function(){return this._minZoom},Eo.minZoom.set=function(t){this._minZoom!==t&&(this._minZoom=t,this.zoom=Math.max(this.zoom,t));},Eo.maxZoom.get=function(){return this._maxZoom},Eo.maxZoom.set=function(t){this._maxZoom!==t&&(this._maxZoom=t,this.zoom=Math.min(this.zoom,t));},Eo.minPitch.get=function(){return this._minPitch},Eo.minPitch.set=function(t){this._minPitch!==t&&(this._minPitch=t,this.pitch=Math.max(this.pitch,t));},Eo.maxPitch.get=function(){return this._maxPitch},Eo.maxPitch.set=function(t){this._maxPitch!==t&&(this._maxPitch=t,this.pitch=Math.min(this.pitch,t));},Eo.renderWorldCopies.get=function(){return this._renderWorldCopies},Eo.renderWorldCopies.set=function(t){void 0===t?t=!0:null===t&&(t=!1),this._renderWorldCopies=t;},Eo.worldSize.get=function(){return this.tileSize*this.scale},Eo.centerOffset.get=function(){return this.centerPoint._sub(this.size._div(2))},Eo.size.get=function(){return new t.Point(this.width,this.height)},Eo.bearing.get=function(){return -this.angle/Math.PI*180},Eo.bearing.set=function(e){var i=-t.wrap(e,-180,180)*Math.PI/180;this.angle!==i&&(this._unmodified=!1,this.angle=i,this._calcMatrices(),this.rotationMatrix=t.create$2(),t.rotate(this.rotationMatrix,this.rotationMatrix,this.angle));},Eo.pitch.get=function(){return this._pitch/Math.PI*180},Eo.pitch.set=function(e){var i=t.clamp(e,this.minPitch,this.maxPitch)/180*Math.PI;this._pitch!==i&&(this._unmodified=!1,this._pitch=i,this._calcMatrices());},Eo.fov.get=function(){return this._fov/Math.PI*180},Eo.fov.set=function(t){t=Math.max(.01,Math.min(60,t)),this._fov!==t&&(this._unmodified=!1,this._fov=t/180*Math.PI,this._calcMatrices());},Eo.zoom.get=function(){return this._zoom},Eo.zoom.set=function(t){var e=Math.min(Math.max(t,this.minZoom),this.maxZoom);this._zoom!==e&&(this._unmodified=!1,this._zoom=e,this.scale=this.zoomScale(e),this.tileZoom=Math.floor(e),this.zoomFraction=e-this.tileZoom,this._constrain(),this._calcMatrices());},Eo.center.get=function(){return this._center},Eo.center.set=function(t){t.lat===this._center.lat&&t.lng===this._center.lng||(this._unmodified=!1,this._center=t,this._constrain(),this._calcMatrices());},Eo.padding.get=function(){return this._edgeInsets.toJSON()},Eo.padding.set=function(t){this._edgeInsets.equals(t)||(this._unmodified=!1,this._edgeInsets.interpolate(this._edgeInsets,t,1),this._calcMatrices());},Eo.centerPoint.get=function(){return this._edgeInsets.getCenter(this.width,this.height)},To.prototype.isPaddingEqual=function(t){return this._edgeInsets.equals(t)},To.prototype.interpolatePadding=function(t,e,i){this._unmodified=!1,this._edgeInsets.interpolate(t,e,i),this._constrain(),this._calcMatrices();},To.prototype.coveringZoomLevel=function(t){var e=(t.roundZoom?Math.round:Math.floor)(this.zoom+this.scaleZoom(this.tileSize/t.tileSize));return Math.max(0,e)},To.prototype.getVisibleUnwrappedCoordinates=function(e){var i=[new t.UnwrappedTileID(0,e)];if(this._renderWorldCopies)for(var o=this.pointCoordinate(new t.Point(0,0)),r=this.pointCoordinate(new t.Point(this.width,0)),a=this.pointCoordinate(new t.Point(this.width,this.height)),n=this.pointCoordinate(new t.Point(0,this.height)),s=Math.floor(Math.min(o.x,r.x,a.x,n.x)),l=Math.floor(Math.max(o.x,r.x,a.x,n.x)),c=s-1;c<=l+1;c++)0!==c&&i.push(new t.UnwrappedTileID(c,e));return i},To.prototype.coveringTiles=function(e){var i=this.coveringZoomLevel(e),o=i;if(void 0!==e.minzoom&&i<e.minzoom)return [];void 0!==e.maxzoom&&i>e.maxzoom&&(i=e.maxzoom);var r=t.MercatorCoordinate.fromLngLat(this.center),a=Math.pow(2,i),n=[a*r.x,a*r.y,0],s=xo.fromInvProjectionMatrix(this.invProjMatrix,this.worldSize,i),l=e.minzoom||0;this.pitch<=60&&this._edgeInsets.top<.1&&(l=i);var c=function(t){return {aabb:new bo([t*a,0,0],[(t+1)*a,a,0]),zoom:0,x:0,y:0,wrap:t,fullyVisible:!1}},u=[],h=[],p=i,d=e.reparseOverscaled?o:i;if(this._renderWorldCopies)for(var _=1;_<=3;_++)u.push(c(-_)),u.push(c(_));for(u.push(c(0));u.length>0;){var f=u.pop(),m=f.x,g=f.y,v=f.fullyVisible;if(!v){var y=f.aabb.intersects(s);if(0===y)continue;v=2===y;}var x=f.aabb.distanceX(n),b=f.aabb.distanceY(n),w=Math.max(Math.abs(x),Math.abs(b));if(f.zoom===p||w>3+(1<<p-f.zoom)-2&&f.zoom>=l)h.push({tileID:new t.OverscaledTileID(f.zoom===p?d:f.zoom,f.wrap,f.zoom,m,g),distanceSq:t.sqrLen([n[0]-.5-m,n[1]-.5-g])});else for(var T=0;T<4;T++){var E=(m<<1)+T%2,I=(g<<1)+(T>>1);u.push({aabb:f.aabb.quadrant(T),zoom:f.zoom+1,x:E,y:I,wrap:f.wrap,fullyVisible:v});}}return h.sort((function(t,e){return t.distanceSq-e.distanceSq})).map((function(t){return t.tileID}))},To.prototype.resize=function(t,e){this.width=t,this.height=e,this.pixelsToGLUnits=[2/t,-2/e],this._constrain(),this._calcMatrices();},Eo.unmodified.get=function(){return this._unmodified},To.prototype.zoomScale=function(t){return Math.pow(2,t)},To.prototype.scaleZoom=function(t){return Math.log(t)/Math.LN2},To.prototype.project=function(e){var i=t.clamp(e.lat,-this.maxValidLatitude,this.maxValidLatitude);return new t.Point(t.mercatorXfromLng(e.lng)*this.worldSize,t.mercatorYfromLat(i)*this.worldSize)},To.prototype.unproject=function(e){return new t.MercatorCoordinate(e.x/this.worldSize,e.y/this.worldSize).toLngLat()},Eo.point.get=function(){return this.project(this.center)},To.prototype.setLocationAtPoint=function(e,i){var o=this.pointCoordinate(i),r=this.pointCoordinate(this.centerPoint),a=this.locationCoordinate(e),n=new t.MercatorCoordinate(a.x-(o.x-r.x),a.y-(o.y-r.y));this.center=this.coordinateLocation(n),this._renderWorldCopies&&(this.center=this.center.wrap());},To.prototype.locationPoint=function(t){return this.coordinatePoint(this.locationCoordinate(t))},To.prototype.pointLocation=function(t){return this.coordinateLocation(this.pointCoordinate(t))},To.prototype.locationCoordinate=function(e){return t.MercatorCoordinate.fromLngLat(e)},To.prototype.coordinateLocation=function(t){return t.toLngLat()},To.prototype.pointCoordinate=function(e){var i=[e.x,e.y,0,1],o=[e.x,e.y,1,1];t.transformMat4(i,i,this.pixelMatrixInverse),t.transformMat4(o,o,this.pixelMatrixInverse);var r=i[3],a=o[3],n=i[1]/r,s=o[1]/a,l=i[2]/r,c=o[2]/a,u=l===c?0:(0-l)/(c-l);return new t.MercatorCoordinate(t.number(i[0]/r,o[0]/a,u)/this.worldSize,t.number(n,s,u)/this.worldSize)},To.prototype.coordinatePoint=function(e){var i=[e.x*this.worldSize,e.y*this.worldSize,0,1];return t.transformMat4(i,i,this.pixelMatrix),new t.Point(i[0]/i[3],i[1]/i[3])},To.prototype.getBounds=function(){return (new t.LngLatBounds).extend(this.pointLocation(new t.Point(0,0))).extend(this.pointLocation(new t.Point(this.width,0))).extend(this.pointLocation(new t.Point(this.width,this.height))).extend(this.pointLocation(new t.Point(0,this.height)))},To.prototype.getMaxBounds=function(){return this.latRange&&2===this.latRange.length&&this.lngRange&&2===this.lngRange.length?new t.LngLatBounds([this.lngRange[0],this.latRange[0]],[this.lngRange[1],this.latRange[1]]):null},To.prototype.setMaxBounds=function(t){t?(this.lngRange=[t.getWest(),t.getEast()],this.latRange=[t.getSouth(),t.getNorth()],this._constrain()):(this.lngRange=null,this.latRange=[-this.maxValidLatitude,this.maxValidLatitude]);},To.prototype.calculatePosMatrix=function(e,i){void 0===i&&(i=!1);var o=e.key,r=i?this._alignedPosMatrixCache:this._posMatrixCache;if(r[o])return r[o];var a=e.canonical,n=this.worldSize/this.zoomScale(a.z),s=a.x+Math.pow(2,a.z)*e.wrap,l=t.identity(new Float64Array(16));return t.translate(l,l,[s*n,a.y*n,0]),t.scale(l,l,[n/t.EXTENT,n/t.EXTENT,1]),t.multiply(l,i?this.alignedProjMatrix:this.projMatrix,l),r[o]=new Float32Array(l),r[o]},To.prototype.customLayerMatrix=function(){return this.mercatorMatrix.slice()},To.prototype._constrain=function(){if(this.center&&this.width&&this.height&&!this._constraining){this._constraining=!0;var e,i,o,r,a=-90,n=90,s=-180,l=180,c=this.size,u=this._unmodified;if(this.latRange){var h=this.latRange;a=t.mercatorYfromLat(h[1])*this.worldSize,e=(n=t.mercatorYfromLat(h[0])*this.worldSize)-a<c.y?c.y/(n-a):0;}if(this.lngRange){var p=this.lngRange;s=t.mercatorXfromLng(p[0])*this.worldSize,i=(l=t.mercatorXfromLng(p[1])*this.worldSize)-s<c.x?c.x/(l-s):0;}var d=this.point,_=Math.max(i||0,e||0);if(_)return this.center=this.unproject(new t.Point(i?(l+s)/2:d.x,e?(n+a)/2:d.y)),this.zoom+=this.scaleZoom(_),this._unmodified=u,void(this._constraining=!1);if(this.latRange){var f=d.y,m=c.y/2;f-m<a&&(r=a+m),f+m>n&&(r=n-m);}if(this.lngRange){var g=d.x,v=c.x/2;g-v<s&&(o=s+v),g+v>l&&(o=l-v);}void 0===o&&void 0===r||(this.center=this.unproject(new t.Point(void 0!==o?o:d.x,void 0!==r?r:d.y))),this._unmodified=u,this._constraining=!1;}},To.prototype._calcMatrices=function(){if(this.height){var e=this.centerOffset;this.cameraToCenterDistance=.5/Math.tan(this._fov/2)*this.height;var i=Math.PI/2+this._pitch,o=this._fov*(.5+e.y/this.height),r=Math.sin(o)*this.cameraToCenterDistance/Math.sin(t.clamp(Math.PI-i-o,.01,Math.PI-.01)),a=this.point,n=a.x,s=a.y,l=1.01*(Math.cos(Math.PI/2-this._pitch)*r+this.cameraToCenterDistance),c=this.height/50,u=new Float64Array(16);t.perspective(u,this._fov,this.width/this.height,c,l),u[8]=2*-e.x/this.width,u[9]=2*e.y/this.height,t.scale(u,u,[1,-1,1]),t.translate(u,u,[0,0,-this.cameraToCenterDistance]),t.rotateX(u,u,this._pitch),t.rotateZ(u,u,this.angle),t.translate(u,u,[-n,-s,0]),this.mercatorMatrix=t.scale([],u,[this.worldSize,this.worldSize,this.worldSize]),t.scale(u,u,[1,1,t.mercatorZfromAltitude(1,this.center.lat)*this.worldSize,1]),this.projMatrix=u,this.invProjMatrix=t.invert([],this.projMatrix);var h=this.width%2/2,p=this.height%2/2,d=Math.cos(this.angle),_=Math.sin(this.angle),f=n-Math.round(n)+d*h+_*p,m=s-Math.round(s)+d*p+_*h,g=new Float64Array(u);if(t.translate(g,g,[f>.5?f-1:f,m>.5?m-1:m,0]),this.alignedProjMatrix=g,u=t.create(),t.scale(u,u,[this.width/2,-this.height/2,1]),t.translate(u,u,[1,-1,0]),this.labelPlaneMatrix=u,u=t.create(),t.scale(u,u,[1,-1,1]),t.translate(u,u,[-1,-1,0]),t.scale(u,u,[2/this.width,2/this.height,1]),this.glCoordMatrix=u,this.pixelMatrix=t.multiply(new Float64Array(16),this.labelPlaneMatrix,this.projMatrix),!(u=t.invert(new Float64Array(16),this.pixelMatrix)))throw new Error("failed to invert matrix");this.pixelMatrixInverse=u,this._posMatrixCache={},this._alignedPosMatrixCache={};}},To.prototype.maxPitchScaleFactor=function(){if(!this.pixelMatrixInverse)return 1;var e=this.pointCoordinate(new t.Point(0,0)),i=[e.x*this.worldSize,e.y*this.worldSize,0,1];return t.transformMat4(i,i,this.pixelMatrix)[3]/this.cameraToCenterDistance},To.prototype.getCameraPoint=function(){var e=Math.tan(this._pitch)*(this.cameraToCenterDistance||1);return this.centerPoint.add(new t.Point(0,e))},To.prototype.getCameraQueryGeometry=function(e){var i=this.getCameraPoint();if(1===e.length)return [e[0],i];for(var o=i.x,r=i.y,a=i.x,n=i.y,s=0,l=e;s<l.length;s+=1){var c=l[s];o=Math.min(o,c.x),r=Math.min(r,c.y),a=Math.max(a,c.x),n=Math.max(n,c.y);}return [new t.Point(o,r),new t.Point(a,r),new t.Point(a,n),new t.Point(o,n),new t.Point(o,r)]},Object.defineProperties(To.prototype,Eo);var Io=function(e){var i,o,r,a;this._hashName=e&&encodeURIComponent(e),t.bindAll(["_getCurrentHash","_onHashChange","_updateHash"],this),this._updateHash=(i=this._updateHashUnthrottled.bind(this),o=!1,r=null,a=function(){r=null,o&&(i(),r=setTimeout(a,300),o=!1);},function(){return o=!0,r||a(),r});};Io.prototype.addTo=function(e){return this._map=e,t.window.addEventListener("hashchange",this._onHashChange,!1),this._map.on("moveend",this._updateHash),this},Io.prototype.remove=function(){return t.window.removeEventListener("hashchange",this._onHashChange,!1),this._map.off("moveend",this._updateHash),clearTimeout(this._updateHash()),delete this._map,this},Io.prototype.getHashString=function(e){var i=this._map.getCenter(),o=Math.round(100*this._map.getZoom())/100,r=Math.ceil((o*Math.LN2+Math.log(512/360/.5))/Math.LN10),a=Math.pow(10,r),n=Math.round(i.lng*a)/a,s=Math.round(i.lat*a)/a,l=this._map.getBearing(),c=this._map.getPitch(),u="";if(u+=e?"/"+n+"/"+s+"/"+o:o+"/"+s+"/"+n,(l||c)&&(u+="/"+Math.round(10*l)/10),c&&(u+="/"+Math.round(c)),this._hashName){var h=this._hashName,p=!1,d=t.window.location.hash.slice(1).split("&").map((function(t){var e=t.split("=")[0];return e===h?(p=!0,e+"="+u):t})).filter((function(t){return t}));return p||d.push(h+"="+u),"#"+d.join("&")}return "#"+u},Io.prototype._getCurrentHash=function(){var e,i=this,o=t.window.location.hash.replace("#","");return this._hashName?(o.split("&").map((function(t){return t.split("=")})).forEach((function(t){t[0]===i._hashName&&(e=t);})),(e&&e[1]||"").split("/")):o.split("/")},Io.prototype._onHashChange=function(){var t=this._getCurrentHash();if(t.length>=3&&!t.some((function(t){return isNaN(t)}))){var e=this._map.dragRotate.isEnabled()&&this._map.touchZoomRotate.isEnabled()?+(t[3]||0):this._map.getBearing();return this._map.jumpTo({center:[+t[2],+t[1]],zoom:+t[0],bearing:e,pitch:+(t[4]||0)}),!0}return !1},Io.prototype._updateHashUnthrottled=function(){var e=t.window.location.href.replace(/(#.+)?$/,this.getHashString());try{t.window.history.replaceState(t.window.history.state,null,e);}catch(t){}};var Po={linearity:.3,easing:t.bezier(0,0,.3,1)},So=t.extend({deceleration:2500,maxSpeed:1400},Po),Co=t.extend({deceleration:20,maxSpeed:1400},Po),zo=t.extend({deceleration:1e3,maxSpeed:360},Po),Do=t.extend({deceleration:1e3,maxSpeed:90},Po),Ao=function(t){this._map=t,this.clear();};function Mo(t,e){(!t.duration||t.duration<e.duration)&&(t.duration=e.duration,t.easing=e.easing);}function Lo(e,i,o){var r=o.maxSpeed,a=o.linearity,n=o.deceleration,s=t.clamp(e*a/(i/1e3),-r,r),l=Math.abs(s)/(n*a);return {easing:o.easing,duration:1e3*l,amount:s*(l/2)}}Ao.prototype.clear=function(){this._inertiaBuffer=[];},Ao.prototype.record=function(e){this._drainInertiaBuffer(),this._inertiaBuffer.push({time:t.browser.now(),settings:e});},Ao.prototype._drainInertiaBuffer=function(){for(var e=this._inertiaBuffer,i=t.browser.now();e.length>0&&i-e[0].time>160;)e.shift();},Ao.prototype._onMoveEnd=function(e){if(this._drainInertiaBuffer(),!(this._inertiaBuffer.length<2)){for(var i={zoom:0,bearing:0,pitch:0,pan:new t.Point(0,0),pinchAround:void 0,around:void 0},o=0,r=this._inertiaBuffer;o<r.length;o+=1){var a=r[o].settings;i.zoom+=a.zoomDelta||0,i.bearing+=a.bearingDelta||0,i.pitch+=a.pitchDelta||0,a.panDelta&&i.pan._add(a.panDelta),a.around&&(i.around=a.around),a.pinchAround&&(i.pinchAround=a.pinchAround);}var n=this._inertiaBuffer[this._inertiaBuffer.length-1].time-this._inertiaBuffer[0].time,s={};if(i.pan.mag()){var l=Lo(i.pan.mag(),n,t.extend({},So,e||{}));s.offset=i.pan.mult(l.amount/i.pan.mag()),s.center=this._map.transform.center,Mo(s,l);}if(i.zoom){var c=Lo(i.zoom,n,Co);s.zoom=this._map.transform.zoom+c.amount,Mo(s,c);}if(i.bearing){var u=Lo(i.bearing,n,zo);s.bearing=this._map.transform.bearing+t.clamp(u.amount,-179,179),Mo(s,u);}if(i.pitch){var h=Lo(i.pitch,n,Do);s.pitch=this._map.transform.pitch+h.amount,Mo(s,h);}if(s.zoom||s.bearing){var p=void 0===i.pinchAround?i.around:i.pinchAround;s.around=p?this._map.unproject(p):this._map.getCenter();}return this.clear(),t.extend(s,{noMoveStart:!0})}};var Ro=function(e){function o(o,r,a,n){void 0===n&&(n={});var s=i.mousePos(r.getCanvasContainer(),a),l=r.unproject(s);e.call(this,o,t.extend({point:s,lngLat:l,originalEvent:a},n)),this._defaultPrevented=!1,this.target=r;}e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o;var r={defaultPrevented:{configurable:!0}};return o.prototype.preventDefault=function(){this._defaultPrevented=!0;},r.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(o.prototype,r),o}(t.Event),ko=function(e){function o(o,r,a){var n="touchend"===o?a.changedTouches:a.touches,s=i.touchPos(r.getCanvasContainer(),n),l=s.map((function(t){return r.unproject(t)})),c=s.reduce((function(t,e,i,o){return t.add(e.div(o.length))}),new t.Point(0,0)),u=r.unproject(c);e.call(this,o,{points:s,point:c,lngLats:l,lngLat:u,originalEvent:a}),this._defaultPrevented=!1;}e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o;var r={defaultPrevented:{configurable:!0}};return o.prototype.preventDefault=function(){this._defaultPrevented=!0;},r.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(o.prototype,r),o}(t.Event),Bo=function(t){function e(e,i,o){t.call(this,e,{originalEvent:o}),this._defaultPrevented=!1;}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var i={defaultPrevented:{configurable:!0}};return e.prototype.preventDefault=function(){this._defaultPrevented=!0;},i.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(e.prototype,i),e}(t.Event),Oo=function(t,e){this._map=t,this._clickTolerance=e.clickTolerance;};Oo.prototype.reset=function(){delete this._mousedownPos;},Oo.prototype.wheel=function(t){return this._firePreventable(new Bo(t.type,this._map,t))},Oo.prototype.mousedown=function(t,e){return this._mousedownPos=e,this._firePreventable(new Ro(t.type,this._map,t))},Oo.prototype.mouseup=function(t){this._map.fire(new Ro(t.type,this._map,t));},Oo.prototype.click=function(t,e){this._mousedownPos&&this._mousedownPos.dist(e)>=this._clickTolerance||this._map.fire(new Ro(t.type,this._map,t));},Oo.prototype.dblclick=function(t){return this._firePreventable(new Ro(t.type,this._map,t))},Oo.prototype.mouseover=function(t){this._map.fire(new Ro(t.type,this._map,t));},Oo.prototype.mouseout=function(t){this._map.fire(new Ro(t.type,this._map,t));},Oo.prototype.touchstart=function(t){return this._firePreventable(new ko(t.type,this._map,t))},Oo.prototype.touchmove=function(t){this._map.fire(new ko(t.type,this._map,t));},Oo.prototype.touchend=function(t){this._map.fire(new ko(t.type,this._map,t));},Oo.prototype.touchcancel=function(t){this._map.fire(new ko(t.type,this._map,t));},Oo.prototype._firePreventable=function(t){if(this._map.fire(t),t.defaultPrevented)return {}},Oo.prototype.isEnabled=function(){return !0},Oo.prototype.isActive=function(){return !1},Oo.prototype.enable=function(){},Oo.prototype.disable=function(){};var Fo=function(t){this._map=t;};Fo.prototype.reset=function(){this._delayContextMenu=!1,delete this._contextMenuEvent;},Fo.prototype.mousemove=function(t){this._map.fire(new Ro(t.type,this._map,t));},Fo.prototype.mousedown=function(){this._delayContextMenu=!0;},Fo.prototype.mouseup=function(){this._delayContextMenu=!1,this._contextMenuEvent&&(this._map.fire(new Ro("contextmenu",this._map,this._contextMenuEvent)),delete this._contextMenuEvent);},Fo.prototype.contextmenu=function(t){this._delayContextMenu?this._contextMenuEvent=t:this._map.fire(new Ro(t.type,this._map,t)),this._map.listens("contextmenu")&&t.preventDefault();},Fo.prototype.isEnabled=function(){return !0},Fo.prototype.isActive=function(){return !1},Fo.prototype.enable=function(){},Fo.prototype.disable=function(){};var Uo=function(t,e){this._map=t,this._el=t.getCanvasContainer(),this._container=t.getContainer(),this._clickTolerance=e.clickTolerance||1;};function No(t,e){for(var i={},o=0;o<t.length;o++)i[t[o].identifier]=e[o];return i}Uo.prototype.isEnabled=function(){return !!this._enabled},Uo.prototype.isActive=function(){return !!this._active},Uo.prototype.enable=function(){this.isEnabled()||(this._enabled=!0);},Uo.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},Uo.prototype.mousedown=function(t,e){this.isEnabled()&&t.shiftKey&&0===t.button&&(i.disableDrag(),this._startPos=this._lastPos=e,this._active=!0);},Uo.prototype.mousemoveWindow=function(t,e){if(this._active){var o=e;if(!(this._lastPos.equals(o)||!this._box&&o.dist(this._startPos)<this._clickTolerance)){var r=this._startPos;this._lastPos=o,this._box||(this._box=i.create("div","mapboxgl-boxzoom",this._container),this._container.classList.add("mapboxgl-crosshair"),this._fireEvent("boxzoomstart",t));var a=Math.min(r.x,o.x),n=Math.max(r.x,o.x),s=Math.min(r.y,o.y),l=Math.max(r.y,o.y);i.setTransform(this._box,"translate("+a+"px,"+s+"px)"),this._box.style.width=n-a+"px",this._box.style.height=l-s+"px";}}},Uo.prototype.mouseupWindow=function(e,o){var r=this;if(this._active&&0===e.button){var a=this._startPos,n=o;if(this.reset(),i.suppressClick(),a.x!==n.x||a.y!==n.y)return this._map.fire(new t.Event("boxzoomend",{originalEvent:e})),{cameraAnimation:function(t){return t.fitScreenCoordinates(a,n,r._map.getBearing(),{linear:!0})}};this._fireEvent("boxzoomcancel",e);}},Uo.prototype.keydown=function(t){this._active&&27===t.keyCode&&(this.reset(),this._fireEvent("boxzoomcancel",t));},Uo.prototype.blur=function(){this.reset();},Uo.prototype.reset=function(){this._active=!1,this._container.classList.remove("mapboxgl-crosshair"),this._box&&(i.remove(this._box),this._box=null),i.enableDrag(),delete this._startPos,delete this._lastPos;},Uo.prototype._fireEvent=function(e,i){return this._map.fire(new t.Event(e,{originalEvent:i}))};var Zo=function(t){this.reset(),this.numTouches=t.numTouches;};Zo.prototype.reset=function(){delete this.centroid,delete this.startTime,delete this.touches,this.aborted=!1;},Zo.prototype.touchstart=function(e,i,o){(this.centroid||o.length>this.numTouches)&&(this.aborted=!0),this.aborted||(void 0===this.startTime&&(this.startTime=e.timeStamp),o.length===this.numTouches&&(this.centroid=function(e){for(var i=new t.Point(0,0),o=0,r=e;o<r.length;o+=1)i._add(r[o]);return i.div(e.length)}(i),this.touches=No(o,i)));},Zo.prototype.touchmove=function(t,e,i){if(!this.aborted&&this.centroid){var o=No(i,e);for(var r in this.touches){var a=o[r];(!a||a.dist(this.touches[r])>30)&&(this.aborted=!0);}}},Zo.prototype.touchend=function(t,e,i){if((!this.centroid||t.timeStamp-this.startTime>500)&&(this.aborted=!0),0===i.length){var o=!this.aborted&&this.centroid;if(this.reset(),o)return o}};var qo=function(t){this.singleTap=new Zo(t),this.numTaps=t.numTaps,this.reset();};qo.prototype.reset=function(){this.lastTime=1/0,delete this.lastTap,this.count=0,this.singleTap.reset();},qo.prototype.touchstart=function(t,e,i){this.singleTap.touchstart(t,e,i);},qo.prototype.touchmove=function(t,e,i){this.singleTap.touchmove(t,e,i);},qo.prototype.touchend=function(t,e,i){var o=this.singleTap.touchend(t,e,i);if(o){var r=t.timeStamp-this.lastTime<500,a=!this.lastTap||this.lastTap.dist(o)<30;if(r&&a||this.reset(),this.count++,this.lastTime=t.timeStamp,this.lastTap=o,this.count===this.numTaps)return this.reset(),o}};var jo=function(){this._zoomIn=new qo({numTouches:1,numTaps:2}),this._zoomOut=new qo({numTouches:2,numTaps:1}),this.reset();};jo.prototype.reset=function(){this._active=!1,this._zoomIn.reset(),this._zoomOut.reset();},jo.prototype.touchstart=function(t,e,i){this._zoomIn.touchstart(t,e,i),this._zoomOut.touchstart(t,e,i);},jo.prototype.touchmove=function(t,e,i){this._zoomIn.touchmove(t,e,i),this._zoomOut.touchmove(t,e,i);},jo.prototype.touchend=function(t,e,i){var o=this,r=this._zoomIn.touchend(t,e,i),a=this._zoomOut.touchend(t,e,i);return r?(this._active=!0,t.preventDefault(),setTimeout((function(){return o.reset()}),0),{cameraAnimation:function(e){return e.easeTo({duration:300,zoom:e.getZoom()+1,around:e.unproject(r)},{originalEvent:t})}}):a?(this._active=!0,t.preventDefault(),setTimeout((function(){return o.reset()}),0),{cameraAnimation:function(e){return e.easeTo({duration:300,zoom:e.getZoom()-1,around:e.unproject(a)},{originalEvent:t})}}):void 0},jo.prototype.touchcancel=function(){this.reset();},jo.prototype.enable=function(){this._enabled=!0;},jo.prototype.disable=function(){this._enabled=!1,this.reset();},jo.prototype.isEnabled=function(){return this._enabled},jo.prototype.isActive=function(){return this._active};var Vo={0:1,2:2},Go=function(t){this.reset(),this._clickTolerance=t.clickTolerance||1;};Go.prototype.blur=function(){this.reset();},Go.prototype.reset=function(){this._active=!1,this._moved=!1,delete this._lastPoint,delete this._eventButton;},Go.prototype._correctButton=function(t,e){return !1},Go.prototype._move=function(t,e){return {}},Go.prototype.mousedown=function(t,e){if(!this._lastPoint){var o=i.mouseButton(t);this._correctButton(t,o)&&(this._lastPoint=e,this._eventButton=o);}},Go.prototype.mousemoveWindow=function(t,e){var i=this._lastPoint;if(i)if(t.preventDefault(),function(t,e){var i=Vo[e];return void 0===t.buttons||(t.buttons&i)!==i}(t,this._eventButton))this.reset();else if(this._moved||!(e.dist(i)<this._clickTolerance))return this._moved=!0,this._lastPoint=e,this._move(i,e)},Go.prototype.mouseupWindow=function(t){this._lastPoint&&i.mouseButton(t)===this._eventButton&&(this._moved&&i.suppressClick(),this.reset());},Go.prototype.enable=function(){this._enabled=!0;},Go.prototype.disable=function(){this._enabled=!1,this.reset();},Go.prototype.isEnabled=function(){return this._enabled},Go.prototype.isActive=function(){return this._active};var Wo=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.mousedown=function(e,i){t.prototype.mousedown.call(this,e,i),this._lastPoint&&(this._active=!0);},e.prototype._correctButton=function(t,e){return 0===e&&!t.ctrlKey},e.prototype._move=function(t,e){return {around:e,panDelta:e.sub(t)}},e}(Go),Xo=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._correctButton=function(t,e){return 0===e&&t.ctrlKey||2===e},e.prototype._move=function(t,e){var i=.8*(e.x-t.x);if(i)return this._active=!0,{bearingDelta:i}},e.prototype.contextmenu=function(t){t.preventDefault();},e}(Go),Ho=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._correctButton=function(t,e){return 0===e&&t.ctrlKey||2===e},e.prototype._move=function(t,e){var i=-.5*(e.y-t.y);if(i)return this._active=!0,{pitchDelta:i}},e.prototype.contextmenu=function(t){t.preventDefault();},e}(Go),Ko=function(t){this._minTouches=1,this._clickTolerance=t.clickTolerance||1,this.reset();};Ko.prototype.reset=function(){this._active=!1,this._touches={},this._sum=new t.Point(0,0);},Ko.prototype.touchstart=function(t,e,i){return this._calculateTransform(t,e,i)},Ko.prototype.touchmove=function(t,e,i){if(this._active&&!(i.length<this._minTouches))return t.preventDefault(),this._calculateTransform(t,e,i)},Ko.prototype.touchend=function(t,e,i){this._calculateTransform(t,e,i),this._active&&i.length<this._minTouches&&this.reset();},Ko.prototype.touchcancel=function(){this.reset();},Ko.prototype._calculateTransform=function(e,i,o){o.length>0&&(this._active=!0);var r=No(o,i),a=new t.Point(0,0),n=new t.Point(0,0),s=0;for(var l in r){var c=r[l],u=this._touches[l];u&&(a._add(c),n._add(c.sub(u)),s++,r[l]=c);}if(this._touches=r,!(s<this._minTouches)&&n.mag()){var h=n.div(s);if(this._sum._add(h),!(this._sum.mag()<this._clickTolerance))return {around:a.div(s),panDelta:h}}},Ko.prototype.enable=function(){this._enabled=!0;},Ko.prototype.disable=function(){this._enabled=!1,this.reset();},Ko.prototype.isEnabled=function(){return this._enabled},Ko.prototype.isActive=function(){return this._active};var Yo=function(){this.reset();};function Jo(t,e,i){for(var o=0;o<t.length;o++)if(t[o].identifier===i)return e[o]}function Qo(t,e){return Math.log(t/e)/Math.LN2}Yo.prototype.reset=function(){this._active=!1,delete this._firstTwoTouches;},Yo.prototype._start=function(t){},Yo.prototype._move=function(t,e,i){return {}},Yo.prototype.touchstart=function(t,e,i){this._firstTwoTouches||i.length<2||(this._firstTwoTouches=[i[0].identifier,i[1].identifier],this._start([e[0],e[1]]));},Yo.prototype.touchmove=function(t,e,i){if(this._firstTwoTouches){t.preventDefault();var o=this._firstTwoTouches,r=o[1],a=Jo(i,e,o[0]),n=Jo(i,e,r);if(a&&n){var s=this._aroundCenter?null:a.add(n).div(2);return this._move([a,n],s,t)}}},Yo.prototype.touchend=function(t,e,o){if(this._firstTwoTouches){var r=this._firstTwoTouches,a=r[1],n=Jo(o,e,r[0]),s=Jo(o,e,a);n&&s||(this._active&&i.suppressClick(),this.reset());}},Yo.prototype.touchcancel=function(){this.reset();},Yo.prototype.enable=function(t){this._enabled=!0,this._aroundCenter=!!t&&"center"===t.around;},Yo.prototype.disable=function(){this._enabled=!1,this.reset();},Yo.prototype.isEnabled=function(){return this._enabled},Yo.prototype.isActive=function(){return this._active};var $o=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.reset=function(){t.prototype.reset.call(this),delete this._distance,delete this._startDistance;},e.prototype._start=function(t){this._startDistance=this._distance=t[0].dist(t[1]);},e.prototype._move=function(t,e){var i=this._distance;if(this._distance=t[0].dist(t[1]),this._active||!(Math.abs(Qo(this._distance,this._startDistance))<.1))return this._active=!0,{zoomDelta:Qo(this._distance,i),pinchAround:e}},e}(Yo);function tr(t,e){return 180*t.angleWith(e)/Math.PI}var er=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.reset=function(){t.prototype.reset.call(this),delete this._minDiameter,delete this._startVector,delete this._vector;},e.prototype._start=function(t){this._startVector=this._vector=t[0].sub(t[1]),this._minDiameter=t[0].dist(t[1]);},e.prototype._move=function(t,e){var i=this._vector;if(this._vector=t[0].sub(t[1]),this._active||!this._isBelowThreshold(this._vector))return this._active=!0,{bearingDelta:tr(this._vector,i),pinchAround:e}},e.prototype._isBelowThreshold=function(t){this._minDiameter=Math.min(this._minDiameter,t.mag());var e=25/(Math.PI*this._minDiameter)*360,i=tr(t,this._startVector);return Math.abs(i)<e},e}(Yo);function ir(t){return Math.abs(t.y)>Math.abs(t.x)}var or=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.reset=function(){t.prototype.reset.call(this),this._valid=void 0,delete this._firstMove,delete this._lastPoints;},e.prototype._start=function(t){this._lastPoints=t,ir(t[0].sub(t[1]))&&(this._valid=!1);},e.prototype._move=function(t,e,i){var o=t[0].sub(this._lastPoints[0]),r=t[1].sub(this._lastPoints[1]);if(this._valid=this.gestureBeginsVertically(o,r,i.timeStamp),this._valid)return this._lastPoints=t,this._active=!0,{pitchDelta:(o.y+r.y)/2*-.5}},e.prototype.gestureBeginsVertically=function(t,e,i){if(void 0!==this._valid)return this._valid;var o=t.mag()>=2,r=e.mag()>=2;if(o||r){if(!o||!r)return void 0===this._firstMove&&(this._firstMove=i),i-this._firstMove<100&&void 0;var a=t.y>0==e.y>0;return ir(t)&&ir(e)&&a}},e}(Yo),rr={panStep:100,bearingStep:15,pitchStep:10},ar=function(){var t=rr;this._panStep=t.panStep,this._bearingStep=t.bearingStep,this._pitchStep=t.pitchStep,this._rotationDisabled=!1;};function nr(t){return t*(2-t)}ar.prototype.blur=function(){this.reset();},ar.prototype.reset=function(){this._active=!1;},ar.prototype.keydown=function(t){var e=this;if(!(t.altKey||t.ctrlKey||t.metaKey)){var i=0,o=0,r=0,a=0,n=0;switch(t.keyCode){case 61:case 107:case 171:case 187:i=1;break;case 189:case 109:case 173:i=-1;break;case 37:t.shiftKey?o=-1:(t.preventDefault(),a=-1);break;case 39:t.shiftKey?o=1:(t.preventDefault(),a=1);break;case 38:t.shiftKey?r=1:(t.preventDefault(),n=-1);break;case 40:t.shiftKey?r=-1:(t.preventDefault(),n=1);break;default:return}return this._rotationDisabled&&(o=0,r=0),{cameraAnimation:function(s){var l=s.getZoom();s.easeTo({duration:300,easeId:"keyboardHandler",easing:nr,zoom:i?Math.round(l)+i*(t.shiftKey?2:1):l,bearing:s.getBearing()+o*e._bearingStep,pitch:s.getPitch()+r*e._pitchStep,offset:[-a*e._panStep,-n*e._panStep],center:s.getCenter()},{originalEvent:t});}}}},ar.prototype.enable=function(){this._enabled=!0;},ar.prototype.disable=function(){this._enabled=!1,this.reset();},ar.prototype.isEnabled=function(){return this._enabled},ar.prototype.isActive=function(){return this._active},ar.prototype.disableRotation=function(){this._rotationDisabled=!0;},ar.prototype.enableRotation=function(){this._rotationDisabled=!1;};var sr=function(e,i){this._map=e,this._el=e.getCanvasContainer(),this._handler=i,this._delta=0,this._defaultZoomRate=.01,this._wheelZoomRate=1/450,t.bindAll(["_onTimeout"],this);};sr.prototype.setZoomRate=function(t){this._defaultZoomRate=t;},sr.prototype.setWheelZoomRate=function(t){this._wheelZoomRate=t;},sr.prototype.isEnabled=function(){return !!this._enabled},sr.prototype.isActive=function(){return !!this._active||void 0!==this._finishTimeout},sr.prototype.isZooming=function(){return !!this._zooming},sr.prototype.enable=function(t){this.isEnabled()||(this._enabled=!0,this._aroundCenter=t&&"center"===t.around);},sr.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},sr.prototype.wheel=function(e){if(this.isEnabled()){var i=e.deltaMode===t.window.WheelEvent.DOM_DELTA_LINE?40*e.deltaY:e.deltaY,o=t.browser.now(),r=o-(this._lastWheelEventTime||0);this._lastWheelEventTime=o,0!==i&&i%4.000244140625==0?this._type="wheel":0!==i&&Math.abs(i)<4?this._type="trackpad":r>400?(this._type=null,this._lastValue=i,this._timeout=setTimeout(this._onTimeout,40,e)):this._type||(this._type=Math.abs(r*i)<200?"trackpad":"wheel",this._timeout&&(clearTimeout(this._timeout),this._timeout=null,i+=this._lastValue)),e.shiftKey&&i&&(i/=4),this._type&&(this._lastWheelEvent=e,this._delta-=i,this._active||this._start(e)),e.preventDefault();}},sr.prototype._onTimeout=function(t){this._type="wheel",this._delta-=this._lastValue,this._active||this._start(t);},sr.prototype._start=function(e){if(this._delta){this._frameId&&(this._frameId=null),this._active=!0,this.isZooming()||(this._zooming=!0),this._finishTimeout&&(clearTimeout(this._finishTimeout),delete this._finishTimeout);var o=i.mousePos(this._el,e);this._around=t.LngLat.convert(this._aroundCenter?this._map.getCenter():this._map.unproject(o)),this._aroundPoint=this._map.transform.locationPoint(this._around),this._frameId||(this._frameId=!0,this._handler._triggerRenderFrame());}},sr.prototype.renderFrame=function(){var e=this;if(this._frameId&&(this._frameId=null,this.isActive())){var i=this._map.transform;if(0!==this._delta){var o="wheel"===this._type&&Math.abs(this._delta)>4.000244140625?this._wheelZoomRate:this._defaultZoomRate,r=2/(1+Math.exp(-Math.abs(this._delta*o)));this._delta<0&&0!==r&&(r=1/r);var a="number"==typeof this._targetZoom?i.zoomScale(this._targetZoom):i.scale;this._targetZoom=Math.min(i.maxZoom,Math.max(i.minZoom,i.scaleZoom(a*r))),"wheel"===this._type&&(this._startZoom=i.zoom,this._easing=this._smoothOutEasing(200)),this._delta=0;}var n,s="number"==typeof this._targetZoom?this._targetZoom:i.zoom,l=this._startZoom,c=this._easing,u=!1;if("wheel"===this._type&&l&&c){var h=Math.min((t.browser.now()-this._lastWheelEventTime)/200,1),p=c(h);n=t.number(l,s,p),h<1?this._frameId||(this._frameId=!0):u=!0;}else n=s,u=!0;return this._active=!0,u&&(this._active=!1,this._finishTimeout=setTimeout((function(){e._zooming=!1,e._handler._triggerRenderFrame(),delete e._targetZoom,delete e._finishTimeout;}),200)),{noInertia:!0,needsRenderFrame:!u,zoomDelta:n-i.zoom,around:this._aroundPoint,originalEvent:this._lastWheelEvent}}},sr.prototype._smoothOutEasing=function(e){var i=t.ease;if(this._prevEase){var o=this._prevEase,r=(t.browser.now()-o.start)/o.duration,a=o.easing(r+.01)-o.easing(r),n=.27/Math.sqrt(a*a+1e-4)*.01,s=Math.sqrt(.0729-n*n);i=t.bezier(n,s,.25,1);}return this._prevEase={start:t.browser.now(),duration:e,easing:i},i},sr.prototype.blur=function(){this.reset();},sr.prototype.reset=function(){this._active=!1;};var lr=function(t,e){this._clickZoom=t,this._tapZoom=e;};lr.prototype.enable=function(){this._clickZoom.enable(),this._tapZoom.enable();},lr.prototype.disable=function(){this._clickZoom.disable(),this._tapZoom.disable();},lr.prototype.isEnabled=function(){return this._clickZoom.isEnabled()&&this._tapZoom.isEnabled()},lr.prototype.isActive=function(){return this._clickZoom.isActive()||this._tapZoom.isActive()};var cr=function(){this.reset();};cr.prototype.reset=function(){this._active=!1;},cr.prototype.blur=function(){this.reset();},cr.prototype.dblclick=function(t,e){return t.preventDefault(),{cameraAnimation:function(i){i.easeTo({duration:300,zoom:i.getZoom()+(t.shiftKey?-1:1),around:i.unproject(e)},{originalEvent:t});}}},cr.prototype.enable=function(){this._enabled=!0;},cr.prototype.disable=function(){this._enabled=!1,this.reset();},cr.prototype.isEnabled=function(){return this._enabled},cr.prototype.isActive=function(){return this._active};var ur=function(){this._tap=new qo({numTouches:1,numTaps:1}),this.reset();};ur.prototype.reset=function(){this._active=!1,delete this._swipePoint,delete this._swipeTouch,delete this._tapTime,this._tap.reset();},ur.prototype.touchstart=function(t,e,i){this._swipePoint||(this._tapTime&&t.timeStamp-this._tapTime>500&&this.reset(),this._tapTime?i.length>0&&(this._swipePoint=e[0],this._swipeTouch=i[0].identifier):this._tap.touchstart(t,e,i));},ur.prototype.touchmove=function(t,e,i){if(this._tapTime){if(this._swipePoint){if(i[0].identifier!==this._swipeTouch)return;var o=e[0],r=o.y-this._swipePoint.y;return this._swipePoint=o,t.preventDefault(),this._active=!0,{zoomDelta:r/128}}}else this._tap.touchmove(t,e,i);},ur.prototype.touchend=function(t,e,i){this._tapTime?this._swipePoint&&0===i.length&&this.reset():this._tap.touchend(t,e,i)&&(this._tapTime=t.timeStamp);},ur.prototype.touchcancel=function(){this.reset();},ur.prototype.enable=function(){this._enabled=!0;},ur.prototype.disable=function(){this._enabled=!1,this.reset();},ur.prototype.isEnabled=function(){return this._enabled},ur.prototype.isActive=function(){return this._active};var hr=function(t,e,i){this._el=t,this._mousePan=e,this._touchPan=i;};hr.prototype.enable=function(t){this._inertiaOptions=t||{},this._mousePan.enable(),this._touchPan.enable(),this._el.classList.add("mapboxgl-touch-drag-pan");},hr.prototype.disable=function(){this._mousePan.disable(),this._touchPan.disable(),this._el.classList.remove("mapboxgl-touch-drag-pan");},hr.prototype.isEnabled=function(){return this._mousePan.isEnabled()&&this._touchPan.isEnabled()},hr.prototype.isActive=function(){return this._mousePan.isActive()||this._touchPan.isActive()};var pr=function(t,e,i){this._pitchWithRotate=t.pitchWithRotate,this._mouseRotate=e,this._mousePitch=i;};pr.prototype.enable=function(){this._mouseRotate.enable(),this._pitchWithRotate&&this._mousePitch.enable();},pr.prototype.disable=function(){this._mouseRotate.disable(),this._mousePitch.disable();},pr.prototype.isEnabled=function(){return this._mouseRotate.isEnabled()&&(!this._pitchWithRotate||this._mousePitch.isEnabled())},pr.prototype.isActive=function(){return this._mouseRotate.isActive()||this._mousePitch.isActive()};var dr=function(t,e,i,o){this._el=t,this._touchZoom=e,this._touchRotate=i,this._tapDragZoom=o,this._rotationDisabled=!1,this._enabled=!0;};dr.prototype.enable=function(t){this._touchZoom.enable(t),this._rotationDisabled||this._touchRotate.enable(t),this._tapDragZoom.enable(),this._el.classList.add("mapboxgl-touch-zoom-rotate");},dr.prototype.disable=function(){this._touchZoom.disable(),this._touchRotate.disable(),this._tapDragZoom.disable(),this._el.classList.remove("mapboxgl-touch-zoom-rotate");},dr.prototype.isEnabled=function(){return this._touchZoom.isEnabled()&&(this._rotationDisabled||this._touchRotate.isEnabled())&&this._tapDragZoom.isEnabled()},dr.prototype.isActive=function(){return this._touchZoom.isActive()||this._touchRotate.isActive()||this._tapDragZoom.isActive()},dr.prototype.disableRotation=function(){this._rotationDisabled=!0,this._touchRotate.disable();},dr.prototype.enableRotation=function(){this._rotationDisabled=!1,this._touchZoom.isEnabled()&&this._touchRotate.enable();};var _r=function(t){return t.zoom||t.drag||t.pitch||t.rotate},fr=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(t.Event);function mr(t){return t.panDelta&&t.panDelta.mag()||t.zoomDelta||t.bearingDelta||t.pitchDelta}var gr=function(e,o){this._map=e,this._el=this._map.getCanvasContainer(),this._handlers=[],this._handlersById={},this._changes=[],this._inertia=new Ao(e),this._bearingSnap=o.bearingSnap,this._previousActiveHandlers={},this._eventsInProgress={},this._addDefaultHandlers(o),t.bindAll(["handleEvent","handleWindowEvent"],this);var r=this._el;this._listeners=[[r,"touchstart",{passive:!0}],[r,"touchmove",{passive:!1}],[r,"touchend",void 0],[r,"touchcancel",void 0],[r,"mousedown",void 0],[r,"mousemove",void 0],[r,"mouseup",void 0],[t.window.document,"mousemove",{capture:!0}],[t.window.document,"mouseup",void 0],[r,"mouseover",void 0],[r,"mouseout",void 0],[r,"dblclick",void 0],[r,"click",void 0],[r,"keydown",{capture:!1}],[r,"keyup",void 0],[r,"wheel",{passive:!1}],[r,"contextmenu",void 0],[t.window,"blur",void 0]];for(var a=0,n=this._listeners;a<n.length;a+=1){var s=n[a],l=s[0];i.addEventListener(l,s[1],l===t.window.document?this.handleWindowEvent:this.handleEvent,s[2]);}};gr.prototype.destroy=function(){for(var e=0,o=this._listeners;e<o.length;e+=1){var r=o[e],a=r[0];i.removeEventListener(a,r[1],a===t.window.document?this.handleWindowEvent:this.handleEvent,r[2]);}},gr.prototype._addDefaultHandlers=function(t){var e=this._map,i=e.getCanvasContainer();this._add("mapEvent",new Oo(e,t));var o=e.boxZoom=new Uo(e,t);this._add("boxZoom",o);var r=new jo,a=new cr;e.doubleClickZoom=new lr(a,r),this._add("tapZoom",r),this._add("clickZoom",a);var n=new ur;this._add("tapDragZoom",n);var s=e.touchPitch=new or;this._add("touchPitch",s);var l=new Xo(t),c=new Ho(t);e.dragRotate=new pr(t,l,c),this._add("mouseRotate",l,["mousePitch"]),this._add("mousePitch",c,["mouseRotate"]);var u=new Wo(t),h=new Ko(t);e.dragPan=new hr(i,u,h),this._add("mousePan",u),this._add("touchPan",h,["touchZoom","touchRotate"]);var p=new er,d=new $o;e.touchZoomRotate=new dr(i,d,p,n),this._add("touchRotate",p,["touchPan","touchZoom"]),this._add("touchZoom",d,["touchPan","touchRotate"]);var _=e.scrollZoom=new sr(e,this);this._add("scrollZoom",_,["mousePan"]);var f=e.keyboard=new ar;this._add("keyboard",f),this._add("blockableMapEvent",new Fo(e));for(var m=0,g=["boxZoom","doubleClickZoom","tapDragZoom","touchPitch","dragRotate","dragPan","touchZoomRotate","scrollZoom","keyboard"];m<g.length;m+=1){var v=g[m];t.interactive&&t[v]&&e[v].enable(t[v]);}},gr.prototype._add=function(t,e,i){this._handlers.push({handlerName:t,handler:e,allowed:i}),this._handlersById[t]=e;},gr.prototype.stop=function(t){if(!this._updatingCamera){for(var e=0,i=this._handlers;e<i.length;e+=1)i[e].handler.reset();this._inertia.clear(),this._fireEvents({},{},t),this._changes=[];}},gr.prototype.isActive=function(){for(var t=0,e=this._handlers;t<e.length;t+=1)if(e[t].handler.isActive())return !0;return !1},gr.prototype.isZooming=function(){return !!this._eventsInProgress.zoom||this._map.scrollZoom.isZooming()},gr.prototype.isRotating=function(){return !!this._eventsInProgress.rotate},gr.prototype.isMoving=function(){return Boolean(_r(this._eventsInProgress))||this.isZooming()},gr.prototype._blockedByActive=function(t,e,i){for(var o in t)if(o!==i&&(!e||e.indexOf(o)<0))return !0;return !1},gr.prototype.handleWindowEvent=function(t){this.handleEvent(t,t.type+"Window");},gr.prototype._getMapTouches=function(t){for(var e=[],i=0,o=t;i<o.length;i+=1){var r=o[i];this._el.contains(r.target)&&e.push(r);}return e},gr.prototype.handleEvent=function(t,e){this._updatingCamera=!0;for(var o="renderFrame"===t.type?void 0:t,r={needsRenderFrame:!1},a={},n={},s=t.touches?this._getMapTouches(t.touches):void 0,l=s?i.touchPos(this._el,s):i.mousePos(this._el,t),c=0,u=this._handlers;c<u.length;c+=1){var h=u[c],p=h.handlerName,d=h.handler,_=h.allowed;if(d.isEnabled()){var f=void 0;this._blockedByActive(n,_,p)?d.reset():d[e||t.type]&&(f=d[e||t.type](t,l,s),this.mergeHandlerResult(r,a,f,p,o),f&&f.needsRenderFrame&&this._triggerRenderFrame()),(f||d.isActive())&&(n[p]=d);}}var m={};for(var g in this._previousActiveHandlers)n[g]||(m[g]=o);this._previousActiveHandlers=n,(Object.keys(m).length||mr(r))&&(this._changes.push([r,a,m]),this._triggerRenderFrame()),(Object.keys(n).length||mr(r))&&this._map._stop(!0),this._updatingCamera=!1;var v=r.cameraAnimation;v&&(this._inertia.clear(),this._fireEvents({},{},!0),this._changes=[],v(this._map));},gr.prototype.mergeHandlerResult=function(e,i,o,r,a){if(o){t.extend(e,o);var n={handlerName:r,originalEvent:o.originalEvent||a};void 0!==o.zoomDelta&&(i.zoom=n),void 0!==o.panDelta&&(i.drag=n),void 0!==o.pitchDelta&&(i.pitch=n),void 0!==o.bearingDelta&&(i.rotate=n);}},gr.prototype._applyChanges=function(){for(var e={},i={},o={},r=0,a=this._changes;r<a.length;r+=1){var n=a[r],s=n[0],l=n[1],c=n[2];s.panDelta&&(e.panDelta=(e.panDelta||new t.Point(0,0))._add(s.panDelta)),s.zoomDelta&&(e.zoomDelta=(e.zoomDelta||0)+s.zoomDelta),s.bearingDelta&&(e.bearingDelta=(e.bearingDelta||0)+s.bearingDelta),s.pitchDelta&&(e.pitchDelta=(e.pitchDelta||0)+s.pitchDelta),void 0!==s.around&&(e.around=s.around),void 0!==s.pinchAround&&(e.pinchAround=s.pinchAround),s.noInertia&&(e.noInertia=s.noInertia),t.extend(i,l),t.extend(o,c);}this._updateMapTransform(e,i,o),this._changes=[];},gr.prototype._updateMapTransform=function(t,e,i){var o=this._map,r=o.transform;if(!mr(t))return this._fireEvents(e,i,!0);var a=t.panDelta,n=t.zoomDelta,s=t.bearingDelta,l=t.pitchDelta,c=t.around,u=t.pinchAround;void 0!==u&&(c=u),o._stop(!0),c=c||o.transform.centerPoint;var h=r.pointLocation(a?c.sub(a):c);s&&(r.bearing+=s),l&&(r.pitch+=l),n&&(r.zoom+=n),r.setLocationAtPoint(h,c),this._map._update(),t.noInertia||this._inertia.record(t),this._fireEvents(e,i,!0);},gr.prototype._fireEvents=function(e,i,o){var r=this,a=_r(this._eventsInProgress),n=_r(e),s={};for(var l in e)this._eventsInProgress[l]||(s[l+"start"]=e[l].originalEvent),this._eventsInProgress[l]=e[l];for(var c in !a&&n&&this._fireEvent("movestart",n.originalEvent),s)this._fireEvent(c,s[c]);for(var u in n&&this._fireEvent("move",n.originalEvent),e)this._fireEvent(u,e[u].originalEvent);var h,p={};for(var d in this._eventsInProgress){var _=this._eventsInProgress[d],f=_.handlerName,m=_.originalEvent;this._handlersById[f].isActive()||(delete this._eventsInProgress[d],p[d+"end"]=h=i[f]||m);}for(var g in p)this._fireEvent(g,p[g]);var v=_r(this._eventsInProgress);if(o&&(a||n)&&!v){this._updatingCamera=!0;var y=this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),x=function(t){return 0!==t&&-r._bearingSnap<t&&t<r._bearingSnap};y?(x(y.bearing||this._map.getBearing())&&(y.bearing=0),this._map.easeTo(y,{originalEvent:h})):(this._map.fire(new t.Event("moveend",{originalEvent:h})),x(this._map.getBearing())&&this._map.resetNorth()),this._updatingCamera=!1;}},gr.prototype._fireEvent=function(e,i){this._map.fire(new t.Event(e,i?{originalEvent:i}:{}));},gr.prototype._requestFrame=function(){var t=this;return this._map.triggerRepaint(),this._map._renderTaskQueue.add((function(e){delete t._frameId,t.handleEvent(new fr("renderFrame",{timeStamp:e})),t._applyChanges();}))},gr.prototype._triggerRenderFrame=function(){void 0===this._frameId&&(this._frameId=this._requestFrame());};var vr=function(e){function i(i,o){e.call(this),this._moving=!1,this._zooming=!1,this.transform=i,this._bearingSnap=o.bearingSnap,t.bindAll(["_renderFrameCallback"],this);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getCenter=function(){return new t.LngLat(this.transform.center.lng,this.transform.center.lat)},i.prototype.setCenter=function(t,e){return this.jumpTo({center:t},e)},i.prototype.panBy=function(e,i,o){return e=t.Point.convert(e).mult(-1),this.panTo(this.transform.center,t.extend({offset:e},i),o)},i.prototype.panTo=function(e,i,o){return this.easeTo(t.extend({center:e},i),o)},i.prototype.getZoom=function(){return this.transform.zoom},i.prototype.setZoom=function(t,e){return this.jumpTo({zoom:t},e),this},i.prototype.zoomTo=function(e,i,o){return this.easeTo(t.extend({zoom:e},i),o)},i.prototype.zoomIn=function(t,e){return this.zoomTo(this.getZoom()+1,t,e),this},i.prototype.zoomOut=function(t,e){return this.zoomTo(this.getZoom()-1,t,e),this},i.prototype.getBearing=function(){return this.transform.bearing},i.prototype.setBearing=function(t,e){return this.jumpTo({bearing:t},e),this},i.prototype.getPadding=function(){return this.transform.padding},i.prototype.setPadding=function(t,e){return this.jumpTo({padding:t},e),this},i.prototype.rotateTo=function(e,i,o){return this.easeTo(t.extend({bearing:e},i),o)},i.prototype.resetNorth=function(e,i){return this.rotateTo(0,t.extend({duration:1e3},e),i),this},i.prototype.resetNorthPitch=function(e,i){return this.easeTo(t.extend({bearing:0,pitch:0,duration:1e3},e),i),this},i.prototype.snapToNorth=function(t,e){return Math.abs(this.getBearing())<this._bearingSnap?this.resetNorth(t,e):this},i.prototype.getPitch=function(){return this.transform.pitch},i.prototype.setPitch=function(t,e){return this.jumpTo({pitch:t},e),this},i.prototype.cameraForBounds=function(e,i){e=t.LngLatBounds.convert(e);var o=i&&i.bearing||0;return this._cameraForBoxAndBearing(e.getNorthWest(),e.getSouthEast(),o,i)},i.prototype._cameraForBoxAndBearing=function(e,i,o,r){var a={top:0,bottom:0,right:0,left:0};if("number"==typeof(r=t.extend({padding:a,offset:[0,0],maxZoom:this.transform.maxZoom},r)).padding){var n=r.padding;r.padding={top:n,bottom:n,right:n,left:n};}r.padding=t.extend(a,r.padding);var s=this.transform,l=s.padding,c=s.project(t.LngLat.convert(e)),u=s.project(t.LngLat.convert(i)),h=c.rotate(-o*Math.PI/180),p=u.rotate(-o*Math.PI/180),d=new t.Point(Math.max(h.x,p.x),Math.max(h.y,p.y)),_=new t.Point(Math.min(h.x,p.x),Math.min(h.y,p.y)),f=d.sub(_),m=(s.width-(l.left+l.right+r.padding.left+r.padding.right))/f.x,g=(s.height-(l.top+l.bottom+r.padding.top+r.padding.bottom))/f.y;if(!(g<0||m<0)){var v=Math.min(s.scaleZoom(s.scale*Math.min(m,g)),r.maxZoom),y="number"==typeof r.offset.x?new t.Point(r.offset.x,r.offset.y):t.Point.convert(r.offset),x=new t.Point((r.padding.left-r.padding.right)/2,(r.padding.top-r.padding.bottom)/2).rotate(o*Math.PI/180),b=y.add(x).mult(s.scale/s.zoomScale(v));return {center:s.unproject(c.add(u).div(2).sub(b)),zoom:v,bearing:o}}t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");},i.prototype.fitBounds=function(t,e,i){return this._fitInternal(this.cameraForBounds(t,e),e,i)},i.prototype.fitScreenCoordinates=function(e,i,o,r,a){return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)),this.transform.pointLocation(t.Point.convert(i)),o,r),r,a)},i.prototype._fitInternal=function(e,i,o){return e?(delete(i=t.extend(e,i)).padding,i.linear?this.easeTo(i,o):this.flyTo(i,o)):this},i.prototype.jumpTo=function(e,i){this.stop();var o=this.transform,r=!1,a=!1,n=!1;return "zoom"in e&&o.zoom!==+e.zoom&&(r=!0,o.zoom=+e.zoom),void 0!==e.center&&(o.center=t.LngLat.convert(e.center)),"bearing"in e&&o.bearing!==+e.bearing&&(a=!0,o.bearing=+e.bearing),"pitch"in e&&o.pitch!==+e.pitch&&(n=!0,o.pitch=+e.pitch),null==e.padding||o.isPaddingEqual(e.padding)||(o.padding=e.padding),this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),r&&this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),a&&this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),n&&this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),this.fire(new t.Event("moveend",i))},i.prototype.easeTo=function(e,i){var o=this;this._stop(!1,e.easeId),(!1===(e=t.extend({offset:[0,0],duration:500,easing:t.ease},e)).animate||!e.essential&&t.browser.prefersReducedMotion)&&(e.duration=0);var r=this.transform,a=this.getZoom(),n=this.getBearing(),s=this.getPitch(),l=this.getPadding(),c="zoom"in e?+e.zoom:a,u="bearing"in e?this._normalizeBearing(e.bearing,n):n,h="pitch"in e?+e.pitch:s,p="padding"in e?e.padding:r.padding,d=t.Point.convert(e.offset),_=r.centerPoint.add(d),f=r.pointLocation(_),m=t.LngLat.convert(e.center||f);this._normalizeCenter(m);var g,v,y=r.project(f),x=r.project(m).sub(y),b=r.zoomScale(c-a);e.around&&(g=t.LngLat.convert(e.around),v=r.locationPoint(g));var w={moving:this._moving,zooming:this._zooming,rotating:this._rotating,pitching:this._pitching};return this._zooming=this._zooming||c!==a,this._rotating=this._rotating||n!==u,this._pitching=this._pitching||h!==s,this._padding=!r.isPaddingEqual(p),this._easeId=e.easeId,this._prepareEase(i,e.noMoveStart,w),this._ease((function(e){if(o._zooming&&(r.zoom=t.number(a,c,e)),o._rotating&&(r.bearing=t.number(n,u,e)),o._pitching&&(r.pitch=t.number(s,h,e)),o._padding&&(r.interpolatePadding(l,p,e),_=r.centerPoint.add(d)),g)r.setLocationAtPoint(g,v);else {var f=r.zoomScale(r.zoom-a),m=c>a?Math.min(2,b):Math.max(.5,b),w=Math.pow(m,1-e),T=r.unproject(y.add(x.mult(e*w)).mult(f));r.setLocationAtPoint(r.renderWorldCopies?T.wrap():T,_);}o._fireMoveEvents(i);}),(function(t){o._afterEase(i,t);}),e),this},i.prototype._prepareEase=function(e,i,o){void 0===o&&(o={}),this._moving=!0,i||o.moving||this.fire(new t.Event("movestart",e)),this._zooming&&!o.zooming&&this.fire(new t.Event("zoomstart",e)),this._rotating&&!o.rotating&&this.fire(new t.Event("rotatestart",e)),this._pitching&&!o.pitching&&this.fire(new t.Event("pitchstart",e));},i.prototype._fireMoveEvents=function(e){this.fire(new t.Event("move",e)),this._zooming&&this.fire(new t.Event("zoom",e)),this._rotating&&this.fire(new t.Event("rotate",e)),this._pitching&&this.fire(new t.Event("pitch",e));},i.prototype._afterEase=function(e,i){if(!this._easeId||!i||this._easeId!==i){delete this._easeId;var o=this._zooming,r=this._rotating,a=this._pitching;this._moving=!1,this._zooming=!1,this._rotating=!1,this._pitching=!1,this._padding=!1,o&&this.fire(new t.Event("zoomend",e)),r&&this.fire(new t.Event("rotateend",e)),a&&this.fire(new t.Event("pitchend",e)),this.fire(new t.Event("moveend",e));}},i.prototype.flyTo=function(e,i){var o=this;if(!e.essential&&t.browser.prefersReducedMotion){var r=t.pick(e,["center","zoom","bearing","pitch","around"]);return this.jumpTo(r,i)}this.stop(),e=t.extend({offset:[0,0],speed:1.2,curve:1.42,easing:t.ease},e);var a=this.transform,n=this.getZoom(),s=this.getBearing(),l=this.getPitch(),c=this.getPadding(),u="zoom"in e?t.clamp(+e.zoom,a.minZoom,a.maxZoom):n,h="bearing"in e?this._normalizeBearing(e.bearing,s):s,p="pitch"in e?+e.pitch:l,d="padding"in e?e.padding:a.padding,_=a.zoomScale(u-n),f=t.Point.convert(e.offset),m=a.centerPoint.add(f),g=a.pointLocation(m),v=t.LngLat.convert(e.center||g);this._normalizeCenter(v);var y=a.project(g),x=a.project(v).sub(y),b=e.curve,w=Math.max(a.width,a.height),T=w/_,E=x.mag();if("minZoom"in e){var I=t.clamp(Math.min(e.minZoom,n,u),a.minZoom,a.maxZoom),P=w/a.zoomScale(I-n);b=Math.sqrt(P/E*2);}var S=b*b;function C(t){var e=(T*T-w*w+(t?-1:1)*S*S*E*E)/(2*(t?T:w)*S*E);return Math.log(Math.sqrt(e*e+1)-e)}function z(t){return (Math.exp(t)-Math.exp(-t))/2}function D(t){return (Math.exp(t)+Math.exp(-t))/2}var A=C(0),M=function(t){return D(A)/D(A+b*t)},L=function(t){return w*((D(A)*(z(e=A+b*t)/D(e))-z(A))/S)/E;var e;},R=(C(1)-A)/b;if(Math.abs(E)<1e-6||!isFinite(R)){if(Math.abs(w-T)<1e-6)return this.easeTo(e,i);var k=T<w?-1:1;R=Math.abs(Math.log(T/w))/b,L=function(){return 0},M=function(t){return Math.exp(k*b*t)};}return e.duration="duration"in e?+e.duration:1e3*R/("screenSpeed"in e?+e.screenSpeed/b:+e.speed),e.maxDuration&&e.duration>e.maxDuration&&(e.duration=0),this._zooming=!0,this._rotating=s!==h,this._pitching=p!==l,this._padding=!a.isPaddingEqual(d),this._prepareEase(i,!1),this._ease((function(e){var r=e*R,_=1/M(r);a.zoom=1===e?u:n+a.scaleZoom(_),o._rotating&&(a.bearing=t.number(s,h,e)),o._pitching&&(a.pitch=t.number(l,p,e)),o._padding&&(a.interpolatePadding(c,d,e),m=a.centerPoint.add(f));var g=1===e?v:a.unproject(y.add(x.mult(L(r))).mult(_));a.setLocationAtPoint(a.renderWorldCopies?g.wrap():g,m),o._fireMoveEvents(i);}),(function(){return o._afterEase(i)}),e),this},i.prototype.isEasing=function(){return !!this._easeFrameId},i.prototype.stop=function(){return this._stop()},i.prototype._stop=function(t,e){if(this._easeFrameId&&(this._cancelRenderFrame(this._easeFrameId),delete this._easeFrameId,delete this._onEaseFrame),this._onEaseEnd){var i=this._onEaseEnd;delete this._onEaseEnd,i.call(this,e);}if(!t){var o=this.handlers;o&&o.stop(!1);}return this},i.prototype._ease=function(e,i,o){!1===o.animate||0===o.duration?(e(1),i()):(this._easeStart=t.browser.now(),this._easeOptions=o,this._onEaseFrame=e,this._onEaseEnd=i,this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback));},i.prototype._renderFrameCallback=function(){var e=Math.min((t.browser.now()-this._easeStart)/this._easeOptions.duration,1);this._onEaseFrame(this._easeOptions.easing(e)),e<1?this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback):this.stop();},i.prototype._normalizeBearing=function(e,i){e=t.wrap(e,-180,180);var o=Math.abs(e-i);return Math.abs(e-360-i)<o&&(e-=360),Math.abs(e+360-i)<o&&(e+=360),e},i.prototype._normalizeCenter=function(t){var e=this.transform;if(e.renderWorldCopies&&!e.lngRange){var i=t.lng-e.center.lng;t.lng+=i>180?-360:i<-180?360:0;}},i}(t.Evented),yr=function(e){void 0===e&&(e={}),this.options=e,t.bindAll(["_toggleAttribution","_updateEditLink","_updateData","_updateCompact"],this);};yr.prototype.getDefaultPosition=function(){return "bottom-right"},yr.prototype.onAdd=function(t){var e=this.options&&this.options.compact;return this._map=t,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-attrib"),this._compactButton=i.create("button","mapboxgl-ctrl-attrib-button",this._container),this._compactButton.addEventListener("click",this._toggleAttribution),this._setElementTitle(this._compactButton,"ToggleAttribution"),this._innerContainer=i.create("div","mapboxgl-ctrl-attrib-inner",this._container),this._innerContainer.setAttribute("role","list"),e&&this._container.classList.add("mapboxgl-compact"),this._updateAttributions(),this._updateEditLink(),this._map.on("styledata",this._updateData),this._map.on("sourcedata",this._updateData),this._map.on("moveend",this._updateEditLink),void 0===e&&(this._map.on("resize",this._updateCompact),this._updateCompact()),this._container},yr.prototype.onRemove=function(){i.remove(this._container),this._map.off("styledata",this._updateData),this._map.off("sourcedata",this._updateData),this._map.off("moveend",this._updateEditLink),this._map.off("resize",this._updateCompact),this._map=void 0,this._attribHTML=void 0;},yr.prototype._setElementTitle=function(t,e){var i=this._map._getUIString("AttributionControl."+e);t.title=i,t.setAttribute("aria-label",i);},yr.prototype._toggleAttribution=function(){this._container.classList.contains("mapboxgl-compact-show")?(this._container.classList.remove("mapboxgl-compact-show"),this._compactButton.setAttribute("aria-pressed","false")):(this._container.classList.add("mapboxgl-compact-show"),this._compactButton.setAttribute("aria-pressed","true"));},yr.prototype._updateEditLink=function(){var e=this._editLink;e||(e=this._editLink=this._container.querySelector(".mapbox-improve-map"));var i=[{key:"owner",value:this.styleOwner},{key:"id",value:this.styleId},{key:"access_token",value:this._map._requestManager._customAccessToken||t.config.ACCESS_TOKEN}];if(e){var o=i.reduce((function(t,e,o){return e.value&&(t+=e.key+"="+e.value+(o<i.length-1?"&":"")),t}),"?");e.href=t.config.FEEDBACK_URL+"/"+o+(this._map._hash?this._map._hash.getHashString(!0):""),e.rel="noopener nofollow",this._setElementTitle(e,"MapFeedback");}},yr.prototype._updateData=function(t){!t||"metadata"!==t.sourceDataType&&"visibility"!==t.sourceDataType&&"style"!==t.dataType||(this._updateAttributions(),this._updateEditLink());},yr.prototype._updateAttributions=function(){if(this._map.style){var t=[];if(this.options.customAttribution&&(Array.isArray(this.options.customAttribution)?t=t.concat(this.options.customAttribution.map((function(t){return "string"!=typeof t?"":t}))):"string"==typeof this.options.customAttribution&&t.push(this.options.customAttribution)),this._map.style.stylesheet){var e=this._map.style.stylesheet;this.styleOwner=e.owner,this.styleId=e.id;}var i=this._map.style.sourceCaches;for(var o in i){var r=i[o];if(r.used){var a=r.getSource();a.attribution&&t.indexOf(a.attribution)<0&&t.push(a.attribution);}}t.sort((function(t,e){return t.length-e.length}));var n=(t=t.filter((function(e,i){for(var o=i+1;o<t.length;o++)if(t[o].indexOf(e)>=0)return !1;return !0}))).join(" | ");n!==this._attribHTML&&(this._attribHTML=n,t.length?(this._innerContainer.innerHTML=n,this._container.classList.remove("mapboxgl-attrib-empty")):this._container.classList.add("mapboxgl-attrib-empty"),this._editLink=null);}},yr.prototype._updateCompact=function(){this._map.getCanvasContainer().offsetWidth<=640?this._container.classList.add("mapboxgl-compact"):this._container.classList.remove("mapboxgl-compact","mapboxgl-compact-show");};var xr=function(){t.bindAll(["_updateLogo"],this),t.bindAll(["_updateCompact"],this);};xr.prototype.onAdd=function(t){this._map=t,this._container=i.create("div","mapboxgl-ctrl");var e=i.create("a","mapboxgl-ctrl-logo");return e.target="_blank",e.rel="noopener nofollow",e.href="https://www.mapbox.com/",e.setAttribute("aria-label",this._map._getUIString("LogoControl.Title")),e.setAttribute("rel","noopener nofollow"),this._container.appendChild(e),this._container.style.display="none",this._map.on("sourcedata",this._updateLogo),this._updateLogo(),this._map.on("resize",this._updateCompact),this._updateCompact(),this._container},xr.prototype.onRemove=function(){i.remove(this._container),this._map.off("sourcedata",this._updateLogo),this._map.off("resize",this._updateCompact);},xr.prototype.getDefaultPosition=function(){return "bottom-left"},xr.prototype._updateLogo=function(t){t&&"metadata"!==t.sourceDataType||(this._container.style.display=this._logoRequired()?"block":"none");},xr.prototype._logoRequired=function(){if(this._map.style){var t=this._map.style.sourceCaches;for(var e in t)if(t[e].getSource().mapbox_logo)return !0;return !1}},xr.prototype._updateCompact=function(){var t=this._container.children;if(t.length){var e=t[0];this._map.getCanvasContainer().offsetWidth<250?e.classList.add("mapboxgl-compact"):e.classList.remove("mapboxgl-compact");}};var br=function(){this._queue=[],this._id=0,this._cleared=!1,this._currentlyRunning=!1;};br.prototype.add=function(t){var e=++this._id;return this._queue.push({callback:t,id:e,cancelled:!1}),e},br.prototype.remove=function(t){for(var e=this._currentlyRunning,i=0,o=e?this._queue.concat(e):this._queue;i<o.length;i+=1){var r=o[i];if(r.id===t)return void(r.cancelled=!0)}},br.prototype.run=function(t){void 0===t&&(t=0);var e=this._currentlyRunning=this._queue;this._queue=[];for(var i=0,o=e;i<o.length;i+=1){var r=o[i];if(!r.cancelled&&(r.callback(t),this._cleared))break}this._cleared=!1,this._currentlyRunning=!1;},br.prototype.clear=function(){this._currentlyRunning&&(this._cleared=!0),this._queue=[];};var wr={"AttributionControl.ToggleAttribution":"Toggle attribution","AttributionControl.MapFeedback":"Map feedback","FullscreenControl.Enter":"Enter fullscreen","FullscreenControl.Exit":"Exit fullscreen","GeolocateControl.FindMyLocation":"Find my location","GeolocateControl.LocationNotAvailable":"Location not available","LogoControl.Title":"Mapbox logo","NavigationControl.ResetBearing":"Reset bearing to north","NavigationControl.ZoomIn":"Zoom in","NavigationControl.ZoomOut":"Zoom out","ScaleControl.Feet":"ft","ScaleControl.Meters":"m","ScaleControl.Kilometers":"km","ScaleControl.Miles":"mi","ScaleControl.NauticalMiles":"nm"},Tr=t.window.HTMLImageElement,Er=t.window.HTMLElement,Ir=t.window.ImageBitmap,Pr={center:[0,0],zoom:0,bearing:0,pitch:0,minZoom:-2,maxZoom:22,minPitch:0,maxPitch:60,interactive:!0,scrollZoom:!0,boxZoom:!0,dragRotate:!0,dragPan:!0,keyboard:!0,doubleClickZoom:!0,touchZoomRotate:!0,touchPitch:!0,bearingSnap:7,clickTolerance:3,pitchWithRotate:!0,hash:!1,attributionControl:!0,failIfMajorPerformanceCaveat:!1,preserveDrawingBuffer:!1,trackResize:!0,renderWorldCopies:!0,refreshExpiredTiles:!0,maxTileCacheSize:null,localIdeographFontFamily:"sans-serif",transformRequest:null,accessToken:null,fadeDuration:300,crossSourceCollisions:!0},Sr=function(o){function r(e){var i=this;if(null!=(e=t.extend({},Pr,e)).minZoom&&null!=e.maxZoom&&e.minZoom>e.maxZoom)throw new Error("maxZoom must be greater than or equal to minZoom");if(null!=e.minPitch&&null!=e.maxPitch&&e.minPitch>e.maxPitch)throw new Error("maxPitch must be greater than or equal to minPitch");if(null!=e.minPitch&&e.minPitch<0)throw new Error("minPitch must be greater than or equal to 0");if(null!=e.maxPitch&&e.maxPitch>60)throw new Error("maxPitch must be less than or equal to 60");var r=new To(e.minZoom,e.maxZoom,e.minPitch,e.maxPitch,e.renderWorldCopies);if(o.call(this,r,e),this._interactive=e.interactive,this._maxTileCacheSize=e.maxTileCacheSize,this._failIfMajorPerformanceCaveat=e.failIfMajorPerformanceCaveat,this._preserveDrawingBuffer=e.preserveDrawingBuffer,this._antialias=e.antialias,this._trackResize=e.trackResize,this._bearingSnap=e.bearingSnap,this._refreshExpiredTiles=e.refreshExpiredTiles,this._fadeDuration=e.fadeDuration,this._crossSourceCollisions=e.crossSourceCollisions,this._crossFadingFactor=1,this._collectResourceTiming=e.collectResourceTiming,this._renderTaskQueue=new br,this._controls=[],this._mapId=t.uniqueId(),this._locale=t.extend({},wr,e.locale),this._clickTolerance=e.clickTolerance,this._requestManager=new t.RequestManager(e.transformRequest,e.accessToken),"string"==typeof e.container){if(this._container=t.window.document.getElementById(e.container),!this._container)throw new Error("Container '"+e.container+"' not found.")}else {if(!(e.container instanceof Er))throw new Error("Invalid type: 'container' must be a String or HTMLElement.");this._container=e.container;}if(e.maxBounds&&this.setMaxBounds(e.maxBounds),t.bindAll(["_onWindowOnline","_onWindowResize","_onMapScroll","_contextLost","_contextRestored"],this),this._setupContainer(),this._setupPainter(),void 0===this.painter)throw new Error("Failed to initialize WebGL.");this.on("move",(function(){return i._update(!1)})),this.on("moveend",(function(){return i._update(!1)})),this.on("zoom",(function(){return i._update(!0)})),void 0!==t.window&&(t.window.addEventListener("online",this._onWindowOnline,!1),t.window.addEventListener("resize",this._onWindowResize,!1),t.window.addEventListener("orientationchange",this._onWindowResize,!1)),this.handlers=new gr(this,e),this._hash=e.hash&&new Io("string"==typeof e.hash&&e.hash||void 0).addTo(this),this._hash&&this._hash._onHashChange()||(this.jumpTo({center:e.center,zoom:e.zoom,bearing:e.bearing,pitch:e.pitch}),e.bounds&&(this.resize(),this.fitBounds(e.bounds,t.extend({},e.fitBoundsOptions,{duration:0})))),this.resize(),this._localIdeographFontFamily=e.localIdeographFontFamily,e.style&&this.setStyle(e.style,{localIdeographFontFamily:e.localIdeographFontFamily}),e.attributionControl&&this.addControl(new yr({customAttribution:e.customAttribution})),this.addControl(new xr,e.logoPosition),this.on("style.load",(function(){i.transform.unmodified&&i.jumpTo(i.style.stylesheet);})),this.on("data",(function(e){i._update("style"===e.dataType),i.fire(new t.Event(e.dataType+"data",e));})),this.on("dataloading",(function(e){i.fire(new t.Event(e.dataType+"dataloading",e));}));}o&&(r.__proto__=o),(r.prototype=Object.create(o&&o.prototype)).constructor=r;var a={showTileBoundaries:{configurable:!0},showPadding:{configurable:!0},showCollisionBoxes:{configurable:!0},showOverdrawInspector:{configurable:!0},repaint:{configurable:!0},vertices:{configurable:!0},version:{configurable:!0}};return r.prototype._getMapId=function(){return this._mapId},r.prototype.addControl=function(e,i){if(void 0===i&&(i=e.getDefaultPosition?e.getDefaultPosition():"top-right"),!e||!e.onAdd)return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));var o=e.onAdd(this);this._controls.push(e);var r=this._controlPositions[i];return -1!==i.indexOf("bottom")?r.insertBefore(o,r.firstChild):r.appendChild(o),this},r.prototype.removeControl=function(e){if(!e||!e.onRemove)return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));var i=this._controls.indexOf(e);return i>-1&&this._controls.splice(i,1),e.onRemove(this),this},r.prototype.hasControl=function(t){return this._controls.indexOf(t)>-1},r.prototype.resize=function(e){var i=this._containerDimensions(),o=i[0],r=i[1];if(o===this.transform.width&&r===this.transform.height)return this;this._resizeCanvas(o,r),this.transform.resize(o,r),this.painter.resize(o,r);var a=!this._moving;return a&&this.fire(new t.Event("movestart",e)).fire(new t.Event("move",e)),this.fire(new t.Event("resize",e)),a&&this.fire(new t.Event("moveend",e)),this},r.prototype.getBounds=function(){return this.transform.getBounds()},r.prototype.getMaxBounds=function(){return this.transform.getMaxBounds()},r.prototype.setMaxBounds=function(e){return this.transform.setMaxBounds(t.LngLatBounds.convert(e)),this._update()},r.prototype.setMinZoom=function(t){if((t=null==t?-2:t)>=-2&&t<=this.transform.maxZoom)return this.transform.minZoom=t,this._update(),this.getZoom()<t&&this.setZoom(t),this;throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")},r.prototype.getMinZoom=function(){return this.transform.minZoom},r.prototype.setMaxZoom=function(t){if((t=null==t?22:t)>=this.transform.minZoom)return this.transform.maxZoom=t,this._update(),this.getZoom()>t&&this.setZoom(t),this;throw new Error("maxZoom must be greater than the current minZoom")},r.prototype.getMaxZoom=function(){return this.transform.maxZoom},r.prototype.setMinPitch=function(t){if((t=null==t?0:t)<0)throw new Error("minPitch must be greater than or equal to 0");if(t>=0&&t<=this.transform.maxPitch)return this.transform.minPitch=t,this._update(),this.getPitch()<t&&this.setPitch(t),this;throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")},r.prototype.getMinPitch=function(){return this.transform.minPitch},r.prototype.setMaxPitch=function(t){if((t=null==t?60:t)>60)throw new Error("maxPitch must be less than or equal to 60");if(t>=this.transform.minPitch)return this.transform.maxPitch=t,this._update(),this.getPitch()>t&&this.setPitch(t),this;throw new Error("maxPitch must be greater than the current minPitch")},r.prototype.getMaxPitch=function(){return this.transform.maxPitch},r.prototype.getRenderWorldCopies=function(){return this.transform.renderWorldCopies},r.prototype.setRenderWorldCopies=function(t){return this.transform.renderWorldCopies=t,this._update()},r.prototype.project=function(e){return this.transform.locationPoint(t.LngLat.convert(e))},r.prototype.unproject=function(e){return this.transform.pointLocation(t.Point.convert(e))},r.prototype.isMoving=function(){return this._moving||this.handlers.isMoving()},r.prototype.isZooming=function(){return this._zooming||this.handlers.isZooming()},r.prototype.isRotating=function(){return this._rotating||this.handlers.isRotating()},r.prototype._createDelegatedListener=function(t,e,i){var o,r=this;if("mouseenter"===t||"mouseover"===t){var a=!1;return {layer:e,listener:i,delegates:{mousemove:function(o){var n=r.getLayer(e)?r.queryRenderedFeatures(o.point,{layers:[e]}):[];n.length?a||(a=!0,i.call(r,new Ro(t,r,o.originalEvent,{features:n}))):a=!1;},mouseout:function(){a=!1;}}}}if("mouseleave"===t||"mouseout"===t){var n=!1;return {layer:e,listener:i,delegates:{mousemove:function(o){(r.getLayer(e)?r.queryRenderedFeatures(o.point,{layers:[e]}):[]).length?n=!0:n&&(n=!1,i.call(r,new Ro(t,r,o.originalEvent)));},mouseout:function(e){n&&(n=!1,i.call(r,new Ro(t,r,e.originalEvent)));}}}}return {layer:e,listener:i,delegates:(o={},o[t]=function(t){var o=r.getLayer(e)?r.queryRenderedFeatures(t.point,{layers:[e]}):[];o.length&&(t.features=o,i.call(r,t),delete t.features);},o)}},r.prototype.on=function(t,e,i){if(void 0===i)return o.prototype.on.call(this,t,e);var r=this._createDelegatedListener(t,e,i);for(var a in this._delegatedListeners=this._delegatedListeners||{},this._delegatedListeners[t]=this._delegatedListeners[t]||[],this._delegatedListeners[t].push(r),r.delegates)this.on(a,r.delegates[a]);return this},r.prototype.once=function(t,e,i){if(void 0===i)return o.prototype.once.call(this,t,e);var r=this._createDelegatedListener(t,e,i);for(var a in r.delegates)this.once(a,r.delegates[a]);return this},r.prototype.off=function(t,e,i){var r=this;return void 0===i?o.prototype.off.call(this,t,e):(this._delegatedListeners&&this._delegatedListeners[t]&&function(o){for(var a=o[t],n=0;n<a.length;n++){var s=a[n];if(s.layer===e&&s.listener===i){for(var l in s.delegates)r.off(l,s.delegates[l]);return a.splice(n,1),r}}}(this._delegatedListeners),this)},r.prototype.queryRenderedFeatures=function(e,i){if(!this.style)return [];var o;if(void 0!==i||void 0===e||e instanceof t.Point||Array.isArray(e)||(i=e,e=void 0),i=i||{},(e=e||[[0,0],[this.transform.width,this.transform.height]])instanceof t.Point||"number"==typeof e[0])o=[t.Point.convert(e)];else {var r=t.Point.convert(e[0]),a=t.Point.convert(e[1]);o=[r,new t.Point(a.x,r.y),a,new t.Point(r.x,a.y),r];}return this.style.queryRenderedFeatures(o,i,this.transform)},r.prototype.querySourceFeatures=function(t,e){return this.style.querySourceFeatures(t,e)},r.prototype.setStyle=function(e,i){return !1!==(i=t.extend({},{localIdeographFontFamily:this._localIdeographFontFamily},i)).diff&&i.localIdeographFontFamily===this._localIdeographFontFamily&&this.style&&e?(this._diffStyle(e,i),this):(this._localIdeographFontFamily=i.localIdeographFontFamily,this._updateStyle(e,i))},r.prototype._getUIString=function(t){var e=this._locale[t];if(null==e)throw new Error("Missing UI string '"+t+"'");return e},r.prototype._updateStyle=function(t,e){return this.style&&(this.style.setEventedParent(null),this.style._remove()),t?(this.style=new je(this,e||{}),this.style.setEventedParent(this,{style:this.style}),"string"==typeof t?this.style.loadURL(t):this.style.loadJSON(t),this):(delete this.style,this)},r.prototype._lazyInitEmptyStyle=function(){this.style||(this.style=new je(this,{}),this.style.setEventedParent(this,{style:this.style}),this.style.loadEmpty());},r.prototype._diffStyle=function(e,i){var o=this;if("string"==typeof e){var r=this._requestManager.normalizeStyleURL(e),a=this._requestManager.transformRequest(r,t.ResourceType.Style);t.getJSON(a,(function(e,r){e?o.fire(new t.ErrorEvent(e)):r&&o._updateDiff(r,i);}));}else "object"==typeof e&&this._updateDiff(e,i);},r.prototype._updateDiff=function(e,i){try{this.style.setState(e)&&this._update(!0);}catch(o){t.warnOnce("Unable to perform style diff: "+(o.message||o.error||o)+".  Rebuilding the style from scratch."),this._updateStyle(e,i);}},r.prototype.getStyle=function(){if(this.style)return this.style.serialize()},r.prototype.isStyleLoaded=function(){return this.style?this.style.loaded():t.warnOnce("There is no style added to the map.")},r.prototype.addSource=function(t,e){return this._lazyInitEmptyStyle(),this.style.addSource(t,e),this._update(!0)},r.prototype.isSourceLoaded=function(e){var i=this.style&&this.style.sourceCaches[e];if(void 0!==i)return i.loaded();this.fire(new t.ErrorEvent(new Error("There is no source with ID '"+e+"'")));},r.prototype.areTilesLoaded=function(){var t=this.style&&this.style.sourceCaches;for(var e in t){var i=t[e]._tiles;for(var o in i){var r=i[o];if("loaded"!==r.state&&"errored"!==r.state)return !1}}return !0},r.prototype.addSourceType=function(t,e,i){return this._lazyInitEmptyStyle(),this.style.addSourceType(t,e,i)},r.prototype.removeSource=function(t){return this.style.removeSource(t),this._update(!0)},r.prototype.getSource=function(t){return this.style.getSource(t)},r.prototype.addImage=function(e,i,o){void 0===o&&(o={});var r=o.pixelRatio;void 0===r&&(r=1);var a=o.sdf;void 0===a&&(a=!1);var n=o.stretchX,s=o.stretchY,l=o.content;if(this._lazyInitEmptyStyle(),i instanceof Tr||Ir&&i instanceof Ir){var c=t.browser.getImageData(i);this.style.addImage(e,{data:new t.RGBAImage({width:c.width,height:c.height},c.data),pixelRatio:r,stretchX:n,stretchY:s,content:l,sdf:a,version:0});}else {if(void 0===i.width||void 0===i.height)return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));var u=i;this.style.addImage(e,{data:new t.RGBAImage({width:i.width,height:i.height},new Uint8Array(i.data)),pixelRatio:r,stretchX:n,stretchY:s,content:l,sdf:a,version:0,userImage:u}),u.onAdd&&u.onAdd(this,e);}},r.prototype.updateImage=function(e,i){var o=this.style.getImage(e);if(!o)return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));var r=i instanceof Tr||Ir&&i instanceof Ir?t.browser.getImageData(i):i,a=r.width,n=r.height,s=r.data;return void 0===a||void 0===n?this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))):a!==o.data.width||n!==o.data.height?this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))):(o.data.replace(s,!(i instanceof Tr||Ir&&i instanceof Ir)),void this.style.updateImage(e,o))},r.prototype.hasImage=function(e){return e?!!this.style.getImage(e):(this.fire(new t.ErrorEvent(new Error("Missing required image id"))),!1)},r.prototype.removeImage=function(t){this.style.removeImage(t);},r.prototype.loadImage=function(e,i){t.getImage(this._requestManager.transformRequest(e,t.ResourceType.Image),i);},r.prototype.listImages=function(){return this.style.listImages()},r.prototype.addLayer=function(t,e){return this._lazyInitEmptyStyle(),this.style.addLayer(t,e),this._update(!0)},r.prototype.moveLayer=function(t,e){return this.style.moveLayer(t,e),this._update(!0)},r.prototype.removeLayer=function(t){return this.style.removeLayer(t),this._update(!0)},r.prototype.getLayer=function(t){return this.style.getLayer(t)},r.prototype.setLayerZoomRange=function(t,e,i){return this.style.setLayerZoomRange(t,e,i),this._update(!0)},r.prototype.setFilter=function(t,e,i){return void 0===i&&(i={}),this.style.setFilter(t,e,i),this._update(!0)},r.prototype.getFilter=function(t){return this.style.getFilter(t)},r.prototype.setPaintProperty=function(t,e,i,o){return void 0===o&&(o={}),this.style.setPaintProperty(t,e,i,o),this._update(!0)},r.prototype.getPaintProperty=function(t,e){return this.style.getPaintProperty(t,e)},r.prototype.setLayoutProperty=function(t,e,i,o){return void 0===o&&(o={}),this.style.setLayoutProperty(t,e,i,o),this._update(!0)},r.prototype.getLayoutProperty=function(t,e){return this.style.getLayoutProperty(t,e)},r.prototype.setLight=function(t,e){return void 0===e&&(e={}),this._lazyInitEmptyStyle(),this.style.setLight(t,e),this._update(!0)},r.prototype.getLight=function(){return this.style.getLight()},r.prototype.setFeatureState=function(t,e){return this.style.setFeatureState(t,e),this._update()},r.prototype.removeFeatureState=function(t,e){return this.style.removeFeatureState(t,e),this._update()},r.prototype.getFeatureState=function(t){return this.style.getFeatureState(t)},r.prototype.getContainer=function(){return this._container},r.prototype.getCanvasContainer=function(){return this._canvasContainer},r.prototype.getCanvas=function(){return this._canvas},r.prototype._containerDimensions=function(){var t=0,e=0;return this._container&&(t=this._container.clientWidth||400,e=this._container.clientHeight||300),[t,e]},r.prototype._detectMissingCSS=function(){"rgb(250, 128, 114)"!==t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color")&&t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");},r.prototype._setupContainer=function(){var t=this._container;t.classList.add("mapboxgl-map"),(this._missingCSSCanary=i.create("div","mapboxgl-canary",t)).style.visibility="hidden",this._detectMissingCSS();var e=this._canvasContainer=i.create("div","mapboxgl-canvas-container",t);this._interactive&&e.classList.add("mapboxgl-interactive"),this._canvas=i.create("canvas","mapboxgl-canvas",e),this._canvas.addEventListener("webglcontextlost",this._contextLost,!1),this._canvas.addEventListener("webglcontextrestored",this._contextRestored,!1),this._canvas.setAttribute("tabindex","0"),this._canvas.setAttribute("aria-label","Map"),this._canvas.setAttribute("role","region");var o=this._containerDimensions();this._resizeCanvas(o[0],o[1]);var r=this._controlContainer=i.create("div","mapboxgl-control-container",t),a=this._controlPositions={};["top-left","top-right","bottom-left","bottom-right"].forEach((function(t){a[t]=i.create("div","mapboxgl-ctrl-"+t,r);})),this._container.addEventListener("scroll",this._onMapScroll,!1);},r.prototype._resizeCanvas=function(e,i){var o=t.browser.devicePixelRatio||1;this._canvas.width=o*e,this._canvas.height=o*i,this._canvas.style.width=e+"px",this._canvas.style.height=i+"px";},r.prototype._setupPainter=function(){var i=t.extend({},e.webGLContextAttributes,{failIfMajorPerformanceCaveat:this._failIfMajorPerformanceCaveat,preserveDrawingBuffer:this._preserveDrawingBuffer,antialias:this._antialias||!1}),o=this._canvas.getContext("webgl",i)||this._canvas.getContext("experimental-webgl",i);o?(this.painter=new yo(o,this.transform),t.webpSupported.testSupport(o)):this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));},r.prototype._contextLost=function(e){e.preventDefault(),this._frame&&(this._frame.cancel(),this._frame=null),this.fire(new t.Event("webglcontextlost",{originalEvent:e}));},r.prototype._contextRestored=function(e){this._setupPainter(),this.resize(),this._update(),this.fire(new t.Event("webglcontextrestored",{originalEvent:e}));},r.prototype._onMapScroll=function(t){if(t.target===this._container)return this._container.scrollTop=0,this._container.scrollLeft=0,!1},r.prototype.loaded=function(){return !this._styleDirty&&!this._sourcesDirty&&!!this.style&&this.style.loaded()},r.prototype._update=function(t){return this.style?(this._styleDirty=this._styleDirty||t,this._sourcesDirty=!0,this.triggerRepaint(),this):this},r.prototype._requestRenderFrame=function(t){return this._update(),this._renderTaskQueue.add(t)},r.prototype._cancelRenderFrame=function(t){this._renderTaskQueue.remove(t);},r.prototype._render=function(e){var i,o=this,r=0,a=this.painter.context.extTimerQuery;if(this.listens("gpu-timing-frame")&&(i=a.createQueryEXT(),a.beginQueryEXT(a.TIME_ELAPSED_EXT,i),r=t.browser.now()),this.painter.context.setDirty(),this.painter.setBaseState(),this._renderTaskQueue.run(e),!this._removed){var n=!1;if(this.style&&this._styleDirty){this._styleDirty=!1;var s=this.transform.zoom,l=t.browser.now();this.style.zoomHistory.update(s,l);var c=new t.EvaluationParameters(s,{now:l,fadeDuration:this._fadeDuration,zoomHistory:this.style.zoomHistory,transition:this.style.getTransition()}),u=c.crossFadingFactor();1===u&&u===this._crossFadingFactor||(n=!0,this._crossFadingFactor=u),this.style.update(c);}if(this.style&&this._sourcesDirty&&(this._sourcesDirty=!1,this.style._updateSources(this.transform)),this._placementDirty=this.style&&this.style._updatePlacement(this.painter.transform,this.showCollisionBoxes,this._fadeDuration,this._crossSourceCollisions),this.painter.render(this.style,{showTileBoundaries:this.showTileBoundaries,showOverdrawInspector:this._showOverdrawInspector,rotating:this.isRotating(),zooming:this.isZooming(),moving:this.isMoving(),fadeDuration:this._fadeDuration,showPadding:this.showPadding,gpuTiming:!!this.listens("gpu-timing-layer")}),this.fire(new t.Event("render")),this.loaded()&&!this._loaded&&(this._loaded=!0,this.fire(new t.Event("load"))),this.style&&(this.style.hasTransitions()||n)&&(this._styleDirty=!0),this.style&&!this._placementDirty&&this.style._releaseSymbolFadeTiles(),this.listens("gpu-timing-frame")){var h=t.browser.now()-r;a.endQueryEXT(a.TIME_ELAPSED_EXT,i),setTimeout((function(){var e=a.getQueryObjectEXT(i,a.QUERY_RESULT_EXT)/1e6;a.deleteQueryEXT(i),o.fire(new t.Event("gpu-timing-frame",{cpuTime:h,gpuTime:e}));}),50);}if(this.listens("gpu-timing-layer")){var p=this.painter.collectGpuTimers();setTimeout((function(){var e=o.painter.queryGpuTimers(p);o.fire(new t.Event("gpu-timing-layer",{layerTimes:e}));}),50);}var d=this._sourcesDirty||this._styleDirty||this._placementDirty;return d||this._repaint?this.triggerRepaint():!this.isMoving()&&this.loaded()&&this.fire(new t.Event("idle")),!this._loaded||this._fullyLoaded||d||(this._fullyLoaded=!0),this}},r.prototype.remove=function(){this._hash&&this._hash.remove();for(var e=0,i=this._controls;e<i.length;e+=1)i[e].onRemove(this);this._controls=[],this._frame&&(this._frame.cancel(),this._frame=null),this._renderTaskQueue.clear(),this.painter.destroy(),this.handlers.destroy(),delete this.handlers,this.setStyle(null),void 0!==t.window&&(t.window.removeEventListener("resize",this._onWindowResize,!1),t.window.removeEventListener("orientationchange",this._onWindowResize,!1),t.window.removeEventListener("online",this._onWindowOnline,!1));var o=this.painter.context.gl.getExtension("WEBGL_lose_context");o&&o.loseContext(),Cr(this._canvasContainer),Cr(this._controlContainer),Cr(this._missingCSSCanary),this._container.classList.remove("mapboxgl-map"),this._removed=!0,this.fire(new t.Event("remove"));},r.prototype.triggerRepaint=function(){var e=this;this.style&&!this._frame&&(this._frame=t.browser.frame((function(t){e._frame=null,e._render(t);})));},r.prototype._onWindowOnline=function(){this._update();},r.prototype._onWindowResize=function(t){this._trackResize&&this.resize({originalEvent:t})._update();},a.showTileBoundaries.get=function(){return !!this._showTileBoundaries},a.showTileBoundaries.set=function(t){this._showTileBoundaries!==t&&(this._showTileBoundaries=t,this._update());},a.showPadding.get=function(){return !!this._showPadding},a.showPadding.set=function(t){this._showPadding!==t&&(this._showPadding=t,this._update());},a.showCollisionBoxes.get=function(){return !!this._showCollisionBoxes},a.showCollisionBoxes.set=function(t){this._showCollisionBoxes!==t&&(this._showCollisionBoxes=t,t?this.style._generateCollisionBoxes():this._update());},a.showOverdrawInspector.get=function(){return !!this._showOverdrawInspector},a.showOverdrawInspector.set=function(t){this._showOverdrawInspector!==t&&(this._showOverdrawInspector=t,this._update());},a.repaint.get=function(){return !!this._repaint},a.repaint.set=function(t){this._repaint!==t&&(this._repaint=t,this.triggerRepaint());},a.vertices.get=function(){return !!this._vertices},a.vertices.set=function(t){this._vertices=t,this._update();},r.prototype._setCacheLimits=function(e,i){t.setCacheLimits(e,i);},a.version.get=function(){return t.version},Object.defineProperties(r.prototype,a),r}(vr);function Cr(t){t.parentNode&&t.parentNode.removeChild(t);}var zr={showCompass:!0,showZoom:!0,visualizePitch:!1},Dr=function(e){var o=this;this.options=t.extend({},zr,e),this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._container.addEventListener("contextmenu",(function(t){return t.preventDefault()})),this.options.showZoom&&(t.bindAll(["_setButtonTitle","_updateZoomButtons"],this),this._zoomInButton=this._createButton("mapboxgl-ctrl-zoom-in",(function(t){return o._map.zoomIn({},{originalEvent:t})})),i.create("span","mapboxgl-ctrl-icon",this._zoomInButton).setAttribute("aria-hidden",!0),this._zoomOutButton=this._createButton("mapboxgl-ctrl-zoom-out",(function(t){return o._map.zoomOut({},{originalEvent:t})})),i.create("span","mapboxgl-ctrl-icon",this._zoomOutButton).setAttribute("aria-hidden",!0)),this.options.showCompass&&(t.bindAll(["_rotateCompassArrow"],this),this._compass=this._createButton("mapboxgl-ctrl-compass",(function(t){o.options.visualizePitch?o._map.resetNorthPitch({},{originalEvent:t}):o._map.resetNorth({},{originalEvent:t});})),this._compassIcon=i.create("span","mapboxgl-ctrl-icon",this._compass),this._compassIcon.setAttribute("aria-hidden",!0));};Dr.prototype._updateZoomButtons=function(){var t=this._map.getZoom(),e=t===this._map.getMaxZoom(),i=t===this._map.getMinZoom();this._zoomInButton.disabled=e,this._zoomOutButton.disabled=i,this._zoomInButton.setAttribute("aria-disabled",e.toString()),this._zoomOutButton.setAttribute("aria-disabled",i.toString());},Dr.prototype._rotateCompassArrow=function(){var t=this.options.visualizePitch?"scale("+1/Math.pow(Math.cos(this._map.transform.pitch*(Math.PI/180)),.5)+") rotateX("+this._map.transform.pitch+"deg) rotateZ("+this._map.transform.angle*(180/Math.PI)+"deg)":"rotate("+this._map.transform.angle*(180/Math.PI)+"deg)";this._compassIcon.style.transform=t;},Dr.prototype.onAdd=function(t){return this._map=t,this.options.showZoom&&(this._setButtonTitle(this._zoomInButton,"ZoomIn"),this._setButtonTitle(this._zoomOutButton,"ZoomOut"),this._map.on("zoom",this._updateZoomButtons),this._updateZoomButtons()),this.options.showCompass&&(this._setButtonTitle(this._compass,"ResetBearing"),this.options.visualizePitch&&this._map.on("pitch",this._rotateCompassArrow),this._map.on("rotate",this._rotateCompassArrow),this._rotateCompassArrow(),this._handler=new Ar(this._map,this._compass,this.options.visualizePitch)),this._container},Dr.prototype.onRemove=function(){i.remove(this._container),this.options.showZoom&&this._map.off("zoom",this._updateZoomButtons),this.options.showCompass&&(this.options.visualizePitch&&this._map.off("pitch",this._rotateCompassArrow),this._map.off("rotate",this._rotateCompassArrow),this._handler.off(),delete this._handler),delete this._map;},Dr.prototype._createButton=function(t,e){var o=i.create("button",t,this._container);return o.type="button",o.addEventListener("click",e),o},Dr.prototype._setButtonTitle=function(t,e){var i=this._map._getUIString("NavigationControl."+e);t.title=i,t.setAttribute("aria-label",i);};var Ar=function(e,o,r){void 0===r&&(r=!1),this._clickTolerance=10,this.element=o,this.mouseRotate=new Xo({clickTolerance:e.dragRotate._mouseRotate._clickTolerance}),this.map=e,r&&(this.mousePitch=new Ho({clickTolerance:e.dragRotate._mousePitch._clickTolerance})),t.bindAll(["mousedown","mousemove","mouseup","touchstart","touchmove","touchend","reset"],this),i.addEventListener(o,"mousedown",this.mousedown),i.addEventListener(o,"touchstart",this.touchstart,{passive:!1}),i.addEventListener(o,"touchmove",this.touchmove),i.addEventListener(o,"touchend",this.touchend),i.addEventListener(o,"touchcancel",this.reset);};function Mr(e,i,o){if(e=new t.LngLat(e.lng,e.lat),i){var r=new t.LngLat(e.lng-360,e.lat),a=new t.LngLat(e.lng+360,e.lat),n=o.locationPoint(e).distSqr(i);o.locationPoint(r).distSqr(i)<n?e=r:o.locationPoint(a).distSqr(i)<n&&(e=a);}for(;Math.abs(e.lng-o.center.lng)>180;){var s=o.locationPoint(e);if(s.x>=0&&s.y>=0&&s.x<=o.width&&s.y<=o.height)break;e.lng>o.center.lng?e.lng-=360:e.lng+=360;}return e}Ar.prototype.down=function(t,e){this.mouseRotate.mousedown(t,e),this.mousePitch&&this.mousePitch.mousedown(t,e),i.disableDrag();},Ar.prototype.move=function(t,e){var i=this.map,o=this.mouseRotate.mousemoveWindow(t,e);if(o&&o.bearingDelta&&i.setBearing(i.getBearing()+o.bearingDelta),this.mousePitch){var r=this.mousePitch.mousemoveWindow(t,e);r&&r.pitchDelta&&i.setPitch(i.getPitch()+r.pitchDelta);}},Ar.prototype.off=function(){var t=this.element;i.removeEventListener(t,"mousedown",this.mousedown),i.removeEventListener(t,"touchstart",this.touchstart,{passive:!1}),i.removeEventListener(t,"touchmove",this.touchmove),i.removeEventListener(t,"touchend",this.touchend),i.removeEventListener(t,"touchcancel",this.reset),this.offTemp();},Ar.prototype.offTemp=function(){i.enableDrag(),i.removeEventListener(t.window,"mousemove",this.mousemove),i.removeEventListener(t.window,"mouseup",this.mouseup);},Ar.prototype.mousedown=function(e){this.down(t.extend({},e,{ctrlKey:!0,preventDefault:function(){return e.preventDefault()}}),i.mousePos(this.element,e)),i.addEventListener(t.window,"mousemove",this.mousemove),i.addEventListener(t.window,"mouseup",this.mouseup);},Ar.prototype.mousemove=function(t){this.move(t,i.mousePos(this.element,t));},Ar.prototype.mouseup=function(t){this.mouseRotate.mouseupWindow(t),this.mousePitch&&this.mousePitch.mouseupWindow(t),this.offTemp();},Ar.prototype.touchstart=function(t){1!==t.targetTouches.length?this.reset():(this._startPos=this._lastPos=i.touchPos(this.element,t.targetTouches)[0],this.down({type:"mousedown",button:0,ctrlKey:!0,preventDefault:function(){return t.preventDefault()}},this._startPos));},Ar.prototype.touchmove=function(t){1!==t.targetTouches.length?this.reset():(this._lastPos=i.touchPos(this.element,t.targetTouches)[0],this.move({preventDefault:function(){return t.preventDefault()}},this._lastPos));},Ar.prototype.touchend=function(t){0===t.targetTouches.length&&this._startPos&&this._lastPos&&this._startPos.dist(this._lastPos)<this._clickTolerance&&this.element.click(),this.reset();},Ar.prototype.reset=function(){this.mouseRotate.reset(),this.mousePitch&&this.mousePitch.reset(),delete this._startPos,delete this._lastPos,this.offTemp();};var Lr={center:"translate(-50%,-50%)",top:"translate(-50%,0)","top-left":"translate(0,0)","top-right":"translate(-100%,0)",bottom:"translate(-50%,-100%)","bottom-left":"translate(0,-100%)","bottom-right":"translate(-100%,-100%)",left:"translate(0,-50%)",right:"translate(-100%,-50%)"};function Rr(t,e,i){var o=t.classList;for(var r in Lr)o.remove("mapboxgl-"+i+"-anchor-"+r);o.add("mapboxgl-"+i+"-anchor-"+e);}var kr,Br=function(e){function o(o,r){if(e.call(this),(o instanceof t.window.HTMLElement||r)&&(o=t.extend({element:o},r)),t.bindAll(["_update","_onMove","_onUp","_addDragHandler","_onMapClick","_onKeyPress"],this),this._anchor=o&&o.anchor||"center",this._color=o&&o.color||"#3FB1CE",this._scale=o&&o.scale||1,this._draggable=o&&o.draggable||!1,this._clickTolerance=o&&o.clickTolerance||0,this._isDragging=!1,this._state="inactive",this._rotation=o&&o.rotation||0,this._rotationAlignment=o&&o.rotationAlignment||"auto",this._pitchAlignment=o&&o.pitchAlignment&&"auto"!==o.pitchAlignment?o.pitchAlignment:this._rotationAlignment,o&&o.element)this._element=o.element,this._offset=t.Point.convert(o&&o.offset||[0,0]);else {this._defaultMarker=!0,this._element=i.create("div"),this._element.setAttribute("aria-label","Map marker");var a=i.createNS("http://www.w3.org/2000/svg","svg");a.setAttributeNS(null,"display","block"),a.setAttributeNS(null,"height","41px"),a.setAttributeNS(null,"width","27px"),a.setAttributeNS(null,"viewBox","0 0 27 41");var n=i.createNS("http://www.w3.org/2000/svg","g");n.setAttributeNS(null,"stroke","none"),n.setAttributeNS(null,"stroke-width","1"),n.setAttributeNS(null,"fill","none"),n.setAttributeNS(null,"fill-rule","evenodd");var s=i.createNS("http://www.w3.org/2000/svg","g");s.setAttributeNS(null,"fill-rule","nonzero");var l=i.createNS("http://www.w3.org/2000/svg","g");l.setAttributeNS(null,"transform","translate(3.0, 29.0)"),l.setAttributeNS(null,"fill","#000000");for(var c=0,u=[{rx:"10.5",ry:"5.25002273"},{rx:"10.5",ry:"5.25002273"},{rx:"9.5",ry:"4.77275007"},{rx:"8.5",ry:"4.29549936"},{rx:"7.5",ry:"3.81822308"},{rx:"6.5",ry:"3.34094679"},{rx:"5.5",ry:"2.86367051"},{rx:"4.5",ry:"2.38636864"}];c<u.length;c+=1){var h=u[c],p=i.createNS("http://www.w3.org/2000/svg","ellipse");p.setAttributeNS(null,"opacity","0.04"),p.setAttributeNS(null,"cx","10.5"),p.setAttributeNS(null,"cy","5.80029008"),p.setAttributeNS(null,"rx",h.rx),p.setAttributeNS(null,"ry",h.ry),l.appendChild(p);}var d=i.createNS("http://www.w3.org/2000/svg","g");d.setAttributeNS(null,"fill",this._color);var _=i.createNS("http://www.w3.org/2000/svg","path");_.setAttributeNS(null,"d","M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"),d.appendChild(_);var f=i.createNS("http://www.w3.org/2000/svg","g");f.setAttributeNS(null,"opacity","0.25"),f.setAttributeNS(null,"fill","#000000");var m=i.createNS("http://www.w3.org/2000/svg","path");m.setAttributeNS(null,"d","M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"),f.appendChild(m);var g=i.createNS("http://www.w3.org/2000/svg","g");g.setAttributeNS(null,"transform","translate(6.0, 7.0)"),g.setAttributeNS(null,"fill","#FFFFFF");var v=i.createNS("http://www.w3.org/2000/svg","g");v.setAttributeNS(null,"transform","translate(8.0, 8.0)");var y=i.createNS("http://www.w3.org/2000/svg","circle");y.setAttributeNS(null,"fill","#000000"),y.setAttributeNS(null,"opacity","0.25"),y.setAttributeNS(null,"cx","5.5"),y.setAttributeNS(null,"cy","5.5"),y.setAttributeNS(null,"r","5.4999962");var x=i.createNS("http://www.w3.org/2000/svg","circle");x.setAttributeNS(null,"fill","#FFFFFF"),x.setAttributeNS(null,"cx","5.5"),x.setAttributeNS(null,"cy","5.5"),x.setAttributeNS(null,"r","5.4999962"),v.appendChild(y),v.appendChild(x),s.appendChild(l),s.appendChild(d),s.appendChild(f),s.appendChild(g),s.appendChild(v),a.appendChild(s),a.setAttributeNS(null,"height",41*this._scale+"px"),a.setAttributeNS(null,"width",27*this._scale+"px"),this._element.appendChild(a),this._offset=t.Point.convert(o&&o.offset||[0,-14]);}this._element.classList.add("mapboxgl-marker"),this._element.addEventListener("dragstart",(function(t){t.preventDefault();})),this._element.addEventListener("mousedown",(function(t){t.preventDefault();})),Rr(this._element,this._anchor,"marker"),this._popup=null;}return e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o,o.prototype.addTo=function(t){return this.remove(),this._map=t,t.getCanvasContainer().appendChild(this._element),t.on("move",this._update),t.on("moveend",this._update),this.setDraggable(this._draggable),this._update(),this._map.on("click",this._onMapClick),this},o.prototype.remove=function(){return this._map&&(this._map.off("click",this._onMapClick),this._map.off("move",this._update),this._map.off("moveend",this._update),this._map.off("mousedown",this._addDragHandler),this._map.off("touchstart",this._addDragHandler),this._map.off("mouseup",this._onUp),this._map.off("touchend",this._onUp),this._map.off("mousemove",this._onMove),this._map.off("touchmove",this._onMove),delete this._map),i.remove(this._element),this._popup&&this._popup.remove(),this},o.prototype.getLngLat=function(){return this._lngLat},o.prototype.setLngLat=function(e){return this._lngLat=t.LngLat.convert(e),this._pos=null,this._popup&&this._popup.setLngLat(this._lngLat),this._update(),this},o.prototype.getElement=function(){return this._element},o.prototype.setPopup=function(t){if(this._popup&&(this._popup.remove(),this._popup=null,this._element.removeEventListener("keypress",this._onKeyPress),this._originalTabIndex||this._element.removeAttribute("tabindex")),t){if(!("offset"in t.options)){var e=Math.sqrt(Math.pow(13.5,2)/2);t.options.offset=this._defaultMarker?{top:[0,0],"top-left":[0,0],"top-right":[0,0],bottom:[0,-38.1],"bottom-left":[e,-1*(24.6+e)],"bottom-right":[-e,-1*(24.6+e)],left:[13.5,-24.6],right:[-13.5,-24.6]}:this._offset;}this._popup=t,this._lngLat&&this._popup.setLngLat(this._lngLat),this._originalTabIndex=this._element.getAttribute("tabindex"),this._originalTabIndex||this._element.setAttribute("tabindex","0"),this._element.addEventListener("keypress",this._onKeyPress);}return this},o.prototype._onKeyPress=function(t){var e=t.code,i=t.charCode||t.keyCode;"Space"!==e&&"Enter"!==e&&32!==i&&13!==i||this.togglePopup();},o.prototype._onMapClick=function(t){var e=t.originalEvent.target,i=this._element;this._popup&&(e===i||i.contains(e))&&this.togglePopup();},o.prototype.getPopup=function(){return this._popup},o.prototype.togglePopup=function(){var t=this._popup;return t?(t.isOpen()?t.remove():t.addTo(this._map),this):this},o.prototype._update=function(t){if(this._map){this._map.transform.renderWorldCopies&&(this._lngLat=Mr(this._lngLat,this._pos,this._map.transform)),this._pos=this._map.project(this._lngLat)._add(this._offset);var e="";"viewport"===this._rotationAlignment||"auto"===this._rotationAlignment?e="rotateZ("+this._rotation+"deg)":"map"===this._rotationAlignment&&(e="rotateZ("+(this._rotation-this._map.getBearing())+"deg)");var o="";"viewport"===this._pitchAlignment||"auto"===this._pitchAlignment?o="rotateX(0deg)":"map"===this._pitchAlignment&&(o="rotateX("+this._map.getPitch()+"deg)"),t&&"moveend"!==t.type||(this._pos=this._pos.round()),i.setTransform(this._element,Lr[this._anchor]+" translate("+this._pos.x+"px, "+this._pos.y+"px) "+o+" "+e);}},o.prototype.getOffset=function(){return this._offset},o.prototype.setOffset=function(e){return this._offset=t.Point.convert(e),this._update(),this},o.prototype._onMove=function(e){if(!this._isDragging){var i=this._clickTolerance||this._map._clickTolerance;this._isDragging=e.point.dist(this._pointerdownPos)>=i;}this._isDragging&&(this._pos=e.point.sub(this._positionDelta),this._lngLat=this._map.unproject(this._pos),this.setLngLat(this._lngLat),this._element.style.pointerEvents="none","pending"===this._state&&(this._state="active",this.fire(new t.Event("dragstart"))),this.fire(new t.Event("drag")));},o.prototype._onUp=function(){this._element.style.pointerEvents="auto",this._positionDelta=null,this._pointerdownPos=null,this._isDragging=!1,this._map.off("mousemove",this._onMove),this._map.off("touchmove",this._onMove),"active"===this._state&&this.fire(new t.Event("dragend")),this._state="inactive";},o.prototype._addDragHandler=function(t){this._element.contains(t.originalEvent.target)&&(t.preventDefault(),this._positionDelta=t.point.sub(this._pos).add(this._offset),this._pointerdownPos=t.point,this._state="pending",this._map.on("mousemove",this._onMove),this._map.on("touchmove",this._onMove),this._map.once("mouseup",this._onUp),this._map.once("touchend",this._onUp));},o.prototype.setDraggable=function(t){return this._draggable=!!t,this._map&&(t?(this._map.on("mousedown",this._addDragHandler),this._map.on("touchstart",this._addDragHandler)):(this._map.off("mousedown",this._addDragHandler),this._map.off("touchstart",this._addDragHandler))),this},o.prototype.isDraggable=function(){return this._draggable},o.prototype.setRotation=function(t){return this._rotation=t||0,this._update(),this},o.prototype.getRotation=function(){return this._rotation},o.prototype.setRotationAlignment=function(t){return this._rotationAlignment=t||"auto",this._update(),this},o.prototype.getRotationAlignment=function(){return this._rotationAlignment},o.prototype.setPitchAlignment=function(t){return this._pitchAlignment=t&&"auto"!==t?t:this._rotationAlignment,this._update(),this},o.prototype.getPitchAlignment=function(){return this._pitchAlignment},o}(t.Evented),Or={positionOptions:{enableHighAccuracy:!1,maximumAge:0,timeout:6e3},fitBoundsOptions:{maxZoom:15},trackUserLocation:!1,showAccuracyCircle:!0,showUserLocation:!0},Fr=0,Ur=!1,Nr=function(e){function o(i){e.call(this),this.options=t.extend({},Or,i),t.bindAll(["_onSuccess","_onError","_onZoom","_finish","_setupUI","_updateCamera","_updateMarker"],this);}return e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o,o.prototype.onAdd=function(e){var o;return this._map=e,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),o=this._setupUI,void 0!==kr?o(kr):void 0!==t.window.navigator.permissions?t.window.navigator.permissions.query({name:"geolocation"}).then((function(t){o(kr="denied"!==t.state);})):o(kr=!!t.window.navigator.geolocation),this._container},o.prototype.onRemove=function(){void 0!==this._geolocationWatchID&&(t.window.navigator.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0),this.options.showUserLocation&&this._userLocationDotMarker&&this._userLocationDotMarker.remove(),this.options.showAccuracyCircle&&this._accuracyCircleMarker&&this._accuracyCircleMarker.remove(),i.remove(this._container),this._map.off("zoom",this._onZoom),this._map=void 0,Fr=0,Ur=!1;},o.prototype._isOutOfMapMaxBounds=function(t){var e=this._map.getMaxBounds(),i=t.coords;return e&&(i.longitude<e.getWest()||i.longitude>e.getEast()||i.latitude<e.getSouth()||i.latitude>e.getNorth())},o.prototype._setErrorState=function(){switch(this._watchState){case"WAITING_ACTIVE":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"ACTIVE_LOCK":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");break;case"BACKGROUND":this._watchState="BACKGROUND_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");}},o.prototype._onSuccess=function(e){if(this._map){if(this._isOutOfMapMaxBounds(e))return this._setErrorState(),this.fire(new t.Event("outofmaxbounds",e)),this._updateMarker(),void this._finish();if(this.options.trackUserLocation)switch(this._lastKnownPosition=e,this._watchState){case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"BACKGROUND":case"BACKGROUND_ERROR":this._watchState="BACKGROUND",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");}this.options.showUserLocation&&"OFF"!==this._watchState&&this._updateMarker(e),this.options.trackUserLocation&&"ACTIVE_LOCK"!==this._watchState||this._updateCamera(e),this.options.showUserLocation&&this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"),this.fire(new t.Event("geolocate",e)),this._finish();}},o.prototype._updateCamera=function(e){var i=new t.LngLat(e.coords.longitude,e.coords.latitude),o=e.coords.accuracy,r=this._map.getBearing(),a=t.extend({bearing:r},this.options.fitBoundsOptions);this._map.fitBounds(i.toBounds(o),a,{geolocateSource:!0});},o.prototype._updateMarker=function(e){if(e){var i=new t.LngLat(e.coords.longitude,e.coords.latitude);this._accuracyCircleMarker.setLngLat(i).addTo(this._map),this._userLocationDotMarker.setLngLat(i).addTo(this._map),this._accuracy=e.coords.accuracy,this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();}else this._userLocationDotMarker.remove(),this._accuracyCircleMarker.remove();},o.prototype._updateCircleRadius=function(){var t=this._map._container.clientHeight/2,e=this._map.unproject([0,t]),i=this._map.unproject([1,t]),o=e.distanceTo(i),r=Math.ceil(2*this._accuracy/o);this._circleElement.style.width=r+"px",this._circleElement.style.height=r+"px";},o.prototype._onZoom=function(){this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();},o.prototype._onError=function(e){if(this._map){if(this.options.trackUserLocation)if(1===e.code){this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.disabled=!0;var i=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.title=i,this._geolocateButton.setAttribute("aria-label",i),void 0!==this._geolocationWatchID&&this._clearWatch();}else {if(3===e.code&&Ur)return;this._setErrorState();}"OFF"!==this._watchState&&this.options.showUserLocation&&this._dotElement.classList.add("mapboxgl-user-location-dot-stale"),this.fire(new t.Event("error",e)),this._finish();}},o.prototype._finish=function(){this._timeoutId&&clearTimeout(this._timeoutId),this._timeoutId=void 0;},o.prototype._setupUI=function(e){var o=this;if(this._container.addEventListener("contextmenu",(function(t){return t.preventDefault()})),this._geolocateButton=i.create("button","mapboxgl-ctrl-geolocate",this._container),i.create("span","mapboxgl-ctrl-icon",this._geolocateButton).setAttribute("aria-hidden",!0),this._geolocateButton.type="button",!1===e){t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");var r=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.disabled=!0,this._geolocateButton.title=r,this._geolocateButton.setAttribute("aria-label",r);}else {var a=this._map._getUIString("GeolocateControl.FindMyLocation");this._geolocateButton.title=a,this._geolocateButton.setAttribute("aria-label",a);}this.options.trackUserLocation&&(this._geolocateButton.setAttribute("aria-pressed","false"),this._watchState="OFF"),this.options.showUserLocation&&(this._dotElement=i.create("div","mapboxgl-user-location-dot"),this._userLocationDotMarker=new Br(this._dotElement),this._circleElement=i.create("div","mapboxgl-user-location-accuracy-circle"),this._accuracyCircleMarker=new Br({element:this._circleElement,pitchAlignment:"map"}),this.options.trackUserLocation&&(this._watchState="OFF"),this._map.on("zoom",this._onZoom)),this._geolocateButton.addEventListener("click",this.trigger.bind(this)),this._setup=!0,this.options.trackUserLocation&&this._map.on("movestart",(function(e){e.geolocateSource||"ACTIVE_LOCK"!==o._watchState||e.originalEvent&&"resize"===e.originalEvent.type||(o._watchState="BACKGROUND",o._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),o._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),o.fire(new t.Event("trackuserlocationend")));}));},o.prototype.trigger=function(){if(!this._setup)return t.warnOnce("Geolocate control triggered before added to a map"),!1;if(this.options.trackUserLocation){switch(this._watchState){case"OFF":this._watchState="WAITING_ACTIVE",this.fire(new t.Event("trackuserlocationstart"));break;case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":case"BACKGROUND_ERROR":Fr--,Ur=!1,this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this.fire(new t.Event("trackuserlocationend"));break;case"BACKGROUND":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._lastKnownPosition&&this._updateCamera(this._lastKnownPosition),this.fire(new t.Event("trackuserlocationstart"));}switch(this._watchState){case"WAITING_ACTIVE":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_LOCK":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"BACKGROUND":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");break;case"BACKGROUND_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");}if("OFF"===this._watchState&&void 0!==this._geolocationWatchID)this._clearWatch();else if(void 0===this._geolocationWatchID){var e;this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","true"),++Fr>1?(e={maximumAge:6e5,timeout:0},Ur=!0):(e=this.options.positionOptions,Ur=!1),this._geolocationWatchID=t.window.navigator.geolocation.watchPosition(this._onSuccess,this._onError,e);}}else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess,this._onError,this.options.positionOptions),this._timeoutId=setTimeout(this._finish,1e4);return !0},o.prototype._clearWatch=function(){t.window.navigator.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0,this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","false"),this.options.showUserLocation&&this._updateMarker(null);},o}(t.Evented),Zr={maxWidth:100,unit:"metric"},qr=function(e){this.options=t.extend({},Zr,e),t.bindAll(["_onMove","setUnit"],this);};function jr(t,e,i){var o=i&&i.maxWidth||100,r=t._container.clientHeight/2,a=t.unproject([0,r]),n=t.unproject([o,r]),s=a.distanceTo(n);if(i&&"imperial"===i.unit){var l=3.2808*s;l>5280?Vr(e,o,l/5280,t._getUIString("ScaleControl.Miles")):Vr(e,o,l,t._getUIString("ScaleControl.Feet"));}else i&&"nautical"===i.unit?Vr(e,o,s/1852,t._getUIString("ScaleControl.NauticalMiles")):s>=1e3?Vr(e,o,s/1e3,t._getUIString("ScaleControl.Kilometers")):Vr(e,o,s,t._getUIString("ScaleControl.Meters"));}function Vr(t,e,i,o){var r,a,n,s=(r=i,(a=Math.pow(10,(""+Math.floor(r)).length-1))*(n=(n=r/a)>=10?10:n>=5?5:n>=3?3:n>=2?2:n>=1?1:function(t){var e=Math.pow(10,Math.ceil(-Math.log(t)/Math.LN10));return Math.round(t*e)/e}(n)));t.style.width=e*(s/i)+"px",t.innerHTML=s+"&nbsp;"+o;}qr.prototype.getDefaultPosition=function(){return "bottom-left"},qr.prototype._onMove=function(){jr(this._map,this._container,this.options);},qr.prototype.onAdd=function(t){return this._map=t,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-scale",t.getContainer()),this._map.on("move",this._onMove),this._onMove(),this._container},qr.prototype.onRemove=function(){i.remove(this._container),this._map.off("move",this._onMove),this._map=void 0;},qr.prototype.setUnit=function(t){this.options.unit=t,jr(this._map,this._container,this.options);};var Gr=function(e){this._fullscreen=!1,e&&e.container&&(e.container instanceof t.window.HTMLElement?this._container=e.container:t.warnOnce("Full screen control 'container' must be a DOM element.")),t.bindAll(["_onClickFullscreen","_changeIcon"],this),"onfullscreenchange"in t.window.document?this._fullscreenchange="fullscreenchange":"onmozfullscreenchange"in t.window.document?this._fullscreenchange="mozfullscreenchange":"onwebkitfullscreenchange"in t.window.document?this._fullscreenchange="webkitfullscreenchange":"onmsfullscreenchange"in t.window.document&&(this._fullscreenchange="MSFullscreenChange");};Gr.prototype.onAdd=function(e){return this._map=e,this._container||(this._container=this._map.getContainer()),this._controlContainer=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._checkFullscreenSupport()?this._setupUI():(this._controlContainer.style.display="none",t.warnOnce("This device does not support fullscreen mode.")),this._controlContainer},Gr.prototype.onRemove=function(){i.remove(this._controlContainer),this._map=null,t.window.document.removeEventListener(this._fullscreenchange,this._changeIcon);},Gr.prototype._checkFullscreenSupport=function(){return !!(t.window.document.fullscreenEnabled||t.window.document.mozFullScreenEnabled||t.window.document.msFullscreenEnabled||t.window.document.webkitFullscreenEnabled)},Gr.prototype._setupUI=function(){var e=this._fullscreenButton=i.create("button","mapboxgl-ctrl-fullscreen",this._controlContainer);i.create("span","mapboxgl-ctrl-icon",e).setAttribute("aria-hidden",!0),e.type="button",this._updateTitle(),this._fullscreenButton.addEventListener("click",this._onClickFullscreen),t.window.document.addEventListener(this._fullscreenchange,this._changeIcon);},Gr.prototype._updateTitle=function(){var t=this._getTitle();this._fullscreenButton.setAttribute("aria-label",t),this._fullscreenButton.title=t;},Gr.prototype._getTitle=function(){return this._map._getUIString(this._isFullscreen()?"FullscreenControl.Exit":"FullscreenControl.Enter")},Gr.prototype._isFullscreen=function(){return this._fullscreen},Gr.prototype._changeIcon=function(){(t.window.document.fullscreenElement||t.window.document.mozFullScreenElement||t.window.document.webkitFullscreenElement||t.window.document.msFullscreenElement)===this._container!==this._fullscreen&&(this._fullscreen=!this._fullscreen,this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),this._updateTitle());},Gr.prototype._onClickFullscreen=function(){this._isFullscreen()?t.window.document.exitFullscreen?t.window.document.exitFullscreen():t.window.document.mozCancelFullScreen?t.window.document.mozCancelFullScreen():t.window.document.msExitFullscreen?t.window.document.msExitFullscreen():t.window.document.webkitCancelFullScreen&&t.window.document.webkitCancelFullScreen():this._container.requestFullscreen?this._container.requestFullscreen():this._container.mozRequestFullScreen?this._container.mozRequestFullScreen():this._container.msRequestFullscreen?this._container.msRequestFullscreen():this._container.webkitRequestFullscreen&&this._container.webkitRequestFullscreen();};var Wr={closeButton:!0,closeOnClick:!0,focusAfterOpen:!0,className:"",maxWidth:"240px"},Xr=["a[href]","[tabindex]:not([tabindex='-1'])","[contenteditable]:not([contenteditable='false'])","button:not([disabled])","input:not([disabled])","select:not([disabled])","textarea:not([disabled])"].join(", "),Hr=function(e){function o(i){e.call(this),this.options=t.extend(Object.create(Wr),i),t.bindAll(["_update","_onClose","remove","_onMouseMove","_onMouseUp","_onDrag"],this);}return e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o,o.prototype.addTo=function(e){return this._map&&this.remove(),this._map=e,this.options.closeOnClick&&this._map.on("click",this._onClose),this.options.closeOnMove&&this._map.on("move",this._onClose),this._map.on("remove",this.remove),this._update(),this._focusFirstElement(),this._trackPointer?(this._map.on("mousemove",this._onMouseMove),this._map.on("mouseup",this._onMouseUp),this._container&&this._container.classList.add("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.add("mapboxgl-track-pointer")):this._map.on("move",this._update),this.fire(new t.Event("open")),this},o.prototype.isOpen=function(){return !!this._map},o.prototype.remove=function(){return this._content&&i.remove(this._content),this._container&&(i.remove(this._container),delete this._container),this._map&&(this._map.off("move",this._update),this._map.off("move",this._onClose),this._map.off("click",this._onClose),this._map.off("remove",this.remove),this._map.off("mousemove",this._onMouseMove),this._map.off("mouseup",this._onMouseUp),this._map.off("drag",this._onDrag),delete this._map),this.fire(new t.Event("close")),this},o.prototype.getLngLat=function(){return this._lngLat},o.prototype.setLngLat=function(e){return this._lngLat=t.LngLat.convert(e),this._pos=null,this._trackPointer=!1,this._update(),this._map&&(this._map.on("move",this._update),this._map.off("mousemove",this._onMouseMove),this._container&&this._container.classList.remove("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")),this},o.prototype.trackPointer=function(){return this._trackPointer=!0,this._pos=null,this._update(),this._map&&(this._map.off("move",this._update),this._map.on("mousemove",this._onMouseMove),this._map.on("drag",this._onDrag),this._container&&this._container.classList.add("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.add("mapboxgl-track-pointer")),this},o.prototype.getElement=function(){return this._container},o.prototype.setText=function(e){return this.setDOMContent(t.window.document.createTextNode(e))},o.prototype.setHTML=function(e){var i,o=t.window.document.createDocumentFragment(),r=t.window.document.createElement("body");for(r.innerHTML=e;i=r.firstChild;)o.appendChild(i);return this.setDOMContent(o)},o.prototype.getMaxWidth=function(){return this._container&&this._container.style.maxWidth},o.prototype.setMaxWidth=function(t){return this.options.maxWidth=t,this._update(),this},o.prototype.setDOMContent=function(t){if(this._content)for(;this._content.hasChildNodes();)this._content.firstChild&&this._content.removeChild(this._content.firstChild);else this._content=i.create("div","mapboxgl-popup-content",this._container);return this._content.appendChild(t),this._createCloseButton(),this._update(),this._focusFirstElement(),this},o.prototype.addClassName=function(t){this._container&&this._container.classList.add(t);},o.prototype.removeClassName=function(t){this._container&&this._container.classList.remove(t);},o.prototype.setOffset=function(t){return this.options.offset=t,this._update(),this},o.prototype.toggleClassName=function(t){if(this._container)return this._container.classList.toggle(t)},o.prototype._createCloseButton=function(){this.options.closeButton&&(this._closeButton=i.create("button","mapboxgl-popup-close-button",this._content),this._closeButton.type="button",this._closeButton.setAttribute("aria-label","Close popup"),this._closeButton.innerHTML="&#215;",this._closeButton.addEventListener("click",this._onClose));},o.prototype._onMouseUp=function(t){this._update(t.point);},o.prototype._onMouseMove=function(t){this._update(t.point);},o.prototype._onDrag=function(t){this._update(t.point);},o.prototype._update=function(e){var o=this;if(this._map&&(this._lngLat||this._trackPointer)&&this._content&&(this._container||(this._container=i.create("div","mapboxgl-popup",this._map.getContainer()),this._tip=i.create("div","mapboxgl-popup-tip",this._container),this._container.appendChild(this._content),this.options.className&&this.options.className.split(" ").forEach((function(t){return o._container.classList.add(t)})),this._trackPointer&&this._container.classList.add("mapboxgl-popup-track-pointer")),this.options.maxWidth&&this._container.style.maxWidth!==this.options.maxWidth&&(this._container.style.maxWidth=this.options.maxWidth),this._map.transform.renderWorldCopies&&!this._trackPointer&&(this._lngLat=Mr(this._lngLat,this._pos,this._map.transform)),!this._trackPointer||e)){var r=this._pos=this._trackPointer&&e?e:this._map.project(this._lngLat),a=this.options.anchor,n=function e(i){if(i){if("number"==typeof i){var o=Math.round(Math.sqrt(.5*Math.pow(i,2)));return {center:new t.Point(0,0),top:new t.Point(0,i),"top-left":new t.Point(o,o),"top-right":new t.Point(-o,o),bottom:new t.Point(0,-i),"bottom-left":new t.Point(o,-o),"bottom-right":new t.Point(-o,-o),left:new t.Point(i,0),right:new t.Point(-i,0)}}if(i instanceof t.Point||Array.isArray(i)){var r=t.Point.convert(i);return {center:r,top:r,"top-left":r,"top-right":r,bottom:r,"bottom-left":r,"bottom-right":r,left:r,right:r}}return {center:t.Point.convert(i.center||[0,0]),top:t.Point.convert(i.top||[0,0]),"top-left":t.Point.convert(i["top-left"]||[0,0]),"top-right":t.Point.convert(i["top-right"]||[0,0]),bottom:t.Point.convert(i.bottom||[0,0]),"bottom-left":t.Point.convert(i["bottom-left"]||[0,0]),"bottom-right":t.Point.convert(i["bottom-right"]||[0,0]),left:t.Point.convert(i.left||[0,0]),right:t.Point.convert(i.right||[0,0])}}return e(new t.Point(0,0))}(this.options.offset);if(!a){var s,l=this._container.offsetWidth,c=this._container.offsetHeight;s=r.y+n.bottom.y<c?["top"]:r.y>this._map.transform.height-c?["bottom"]:[],r.x<l/2?s.push("left"):r.x>this._map.transform.width-l/2&&s.push("right"),a=0===s.length?"bottom":s.join("-");}var u=r.add(n[a]).round();i.setTransform(this._container,Lr[a]+" translate("+u.x+"px,"+u.y+"px)"),Rr(this._container,a,"popup");}},o.prototype._focusFirstElement=function(){if(this.options.focusAfterOpen&&this._container){var t=this._container.querySelector(Xr);t&&t.focus();}},o.prototype._onClose=function(){this.remove();},o}(t.Evented),Kr={version:t.version,supported:e,setRTLTextPlugin:t.setRTLTextPlugin,getRTLTextPluginStatus:t.getRTLTextPluginStatus,Map:Sr,NavigationControl:Dr,GeolocateControl:Nr,AttributionControl:yr,ScaleControl:qr,FullscreenControl:Gr,Popup:Hr,Marker:Br,Style:je,LngLat:t.LngLat,LngLatBounds:t.LngLatBounds,Point:t.Point,MercatorCoordinate:t.MercatorCoordinate,Evented:t.Evented,config:t.config,prewarm:function(){Ft().acquire(Rt);},clearPrewarmedResources:function(){var t=Bt;t&&(t.isPreloaded()&&1===t.numActive()?(t.release(Rt),Bt=null):console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));},get accessToken(){return t.config.ACCESS_TOKEN},set accessToken(e){t.config.ACCESS_TOKEN=e;},get baseApiUrl(){return t.config.API_URL},set baseApiUrl(e){t.config.API_URL=e;},get workerCount(){return kt.workerCount},set workerCount(t){kt.workerCount=t;},get maxParallelImageRequests(){return t.config.MAX_PARALLEL_IMAGE_REQUESTS},set maxParallelImageRequests(e){t.config.MAX_PARALLEL_IMAGE_REQUESTS=e;},clearStorage:function(e){t.clearTileCache(e);},workerUrl:""};return Kr}));

    //

    return mapboxgl;

    })));

    });

    var css$3 = ".edit-button.svelte-gfr88e{position:absolute;top:12px;left:12px}.submit-button.svelte-gfr88e{margin-left:6px}.submit-button.svelte-gfr88e:disabled{pointer-events:none}";
    n(css$3,{});

    /* src/TypographyChart.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1 } = globals;
    const file$3 = "src/TypographyChart.svelte";

    // (410:2) {#if Object.keys(tooltip).length > 0}
    function create_if_block_1$2(ctx) {
    	let tooltip_1;
    	let current;

    	tooltip_1 = new Tooltip({
    			props: {
    				left: /*tooltip*/ ctx[1].left,
    				top: /*tooltip*/ ctx[1].top,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tooltip_1.$on("close", /*handleTooltipClose*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(tooltip_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tooltip_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tooltip_1_changes = {};
    			if (dirty[0] & /*tooltip*/ 2) tooltip_1_changes.left = /*tooltip*/ ctx[1].left;
    			if (dirty[0] & /*tooltip*/ 2) tooltip_1_changes.top = /*tooltip*/ ctx[1].top;

    			if (dirty[0] & /*tooltip, labelText, editMode*/ 26 | dirty[1] & /*$$scope*/ 2) {
    				tooltip_1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip_1.$set(tooltip_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tooltip_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(410:2) {#if Object.keys(tooltip).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (416:6) {#if !editMode}
    function create_if_block_3$1(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Edit label";
    			add_location(button, file$3, 417, 10, 10487);
    			attr_dev(div, "class", "edit-button svelte-gfr88e");
    			add_location(div, file$3, 416, 8, 10451);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(416:6) {#if !editMode}",
    		ctx
    	});

    	return block;
    }

    // (425:6) {#if editMode}
    function create_if_block_2$2(ctx) {
    	let div;
    	let input;
    	let button;
    	let t;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			button = element("button");
    			t = text$1("Submit");
    			add_location(input, file$3, 426, 10, 10694);
    			attr_dev(button, "class", "submit-button svelte-gfr88e");
    			button.disabled = button_disabled_value = !/*labelText*/ ctx[4];
    			add_location(button, file$3, 426, 42, 10726);
    			attr_dev(div, "class", "edit-button svelte-gfr88e");
    			add_location(div, file$3, 425, 8, 10658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*labelText*/ ctx[4]);
    			append_dev(div, button);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[13]),
    					listen_dev(button, "click", /*updateSelectedLayerLabel*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*labelText*/ 16 && input.value !== /*labelText*/ ctx[4]) {
    				set_input_value(input, /*labelText*/ ctx[4]);
    			}

    			if (dirty[0] & /*labelText*/ 16 && button_disabled_value !== (button_disabled_value = !/*labelText*/ ctx[4])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(425:6) {#if editMode}",
    		ctx
    	});

    	return block;
    }

    // (411:4) <Tooltip       left={tooltip.left}       top={tooltip.top}       on:close={handleTooltipClose}     >
    function create_default_slot_1(ctx) {
    	let t0;
    	let t1;
    	let p;
    	let t2_value = (/*tooltip*/ ctx[1].text || '') + "";
    	let t2;
    	let if_block0 = !/*editMode*/ ctx[3] && create_if_block_3$1(ctx);
    	let if_block1 = /*editMode*/ ctx[3] && create_if_block_2$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			p = element("p");
    			t2 = text$1(t2_value);
    			add_location(p, file$3, 433, 6, 10910);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*editMode*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*editMode*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$2(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*tooltip*/ 2 && t2_value !== (t2_value = (/*tooltip*/ ctx[1].text || '') + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(411:4) <Tooltip       left={tooltip.left}       top={tooltip.top}       on:close={handleTooltipClose}     >",
    		ctx
    	});

    	return block;
    }

    // (437:2) {#if Object.keys(hoverTooltip).length > 0}
    function create_if_block$2(ctx) {
    	let tooltip_1;
    	let current;

    	tooltip_1 = new Tooltip({
    			props: {
    				left: /*hoverTooltip*/ ctx[2].left,
    				top: /*hoverTooltip*/ ctx[2].top,
    				showCloseButton: false,
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tooltip_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tooltip_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tooltip_1_changes = {};
    			if (dirty[0] & /*hoverTooltip*/ 4) tooltip_1_changes.left = /*hoverTooltip*/ ctx[2].left;
    			if (dirty[0] & /*hoverTooltip*/ 4) tooltip_1_changes.top = /*hoverTooltip*/ ctx[2].top;

    			if (dirty[0] & /*hoverTooltip*/ 4 | dirty[1] & /*$$scope*/ 2) {
    				tooltip_1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip_1.$set(tooltip_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tooltip_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(437:2) {#if Object.keys(hoverTooltip).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (438:4) <Tooltip       left={hoverTooltip.left}       top={hoverTooltip.top}       showCloseButton={false}     >
    function create_default_slot(ctx) {
    	let t_value = (/*hoverTooltip*/ ctx[2].text || '') + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*hoverTooltip*/ 4 && t_value !== (t_value = (/*hoverTooltip*/ ctx[2].text || '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(438:4) <Tooltip       left={hoverTooltip.left}       top={hoverTooltip.top}       showCloseButton={false}     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let show_if_1 = Object.keys(/*tooltip*/ ctx[1]).length > 0;
    	let t1;
    	let show_if = Object.keys(/*hoverTooltip*/ ctx[2]).length > 0;
    	let current;
    	let if_block0 = show_if_1 && create_if_block_1$2(ctx);
    	let if_block1 = show_if && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			set_style(div0, "width", width + "px");
    			set_style(div0, "height", /*height*/ ctx[0] + "px");
    			attr_dev(div0, "id", "map");
    			add_location(div0, file$3, 407, 2, 10212);
    			attr_dev(div1, "class", "typography-chart");
    			add_location(div1, file$3, 406, 0, 10179);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(div0, "height", /*height*/ ctx[0] + "px");
    			}

    			if (dirty[0] & /*tooltip*/ 2) show_if_1 = Object.keys(/*tooltip*/ ctx[1]).length > 0;

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*tooltip*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*hoverTooltip*/ 4) show_if = Object.keys(/*hoverTooltip*/ ctx[2]).length > 0;

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*hoverTooltip*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const width = 2500;

    function isValidZoom(layer, zoom) {
    	if (layer.minzoom && zoom < layer.minzoom) return false;
    	if (layer.maxzoom && zoom > layer.maxzoom) return false;
    	return true;
    }

    function getGetExpressionsInner(expression) {
    	if (!Array.isArray(expression)) return null;
    	if (expression[0] === 'get') return expression;
    	return expression.map(getGetExpressionsInner).filter(v => !!v);
    }

    function getGetExpressions(expression) {
    	return getGetExpressionsInner(expression).flat(Infinity).filter(v => v !== 'get');
    }

    function getLabel(layer) {
    	if (layer.id.indexOf('shield') >= 0) {
    		return 80;
    	}

    	const textField = layer.layout['text-field'];
    	if (!textField) return layer.id;

    	if (Array.isArray(textField)) {
    		return getGetExpressions(textField)?.[0] ?? textField;
    	}

    	return textField;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $displayLayersStore;
    	validate_store(displayLayersStore, 'displayLayersStore');
    	component_subscribe($$self, displayLayersStore, $$value => $$invalidate(18, $displayLayersStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TypographyChart', slots, []);
    	let { style } = $$props;
    	let { minZoom = 0 } = $$props;
    	let { maxZoom = 24 } = $$props;
    	let map;
    	let height;
    	let xScale;
    	let yScale;
    	let tooltip = {};
    	let hoverTooltip = {};
    	let selectedLayerId = null;
    	let editMode = false;
    	let labelText = '';
    	let layers;
    	let xAxisFont;
    	let zooms = range$2(minZoom, maxZoom + 1, 2);

    	const handleTooltipClose = () => {
    		selectedLayerId = null;
    		$$invalidate(3, editMode = false);
    		$$invalidate(4, labelText = '');
    		$$invalidate(1, tooltip = {});
    	};

    	const handleHoverTooltipClose = () => $$invalidate(2, hoverTooltip = {});

    	// XXX These properties aren't currently supported in this chart, this is
    	// likely okay for most uses
    	const dataExpressionsDisallowed = ['icon-text-fit-padding', 'symbol-spacing', 'text-fit-padding', 'text-padding'];

    	function getNumericProperty(layer, zoom, propertyType, property) {
    		if (!layer[propertyType]) return null;
    		let value = layer[propertyType][property];
    		return getValue(value, zoom, null);
    	}

    	function getColorProperty(layer, zoom, propertyType, property) {
    		if (!layer[propertyType]) return null;
    		let value = layer[propertyType][property];
    		return getValue(value, zoom, null);
    	}

    	function handleClick(e) {
    		const feature = map.queryRenderedFeatures(e.point)[0];

    		if (!feature) {
    			handleTooltipClose();
    			return;
    		}

    		const layerId = feature.layer.id;
    		const layer = layers.filter(l => l.id === layerId)[0];
    		const displayLayer = map.getStyle().layers.find(l => l.id === layerId);
    		handleHoverTooltipClose();
    		handleTooltipClose();
    		if (!layer) return;

    		if (displayLayer) {
    			const textField = displayLayer?.layout?.['text-field'];

    			$$invalidate(4, labelText = Array.isArray(textField) && textField[0] === 'get' && textField[1] === 'label'
    			? feature?.properties?.label
    			: textField);
    		}

    		$$invalidate(1, tooltip = {
    			text: JSON.stringify({ layout: layer.layout, paint: layer.paint }, null, 2),
    			left: e.point.x,
    			top: e.point.y
    		});

    		selectedLayerId = layer.id;
    	}

    	function handleHover(e) {
    		const feature = map.queryRenderedFeatures(e.point)[0];

    		if (!feature) {
    			handleHoverTooltipClose();
    			return;
    		}

    		const layerId = feature.layer.id;
    		const layer = layers.filter(l => l.id === layerId)[0];

    		if (!layer) {
    			handleHoverTooltipClose();
    			return;
    		}

    		let details = feature.layer.metadata.parentId
    		? feature.layer.metadata.parentId
    		: feature.layer.id;

    		const { conditions } = feature.layer.metadata;

    		if (conditions) {
    			conditions.forEach(({ conditionType, type, key, value, input }) => {
    				details += `\n${type}.${key}: `;

    				if (conditionType === 'case') {
    					details += `${value}`;
    				}

    				if (conditionType === 'match') {
    					details += `${JSON.stringify(input)} == ${JSON.stringify(value)}`;
    				}
    			});
    		} else if (feature.layer.metadata.descriptor) {
    			details += `\n\n${feature.layer.metadata.descriptor}`;
    		}

    		$$invalidate(2, hoverTooltip = {
    			text: details,
    			left: e.point.x + 25,
    			top: e.point.y
    		});
    	}

    	function drawAxis() {
    		const features = zooms.map(zoom => ({
    			type: 'Feature',
    			properties: { label: `${zoom}` },
    			geometry: {
    				type: 'Point',
    				coordinates: [xScale(zoom), yScale('x-axis')]
    			}
    		}));

    		map.addSource('x-axis', {
    			type: 'geojson',
    			data: { type: 'FeatureCollection', features }
    		});

    		map.addLayer({
    			id: 'x-axis',
    			source: 'x-axis',
    			layout: {
    				'text-font': xAxisFont,
    				'icon-allow-overlap': true,
    				'symbol-placement': 'point',
    				'text-allow-overlap': true,
    				'text-field': '{label}',
    				'text-size': 10
    			},
    			paint: { 'text-color': 'black' },
    			type: 'symbol'
    		});
    	}

    	function drawLines() {
    		let features = layers.map(layer => {
    			let color = layer?.paint?.['icon-color'];

    			if (!color) {
    				color = layer?.paint?.['text-color'];
    			}

    			if (!color) color = 'black';

    			return {
    				type: 'Feature',
    				properties: { color },
    				geometry: {
    					type: 'LineString',
    					coordinates: [
    						[xScale(layer.minzoom || minZoom), yScale(layer.id)],
    						[xScale(layer.maxzoom || maxZoom), yScale(layer.id)]
    					]
    				}
    			};
    		});

    		map.addSource('lines', {
    			type: 'geojson',
    			data: { type: 'FeatureCollection', features }
    		});

    		map.addLayer({
    			id: 'lines',
    			source: 'lines',
    			paint: {
    				'line-width': 15,
    				'line-color': ['get', 'color'],
    				'line-opacity': 0.1
    			},
    			layout: {},
    			type: 'line'
    		});
    	}

    	function drawLabels() {
    		layers.forEach(layer => {
    			// Create one source per layer, spacing features out along valid zooms for
    			// the layer
    			let features = [];

    			zooms.forEach(zoom => {
    				if (!isValidZoom(layer, zoom)) return;

    				// NB: we are setting the zoom here as a property, all rendering happens
    				// at the same zoom level in this visualization
    				features.push({
    					type: 'Feature',
    					properties: { label: getLabel(layer), zoom },
    					geometry: {
    						type: 'Point',
    						coordinates: [xScale(zoom), yScale(layer.id)]
    					}
    				});
    			});

    			map.addSource(layer.id, {
    				type: 'geojson',
    				data: { type: 'FeatureCollection', features }
    			});

    			// Replace zoom-dependent style expressions with expressions that use the
    			// zoom property set above at the feature level
    			let paint = {};

    			if (layer.paint) {
    				paint = JSON.parse(JSON.stringify(layer.paint).replaceAll('["zoom"]', '["get", "zoom"]'));
    			}

    			let layout = {};

    			if (layer.layout) {
    				layout = Object.fromEntries(Object.entries(layer.layout).map(([k, v]) => {
    					if (dataExpressionsDisallowed.indexOf(k) >= 0) {
    						return [k, v];
    					} else {
    						return [
    							k,
    							JSON.parse(JSON.stringify(v).replaceAll('["zoom"]', '["get", "zoom"]'))
    						];
    					}
    				}));

    				layout = {
    					...layout,
    					'icon-allow-overlap': true, // Add overrides to force visibility
    					'symbol-placement': 'point',
    					'text-allow-overlap': true
    				};

    				if (layer.layout['text-field'] && layer.layout['text-field'][0] !== 'format') {
    					layout['text-field'] = ['get', 'label'];
    				}
    			}

    			map.addLayer({
    				id: layer.id,
    				source: layer.id,
    				paint,
    				layout,
    				type: layer.type,
    				metadata: {
    					...layer.metadata,
    					parentId: layer.metadata && layer.metadata.parentId
    					? layer.metadata.parentId
    					: layer.id
    				}
    			});
    		});
    	}

    	function draw() {
    		const bounds = map.getBounds();
    		const boundsWidth = Math.abs(bounds.getEast() - bounds.getWest());
    		const boundsHeight = Math.abs(bounds.getNorth() - bounds.getSouth());
    		const xPadding = boundsWidth * 0.08;
    		const yPadding = boundsHeight * 0.01;
    		xScale = linear([minZoom, maxZoom], [bounds.getWest() + xPadding, bounds.getEast() - xPadding]);
    		yScale = band(['x-axis', ...layers.map(({ id }) => id)], [bounds.getNorth(), bounds.getSouth() + yPadding]);
    		drawAxis();
    		drawLines();
    		drawLabels();
    	}

    	function createMap(style) {
    		$$invalidate(10, map = new mapboxGl.Map({
    				container: 'map',
    				style: {
    					version: 8,
    					glyphs: style.glyphs,
    					sprite: style.sprite,
    					sources: {},
    					layers: style.layers.filter(l => l.type === 'background')
    				},
    				boxZoom: false,
    				doubleClickZoom: false,
    				dragPan: false,
    				scrollZoom: false,
    				center: [0, 10],
    				zoom: 14
    			}));

    		map.on('load', draw);
    		map.on('click', handleClick);
    		map.on('mousemove', handleHover);
    	}

    	function getLayers(style) {
    		const layers = $displayLayersStore.layers.filter(layer => layer.type === 'symbol');
    		return layers;
    	}

    	const updateSelectedLayerLabel = () => {
    		if (selectedLayerId) {
    			let value = labelText;
    			map.setLayoutProperty(selectedLayerId, 'text-field', value);
    		}

    		handleTooltipClose();
    	};

    	onMount(() => {
    		createMap(style);
    	});

    	const writable_props = ['style', 'minZoom', 'maxZoom'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TypographyChart> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(3, editMode = true);
    	};

    	function input_input_handler() {
    		labelText = this.value;
    		$$invalidate(4, labelText);
    	}

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(7, style = $$props.style);
    		if ('minZoom' in $$props) $$invalidate(8, minZoom = $$props.minZoom);
    		if ('maxZoom' in $$props) $$invalidate(9, maxZoom = $$props.maxZoom);
    	};

    	$$self.$capture_state = () => ({
    		d3,
    		onMount,
    		mapboxGl,
    		getInterpolatedValue: getValue,
    		Tooltip,
    		displayLayersStore,
    		style,
    		minZoom,
    		maxZoom,
    		map,
    		width,
    		height,
    		xScale,
    		yScale,
    		tooltip,
    		hoverTooltip,
    		selectedLayerId,
    		editMode,
    		labelText,
    		layers,
    		xAxisFont,
    		zooms,
    		handleTooltipClose,
    		handleHoverTooltipClose,
    		dataExpressionsDisallowed,
    		getNumericProperty,
    		getColorProperty,
    		isValidZoom,
    		handleClick,
    		handleHover,
    		drawAxis,
    		getGetExpressionsInner,
    		getGetExpressions,
    		getLabel,
    		drawLines,
    		drawLabels,
    		draw,
    		createMap,
    		getLayers,
    		updateSelectedLayerLabel,
    		$displayLayersStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(7, style = $$props.style);
    		if ('minZoom' in $$props) $$invalidate(8, minZoom = $$props.minZoom);
    		if ('maxZoom' in $$props) $$invalidate(9, maxZoom = $$props.maxZoom);
    		if ('map' in $$props) $$invalidate(10, map = $$props.map);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('xScale' in $$props) xScale = $$props.xScale;
    		if ('yScale' in $$props) yScale = $$props.yScale;
    		if ('tooltip' in $$props) $$invalidate(1, tooltip = $$props.tooltip);
    		if ('hoverTooltip' in $$props) $$invalidate(2, hoverTooltip = $$props.hoverTooltip);
    		if ('selectedLayerId' in $$props) selectedLayerId = $$props.selectedLayerId;
    		if ('editMode' in $$props) $$invalidate(3, editMode = $$props.editMode);
    		if ('labelText' in $$props) $$invalidate(4, labelText = $$props.labelText);
    		if ('layers' in $$props) $$invalidate(11, layers = $$props.layers);
    		if ('xAxisFont' in $$props) xAxisFont = $$props.xAxisFont;
    		if ('zooms' in $$props) zooms = $$props.zooms;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*style, layers, map*/ 3200) {
    			{
    				$$invalidate(11, layers = getLayers());
    				$$invalidate(0, height = layers.length * 45);
    				if (map && map.isStyleLoaded()) draw();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*layers*/ 2048) {
    			{
    				xAxisFont = layers.filter(l => {
    					return l.layout && l.layout['text-font'];
    				})[0].layout['text-font'];
    			}
    		}
    	};

    	return [
    		height,
    		tooltip,
    		hoverTooltip,
    		editMode,
    		labelText,
    		handleTooltipClose,
    		updateSelectedLayerLabel,
    		style,
    		minZoom,
    		maxZoom,
    		map,
    		layers,
    		click_handler,
    		input_input_handler
    	];
    }

    class TypographyChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, { style: 7, minZoom: 8, maxZoom: 9 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TypographyChart",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*style*/ ctx[7] === undefined && !('style' in props)) {
    			console.warn("<TypographyChart> was created without expected prop 'style'");
    		}
    	}

    	get style() {
    		throw new Error("<TypographyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<TypographyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minZoom() {
    		throw new Error("<TypographyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minZoom(value) {
    		throw new Error("<TypographyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxZoom() {
    		throw new Error("<TypographyChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxZoom(value) {
    		throw new Error("<TypographyChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$2 = ".tabs-content.svelte-1hc7bk{display:flex;margin-top:2.5em;padding:var(--app-padding)}";
    n(css$2,{});

    /* src/TabsContent.svelte generated by Svelte v3.48.0 */
    const file$2 = "src/TabsContent.svelte";

    // (17:41) 
    function create_if_block_2$1(ctx) {
    	let typographychart;
    	let current;

    	typographychart = new TypographyChart({
    			props: { style: /*style*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(typographychart.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(typographychart, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const typographychart_changes = {};
    			if (dirty & /*style*/ 2) typographychart_changes.style = /*style*/ ctx[1];
    			typographychart.$set(typographychart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(typographychart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(typographychart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(typographychart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(17:41) ",
    		ctx
    	});

    	return block;
    }

    // (15:36) 
    function create_if_block_1$1(ctx) {
    	let lineschart;
    	let current;

    	lineschart = new LinesChart({
    			props: {
    				style: /*style*/ ctx[1],
    				backgroundSvgData: /*backgroundSvgData*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lineschart.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lineschart, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lineschart_changes = {};
    			if (dirty & /*style*/ 2) lineschart_changes.style = /*style*/ ctx[1];
    			if (dirty & /*backgroundSvgData*/ 8) lineschart_changes.backgroundSvgData = /*backgroundSvgData*/ ctx[3];
    			lineschart.$set(lineschart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lineschart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lineschart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lineschart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(15:36) ",
    		ctx
    	});

    	return block;
    }

    // (13:2) {#if selectedTab === 'fill'}
    function create_if_block$1(ctx) {
    	let fillschart;
    	let current;

    	fillschart = new FillsChart({
    			props: {
    				style: /*style*/ ctx[1],
    				updateBackgroundRect: /*updateBackgroundRect*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fillschart.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fillschart, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fillschart_changes = {};
    			if (dirty & /*style*/ 2) fillschart_changes.style = /*style*/ ctx[1];
    			if (dirty & /*updateBackgroundRect*/ 4) fillschart_changes.updateBackgroundRect = /*updateBackgroundRect*/ ctx[2];
    			fillschart.$set(fillschart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fillschart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fillschart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fillschart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(13:2) {#if selectedTab === 'fill'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$1, create_if_block_1$1, create_if_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*selectedTab*/ ctx[0] === 'fill') return 0;
    		if (/*selectedTab*/ ctx[0] === 'lines') return 1;
    		if (/*selectedTab*/ ctx[0] === 'typography') return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "tabs-content svelte-1hc7bk");
    			add_location(div, file$2, 11, 0, 288);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabsContent', slots, []);
    	let { selectedTab } = $$props;
    	let { style } = $$props;
    	let { updateBackgroundRect } = $$props;
    	let { backgroundSvgData } = $$props;
    	const writable_props = ['selectedTab', 'style', 'updateBackgroundRect', 'backgroundSvgData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabsContent> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('selectedTab' in $$props) $$invalidate(0, selectedTab = $$props.selectedTab);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('updateBackgroundRect' in $$props) $$invalidate(2, updateBackgroundRect = $$props.updateBackgroundRect);
    		if ('backgroundSvgData' in $$props) $$invalidate(3, backgroundSvgData = $$props.backgroundSvgData);
    	};

    	$$self.$capture_state = () => ({
    		FillsChart,
    		LinesChart,
    		TypographyChart,
    		selectedTab,
    		style,
    		updateBackgroundRect,
    		backgroundSvgData
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedTab' in $$props) $$invalidate(0, selectedTab = $$props.selectedTab);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('updateBackgroundRect' in $$props) $$invalidate(2, updateBackgroundRect = $$props.updateBackgroundRect);
    		if ('backgroundSvgData' in $$props) $$invalidate(3, backgroundSvgData = $$props.backgroundSvgData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selectedTab, style, updateBackgroundRect, backgroundSvgData];
    }

    class TabsContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {
    			selectedTab: 0,
    			style: 1,
    			updateBackgroundRect: 2,
    			backgroundSvgData: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabsContent",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*selectedTab*/ ctx[0] === undefined && !('selectedTab' in props)) {
    			console.warn("<TabsContent> was created without expected prop 'selectedTab'");
    		}

    		if (/*style*/ ctx[1] === undefined && !('style' in props)) {
    			console.warn("<TabsContent> was created without expected prop 'style'");
    		}

    		if (/*updateBackgroundRect*/ ctx[2] === undefined && !('updateBackgroundRect' in props)) {
    			console.warn("<TabsContent> was created without expected prop 'updateBackgroundRect'");
    		}

    		if (/*backgroundSvgData*/ ctx[3] === undefined && !('backgroundSvgData' in props)) {
    			console.warn("<TabsContent> was created without expected prop 'backgroundSvgData'");
    		}
    	}

    	get selectedTab() {
    		throw new Error("<TabsContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedTab(value) {
    		throw new Error("<TabsContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<TabsContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<TabsContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateBackgroundRect() {
    		throw new Error("<TabsContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateBackgroundRect(value) {
    		throw new Error("<TabsContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundSvgData() {
    		throw new Error("<TabsContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundSvgData(value) {
    		throw new Error("<TabsContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$1 = ".container.svelte-1h09j0i{width:100%;height:100%;display:flex;justify-content:center;align-items:center;flex-direction:column}.grayed-out.svelte-1h09j0i{background-color:gray;opacity:60%;width:100%;height:100%;position:absolute;z-index:0}.loading-text.svelte-1h09j0i{margin-bottom:12px;font-size:24px;color:white;z-index:1}.progress-bar.svelte-1h09j0i{width:360px;height:24px;border-radius:24px;border:2px solid white;z-index:1;padding:3px}.progress.svelte-1h09j0i{height:100%;background-color:white;transition:all ease 0.1s;border-radius:18px}";
    n(css$1,{});

    /* src/ProgressBar.svelte generated by Svelte v3.48.0 */

    const file$1 = "src/ProgressBar.svelte";

    function create_fragment$1(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let t2;
    	let div3;
    	let div2;
    	let div2_style_value;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			div1.textContent = "Loading ...";
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			attr_dev(div0, "class", "grayed-out svelte-1h09j0i");
    			add_location(div0, file$1, 8, 2, 154);
    			attr_dev(div1, "class", "loading-text svelte-1h09j0i");
    			add_location(div1, file$1, 9, 2, 183);
    			attr_dev(div2, "class", "progress svelte-1h09j0i");
    			attr_dev(div2, "style", div2_style_value = `width: ${/*loadedWidth*/ ctx[0]}px`);
    			add_location(div2, file$1, 11, 4, 260);
    			attr_dev(div3, "class", "progress-bar svelte-1h09j0i");
    			add_location(div3, file$1, 10, 2, 229);
    			attr_dev(div4, "class", "container svelte-1h09j0i");
    			add_location(div4, file$1, 7, 0, 128);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*loadedWidth*/ 1 && div2_style_value !== (div2_style_value = `width: ${/*loadedWidth*/ ctx[0]}px`)) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let fullWidth;
    	let loadedWidth;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ProgressBar', slots, []);
    	let { progress } = $$props;
    	const writable_props = ['progress'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ProgressBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('progress' in $$props) $$invalidate(1, progress = $$props.progress);
    	};

    	$$self.$capture_state = () => ({ progress, fullWidth, loadedWidth });

    	$$self.$inject_state = $$props => {
    		if ('progress' in $$props) $$invalidate(1, progress = $$props.progress);
    		if ('fullWidth' in $$props) $$invalidate(2, fullWidth = $$props.fullWidth);
    		if ('loadedWidth' in $$props) $$invalidate(0, loadedWidth = $$props.loadedWidth);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*progress, fullWidth*/ 6) {
    			$$invalidate(0, loadedWidth = progress !== null && fullWidth * progress);
    		}
    	};

    	$$invalidate(2, fullWidth = 360);
    	return [loadedWidth, progress, fullWidth];
    }

    class ProgressBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { progress: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProgressBar",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*progress*/ ctx[1] === undefined && !('progress' in props)) {
    			console.warn("<ProgressBar> was created without expected prop 'progress'");
    		}
    	}

    	get progress() {
    		throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set progress(value) {
    		throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var dist = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      {
        factory(module);
      }
    })(commonjsGlobal, function (module) {

      var each = Array.prototype.forEach;


      function computedStyleToInlineStyle(element) {
        var _context2;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (!element) {
          throw new Error("No element specified.");
        }

        if (options.recursive) {
          var _context;

          (_context = element.children, each).call(_context, function (child) {
            computedStyleToInlineStyle(child, options);
          });
        }

        var computedStyle = getComputedStyle(element);
        (_context2 = options.properties || computedStyle, each).call(_context2, function (property) {
          element.style[property] = computedStyle.getPropertyValue(property);
        });
      }

      module.exports = computedStyleToInlineStyle;
    });
    });

    var colorName = {
    	"aliceblue": [240, 248, 255],
    	"antiquewhite": [250, 235, 215],
    	"aqua": [0, 255, 255],
    	"aquamarine": [127, 255, 212],
    	"azure": [240, 255, 255],
    	"beige": [245, 245, 220],
    	"bisque": [255, 228, 196],
    	"black": [0, 0, 0],
    	"blanchedalmond": [255, 235, 205],
    	"blue": [0, 0, 255],
    	"blueviolet": [138, 43, 226],
    	"brown": [165, 42, 42],
    	"burlywood": [222, 184, 135],
    	"cadetblue": [95, 158, 160],
    	"chartreuse": [127, 255, 0],
    	"chocolate": [210, 105, 30],
    	"coral": [255, 127, 80],
    	"cornflowerblue": [100, 149, 237],
    	"cornsilk": [255, 248, 220],
    	"crimson": [220, 20, 60],
    	"cyan": [0, 255, 255],
    	"darkblue": [0, 0, 139],
    	"darkcyan": [0, 139, 139],
    	"darkgoldenrod": [184, 134, 11],
    	"darkgray": [169, 169, 169],
    	"darkgreen": [0, 100, 0],
    	"darkgrey": [169, 169, 169],
    	"darkkhaki": [189, 183, 107],
    	"darkmagenta": [139, 0, 139],
    	"darkolivegreen": [85, 107, 47],
    	"darkorange": [255, 140, 0],
    	"darkorchid": [153, 50, 204],
    	"darkred": [139, 0, 0],
    	"darksalmon": [233, 150, 122],
    	"darkseagreen": [143, 188, 143],
    	"darkslateblue": [72, 61, 139],
    	"darkslategray": [47, 79, 79],
    	"darkslategrey": [47, 79, 79],
    	"darkturquoise": [0, 206, 209],
    	"darkviolet": [148, 0, 211],
    	"deeppink": [255, 20, 147],
    	"deepskyblue": [0, 191, 255],
    	"dimgray": [105, 105, 105],
    	"dimgrey": [105, 105, 105],
    	"dodgerblue": [30, 144, 255],
    	"firebrick": [178, 34, 34],
    	"floralwhite": [255, 250, 240],
    	"forestgreen": [34, 139, 34],
    	"fuchsia": [255, 0, 255],
    	"gainsboro": [220, 220, 220],
    	"ghostwhite": [248, 248, 255],
    	"gold": [255, 215, 0],
    	"goldenrod": [218, 165, 32],
    	"gray": [128, 128, 128],
    	"green": [0, 128, 0],
    	"greenyellow": [173, 255, 47],
    	"grey": [128, 128, 128],
    	"honeydew": [240, 255, 240],
    	"hotpink": [255, 105, 180],
    	"indianred": [205, 92, 92],
    	"indigo": [75, 0, 130],
    	"ivory": [255, 255, 240],
    	"khaki": [240, 230, 140],
    	"lavender": [230, 230, 250],
    	"lavenderblush": [255, 240, 245],
    	"lawngreen": [124, 252, 0],
    	"lemonchiffon": [255, 250, 205],
    	"lightblue": [173, 216, 230],
    	"lightcoral": [240, 128, 128],
    	"lightcyan": [224, 255, 255],
    	"lightgoldenrodyellow": [250, 250, 210],
    	"lightgray": [211, 211, 211],
    	"lightgreen": [144, 238, 144],
    	"lightgrey": [211, 211, 211],
    	"lightpink": [255, 182, 193],
    	"lightsalmon": [255, 160, 122],
    	"lightseagreen": [32, 178, 170],
    	"lightskyblue": [135, 206, 250],
    	"lightslategray": [119, 136, 153],
    	"lightslategrey": [119, 136, 153],
    	"lightsteelblue": [176, 196, 222],
    	"lightyellow": [255, 255, 224],
    	"lime": [0, 255, 0],
    	"limegreen": [50, 205, 50],
    	"linen": [250, 240, 230],
    	"magenta": [255, 0, 255],
    	"maroon": [128, 0, 0],
    	"mediumaquamarine": [102, 205, 170],
    	"mediumblue": [0, 0, 205],
    	"mediumorchid": [186, 85, 211],
    	"mediumpurple": [147, 112, 219],
    	"mediumseagreen": [60, 179, 113],
    	"mediumslateblue": [123, 104, 238],
    	"mediumspringgreen": [0, 250, 154],
    	"mediumturquoise": [72, 209, 204],
    	"mediumvioletred": [199, 21, 133],
    	"midnightblue": [25, 25, 112],
    	"mintcream": [245, 255, 250],
    	"mistyrose": [255, 228, 225],
    	"moccasin": [255, 228, 181],
    	"navajowhite": [255, 222, 173],
    	"navy": [0, 0, 128],
    	"oldlace": [253, 245, 230],
    	"olive": [128, 128, 0],
    	"olivedrab": [107, 142, 35],
    	"orange": [255, 165, 0],
    	"orangered": [255, 69, 0],
    	"orchid": [218, 112, 214],
    	"palegoldenrod": [238, 232, 170],
    	"palegreen": [152, 251, 152],
    	"paleturquoise": [175, 238, 238],
    	"palevioletred": [219, 112, 147],
    	"papayawhip": [255, 239, 213],
    	"peachpuff": [255, 218, 185],
    	"peru": [205, 133, 63],
    	"pink": [255, 192, 203],
    	"plum": [221, 160, 221],
    	"powderblue": [176, 224, 230],
    	"purple": [128, 0, 128],
    	"rebeccapurple": [102, 51, 153],
    	"red": [255, 0, 0],
    	"rosybrown": [188, 143, 143],
    	"royalblue": [65, 105, 225],
    	"saddlebrown": [139, 69, 19],
    	"salmon": [250, 128, 114],
    	"sandybrown": [244, 164, 96],
    	"seagreen": [46, 139, 87],
    	"seashell": [255, 245, 238],
    	"sienna": [160, 82, 45],
    	"silver": [192, 192, 192],
    	"skyblue": [135, 206, 235],
    	"slateblue": [106, 90, 205],
    	"slategray": [112, 128, 144],
    	"slategrey": [112, 128, 144],
    	"snow": [255, 250, 250],
    	"springgreen": [0, 255, 127],
    	"steelblue": [70, 130, 180],
    	"tan": [210, 180, 140],
    	"teal": [0, 128, 128],
    	"thistle": [216, 191, 216],
    	"tomato": [255, 99, 71],
    	"turquoise": [64, 224, 208],
    	"violet": [238, 130, 238],
    	"wheat": [245, 222, 179],
    	"white": [255, 255, 255],
    	"whitesmoke": [245, 245, 245],
    	"yellow": [255, 255, 0],
    	"yellowgreen": [154, 205, 50]
    };

    var isArrayish = function isArrayish(obj) {
    	if (!obj || typeof obj === 'string') {
    		return false;
    	}

    	return obj instanceof Array || Array.isArray(obj) ||
    		(obj.length >= 0 && (obj.splice instanceof Function ||
    			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
    };

    var simpleSwizzle = createCommonjsModule(function (module) {



    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;

    var swizzle = module.exports = function swizzle(args) {
    	var results = [];

    	for (var i = 0, len = args.length; i < len; i++) {
    		var arg = args[i];

    		if (isArrayish(arg)) {
    			// http://jsperf.com/javascript-array-concat-vs-push/98
    			results = concat.call(results, slice.call(arg));
    		} else {
    			results.push(arg);
    		}
    	}

    	return results;
    };

    swizzle.wrap = function (fn) {
    	return function () {
    		return fn(swizzle(arguments));
    	};
    };
    });

    /* MIT license */

    var colorString = createCommonjsModule(function (module) {
    var hasOwnProperty = Object.hasOwnProperty;

    var reverseNames = Object.create(null);

    // create a list of reverse color names
    for (var name in colorName) {
    	if (hasOwnProperty.call(colorName, name)) {
    		reverseNames[colorName[name]] = name;
    	}
    }

    var cs = module.exports = {
    	to: {},
    	get: {}
    };

    cs.get = function (string) {
    	var prefix = string.substring(0, 3).toLowerCase();
    	var val;
    	var model;
    	switch (prefix) {
    		case 'hsl':
    			val = cs.get.hsl(string);
    			model = 'hsl';
    			break;
    		case 'hwb':
    			val = cs.get.hwb(string);
    			model = 'hwb';
    			break;
    		default:
    			val = cs.get.rgb(string);
    			model = 'rgb';
    			break;
    	}

    	if (!val) {
    		return null;
    	}

    	return {model: model, value: val};
    };

    cs.get.rgb = function (string) {
    	if (!string) {
    		return null;
    	}

    	var abbr = /^#([a-f0-9]{3,4})$/i;
    	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    	var keyword = /^(\w+)$/;

    	var rgb = [0, 0, 0, 1];
    	var match;
    	var i;
    	var hexAlpha;

    	if (match = string.match(hex)) {
    		hexAlpha = match[2];
    		match = match[1];

    		for (i = 0; i < 3; i++) {
    			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
    			var i2 = i * 2;
    			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
    		}

    		if (hexAlpha) {
    			rgb[3] = parseInt(hexAlpha, 16) / 255;
    		}
    	} else if (match = string.match(abbr)) {
    		match = match[1];
    		hexAlpha = match[3];

    		for (i = 0; i < 3; i++) {
    			rgb[i] = parseInt(match[i] + match[i], 16);
    		}

    		if (hexAlpha) {
    			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    		}
    	} else if (match = string.match(rgba)) {
    		for (i = 0; i < 3; i++) {
    			rgb[i] = parseInt(match[i + 1], 0);
    		}

    		if (match[4]) {
    			if (match[5]) {
    				rgb[3] = parseFloat(match[4]) * 0.01;
    			} else {
    				rgb[3] = parseFloat(match[4]);
    			}
    		}
    	} else if (match = string.match(per)) {
    		for (i = 0; i < 3; i++) {
    			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
    		}

    		if (match[4]) {
    			if (match[5]) {
    				rgb[3] = parseFloat(match[4]) * 0.01;
    			} else {
    				rgb[3] = parseFloat(match[4]);
    			}
    		}
    	} else if (match = string.match(keyword)) {
    		if (match[1] === 'transparent') {
    			return [0, 0, 0, 0];
    		}

    		if (!hasOwnProperty.call(colorName, match[1])) {
    			return null;
    		}

    		rgb = colorName[match[1]];
    		rgb[3] = 1;

    		return rgb;
    	} else {
    		return null;
    	}

    	for (i = 0; i < 3; i++) {
    		rgb[i] = clamp(rgb[i], 0, 255);
    	}
    	rgb[3] = clamp(rgb[3], 0, 1);

    	return rgb;
    };

    cs.get.hsl = function (string) {
    	if (!string) {
    		return null;
    	}

    	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    	var match = string.match(hsl);

    	if (match) {
    		var alpha = parseFloat(match[4]);
    		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
    		var s = clamp(parseFloat(match[2]), 0, 100);
    		var l = clamp(parseFloat(match[3]), 0, 100);
    		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

    		return [h, s, l, a];
    	}

    	return null;
    };

    cs.get.hwb = function (string) {
    	if (!string) {
    		return null;
    	}

    	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    	var match = string.match(hwb);

    	if (match) {
    		var alpha = parseFloat(match[4]);
    		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
    		var w = clamp(parseFloat(match[2]), 0, 100);
    		var b = clamp(parseFloat(match[3]), 0, 100);
    		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    		return [h, w, b, a];
    	}

    	return null;
    };

    cs.to.hex = function () {
    	var rgba = simpleSwizzle(arguments);

    	return (
    		'#' +
    		hexDouble(rgba[0]) +
    		hexDouble(rgba[1]) +
    		hexDouble(rgba[2]) +
    		(rgba[3] < 1
    			? (hexDouble(Math.round(rgba[3] * 255)))
    			: '')
    	);
    };

    cs.to.rgb = function () {
    	var rgba = simpleSwizzle(arguments);

    	return rgba.length < 4 || rgba[3] === 1
    		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
    		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
    };

    cs.to.rgb.percent = function () {
    	var rgba = simpleSwizzle(arguments);

    	var r = Math.round(rgba[0] / 255 * 100);
    	var g = Math.round(rgba[1] / 255 * 100);
    	var b = Math.round(rgba[2] / 255 * 100);

    	return rgba.length < 4 || rgba[3] === 1
    		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
    		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
    };

    cs.to.hsl = function () {
    	var hsla = simpleSwizzle(arguments);
    	return hsla.length < 4 || hsla[3] === 1
    		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
    		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
    };

    // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)
    cs.to.hwb = function () {
    	var hwba = simpleSwizzle(arguments);

    	var a = '';
    	if (hwba.length >= 4 && hwba[3] !== 1) {
    		a = ', ' + hwba[3];
    	}

    	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
    };

    cs.to.keyword = function (rgb) {
    	return reverseNames[rgb.slice(0, 3)];
    };

    // helpers
    function clamp(num, min, max) {
    	return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
    	var str = Math.round(num).toString(16).toUpperCase();
    	return (str.length < 2) ? '0' + str : str;
    }
    });

    /* MIT license */

    /* eslint-disable no-mixed-operators */


    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)

    const reverseKeywords = {};
    for (const key of Object.keys(colorName)) {
    	reverseKeywords[colorName[key]] = key;
    }

    const convert$1 = {
    	rgb: {channels: 3, labels: 'rgb'},
    	hsl: {channels: 3, labels: 'hsl'},
    	hsv: {channels: 3, labels: 'hsv'},
    	hwb: {channels: 3, labels: 'hwb'},
    	cmyk: {channels: 4, labels: 'cmyk'},
    	xyz: {channels: 3, labels: 'xyz'},
    	lab: {channels: 3, labels: 'lab'},
    	lch: {channels: 3, labels: 'lch'},
    	hex: {channels: 1, labels: ['hex']},
    	keyword: {channels: 1, labels: ['keyword']},
    	ansi16: {channels: 1, labels: ['ansi16']},
    	ansi256: {channels: 1, labels: ['ansi256']},
    	hcg: {channels: 3, labels: ['h', 'c', 'g']},
    	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
    	gray: {channels: 1, labels: ['gray']}
    };

    var conversions = convert$1;

    // Hide .channels and .labels properties
    for (const model of Object.keys(convert$1)) {
    	if (!('channels' in convert$1[model])) {
    		throw new Error('missing channels property: ' + model);
    	}

    	if (!('labels' in convert$1[model])) {
    		throw new Error('missing channel labels property: ' + model);
    	}

    	if (convert$1[model].labels.length !== convert$1[model].channels) {
    		throw new Error('channel and label counts mismatch: ' + model);
    	}

    	const {channels, labels} = convert$1[model];
    	delete convert$1[model].channels;
    	delete convert$1[model].labels;
    	Object.defineProperty(convert$1[model], 'channels', {value: channels});
    	Object.defineProperty(convert$1[model], 'labels', {value: labels});
    }

    convert$1.rgb.hsl = function (rgb) {
    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;
    	const min = Math.min(r, g, b);
    	const max = Math.max(r, g, b);
    	const delta = max - min;
    	let h;
    	let s;

    	if (max === min) {
    		h = 0;
    	} else if (r === max) {
    		h = (g - b) / delta;
    	} else if (g === max) {
    		h = 2 + (b - r) / delta;
    	} else if (b === max) {
    		h = 4 + (r - g) / delta;
    	}

    	h = Math.min(h * 60, 360);

    	if (h < 0) {
    		h += 360;
    	}

    	const l = (min + max) / 2;

    	if (max === min) {
    		s = 0;
    	} else if (l <= 0.5) {
    		s = delta / (max + min);
    	} else {
    		s = delta / (2 - max - min);
    	}

    	return [h, s * 100, l * 100];
    };

    convert$1.rgb.hsv = function (rgb) {
    	let rdif;
    	let gdif;
    	let bdif;
    	let h;
    	let s;

    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;
    	const v = Math.max(r, g, b);
    	const diff = v - Math.min(r, g, b);
    	const diffc = function (c) {
    		return (v - c) / 6 / diff + 1 / 2;
    	};

    	if (diff === 0) {
    		h = 0;
    		s = 0;
    	} else {
    		s = diff / v;
    		rdif = diffc(r);
    		gdif = diffc(g);
    		bdif = diffc(b);

    		if (r === v) {
    			h = bdif - gdif;
    		} else if (g === v) {
    			h = (1 / 3) + rdif - bdif;
    		} else if (b === v) {
    			h = (2 / 3) + gdif - rdif;
    		}

    		if (h < 0) {
    			h += 1;
    		} else if (h > 1) {
    			h -= 1;
    		}
    	}

    	return [
    		h * 360,
    		s * 100,
    		v * 100
    	];
    };

    convert$1.rgb.hwb = function (rgb) {
    	const r = rgb[0];
    	const g = rgb[1];
    	let b = rgb[2];
    	const h = convert$1.rgb.hsl(rgb)[0];
    	const w = 1 / 255 * Math.min(r, Math.min(g, b));

    	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

    	return [h, w * 100, b * 100];
    };

    convert$1.rgb.cmyk = function (rgb) {
    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;

    	const k = Math.min(1 - r, 1 - g, 1 - b);
    	const c = (1 - r - k) / (1 - k) || 0;
    	const m = (1 - g - k) / (1 - k) || 0;
    	const y = (1 - b - k) / (1 - k) || 0;

    	return [c * 100, m * 100, y * 100, k * 100];
    };

    function comparativeDistance(x, y) {
    	/*
    		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
    	*/
    	return (
    		((x[0] - y[0]) ** 2) +
    		((x[1] - y[1]) ** 2) +
    		((x[2] - y[2]) ** 2)
    	);
    }

    convert$1.rgb.keyword = function (rgb) {
    	const reversed = reverseKeywords[rgb];
    	if (reversed) {
    		return reversed;
    	}

    	let currentClosestDistance = Infinity;
    	let currentClosestKeyword;

    	for (const keyword of Object.keys(colorName)) {
    		const value = colorName[keyword];

    		// Compute comparative distance
    		const distance = comparativeDistance(rgb, value);

    		// Check if its less, if so set as closest
    		if (distance < currentClosestDistance) {
    			currentClosestDistance = distance;
    			currentClosestKeyword = keyword;
    		}
    	}

    	return currentClosestKeyword;
    };

    convert$1.keyword.rgb = function (keyword) {
    	return colorName[keyword];
    };

    convert$1.rgb.xyz = function (rgb) {
    	let r = rgb[0] / 255;
    	let g = rgb[1] / 255;
    	let b = rgb[2] / 255;

    	// Assume sRGB
    	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
    	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
    	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

    	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
    	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
    	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

    	return [x * 100, y * 100, z * 100];
    };

    convert$1.rgb.lab = function (rgb) {
    	const xyz = convert$1.rgb.xyz(rgb);
    	let x = xyz[0];
    	let y = xyz[1];
    	let z = xyz[2];

    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;

    	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

    	const l = (116 * y) - 16;
    	const a = 500 * (x - y);
    	const b = 200 * (y - z);

    	return [l, a, b];
    };

    convert$1.hsl.rgb = function (hsl) {
    	const h = hsl[0] / 360;
    	const s = hsl[1] / 100;
    	const l = hsl[2] / 100;
    	let t2;
    	let t3;
    	let val;

    	if (s === 0) {
    		val = l * 255;
    		return [val, val, val];
    	}

    	if (l < 0.5) {
    		t2 = l * (1 + s);
    	} else {
    		t2 = l + s - l * s;
    	}

    	const t1 = 2 * l - t2;

    	const rgb = [0, 0, 0];
    	for (let i = 0; i < 3; i++) {
    		t3 = h + 1 / 3 * -(i - 1);
    		if (t3 < 0) {
    			t3++;
    		}

    		if (t3 > 1) {
    			t3--;
    		}

    		if (6 * t3 < 1) {
    			val = t1 + (t2 - t1) * 6 * t3;
    		} else if (2 * t3 < 1) {
    			val = t2;
    		} else if (3 * t3 < 2) {
    			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    		} else {
    			val = t1;
    		}

    		rgb[i] = val * 255;
    	}

    	return rgb;
    };

    convert$1.hsl.hsv = function (hsl) {
    	const h = hsl[0];
    	let s = hsl[1] / 100;
    	let l = hsl[2] / 100;
    	let smin = s;
    	const lmin = Math.max(l, 0.01);

    	l *= 2;
    	s *= (l <= 1) ? l : 2 - l;
    	smin *= lmin <= 1 ? lmin : 2 - lmin;
    	const v = (l + s) / 2;
    	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

    	return [h, sv * 100, v * 100];
    };

    convert$1.hsv.rgb = function (hsv) {
    	const h = hsv[0] / 60;
    	const s = hsv[1] / 100;
    	let v = hsv[2] / 100;
    	const hi = Math.floor(h) % 6;

    	const f = h - Math.floor(h);
    	const p = 255 * v * (1 - s);
    	const q = 255 * v * (1 - (s * f));
    	const t = 255 * v * (1 - (s * (1 - f)));
    	v *= 255;

    	switch (hi) {
    		case 0:
    			return [v, t, p];
    		case 1:
    			return [q, v, p];
    		case 2:
    			return [p, v, t];
    		case 3:
    			return [p, q, v];
    		case 4:
    			return [t, p, v];
    		case 5:
    			return [v, p, q];
    	}
    };

    convert$1.hsv.hsl = function (hsv) {
    	const h = hsv[0];
    	const s = hsv[1] / 100;
    	const v = hsv[2] / 100;
    	const vmin = Math.max(v, 0.01);
    	let sl;
    	let l;

    	l = (2 - s) * v;
    	const lmin = (2 - s) * vmin;
    	sl = s * vmin;
    	sl /= (lmin <= 1) ? lmin : 2 - lmin;
    	sl = sl || 0;
    	l /= 2;

    	return [h, sl * 100, l * 100];
    };

    // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
    convert$1.hwb.rgb = function (hwb) {
    	const h = hwb[0] / 360;
    	let wh = hwb[1] / 100;
    	let bl = hwb[2] / 100;
    	const ratio = wh + bl;
    	let f;

    	// Wh + bl cant be > 1
    	if (ratio > 1) {
    		wh /= ratio;
    		bl /= ratio;
    	}

    	const i = Math.floor(6 * h);
    	const v = 1 - bl;
    	f = 6 * h - i;

    	if ((i & 0x01) !== 0) {
    		f = 1 - f;
    	}

    	const n = wh + f * (v - wh); // Linear interpolation

    	let r;
    	let g;
    	let b;
    	/* eslint-disable max-statements-per-line,no-multi-spaces */
    	switch (i) {
    		default:
    		case 6:
    		case 0: r = v;  g = n;  b = wh; break;
    		case 1: r = n;  g = v;  b = wh; break;
    		case 2: r = wh; g = v;  b = n; break;
    		case 3: r = wh; g = n;  b = v; break;
    		case 4: r = n;  g = wh; b = v; break;
    		case 5: r = v;  g = wh; b = n; break;
    	}
    	/* eslint-enable max-statements-per-line,no-multi-spaces */

    	return [r * 255, g * 255, b * 255];
    };

    convert$1.cmyk.rgb = function (cmyk) {
    	const c = cmyk[0] / 100;
    	const m = cmyk[1] / 100;
    	const y = cmyk[2] / 100;
    	const k = cmyk[3] / 100;

    	const r = 1 - Math.min(1, c * (1 - k) + k);
    	const g = 1 - Math.min(1, m * (1 - k) + k);
    	const b = 1 - Math.min(1, y * (1 - k) + k);

    	return [r * 255, g * 255, b * 255];
    };

    convert$1.xyz.rgb = function (xyz) {
    	const x = xyz[0] / 100;
    	const y = xyz[1] / 100;
    	const z = xyz[2] / 100;
    	let r;
    	let g;
    	let b;

    	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
    	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
    	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

    	// Assume sRGB
    	r = r > 0.0031308
    		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
    		: r * 12.92;

    	g = g > 0.0031308
    		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
    		: g * 12.92;

    	b = b > 0.0031308
    		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
    		: b * 12.92;

    	r = Math.min(Math.max(0, r), 1);
    	g = Math.min(Math.max(0, g), 1);
    	b = Math.min(Math.max(0, b), 1);

    	return [r * 255, g * 255, b * 255];
    };

    convert$1.xyz.lab = function (xyz) {
    	let x = xyz[0];
    	let y = xyz[1];
    	let z = xyz[2];

    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;

    	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

    	const l = (116 * y) - 16;
    	const a = 500 * (x - y);
    	const b = 200 * (y - z);

    	return [l, a, b];
    };

    convert$1.lab.xyz = function (lab) {
    	const l = lab[0];
    	const a = lab[1];
    	const b = lab[2];
    	let x;
    	let y;
    	let z;

    	y = (l + 16) / 116;
    	x = a / 500 + y;
    	z = y - b / 200;

    	const y2 = y ** 3;
    	const x2 = x ** 3;
    	const z2 = z ** 3;
    	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

    	x *= 95.047;
    	y *= 100;
    	z *= 108.883;

    	return [x, y, z];
    };

    convert$1.lab.lch = function (lab) {
    	const l = lab[0];
    	const a = lab[1];
    	const b = lab[2];
    	let h;

    	const hr = Math.atan2(b, a);
    	h = hr * 360 / 2 / Math.PI;

    	if (h < 0) {
    		h += 360;
    	}

    	const c = Math.sqrt(a * a + b * b);

    	return [l, c, h];
    };

    convert$1.lch.lab = function (lch) {
    	const l = lch[0];
    	const c = lch[1];
    	const h = lch[2];

    	const hr = h / 360 * 2 * Math.PI;
    	const a = c * Math.cos(hr);
    	const b = c * Math.sin(hr);

    	return [l, a, b];
    };

    convert$1.rgb.ansi16 = function (args, saturation = null) {
    	const [r, g, b] = args;
    	let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

    	value = Math.round(value / 50);

    	if (value === 0) {
    		return 30;
    	}

    	let ansi = 30
    		+ ((Math.round(b / 255) << 2)
    		| (Math.round(g / 255) << 1)
    		| Math.round(r / 255));

    	if (value === 2) {
    		ansi += 60;
    	}

    	return ansi;
    };

    convert$1.hsv.ansi16 = function (args) {
    	// Optimization here; we already know the value and don't need to get
    	// it converted for us.
    	return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };

    convert$1.rgb.ansi256 = function (args) {
    	const r = args[0];
    	const g = args[1];
    	const b = args[2];

    	// We use the extended greyscale palette here, with the exception of
    	// black and white. normal palette only has 4 greyscale shades.
    	if (r === g && g === b) {
    		if (r < 8) {
    			return 16;
    		}

    		if (r > 248) {
    			return 231;
    		}

    		return Math.round(((r - 8) / 247) * 24) + 232;
    	}

    	const ansi = 16
    		+ (36 * Math.round(r / 255 * 5))
    		+ (6 * Math.round(g / 255 * 5))
    		+ Math.round(b / 255 * 5);

    	return ansi;
    };

    convert$1.ansi16.rgb = function (args) {
    	let color = args % 10;

    	// Handle greyscale
    	if (color === 0 || color === 7) {
    		if (args > 50) {
    			color += 3.5;
    		}

    		color = color / 10.5 * 255;

    		return [color, color, color];
    	}

    	const mult = (~~(args > 50) + 1) * 0.5;
    	const r = ((color & 1) * mult) * 255;
    	const g = (((color >> 1) & 1) * mult) * 255;
    	const b = (((color >> 2) & 1) * mult) * 255;

    	return [r, g, b];
    };

    convert$1.ansi256.rgb = function (args) {
    	// Handle greyscale
    	if (args >= 232) {
    		const c = (args - 232) * 10 + 8;
    		return [c, c, c];
    	}

    	args -= 16;

    	let rem;
    	const r = Math.floor(args / 36) / 5 * 255;
    	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    	const b = (rem % 6) / 5 * 255;

    	return [r, g, b];
    };

    convert$1.rgb.hex = function (args) {
    	const integer = ((Math.round(args[0]) & 0xFF) << 16)
    		+ ((Math.round(args[1]) & 0xFF) << 8)
    		+ (Math.round(args[2]) & 0xFF);

    	const string = integer.toString(16).toUpperCase();
    	return '000000'.substring(string.length) + string;
    };

    convert$1.hex.rgb = function (args) {
    	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    	if (!match) {
    		return [0, 0, 0];
    	}

    	let colorString = match[0];

    	if (match[0].length === 3) {
    		colorString = colorString.split('').map(char => {
    			return char + char;
    		}).join('');
    	}

    	const integer = parseInt(colorString, 16);
    	const r = (integer >> 16) & 0xFF;
    	const g = (integer >> 8) & 0xFF;
    	const b = integer & 0xFF;

    	return [r, g, b];
    };

    convert$1.rgb.hcg = function (rgb) {
    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;
    	const max = Math.max(Math.max(r, g), b);
    	const min = Math.min(Math.min(r, g), b);
    	const chroma = (max - min);
    	let grayscale;
    	let hue;

    	if (chroma < 1) {
    		grayscale = min / (1 - chroma);
    	} else {
    		grayscale = 0;
    	}

    	if (chroma <= 0) {
    		hue = 0;
    	} else
    	if (max === r) {
    		hue = ((g - b) / chroma) % 6;
    	} else
    	if (max === g) {
    		hue = 2 + (b - r) / chroma;
    	} else {
    		hue = 4 + (r - g) / chroma;
    	}

    	hue /= 6;
    	hue %= 1;

    	return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert$1.hsl.hcg = function (hsl) {
    	const s = hsl[1] / 100;
    	const l = hsl[2] / 100;

    	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

    	let f = 0;
    	if (c < 1.0) {
    		f = (l - 0.5 * c) / (1.0 - c);
    	}

    	return [hsl[0], c * 100, f * 100];
    };

    convert$1.hsv.hcg = function (hsv) {
    	const s = hsv[1] / 100;
    	const v = hsv[2] / 100;

    	const c = s * v;
    	let f = 0;

    	if (c < 1.0) {
    		f = (v - c) / (1 - c);
    	}

    	return [hsv[0], c * 100, f * 100];
    };

    convert$1.hcg.rgb = function (hcg) {
    	const h = hcg[0] / 360;
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;

    	if (c === 0.0) {
    		return [g * 255, g * 255, g * 255];
    	}

    	const pure = [0, 0, 0];
    	const hi = (h % 1) * 6;
    	const v = hi % 1;
    	const w = 1 - v;
    	let mg = 0;

    	/* eslint-disable max-statements-per-line */
    	switch (Math.floor(hi)) {
    		case 0:
    			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
    		case 1:
    			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
    		case 2:
    			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
    		case 3:
    			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
    		case 4:
    			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
    		default:
    			pure[0] = 1; pure[1] = 0; pure[2] = w;
    	}
    	/* eslint-enable max-statements-per-line */

    	mg = (1.0 - c) * g;

    	return [
    		(c * pure[0] + mg) * 255,
    		(c * pure[1] + mg) * 255,
    		(c * pure[2] + mg) * 255
    	];
    };

    convert$1.hcg.hsv = function (hcg) {
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;

    	const v = c + g * (1.0 - c);
    	let f = 0;

    	if (v > 0.0) {
    		f = c / v;
    	}

    	return [hcg[0], f * 100, v * 100];
    };

    convert$1.hcg.hsl = function (hcg) {
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;

    	const l = g * (1.0 - c) + 0.5 * c;
    	let s = 0;

    	if (l > 0.0 && l < 0.5) {
    		s = c / (2 * l);
    	} else
    	if (l >= 0.5 && l < 1.0) {
    		s = c / (2 * (1 - l));
    	}

    	return [hcg[0], s * 100, l * 100];
    };

    convert$1.hcg.hwb = function (hcg) {
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;
    	const v = c + g * (1.0 - c);
    	return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert$1.hwb.hcg = function (hwb) {
    	const w = hwb[1] / 100;
    	const b = hwb[2] / 100;
    	const v = 1 - b;
    	const c = v - w;
    	let g = 0;

    	if (c < 1) {
    		g = (v - c) / (1 - c);
    	}

    	return [hwb[0], c * 100, g * 100];
    };

    convert$1.apple.rgb = function (apple) {
    	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
    };

    convert$1.rgb.apple = function (rgb) {
    	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
    };

    convert$1.gray.rgb = function (args) {
    	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };

    convert$1.gray.hsl = function (args) {
    	return [0, 0, args[0]];
    };

    convert$1.gray.hsv = convert$1.gray.hsl;

    convert$1.gray.hwb = function (gray) {
    	return [0, 100, gray[0]];
    };

    convert$1.gray.cmyk = function (gray) {
    	return [0, 0, 0, gray[0]];
    };

    convert$1.gray.lab = function (gray) {
    	return [gray[0], 0, 0];
    };

    convert$1.gray.hex = function (gray) {
    	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    	const integer = (val << 16) + (val << 8) + val;

    	const string = integer.toString(16).toUpperCase();
    	return '000000'.substring(string.length) + string;
    };

    convert$1.rgb.gray = function (rgb) {
    	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    	return [val / 255 * 100];
    };

    /*
    	This function routes a model to all other models.

    	all functions that are routed have a property `.conversion` attached
    	to the returned synthetic function. This property is an array
    	of strings, each with the steps in between the 'from' and 'to'
    	color models (inclusive).

    	conversions that are not possible simply are not included.
    */

    function buildGraph() {
    	const graph = {};
    	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
    	const models = Object.keys(conversions);

    	for (let len = models.length, i = 0; i < len; i++) {
    		graph[models[i]] = {
    			// http://jsperf.com/1-vs-infinity
    			// micro-opt, but this is simple.
    			distance: -1,
    			parent: null
    		};
    	}

    	return graph;
    }

    // https://en.wikipedia.org/wiki/Breadth-first_search
    function deriveBFS(fromModel) {
    	const graph = buildGraph();
    	const queue = [fromModel]; // Unshift -> queue -> pop

    	graph[fromModel].distance = 0;

    	while (queue.length) {
    		const current = queue.pop();
    		const adjacents = Object.keys(conversions[current]);

    		for (let len = adjacents.length, i = 0; i < len; i++) {
    			const adjacent = adjacents[i];
    			const node = graph[adjacent];

    			if (node.distance === -1) {
    				node.distance = graph[current].distance + 1;
    				node.parent = current;
    				queue.unshift(adjacent);
    			}
    		}
    	}

    	return graph;
    }

    function link(from, to) {
    	return function (args) {
    		return to(from(args));
    	};
    }

    function wrapConversion(toModel, graph) {
    	const path = [graph[toModel].parent, toModel];
    	let fn = conversions[graph[toModel].parent][toModel];

    	let cur = graph[toModel].parent;
    	while (graph[cur].parent) {
    		path.unshift(graph[cur].parent);
    		fn = link(conversions[graph[cur].parent][cur], fn);
    		cur = graph[cur].parent;
    	}

    	fn.conversion = path;
    	return fn;
    }

    var route = function (fromModel) {
    	const graph = deriveBFS(fromModel);
    	const conversion = {};

    	const models = Object.keys(graph);
    	for (let len = models.length, i = 0; i < len; i++) {
    		const toModel = models[i];
    		const node = graph[toModel];

    		if (node.parent === null) {
    			// No possible conversion, or this node is the source model.
    			continue;
    		}

    		conversion[toModel] = wrapConversion(toModel, graph);
    	}

    	return conversion;
    };

    const convert = {};

    const models = Object.keys(conversions);

    function wrapRaw(fn) {
    	const wrappedFn = function (...args) {
    		const arg0 = args[0];
    		if (arg0 === undefined || arg0 === null) {
    			return arg0;
    		}

    		if (arg0.length > 1) {
    			args = arg0;
    		}

    		return fn(args);
    	};

    	// Preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}

    	return wrappedFn;
    }

    function wrapRounded(fn) {
    	const wrappedFn = function (...args) {
    		const arg0 = args[0];

    		if (arg0 === undefined || arg0 === null) {
    			return arg0;
    		}

    		if (arg0.length > 1) {
    			args = arg0;
    		}

    		const result = fn(args);

    		// We're assuming the result is an array here.
    		// see notice in conversions.js; don't use box types
    		// in conversion functions.
    		if (typeof result === 'object') {
    			for (let len = result.length, i = 0; i < len; i++) {
    				result[i] = Math.round(result[i]);
    			}
    		}

    		return result;
    	};

    	// Preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}

    	return wrappedFn;
    }

    models.forEach(fromModel => {
    	convert[fromModel] = {};

    	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
    	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

    	const routes = route(fromModel);
    	const routeModels = Object.keys(routes);

    	routeModels.forEach(toModel => {
    		const fn = routes[toModel];

    		convert[fromModel][toModel] = wrapRounded(fn);
    		convert[fromModel][toModel].raw = wrapRaw(fn);
    	});
    });

    var colorConvert = convert;

    const skippedModels = [
    	// To be honest, I don't really feel like keyword belongs in color convert, but eh.
    	'keyword',

    	// Gray conflicts with some method names, and has its own method defined.
    	'gray',

    	// Shouldn't really be in color-convert either...
    	'hex',
    ];

    const hashedModelKeys = {};
    for (const model of Object.keys(colorConvert)) {
    	hashedModelKeys[[...colorConvert[model].labels].sort().join('')] = model;
    }

    const limiters = {};

    function Color(object, model) {
    	if (!(this instanceof Color)) {
    		return new Color(object, model);
    	}

    	if (model && model in skippedModels) {
    		model = null;
    	}

    	if (model && !(model in colorConvert)) {
    		throw new Error('Unknown model: ' + model);
    	}

    	let i;
    	let channels;

    	if (object == null) { // eslint-disable-line no-eq-null,eqeqeq
    		this.model = 'rgb';
    		this.color = [0, 0, 0];
    		this.valpha = 1;
    	} else if (object instanceof Color) {
    		this.model = object.model;
    		this.color = [...object.color];
    		this.valpha = object.valpha;
    	} else if (typeof object === 'string') {
    		const result = colorString.get(object);
    		if (result === null) {
    			throw new Error('Unable to parse color from string: ' + object);
    		}

    		this.model = result.model;
    		channels = colorConvert[this.model].channels;
    		this.color = result.value.slice(0, channels);
    		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
    	} else if (object.length > 0) {
    		this.model = model || 'rgb';
    		channels = colorConvert[this.model].channels;
    		const newArray = Array.prototype.slice.call(object, 0, channels);
    		this.color = zeroArray(newArray, channels);
    		this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;
    	} else if (typeof object === 'number') {
    		// This is always RGB - can be converted later on.
    		this.model = 'rgb';
    		this.color = [
    			(object >> 16) & 0xFF,
    			(object >> 8) & 0xFF,
    			object & 0xFF,
    		];
    		this.valpha = 1;
    	} else {
    		this.valpha = 1;

    		const keys = Object.keys(object);
    		if ('alpha' in object) {
    			keys.splice(keys.indexOf('alpha'), 1);
    			this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;
    		}

    		const hashedKeys = keys.sort().join('');
    		if (!(hashedKeys in hashedModelKeys)) {
    			throw new Error('Unable to parse color from object: ' + JSON.stringify(object));
    		}

    		this.model = hashedModelKeys[hashedKeys];

    		const {labels} = colorConvert[this.model];
    		const color = [];
    		for (i = 0; i < labels.length; i++) {
    			color.push(object[labels[i]]);
    		}

    		this.color = zeroArray(color);
    	}

    	// Perform limitations (clamping, etc.)
    	if (limiters[this.model]) {
    		channels = colorConvert[this.model].channels;
    		for (i = 0; i < channels; i++) {
    			const limit = limiters[this.model][i];
    			if (limit) {
    				this.color[i] = limit(this.color[i]);
    			}
    		}
    	}

    	this.valpha = Math.max(0, Math.min(1, this.valpha));

    	if (Object.freeze) {
    		Object.freeze(this);
    	}
    }

    Color.prototype = {
    	toString() {
    		return this.string();
    	},

    	toJSON() {
    		return this[this.model]();
    	},

    	string(places) {
    		let self = this.model in colorString.to ? this : this.rgb();
    		self = self.round(typeof places === 'number' ? places : 1);
    		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
    		return colorString.to[self.model](args);
    	},

    	percentString(places) {
    		const self = this.rgb().round(typeof places === 'number' ? places : 1);
    		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
    		return colorString.to.rgb.percent(args);
    	},

    	array() {
    		return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    	},

    	object() {
    		const result = {};
    		const {channels} = colorConvert[this.model];
    		const {labels} = colorConvert[this.model];

    		for (let i = 0; i < channels; i++) {
    			result[labels[i]] = this.color[i];
    		}

    		if (this.valpha !== 1) {
    			result.alpha = this.valpha;
    		}

    		return result;
    	},

    	unitArray() {
    		const rgb = this.rgb().color;
    		rgb[0] /= 255;
    		rgb[1] /= 255;
    		rgb[2] /= 255;

    		if (this.valpha !== 1) {
    			rgb.push(this.valpha);
    		}

    		return rgb;
    	},

    	unitObject() {
    		const rgb = this.rgb().object();
    		rgb.r /= 255;
    		rgb.g /= 255;
    		rgb.b /= 255;

    		if (this.valpha !== 1) {
    			rgb.alpha = this.valpha;
    		}

    		return rgb;
    	},

    	round(places) {
    		places = Math.max(places || 0, 0);
    		return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    	},

    	alpha(value) {
    		if (value !== undefined) {
    			return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
    		}

    		return this.valpha;
    	},

    	// Rgb
    	red: getset('rgb', 0, maxfn(255)),
    	green: getset('rgb', 1, maxfn(255)),
    	blue: getset('rgb', 2, maxfn(255)),

    	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),

    	saturationl: getset('hsl', 1, maxfn(100)),
    	lightness: getset('hsl', 2, maxfn(100)),

    	saturationv: getset('hsv', 1, maxfn(100)),
    	value: getset('hsv', 2, maxfn(100)),

    	chroma: getset('hcg', 1, maxfn(100)),
    	gray: getset('hcg', 2, maxfn(100)),

    	white: getset('hwb', 1, maxfn(100)),
    	wblack: getset('hwb', 2, maxfn(100)),

    	cyan: getset('cmyk', 0, maxfn(100)),
    	magenta: getset('cmyk', 1, maxfn(100)),
    	yellow: getset('cmyk', 2, maxfn(100)),
    	black: getset('cmyk', 3, maxfn(100)),

    	x: getset('xyz', 0, maxfn(95.047)),
    	y: getset('xyz', 1, maxfn(100)),
    	z: getset('xyz', 2, maxfn(108.833)),

    	l: getset('lab', 0, maxfn(100)),
    	a: getset('lab', 1),
    	b: getset('lab', 2),

    	keyword(value) {
    		if (value !== undefined) {
    			return new Color(value);
    		}

    		return colorConvert[this.model].keyword(this.color);
    	},

    	hex(value) {
    		if (value !== undefined) {
    			return new Color(value);
    		}

    		return colorString.to.hex(this.rgb().round().color);
    	},

    	hexa(value) {
    		if (value !== undefined) {
    			return new Color(value);
    		}

    		const rgbArray = this.rgb().round().color;

    		let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
    		if (alphaHex.length === 1) {
    			alphaHex = '0' + alphaHex;
    		}

    		return colorString.to.hex(rgbArray) + alphaHex;
    	},

    	rgbNumber() {
    		const rgb = this.rgb().color;
    		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
    	},

    	luminosity() {
    		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
    		const rgb = this.rgb().color;

    		const lum = [];
    		for (const [i, element] of rgb.entries()) {
    			const chan = element / 255;
    			lum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
    		}

    		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    	},

    	contrast(color2) {
    		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
    		const lum1 = this.luminosity();
    		const lum2 = color2.luminosity();

    		if (lum1 > lum2) {
    			return (lum1 + 0.05) / (lum2 + 0.05);
    		}

    		return (lum2 + 0.05) / (lum1 + 0.05);
    	},

    	level(color2) {
    		// https://www.w3.org/TR/WCAG/#contrast-enhanced
    		const contrastRatio = this.contrast(color2);
    		if (contrastRatio >= 7) {
    			return 'AAA';
    		}

    		return (contrastRatio >= 4.5) ? 'AA' : '';
    	},

    	isDark() {
    		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
    		const rgb = this.rgb().color;
    		const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;
    		return yiq < 128;
    	},

    	isLight() {
    		return !this.isDark();
    	},

    	negate() {
    		const rgb = this.rgb();
    		for (let i = 0; i < 3; i++) {
    			rgb.color[i] = 255 - rgb.color[i];
    		}

    		return rgb;
    	},

    	lighten(ratio) {
    		const hsl = this.hsl();
    		hsl.color[2] += hsl.color[2] * ratio;
    		return hsl;
    	},

    	darken(ratio) {
    		const hsl = this.hsl();
    		hsl.color[2] -= hsl.color[2] * ratio;
    		return hsl;
    	},

    	saturate(ratio) {
    		const hsl = this.hsl();
    		hsl.color[1] += hsl.color[1] * ratio;
    		return hsl;
    	},

    	desaturate(ratio) {
    		const hsl = this.hsl();
    		hsl.color[1] -= hsl.color[1] * ratio;
    		return hsl;
    	},

    	whiten(ratio) {
    		const hwb = this.hwb();
    		hwb.color[1] += hwb.color[1] * ratio;
    		return hwb;
    	},

    	blacken(ratio) {
    		const hwb = this.hwb();
    		hwb.color[2] += hwb.color[2] * ratio;
    		return hwb;
    	},

    	grayscale() {
    		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
    		const rgb = this.rgb().color;
    		const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    		return Color.rgb(value, value, value);
    	},

    	fade(ratio) {
    		return this.alpha(this.valpha - (this.valpha * ratio));
    	},

    	opaquer(ratio) {
    		return this.alpha(this.valpha + (this.valpha * ratio));
    	},

    	rotate(degrees) {
    		const hsl = this.hsl();
    		let hue = hsl.color[0];
    		hue = (hue + degrees) % 360;
    		hue = hue < 0 ? 360 + hue : hue;
    		hsl.color[0] = hue;
    		return hsl;
    	},

    	mix(mixinColor, weight) {
    		// Ported from sass implementation in C
    		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
    		if (!mixinColor || !mixinColor.rgb) {
    			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
    		}

    		const color1 = mixinColor.rgb();
    		const color2 = this.rgb();
    		const p = weight === undefined ? 0.5 : weight;

    		const w = 2 * p - 1;
    		const a = color1.alpha() - color2.alpha();

    		const w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;
    		const w2 = 1 - w1;

    		return Color.rgb(
    			w1 * color1.red() + w2 * color2.red(),
    			w1 * color1.green() + w2 * color2.green(),
    			w1 * color1.blue() + w2 * color2.blue(),
    			color1.alpha() * p + color2.alpha() * (1 - p));
    	},
    };

    // Model conversion methods and static constructors
    for (const model of Object.keys(colorConvert)) {
    	if (skippedModels.includes(model)) {
    		continue;
    	}

    	const {channels} = colorConvert[model];

    	// Conversion methods
    	Color.prototype[model] = function (...args) {
    		if (this.model === model) {
    			return new Color(this);
    		}

    		if (args.length > 0) {
    			return new Color(args, model);
    		}

    		return new Color([...assertArray(colorConvert[this.model][model].raw(this.color)), this.valpha], model);
    	};

    	// 'static' construction methods
    	Color[model] = function (...args) {
    		let color = args[0];
    		if (typeof color === 'number') {
    			color = zeroArray(args, channels);
    		}

    		return new Color(color, model);
    	};
    }

    function roundTo(number, places) {
    	return Number(number.toFixed(places));
    }

    function roundToPlace(places) {
    	return function (number) {
    		return roundTo(number, places);
    	};
    }

    function getset(model, channel, modifier) {
    	model = Array.isArray(model) ? model : [model];

    	for (const m of model) {
    		(limiters[m] || (limiters[m] = []))[channel] = modifier;
    	}

    	model = model[0];

    	return function (value) {
    		let result;

    		if (value !== undefined) {
    			if (modifier) {
    				value = modifier(value);
    			}

    			result = this[model]();
    			result.color[channel] = value;
    			return result;
    		}

    		result = this[model]().color[channel];
    		if (modifier) {
    			result = modifier(result);
    		}

    		return result;
    	};
    }

    function maxfn(max) {
    	return function (v) {
    		return Math.max(0, Math.min(max, v));
    	};
    }

    function assertArray(value) {
    	return Array.isArray(value) ? value : [value];
    }

    function zeroArray(array, length) {
    	for (let i = 0; i < length; i++) {
    		if (typeof array[i] !== 'number') {
    			array[i] = 0;
    		}
    	}

    	return array;
    }

    var color = Color;

    var Color$1 = color;

    var $parcel$global =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
    var $parcel$modules = {};
    var $parcel$inits = {};

    var parcelRequire = $parcel$global["parcelRequiree40e"];
    if (parcelRequire == null) {
      parcelRequire = function(id) {
        if (id in $parcel$modules) {
          return $parcel$modules[id].exports;
        }
        if (id in $parcel$inits) {
          var init = $parcel$inits[id];
          delete $parcel$inits[id];
          var module = {id: id, exports: {}};
          $parcel$modules[id] = module;
          init.call(module.exports, module, module.exports);
          return module.exports;
        }
        var err = new Error("Cannot find module '" + id + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      };

      parcelRequire.register = function register(id, init) {
        $parcel$inits[id] = init;
      };

      $parcel$global["parcelRequiree40e"] = parcelRequire;
    }
    parcelRequire.register("dcBU0", function(module, exports) {
    function $99c9cbf514d06989$var$ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
        }
        return keys;
    }
    function $99c9cbf514d06989$var$_objectSpread(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? $99c9cbf514d06989$var$ownKeys(Object(source), !0).forEach(function(key) {
                $99c9cbf514d06989$var$_defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : $99c9cbf514d06989$var$ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
        return target;
    }
    function $99c9cbf514d06989$var$_defineProperty(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    function $99c9cbf514d06989$var$_typeof(obj1) {
        return $99c9cbf514d06989$var$_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, $99c9cbf514d06989$var$_typeof(obj1);
    }
    /**
     * @param {Object} options - options object to be passed with args to alter style
     * @param {transformFn} options.transformFn - the transform function to run on property values
     * @param {transformCondition} [options.transformCondition] - optional function for condition to be met to transform property
     * @param {Array} [options.propertyIds] - optional array of property ids to filter transform to
     */ /**
     * transformFn
     * The transform function passed in as an option to run recursively on expressions
     * @function transformFn
     * @param {string} layerId - id of the relevant layer
     * @param {Object|Array|string|number} propertyValue - the value of the property passed in
     * @param {string} propertyKey - the key of the property passed in
     * @returns {Object|Array|string|number} - transformed property value
     */ /**
     * transformCondition
     * Returns a boolean for if the condition is met
     * @function transformCondition
     * @param {Object|Array|string|number} propertyValue - the value of the property passed in
     * @param {string} propertyKey - the key of the property passed in
     * @returns {boolean} - true or false
     */ /**
     * recurseExpression
     * Recurses an expression and passes all sub expressions to transformFn
     * @param {string} layerId - id of the relevant layer
     * @param {string} propertyKey - key of the property where the expression was found
     * @param {Array} exp - expression
     * @param {transformFn} transformFn - transforms the value
     * @param {transformCondition} transformCondition - returns true if value meets condition
     * @returns {Array} - modified expression
     */ var $99c9cbf514d06989$var$recurseExpression = function recurseExpression(layerId, propertyKey, exp, transformFn, transformCondition) {
        if (transformCondition(exp, propertyKey)) return transformFn(layerId, exp, propertyKey);
        if (Array.isArray(exp)) return exp.map(function(item) {
            return recurseExpression(layerId, propertyKey, item, transformFn, transformCondition);
        });
        return exp;
    };
    /**
     * updatePropertyValue
     * Returns updated property value
     * @param {string} layerId - id of the relevant layer
     * @param {string} propertyKey - key of the property where the value was found
     * @param {Object|Array|string|number} propertyValue - property value
     * @param {Object} options - options object with transform fn and optional recurse condition
     * @returns {Object|Array|string|number} - modified property value
     */ var $99c9cbf514d06989$var$updatePropertyValue = function updatePropertyValue(layerId, propertyKey, propertyValue, options) {
        var transformFn = options.transformFn, transformCondition = options.transformCondition;
        var propertyFormat = $99c9cbf514d06989$var$_typeof(propertyValue);
        if (!transformCondition) return transformFn(propertyValue, propertyKey);
        if (propertyFormat === 'object' && Array.isArray(propertyValue)) propertyFormat = 'expression';
        else if (propertyFormat === 'object' && propertyValue.hasOwnProperty('stops')) propertyFormat = 'legacyStops';
        else propertyFormat = 'literal';
        switch(propertyFormat){
            case 'literal':
                return transformCondition(propertyValue, propertyKey) ? transformFn(layerId, propertyValue, propertyKey) : propertyValue;
            case 'expression':
                // Since expressions can be nested, recurse through the expression to find any instance that meets the condition
                return $99c9cbf514d06989$var$recurseExpression(layerId, propertyKey, propertyValue, transformFn, transformCondition);
            case 'legacyStops':
                return $99c9cbf514d06989$var$_objectSpread($99c9cbf514d06989$var$_objectSpread({}, propertyValue), {}, {
                    stops: $99c9cbf514d06989$var$recurseExpression(layerId, propertyKey, propertyValue.stops, transformFn, transformCondition)
                });
        }
    };
    /**
     * updateLayerPropertyValues
     * Returns a layer or property object with all properties updated with appropriate value
     * @param {string} layerId - id of the relevant layer
     * @param {Object} propertyObj - property object, can be layer or paint/layout object
     * @param {Object} options - options object with transform fn, optional propertyIds, and optional recurse condition
     * @returns {Object} - modified property object
     */ var $99c9cbf514d06989$var$updateLayerPropertyValues = function updateLayerPropertyValues(layerId, propertyObj, options) {
        var propertyIds = options.propertyIds;
        var nextObj = JSON.parse(JSON.stringify(propertyObj));
        for(var k in propertyObj)switch(k){
            case 'metadata':
                break;
            case 'paint':
            case 'layout':
                nextObj[k] = updateLayerPropertyValues(layerId, propertyObj[k], options);
                break;
            default:
                // If specific properties are specified, only transform them
                if (propertyIds && !propertyIds.includes(k)) continue;
                var nextOptions = {
                    transformFn: options.transformFn,
                    transformCondition: options.transformCondition
                }; // Handle nested keys here (to get "paint.*" and "layout.*")
                nextObj[k] = $99c9cbf514d06989$var$updatePropertyValue(layerId, k, propertyObj[k], nextOptions);
                break;
        }
        return nextObj;
    };
    /**
     * recurseStyle
     * @param {Object} stylesheet - style json
     * @param {Object} options - options object with transform fn, optional propertyIds, and optional recurse condition
     * @returns {Object} - modified style json with single matches replaced
     */ var $99c9cbf514d06989$var$recurseStyle = function recurseStyle(stylesheet, options) {
        // Copy stylesheet to not make edits in Maputnik
        var stylesheetCopy = JSON.parse(JSON.stringify(stylesheet));
        stylesheetCopy.layers = stylesheet.layers.map(function(l) {
            return $99c9cbf514d06989$var$updateLayerPropertyValues(l.id, l, options);
        });
        return stylesheetCopy;
    };
    /**
     * createRecurseStyle
     * @param {Object} options - options object with transform fn and optional recurse condition
     * @returns {Object} - modified style json with single matches replaced
     */ var $99c9cbf514d06989$var$createRecurseStyle = function createRecurseStyle(options) {
        return function(stylesheet) {
            return $99c9cbf514d06989$var$recurseStyle(stylesheet, options);
        };
    };
    module.exports = $99c9cbf514d06989$var$createRecurseStyle;

    });

    var $cf838c15c8b009ba$exports = {};
    Object.defineProperty($cf838c15c8b009ba$exports, "__esModule", {
        value: true
    });
    Object.defineProperty($cf838c15c8b009ba$exports, "createRecurseStyle", {
        enumerable: true,
        get: function get() {
            return $cf838c15c8b009ba$var$_createRecurseStyle["default"];
        }
    });

    var $cf838c15c8b009ba$var$_createRecurseStyle = $cf838c15c8b009ba$var$_interopRequireDefault((parcelRequire("dcBU0")));
    function $cf838c15c8b009ba$var$_interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        };
    }

    // Converts all color values in stylesheet to RGB

    const createRecurseStyle = $cf838c15c8b009ba$exports.createRecurseStyle;

    // Color properties from the style spec in case new ones are added
    const convertToRgbPropertyIds = Object.keys(v8).reduce((acc, k) => {
      if (k.includes('paint')) {
        Object.keys(v8[k]).forEach(propertyId => {
          if (v8[k][propertyId]['type'] === 'color') {
            acc.push(propertyId);
          }
        });
      }
      return acc;
    }, []);

    const expressionNames = Object.keys(v8['expression_name']['values']);

    /**
     * convertToRgb
     * Convert colors to RGB (rounded off decimal points)
     * @param {string} color - color string to be converted
     * @returns {string} - color as rgb value
     */
    const convertToRgb = (id, color, key) => {
      // Hue might not be necessary, but basically we want to avoid rounding alpha
      const attrToRound = ['r', 'g', 'b', 'a'];

      let rgbObj = Color$1(color).rgb().object();

      rgbObj = Object.keys(rgbObj).reduce((acc, k) => {
        acc[k] = attrToRound.includes(k) ? Math.round(rgbObj[k]) : rgbObj[k];
        return acc;
      }, {});

      const rgbcolor = Color$1(rgbObj).rgb().string();

      return rgbcolor;
    };

    /**
     * convertToRgbCondition
     * Condition to run convertToRgb on
     * @param {Array} val - property value
     * @returns {boolean} - true or false
     */
    const convertToRgbCondition = (val, key) => {
      if (typeof val !== 'string') return false;
      if (expressionNames.includes(val)) return false;
      try {
        // Checks if it is a valid color string
        new Color$1(val);
      } catch (e) {
        return false;
      }
      return true;
    };

    const convertStylesheetToRgb = createRecurseStyle({
      transformFn: convertToRgb,
      transformCondition: convertToRgbCondition,
      propertyIds: convertToRgbPropertyIds,
    });

    var WorkerClass = null;

    try {
        var WorkerThreads =
            typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||
            typeof __non_webpack_require__ === 'function' && __non_webpack_require__('worker_threads') ||
            typeof require === 'function' && require('worker_threads');
        WorkerClass = WorkerThreads.Worker;
    } catch(e) {} // eslint-disable-line

    function decodeBase64$1(base64, enableUnicode) {
        return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');
    }

    function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
        var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
        var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
        var source = decodeBase64$1(base64, enableUnicode);
        var start = source.indexOf('\n', 10) + 1;
        var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
        return function WorkerFactory(options) {
            return new WorkerClass(body, Object.assign({}, options, { eval: true }));
        };
    }

    function decodeBase64(base64, enableUnicode) {
        var binaryString = atob(base64);
        if (enableUnicode) {
            var binaryView = new Uint8Array(binaryString.length);
            for (var i = 0, n = binaryString.length; i < n; ++i) {
                binaryView[i] = binaryString.charCodeAt(i);
            }
            return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
        }
        return binaryString;
    }

    function createURL(base64, sourcemapArg, enableUnicodeArg) {
        var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
        var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
        var source = decodeBase64(base64, enableUnicode);
        var start = source.indexOf('\n', 10) + 1;
        var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
        var blob = new Blob([body], { type: 'application/javascript' });
        return URL.createObjectURL(blob);
    }

    function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
        var url;
        return function WorkerFactory(options) {
            url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
            return new Worker(url, options);
        };
    }

    var kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

    function isNodeJS() {
        return kIsNodeJS;
    }

    function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
        if (isNodeJS()) {
            return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);
        }
        return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
    }

    var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICAgJ3VzZSBzdHJpY3QnOwoKICAgIHZhciBpbW11dGFibGUgPSBleHRlbmQkMTsKCiAgICB2YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CgogICAgZnVuY3Rpb24gZXh0ZW5kJDEoKSB7CiAgICAgICAgdmFyIHRhcmdldCA9IHt9OwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOwoKICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgewogICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbChzb3VyY2UsIGtleSkpIHsKICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdGFyZ2V0CiAgICB9CgogICAgLy8gUHVibGljIEFQSQogICAgdmFyIGNhcnRlc2lhbl8xID0gY2FydGVzaWFuOwoKICAgIC8qKgogICAgICogQ3JlYXRlcyBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiB0aGUgcHJvdmlkZWQgcHJvcGVydGllcwogICAgICoKICAgICAqIEBwYXJhbSAgIHtvYmplY3R8YXJyYXl9IGxpc3QgLSBsaXN0IG9mIChhcnJheSkgcHJvcGVydGllcyBvciBhcnJheSBvZiBhcnJheXMKICAgICAqIEByZXR1cm5zIHthcnJheX0gYWxsIHRoZSBjb21iaW5hdGlvbnMgb2YgdGhlIHByb3BlcnRpZXMKICAgICAqLwogICAgZnVuY3Rpb24gY2FydGVzaWFuKGxpc3QpCiAgICB7CiAgICAgIHZhciBsYXN0LCBpbml0LCBrZXlzLCBwcm9kdWN0ID0gW107CgogICAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0KSkKICAgICAgewogICAgICAgIGluaXQgPSBbXTsKICAgICAgICBsYXN0ID0gbGlzdC5sZW5ndGggLSAxOwogICAgICB9CiAgICAgIGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09ICdvYmplY3QnICYmIGxpc3QgIT09IG51bGwpCiAgICAgIHsKICAgICAgICBpbml0ID0ge307CiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGxpc3QpOwogICAgICAgIGxhc3QgPSBrZXlzLmxlbmd0aCAtIDE7CiAgICAgIH0KICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0aW5nIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYnV0IGAnICsgKGxpc3QgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgbGlzdCkgKyAnYCBwcm92aWRlZC4nKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gYWRkKHJvdywgaSkKICAgICAgewogICAgICAgIHZhciBqLCBrLCByOwoKICAgICAgICBrID0ga2V5cyA/IGtleXNbaV0gOiBpOwoKICAgICAgICAvLyBlaXRoZXIgYXJyYXkgb3Igbm90LCBub3QgZXhwZWN0aW5nIG9iamVjdHMgaGVyZQogICAgICAgIEFycmF5LmlzQXJyYXkobGlzdFtrXSkgfHwgKHR5cGVvZiBsaXN0W2tdID09ICd1bmRlZmluZWQnID8gbGlzdFtrXSA9IFtdIDogbGlzdFtrXSA9IFtsaXN0W2tdXSk7CgogICAgICAgIGZvciAoaj0wOyBqIDwgbGlzdFtrXS5sZW5ndGg7IGorKykKICAgICAgICB7CiAgICAgICAgICByID0gY2xvbmUocm93KTsKICAgICAgICAgIHN0b3JlKHIsIGxpc3Rba11bal0sIGspOwoKICAgICAgICAgIGlmIChpID49IGxhc3QpCiAgICAgICAgICB7CiAgICAgICAgICAgIHByb2R1Y3QucHVzaChyKTsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UKICAgICAgICAgIHsKICAgICAgICAgICAgYWRkKHIsIGkgKyAxKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGFkZChpbml0LCAwKTsKCiAgICAgIHJldHVybiBwcm9kdWN0OwogICAgfQoKICAgIC8qKgogICAgICogQ2xvbmVzIChzaGFsbG93IGNvcHkpIHByb3ZpZGVkIG9iamVjdCBvciBhcnJheQogICAgICoKICAgICAqIEBwYXJhbSAgIHtvYmplY3R8YXJyYXl9IG9iaiAtIG9iamVjdCBvciBhcnJheSB0byBjbG9uZQogICAgICogQHJldHVybnMge29iamVjdHxhcnJheX0gLSBzaGFsbG93IGNvcHkgb2YgdGhlIHByb3ZpZGVkIG9iamVjdCBvciBhcnJheQogICAgICovCiAgICBmdW5jdGlvbiBjbG9uZShvYmopCiAgICB7CiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgPyBbXS5jb25jYXQob2JqKSA6IGltbXV0YWJsZShvYmopOwogICAgfQoKICAgIC8qKgogICAgICogU3RvcmVzIHByb3ZpZGVkIGVsZW1lbnQgaW4gdGhlIHByb3ZpZGVkIG9iamVjdCBvciBhcnJheQogICAgICoKICAgICAqIEBwYXJhbSAgIHtvYmplY3R8YXJyYXl9IG9iaiAtIG9iamVjdCBvciBhcnJheSB0byBhZGQgdG8KICAgICAqIEBwYXJhbSAgIHttaXhlZH0gZWxlbSAtIGVsZW1lbnQgdG8gYWRkCiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfG51bWJlcn0ga2V5IC0gb2JqZWN0J3MgcHJvcGVydHkga2V5IHRvIGFkZCB0bwogICAgICogQHJldHVybnMge3ZvaWR9CiAgICAgKi8KICAgIGZ1bmN0aW9uIHN0b3JlKG9iaiwgZWxlbSwga2V5KQogICAgewogICAgICBBcnJheS5pc0FycmF5KG9iaikgPyBvYmoucHVzaChlbGVtKSA6IChvYmpba2V5XSA9IGVsZW0pOwogICAgfQoKICAgIHZhciBjb21tb25qc0dsb2JhbCQxID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307CgogICAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUkMShmbikgewogICAgICB2YXIgbW9kdWxlID0geyBleHBvcnRzOiB7fSB9OwogICAgCXJldHVybiBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7CiAgICB9CgogICAgLyoqCiAgICAgKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+CiAgICAgKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9Im5wbSIgLW8gLi9gCiAgICAgKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+CiAgICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+CiAgICAgKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPgogICAgICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzCiAgICAgKi8KCiAgICB2YXIgbG9kYXNoX21lcmdld2l0aCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykgewogICAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovCiAgICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDsKCiAgICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovCiAgICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7CgogICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqLwogICAgdmFyIEhPVF9DT1VOVCA9IDgwMCwKICAgICAgICBIT1RfU1BBTiA9IDE2OwoKICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqLwogICAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOwoKICAgIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi8KICAgIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsCiAgICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLAogICAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLAogICAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsCiAgICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJywKICAgICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsCiAgICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsCiAgICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJywKICAgICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJywKICAgICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJywKICAgICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLAogICAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLAogICAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJywKICAgICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJywKICAgICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJywKICAgICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJywKICAgICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJywKICAgICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nOwoKICAgIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsCiAgICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLAogICAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJywKICAgICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsCiAgICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLAogICAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLAogICAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLAogICAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLAogICAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsCiAgICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJywKICAgICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nOwoKICAgIC8qKgogICAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYAogICAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuCiAgICAgKi8KICAgIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXiQuKis/KClbXF17fXxdL2c7CgogICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqLwogICAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXSQvOwoKICAgIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi8KICAgIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxkKikkLzsKCiAgICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovCiAgICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTsKICAgIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPQogICAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPQogICAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID0KICAgIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0KICAgIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlOwogICAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPQogICAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPQogICAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPQogICAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPQogICAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPQogICAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPQogICAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPQogICAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTsKCiAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqLwogICAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwkMSA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCQxICYmIGNvbW1vbmpzR2xvYmFsJDEuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWwkMTsKCiAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqLwogICAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CgogICAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovCiAgICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTsKCiAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqLwogICAgdmFyIGZyZWVFeHBvcnRzID0gZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwoKICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi8KICAgIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwoKICAgIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovCiAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0czsKCiAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi8KICAgIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzOwoKICAgIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqLwogICAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkgewogICAgICB0cnkgewogICAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLgogICAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzOwoKICAgICAgICBpZiAodHlwZXMpIHsKICAgICAgICAgIHJldHVybiB0eXBlczsKICAgICAgICB9CgogICAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuCiAgICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpOwogICAgICB9IGNhdGNoIChlKSB7fQogICAgfSgpKTsKCiAgICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqLwogICAgdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7CgogICAgLyoqCiAgICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgCiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuCiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC4KICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4KICAgICAqLwogICAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykgewogICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7CiAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpOwogICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTsKICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7CiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pOwogICAgICB9CiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpOwogICAgfQoKICAgIC8qKgogICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcwogICAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLgogICAgICovCiAgICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHsKICAgICAgdmFyIGluZGV4ID0gLTEsCiAgICAgICAgICByZXN1bHQgPSBBcnJheShuKTsKCiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikgewogICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7CiAgICAgIH0KICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgICAvKioKICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLgogICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLgogICAgICovCiAgICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykgewogICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7CiAgICAgIH07CiAgICB9CgogICAgLyoqCiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC4KICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS4KICAgICAqLwogICAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHsKICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07CiAgICB9CgogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC4KICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLgogICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uCiAgICAgKi8KICAgIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7CiAgICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHsKICAgICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7CiAgICAgIH07CiAgICB9CgogICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwogICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsCiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLAogICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTsKCiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovCiAgICB2YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddOwoKICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi8KICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7CgogICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovCiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsKCiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqLwogICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7CiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7CiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJzsKICAgIH0oKSk7CgogICAgLyoqCiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlCiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZykKICAgICAqIG9mIHZhbHVlcy4KICAgICAqLwogICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7CgogICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqLwogICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpOwoKICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovCiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKwogICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXCQmJykKICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFwoKXwgZm9yIC4rPyg/PVxcXF0pL2csICckMS4qPycpICsgJyQnCiAgICApOwoKICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqLwogICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCwKICAgICAgICBTeW1ib2wgPSByb290LlN5bWJvbCwKICAgICAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LAogICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLAogICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLAogICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsCiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSwKICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSwKICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDsKCiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTsKICAgICAgICBmdW5jKHt9LCAnJywge30pOwogICAgICAgIHJldHVybiBmdW5jOwogICAgICB9IGNhdGNoIChlKSB7fQogICAgfSgpKTsKCiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovCiAgICB2YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsCiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsCiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3c7CgogICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqLwogICAgdmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksCiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpOwoKICAgIC8qKgogICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZwogICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS4KICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuCiAgICAgKi8KICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkgewogICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fQogICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHsKICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkgewogICAgICAgICAgcmV0dXJuIHt9OwogICAgICAgIH0KICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7CiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTsKICAgICAgICB9CiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvOwogICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0OwogICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfTsKICAgIH0oKSk7CgogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBjb25zdHJ1Y3RvcgogICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuCiAgICAgKi8KICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykgewogICAgICB2YXIgaW5kZXggPSAtMSwKICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDsKCiAgICAgIHRoaXMuY2xlYXIoKTsKICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHsKICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTsKICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pOwogICAgICB9CiAgICB9CgogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBjbGVhcgogICAgICogQG1lbWJlck9mIEhhc2gKICAgICAqLwogICAgZnVuY3Rpb24gaGFzaENsZWFyKCkgewogICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307CiAgICAgIHRoaXMuc2l6ZSA9IDA7CiAgICB9CgogICAgLyoqCiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG5hbWUgZGVsZXRlCiAgICAgKiBAbWVtYmVyT2YgSGFzaAogICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LgogICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7CiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07CiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgICAvKioKICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBnZXQKICAgICAqIEBtZW1iZXJPZiBIYXNoCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC4KICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS4KICAgICAqLwogICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHsKICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fOwogICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7CiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTsKICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDsKICAgICAgfQogICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkOwogICAgfQoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBoYXMKICAgICAqIEBtZW1iZXJPZiBIYXNoCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC4KICAgICAqLwogICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHsKICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fOwogICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTsKICAgIH0KCiAgICAvKioKICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG5hbWUgc2V0CiAgICAgKiBAbWVtYmVyT2YgSGFzaAogICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLgogICAgICovCiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHsKICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fOwogICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxOwogICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CgogICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLgogICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7CiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlOwogICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDsKICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7CiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0OwoKICAgIC8qKgogICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQGNvbnN0cnVjdG9yCiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS4KICAgICAqLwogICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHsKICAgICAgdmFyIGluZGV4ID0gLTEsCiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7CgogICAgICB0aGlzLmNsZWFyKCk7CiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07CiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTsKICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG5hbWUgY2xlYXIKICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGUKICAgICAqLwogICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7CiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTsKICAgICAgdGhpcy5zaXplID0gMDsKICAgIH0KCiAgICAvKioKICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBkZWxldGUKICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGUKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLgogICAgICovCiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7CiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXywKICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7CgogICAgICBpZiAoaW5kZXggPCAwKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7CiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHsKICAgICAgICBkYXRhLnBvcCgpOwogICAgICB9IGVsc2UgewogICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTsKICAgICAgfQogICAgICAtLXRoaXMuc2l6ZTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG5hbWUgZ2V0CiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC4KICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS4KICAgICAqLwogICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkgewogICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sCiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpOwoKICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdOwogICAgfQoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBoYXMKICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGUKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLgogICAgICovCiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7CiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xOwogICAgfQoKICAgIC8qKgogICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBzZXQKICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGUKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LgogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LgogICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS4KICAgICAqLwogICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHsKICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLAogICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTsKCiAgICAgIGlmIChpbmRleCA8IDApIHsKICAgICAgICArK3RoaXMuc2l6ZTsKICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzOwogICAgfQoKICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLgogICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyOwogICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7CiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDsKICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzOwogICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7CgogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBjb25zdHJ1Y3RvcgogICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuCiAgICAgKi8KICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHsKICAgICAgdmFyIGluZGV4ID0gLTEsCiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7CgogICAgICB0aGlzLmNsZWFyKCk7CiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07CiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTsKICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBjbGVhcgogICAgICogQG1lbWJlck9mIE1hcENhY2hlCiAgICAgKi8KICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7CiAgICAgIHRoaXMuc2l6ZSA9IDA7CiAgICAgIHRoaXMuX19kYXRhX18gPSB7CiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCwKICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSwKICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2gKICAgICAgfTsKICAgIH0KCiAgICAvKioKICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBuYW1lIGRlbGV0ZQogICAgICogQG1lbWJlck9mIE1hcENhY2hlCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC4KICAgICAqLwogICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7CiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7CiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgICAvKioKICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBuYW1lIGdldAogICAgICogQG1lbWJlck9mIE1hcENhY2hlCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC4KICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS4KICAgICAqLwogICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7CiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG5hbWUgaGFzCiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGUKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLgogICAgICovCiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHsKICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTsKICAgIH0KCiAgICAvKioKICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBzZXQKICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZQogICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuCiAgICAgKi8KICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHsKICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksCiAgICAgICAgICBzaXplID0gZGF0YS5zaXplOwoKICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KCiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLgogICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjsKICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTsKICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDsKICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhczsKICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDsKCiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAY29uc3RydWN0b3IKICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLgogICAgICovCiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7CiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7CiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTsKICAgIH0KCiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBjbGVhcgogICAgICogQG1lbWJlck9mIFN0YWNrCiAgICAgKi8KICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7CiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlOwogICAgICB0aGlzLnNpemUgPSAwOwogICAgfQoKICAgIC8qKgogICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBkZWxldGUKICAgICAqIEBtZW1iZXJPZiBTdGFjawogICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuCiAgICAgKi8KICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkgewogICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sCiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpOwoKICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICAgIC8qKgogICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbmFtZSBnZXQKICAgICAqIEBtZW1iZXJPZiBTdGFjawogICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuCiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuCiAgICAgKi8KICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkgewogICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTsKICAgIH0KCiAgICAvKioKICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBuYW1lIGhhcwogICAgICogQG1lbWJlck9mIFN0YWNrCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC4KICAgICAqLwogICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7CiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpOwogICAgfQoKICAgIC8qKgogICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG5hbWUgc2V0CiAgICAgKiBAbWVtYmVyT2YgU3RhY2sKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LgogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LgogICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuCiAgICAgKi8KICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHsKICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fOwogICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkgewogICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187CiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkgewogICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pOwogICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpOwogICAgICB9CiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpOwogICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQoKICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuCiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyOwogICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlOwogICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0OwogICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzOwogICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0OwoKICAgIC8qKgogICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS4KICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy4KICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkgewogICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSwKICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSwKICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLAogICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksCiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsCiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSwKICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7CgogICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHsKICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJgogICAgICAgICAgICAhKHNraXBJbmRleGVzICYmICgKICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLgogICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHwKICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuCiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fAogICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuCiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fAogICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuCiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpCiAgICAgICAgICAgICkpKSB7CiAgICAgICAgICByZXN1bHQucHVzaChrZXkpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICAgIC8qKgogICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ24KICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS4KICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLgogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLgogICAgICovCiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkgewogICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8CiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkgewogICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpOwogICAgICB9CiAgICB9CgogICAgLyoqCiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50CiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKQogICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LgogICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uCiAgICAgKi8KICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkgewogICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTsKICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHwKICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7CiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7CiAgICAgIH0KICAgIH0KCiAgICAvKioKICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuCiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLgogICAgICovCiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkgewogICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogICAgICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkgewogICAgICAgICAgcmV0dXJuIGxlbmd0aDsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIC0xOwogICAgfQoKICAgIC8qKgogICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXQKICAgICAqIHZhbHVlIGNoZWNrcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS4KICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLgogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLgogICAgICovCiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7CiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHsKICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwgewogICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsCiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsCiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSwKICAgICAgICAgICd3cml0YWJsZSc6IHRydWUKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlOwogICAgICB9CiAgICB9CgogICAgLyoqCiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YAogICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuCiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC4KICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuCiAgICAgKi8KICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpOwoKICAgIC8qKgogICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuCiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLgogICAgICovCiAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7CiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnOwogICAgICB9CiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSkKICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSkKICAgICAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTsKICAgIH0KCiAgICAvKioKICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsCiAgICAgKi8KICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkgewogICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnOwogICAgfQoKICAgIC8qKgogICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLAogICAgICogIGVsc2UgYGZhbHNlYC4KICAgICAqLwogICAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7CiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjsKICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpOwogICAgfQoKICAgIC8qKgogICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHsKICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYKICAgICAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldOwogICAgfQoKICAgIC8qKgogICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS4KICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7CiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkgewogICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTsKICAgICAgfQogICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksCiAgICAgICAgICByZXN1bHQgPSBbXTsKCiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHsKICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkgewogICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgICAvKioKICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuCiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkCiAgICAgKiAgY291bnRlcnBhcnRzLgogICAgICovCiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykgewogICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHsKICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spOwogICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHsKICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIKICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKQogICAgICAgICAgICA6IHVuZGVmaW5lZDsKCiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpOwogICAgICAgIH0KICAgICAgfSwga2V5c0luKTsKICAgIH0KCiAgICAvKioKICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zCiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhcgogICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLgogICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC4KICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWQKICAgICAqICBjb3VudGVycGFydHMuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHsKICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksCiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLAogICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7CgogICAgICBpZiAoc3RhY2tlZCkgewogICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyCiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKQogICAgICAgIDogdW5kZWZpbmVkOwoKICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDsKCiAgICAgIGlmIChpc0NvbW1vbikgewogICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLAogICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLAogICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTsKCiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTsKICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHsKICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkgewogICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7CiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikgewogICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlOwogICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHsKICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTsKICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkgewogICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTsKICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHsKICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHsKICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChpc0NvbW1vbikgewogICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLgogICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpOwogICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7CiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTsKICAgICAgfQogICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7CiAgICB9CgogICAgLyoqCiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uCiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuCiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi4KICAgICAqLwogICAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHsKICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7CiAgICB9CgogICAgLyoqCiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS4KICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuCiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLgogICAgICovCiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHsKICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHsKICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSwKICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLAogICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksCiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZQogICAgICB9KTsKICAgIH07CgogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuCiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLgogICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci4KICAgICAqLwogICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHsKICAgICAgaWYgKGlzRGVlcCkgewogICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTsKICAgICAgfQogICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCwKICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTsKCiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS4KICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci4KICAgICAqLwogICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikgewogICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpOwogICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLgogICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS4KICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS4KICAgICAqLwogICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkgewogICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjsKICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7CiAgICB9CgogICAgLyoqCiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uCiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by4KICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLgogICAgICovCiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkgewogICAgICB2YXIgaW5kZXggPSAtMSwKICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7CgogICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTsKICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHsKICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdOwogICAgICB9CiAgICAgIHJldHVybiBhcnJheTsKICAgIH0KCiAgICAvKioKICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uCiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by4KICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLgogICAgICovCiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikgewogICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0OwogICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTsKCiAgICAgIHZhciBpbmRleCA9IC0xLAogICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoOwoKICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHsKICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdOwoKICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyCiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKQogICAgICAgICAgOiB1bmRlZmluZWQ7CgogICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldOwogICAgICAgIH0KICAgICAgICBpZiAoaXNOZXcpIHsKICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb2JqZWN0OwogICAgfQoKICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuCiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi4KICAgICAqLwogICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHsKICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykgewogICAgICAgIHZhciBpbmRleCA9IC0xLAogICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCwKICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLAogICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkOwoKICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJykKICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKQogICAgICAgICAgOiB1bmRlZmluZWQ7CgogICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHsKICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjsKICAgICAgICAgIGxlbmd0aCA9IDE7CiAgICAgICAgfQogICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpOwogICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07CiAgICAgICAgICBpZiAoc291cmNlKSB7CiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBvYmplY3Q7CiAgICAgIH0pOwogICAgfQoKICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LgogICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi4KICAgICAqLwogICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHsKICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7CiAgICAgICAgdmFyIGluZGV4ID0gLTEsCiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksCiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSwKICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoOwoKICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTsKICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBvYmplY3Q7CiAgICAgIH07CiAgICB9CgogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LgogICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS4KICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS4KICAgICAqLwogICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkgewogICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXzsKICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpCiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ10KICAgICAgICA6IGRhdGEubWFwOwogICAgfQoKICAgIC8qKgogICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuCiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuCiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkgewogICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7CiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7CiAgICB9CgogICAgLyoqCiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS4KICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLgogICAgICovCiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHsKICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLAogICAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddOwoKICAgICAgdHJ5IHsKICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7CiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTsKICAgICAgfSBjYXRjaCAoZSkge30KCiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTsKICAgICAgaWYgKHVubWFza2VkKSB7CiAgICAgICAgaWYgKGlzT3duKSB7CiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogICAgLyoqCiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS4KICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLgogICAgICovCiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7CiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKQogICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkKICAgICAgICA6IHt9OwogICAgfQoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC4KICAgICAqLwogICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7CiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7CgogICAgICByZXR1cm4gISFsZW5ndGggJiYKICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fAogICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJgogICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuCiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LgogICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLAogICAgICogIGVsc2UgYGZhbHNlYC4KICAgICAqLwogICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHsKICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4OwogICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJwogICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKQogICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkKICAgICAgICAgICkgewogICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLgogICAgICovCiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHsKICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpCiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKQogICAgICAgIDogKHZhbHVlID09PSBudWxsKTsKICAgIH0KCiAgICAvKioKICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHsKICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTsKICAgIH0KCiAgICAvKioKICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC4KICAgICAqLwogICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHsKICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciwKICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvOwoKICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bzsKICAgIH0KCiAgICAvKioKICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZQogICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKQogICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LgogICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4KICAgICAqLwogICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkgewogICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkgewogICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkgewogICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgICAvKioKICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LgogICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy4KICAgICAqLwogICAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHsKICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpOwogICAgfQoKICAgIC8qKgogICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by4KICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci4KICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uCiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi4KICAgICAqLwogICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkgewogICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7CiAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cywKICAgICAgICAgICAgaW5kZXggPSAtMSwKICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLAogICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7CgogICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdOwogICAgICAgIH0KICAgICAgICBpbmRleCA9IC0xOwogICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpOwogICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHsKICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTsKICAgICAgICB9CiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7CiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7CiAgICAgIH07CiAgICB9CgogICAgLyoqCiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzICJfX3Byb3RvX18iIG9yICJjb25zdHJ1Y3RvciIuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS4KICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LgogICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLgogICAgICovCiAgICBmdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7CiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICByZXR1cm4gb2JqZWN0W2tleV07CiAgICB9CgogICAgLyoqCiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LgogICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC4KICAgICAqLwogICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTsKCiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZAogICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gCiAgICAgKiBtaWxsaXNlY29uZHMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LgogICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLgogICAgICovCiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7CiAgICAgIHZhciBjb3VudCA9IDAsCiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDsKCiAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSwKICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTsKCiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wOwogICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7CiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHsKICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgY291bnQgPSAwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICB9CgogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LgogICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuCiAgICAgKi8KICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHsKICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7CiAgICAgICAgfSBjYXRjaCAoZSkge30KICAgICAgICB0cnkgewogICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpOwogICAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICAgIH0KICAgICAgcmV0dXJuICcnOwogICAgfQoKICAgIC8qKgogICAgICogUGVyZm9ybXMgYQogICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybykKICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgNC4wLjAKICAgICAqIEBjYXRlZ29yeSBMYW5nCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLgogICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuCiAgICAgKiBAZXhhbXBsZQogICAgICoKICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9OwogICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTsKICAgICAqCiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTsKICAgICAqIC8vID0+IHRydWUKICAgICAqCiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqCiAgICAgKiBfLmVxKCdhJywgJ2EnKTsKICAgICAqIC8vID0+IHRydWUKICAgICAqCiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqCiAgICAgKiBfLmVxKE5hTiwgTmFOKTsKICAgICAqIC8vID0+IHRydWUKICAgICAqLwogICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpOwogICAgfQoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDAuMS4wCiAgICAgKiBAY2F0ZWdvcnkgTGFuZwogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsCiAgICAgKiAgZWxzZSBgZmFsc2VgLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKi8KICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJgogICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7CiAgICB9OwoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDAuMS4wCiAgICAgKiBAY2F0ZWdvcnkgTGFuZwogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTsKICAgICAqIC8vID0+IHRydWUKICAgICAqCiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICoKICAgICAqIF8uaXNBcnJheSgnYWJjJyk7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICoKICAgICAqIF8uaXNBcnJheShfLm5vb3ApOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqLwogICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OwoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQncwogICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvcgogICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDQuMC4wCiAgICAgKiBAY2F0ZWdvcnkgTGFuZwogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuCiAgICAgKiBAZXhhbXBsZQogICAgICoKICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTsKICAgICAqIC8vID0+IHRydWUKICAgICAqCiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKi8KICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7CiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpOwogICAgfQoKICAgIC8qKgogICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYAogICAgICogaXMgYW4gb2JqZWN0LgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgNC4wLjAKICAgICAqIEBjYXRlZ29yeSBMYW5nCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LAogICAgICogIGVsc2UgYGZhbHNlYC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICoKICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKi8KICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7CiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTsKICAgIH0KCiAgICAvKioKICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgNC4zLjAKICAgICAqIEBjYXRlZ29yeSBMYW5nCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuCiAgICAgKiBAZXhhbXBsZQogICAgICoKICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICovCiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSAwLjEuMAogICAgICogQGNhdGVnb3J5IExhbmcKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKi8KICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsKICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yCiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLgogICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7CiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLgogICAgICoKICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uCiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgNC4wLjAKICAgICAqIEBjYXRlZ29yeSBMYW5nCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuCiAgICAgKiBAZXhhbXBsZQogICAgICoKICAgICAqIF8uaXNMZW5ndGgoMyk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKgogICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICoKICAgICAqIF8uaXNMZW5ndGgoJzMnKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKi8KICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7CiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYKICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUKICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcykKICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYCkKICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDAuMS4wCiAgICAgKiBAY2F0ZWdvcnkgTGFuZwogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogXy5pc09iamVjdCh7fSk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc09iamVjdChbMSwgMiwgM10pOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTsKICAgICAqIC8vID0+IHRydWUKICAgICAqCiAgICAgKiBfLmlzT2JqZWN0KG51bGwpOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqLwogICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGAKICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgIm9iamVjdCIuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSA0LjAuMAogICAgICogQGNhdGVnb3J5IExhbmcKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogXy5pc09iamVjdExpa2Uoe30pOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKgogICAgICogXy5pc09iamVjdExpa2UobnVsbCk7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICovCiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHsKICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnOwogICAgfQoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZQogICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgMC44LjAKICAgICAqIEBjYXRlZ29yeSBMYW5nCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuCiAgICAgKiBAZXhhbXBsZQogICAgICoKICAgICAqIGZ1bmN0aW9uIEZvbygpIHsKICAgICAqICAgdGhpcy5hID0gMTsKICAgICAqIH0KICAgICAqCiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICoKICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqCiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTsKICAgICAqIC8vID0+IHRydWUKICAgICAqCiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKi8KICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHsKICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpOwogICAgICBpZiAocHJvdG8gPT09IG51bGwpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yOwogICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJgogICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSAzLjAuMAogICAgICogQGNhdGVnb3J5IExhbmcKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc1R5cGVkQXJyYXkoW10pOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqLwogICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5OwoKICAgIC8qKgogICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZwogICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSAzLjAuMAogICAgICogQGNhdGVnb3J5IExhbmcKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBmdW5jdGlvbiBGb28oKSB7CiAgICAgKiAgIHRoaXMuYiA9IDI7CiAgICAgKiB9CiAgICAgKgogICAgICogRm9vLnByb3RvdHlwZS5jID0gMzsKICAgICAqCiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTsKICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfQogICAgICoKICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7CiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfQogICAgICovCiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7CiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTsKICAgIH0KCiAgICAvKioKICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuCiAgICAgKgogICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSAzLjAuMAogICAgICogQGNhdGVnb3J5IE9iamVjdAogICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LgogICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogZnVuY3Rpb24gRm9vKCkgewogICAgICogICB0aGlzLmEgPSAxOwogICAgICogICB0aGlzLmIgPSAyOwogICAgICogfQogICAgICoKICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7CiAgICAgKgogICAgICogXy5rZXlzSW4obmV3IEZvbyk7CiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkKICAgICAqLwogICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkgewogICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTsKICAgIH0KCiAgICAvKioKICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoCiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2UKICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlCiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czoKICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDQuMC4wCiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0CiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuCiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLgogICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHsKICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHsKICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTsKICAgICAqICAgfQogICAgICogfQogICAgICoKICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9OwogICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTsKICAgICAqCiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTsKICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH0KICAgICAqLwogICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikgewogICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTsKICAgIH0pOwoKICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgMi40LjAKICAgICAqIEBjYXRlZ29yeSBVdGlsCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLgogICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uCiAgICAgKiBAZXhhbXBsZQogICAgICoKICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTsKICAgICAqCiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTsKICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XQogICAgICoKICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pOwogICAgICogLy8gPT4gdHJ1ZQogICAgICovCiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkgewogICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICB9OwogICAgfQoKICAgIC8qKgogICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQHNpbmNlIDAuMS4wCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQGNhdGVnb3J5IFV0aWwKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLgogICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07CiAgICAgKgogICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpOwogICAgICogLy8gPT4gdHJ1ZQogICAgICovCiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWU7CiAgICB9CgogICAgLyoqCiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSA0LjEzLjAKICAgICAqIEBjYXRlZ29yeSBVdGlsCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTsKICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdCiAgICAgKi8KICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIG1vZHVsZS5leHBvcnRzID0gbWVyZ2VXaXRoOwogICAgfSk7CgogICAgZnVuY3Rpb24gbm9vcCgpIHsgfQogICAgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikgewogICAgICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTsKICAgIH0KICAgIFByb21pc2UucmVzb2x2ZSgpOwoKICAgIGNvbnN0IHN1YnNjcmliZXJfcXVldWUgPSBbXTsKICAgIC8qKgogICAgICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi4KICAgICAqIEBwYXJhbSB7Kj19dmFsdWUgaW5pdGlhbCB2YWx1ZQogICAgICogQHBhcmFtIHtTdGFydFN0b3BOb3RpZmllcj19c3RhcnQgc3RhcnQgYW5kIHN0b3Agbm90aWZpY2F0aW9ucyBmb3Igc3Vic2NyaXB0aW9ucwogICAgICovCiAgICBmdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7CiAgICAgICAgbGV0IHN0b3A7CiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7CiAgICAgICAgZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkgewogICAgICAgICAgICBpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHsKICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3X3ZhbHVlOwogICAgICAgICAgICAgICAgaWYgKHN0b3ApIHsgLy8gc3RvcmUgaXMgcmVhZHkKICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJbMV0oKTsKICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHN1YnNjcmliZXIsIHZhbHVlKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bl9xdWV1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWUubGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKGZuKSB7CiAgICAgICAgICAgIHNldChmbih2YWx1ZSkpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkgewogICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07CiAgICAgICAgICAgIHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTsKICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHsKICAgICAgICAgICAgICAgIHN0b3AgPSBzdGFydChzZXQpIHx8IG5vb3A7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcnVuKHZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuICgpID0+IHsKICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTsKICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgc3RvcCgpOwogICAgICAgICAgICAgICAgICAgIHN0b3AgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07CiAgICB9CgogICAgY29uc3QgcHJvcGVydHlWYWx1ZUNvbWJvTGltaXRTdG9yZSA9IHdyaXRhYmxlKDEwKTsKCiAgICB2YXIgJHZlcnNpb24gPSA4OwogICAgdmFyICRyb290ID0gewogICAgCXZlcnNpb246IHsKICAgIAkJcmVxdWlyZWQ6IHRydWUsCiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiBbCiAgICAJCQk4CiAgICAJCV0sCiAgICAJCWRvYzogIlN0eWxlIHNwZWNpZmljYXRpb24gdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgOC4iLAogICAgCQlleGFtcGxlOiA4CiAgICAJfSwKICAgIAluYW1lOiB7CiAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJBIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBzdHlsZS4iLAogICAgCQlleGFtcGxlOiAiQnJpZ2h0IgogICAgCX0sCiAgICAJbWV0YWRhdGE6IHsKICAgIAkJdHlwZTogIioiLAogICAgCQlkb2M6ICJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgc3R5bGVzaGVldCwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy4iCiAgICAJfSwKICAgIAljZW50ZXI6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQlkb2M6ICJEZWZhdWx0IG1hcCBjZW50ZXIgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS4gIFRoZSBzdHlsZSBjZW50ZXIgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS4iLAogICAgCQlleGFtcGxlOiBbCiAgICAJCQktNzMuOTc0OSwKICAgIAkJCTQwLjc3MzYKICAgIAkJXQogICAgCX0sCiAgICAJem9vbTogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiRGVmYXVsdCB6b29tIGxldmVsLiAgVGhlIHN0eWxlIHpvb20gd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS4iLAogICAgCQlleGFtcGxlOiAxMi41CiAgICAJfSwKICAgIAliZWFyaW5nOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCXBlcmlvZDogMzYwLAogICAgCQl1bml0czogImRlZ3JlZXMiLAogICAgCQlkb2M6ICJEZWZhdWx0IGJlYXJpbmcsIGluIGRlZ3JlZXMuIFRoZSBiZWFyaW5nIGlzIHRoZSBjb21wYXNzIGRpcmVjdGlvbiB0aGF0IGlzIFwidXBcIjsgZm9yIGV4YW1wbGUsIGEgYmVhcmluZyBvZiA5MMKwIG9yaWVudHMgdGhlIG1hcCBzbyB0aGF0IGVhc3QgaXMgdXAuIFRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS4iLAogICAgCQlleGFtcGxlOiAyOQogICAgCX0sCiAgICAJcGl0Y2g6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMCwKICAgIAkJdW5pdHM6ICJkZWdyZWVzIiwKICAgIAkJZG9jOiAiRGVmYXVsdCBwaXRjaCwgaW4gZGVncmVlcy4gWmVybyBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBzdXJmYWNlLCBmb3IgYSBsb29rIHN0cmFpZ2h0IGRvd24gYXQgdGhlIG1hcCwgd2hpbGUgYSBncmVhdGVyIHZhbHVlIGxpa2UgNjAgbG9va3MgYWhlYWQgdG93YXJkcyB0aGUgaG9yaXpvbi4gVGhlIHN0eWxlIHBpdGNoIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuIiwKICAgIAkJZXhhbXBsZTogNTAKICAgIAl9LAogICAgCWxpZ2h0OiB7CiAgICAJCXR5cGU6ICJsaWdodCIsCiAgICAJCWRvYzogIlRoZSBnbG9iYWwgbGlnaHQgc291cmNlLiIsCiAgICAJCWV4YW1wbGU6IHsKICAgIAkJCWFuY2hvcjogInZpZXdwb3J0IiwKICAgIAkJCWNvbG9yOiAid2hpdGUiLAogICAgCQkJaW50ZW5zaXR5OiAwLjQKICAgIAkJfQogICAgCX0sCiAgICAJdGVycmFpbjogewogICAgCQl0eXBlOiAidGVycmFpbiIsCiAgICAJCWRvYzogIkEgZ2xvYmFsIG1vZGlmaWVyIHRoYXQgZWxldmF0ZXMgbGF5ZXJzIGFuZCBtYXJrZXJzIGJhc2VkIG9uIGEgREVNIGRhdGEgc291cmNlLiIKICAgIAl9LAogICAgCWZvZzogewogICAgCQl0eXBlOiAiZm9nIiwKICAgIAkJZG9jOiAiQSBnbG9iYWwgZWZmZWN0IHRoYXQgZmFkZXMgbGF5ZXJzIGFuZCBtYXJrZXJzIGJhc2VkIG9uIHRoZWlyIGRpc3RhbmNlIHRvIHRoZSBjYW1lcmEuIFRoZSBmb2cgY2FuIGJlIHVzZWQgdG8gYXBwcm94aW1hdGUgdGhlIGVmZmVjdCBvZiBhdG1vc3BoZXJlIG9uIGRpc3RhbnQgb2JqZWN0cyBhbmQgZW5oYW5jZSB0aGUgZGVwdGggcGVyY2VwdGlvbiBvZiB0aGUgbWFwIHdoZW4gdXNlZCB3aXRoIHRlcnJhaW4gb3IgM0QgZmVhdHVyZXMuIE5vdGU6IGZvZyBpcyByZW5hbWVkIHRvIGF0bW9zcGhlcmUgaW4gdGhlIEFuZHJvaWQgYW5kIGlPUyBTREtzIGFuZCBwbGFubmVkIHRvIGJlIGNoYW5nZWQgaW4gR0wtSlMgdi4zLjAuMC4iCiAgICAJfSwKICAgIAlzb3VyY2VzOiB7CiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQl0eXBlOiAic291cmNlcyIsCiAgICAJCWRvYzogIkRhdGEgc291cmNlIHNwZWNpZmljYXRpb25zLiIsCiAgICAJCWV4YW1wbGU6IHsKICAgIAkJCSJtYXBib3gtc3RyZWV0cyI6IHsKICAgIAkJCQl0eXBlOiAidmVjdG9yIiwKICAgIAkJCQl1cmw6ICJtYXBib3g6Ly9tYXBib3gubWFwYm94LXN0cmVldHMtdjYiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9LAogICAgCXNwcml0ZTogewogICAgCQl0eXBlOiAic3RyaW5nIiwKICAgIAkJZG9jOiAiQSBiYXNlIFVSTCBmb3IgcmV0cmlldmluZyB0aGUgc3ByaXRlIGltYWdlIGFuZCBtZXRhZGF0YS4gVGhlIGV4dGVuc2lvbnMgYC5wbmdgLCBgLmpzb25gIGFuZCBzY2FsZSBmYWN0b3IgYEAyeC5wbmdgIHdpbGwgYmUgYXV0b21hdGljYWxseSBhcHBlbmRlZC4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgYGJhY2tncm91bmQtcGF0dGVybmAsIGBmaWxsLXBhdHRlcm5gLCBgbGluZS1wYXR0ZXJuYCwgYGZpbGwtZXh0cnVzaW9uLXBhdHRlcm5gLCBvciBgaWNvbi1pbWFnZWAgcHJvcGVydGllcy4gVGhlIFVSTCBtdXN0IGJlIGFic29sdXRlLCBjb250YWluaW5nIHRoZSBbc2NoZW1lLCBhdXRob3JpdHkgYW5kIHBhdGggY29tcG9uZW50c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJMI1N5bnRheCkuIiwKICAgIAkJZXhhbXBsZTogIm1hcGJveDovL3Nwcml0ZXMvbWFwYm94L2JyaWdodC12OCIKICAgIAl9LAogICAgCWdseXBoczogewogICAgCQl0eXBlOiAic3RyaW5nIiwKICAgIAkJZG9jOiAiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVGhlIFVSTCBtdXN0IGluY2x1ZGUgYHtmb250c3RhY2t9YCBhbmQgYHtyYW5nZX1gIHRva2Vucy4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgYHRleHQtZmllbGRgIGxheW91dCBwcm9wZXJ0eS4gVGhlIFVSTCBtdXN0IGJlIGFic29sdXRlLCBjb250YWluaW5nIHRoZSBbc2NoZW1lLCBhdXRob3JpdHkgYW5kIHBhdGggY29tcG9uZW50c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJMI1N5bnRheCkuIiwKICAgIAkJZXhhbXBsZTogIm1hcGJveDovL2ZvbnRzL21hcGJveC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZiIKICAgIAl9LAogICAgCXRyYW5zaXRpb246IHsKICAgIAkJdHlwZTogInRyYW5zaXRpb24iLAogICAgCQlkb2M6ICJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcywgdG8gYmUgdXNlZCBmb3IgdGltaW5nIHRyYW5zaXRpb25zIGJldHdlZW4gb25lIHZhbHVlIGFuZCB0aGUgbmV4dCB3aGVuIG5vIHByb3BlcnR5LXNwZWNpZmljIHRyYW5zaXRpb24gaXMgc2V0LiBDb2xsaXNpb24tYmFzZWQgc3ltYm9sIGZhZGluZyBpcyBjb250cm9sbGVkIGluZGVwZW5kZW50bHkgb2YgdGhlIHN0eWxlJ3MgYHRyYW5zaXRpb25gIHByb3BlcnR5LiIsCiAgICAJCWV4YW1wbGU6IHsKICAgIAkJCWR1cmF0aW9uOiAzMDAsCiAgICAJCQlkZWxheTogMAogICAgCQl9CiAgICAJfSwKICAgIAlwcm9qZWN0aW9uOiB7CiAgICAJCXR5cGU6ICJwcm9qZWN0aW9uIiwKICAgIAkJZG9jOiAiVGhlIHByb2plY3Rpb24gdGhlIG1hcCBzaG91bGQgYmUgcmVuZGVyZWQgaW4uIFN1cHBvcnRlZCBwcm9qZWN0aW9ucyBhcmUgTWVyY2F0b3IsIEdsb2JlLCBBbGJlcnMsIEVxdWFsIEVhcnRoLCBFcXVpcmVjdGFuZ3VsYXIgKFdHUzg0KSwgTGFtYmVydCBjb25mb3JtYWwgY29uaWMsIE5hdHVyYWwgRWFydGgsIGFuZCBXaW5rZWwgVHJpcGVsLiBUZXJyYWluLCBza3kgYW5kIGZvZyBhcmUgc3VwcG9ydGVkIGJ5IG9ubHkgTWVyY2F0b3IgYW5kIGdsb2JlLiBDdXN0b21MYXllckludGVyZmFjZSBpcyBub3Qgc3VwcG9ydGVkIG91dHNpZGUgb2YgTWVyY2F0b3IuIiwKICAgIAkJZXhhbXBsZTogewogICAgCQkJbmFtZTogImFsYmVycyIsCiAgICAJCQljZW50ZXI6IFsKICAgIAkJCQktMTU0LAogICAgCQkJCTUwCiAgICAJCQldLAogICAgCQkJcGFyYWxsZWxzOiBbCiAgICAJCQkJNTUsCiAgICAJCQkJNjUKICAgIAkJCV0KICAgIAkJfQogICAgCX0sCiAgICAJbGF5ZXJzOiB7CiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogImxheWVyIiwKICAgIAkJZG9jOiAiTGF5ZXJzIHdpbGwgYmUgZHJhd24gaW4gdGhlIG9yZGVyIG9mIHRoaXMgYXJyYXkuIiwKICAgIAkJZXhhbXBsZTogWwogICAgCQkJewogICAgCQkJCWlkOiAid2F0ZXIiLAogICAgCQkJCXNvdXJjZTogIm1hcGJveC1zdHJlZXRzIiwKICAgIAkJCQkic291cmNlLWxheWVyIjogIndhdGVyIiwKICAgIAkJCQl0eXBlOiAiZmlsbCIsCiAgICAJCQkJcGFpbnQ6IHsKICAgIAkJCQkJImZpbGwtY29sb3IiOiAiIzAwZmZmZiIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCV0KICAgIAl9CiAgICB9OwogICAgdmFyIHNvdXJjZXMgPSB7CiAgICAJIioiOiB7CiAgICAJCXR5cGU6ICJzb3VyY2UiLAogICAgCQlkb2M6ICJTcGVjaWZpY2F0aW9uIG9mIGEgZGF0YSBzb3VyY2UuIEZvciB2ZWN0b3IgYW5kIHJhc3RlciBzb3VyY2VzLCBlaXRoZXIgVGlsZUpTT04gb3IgYSBVUkwgdG8gYSBUaWxlSlNPTiBtdXN0IGJlIHByb3ZpZGVkLiBGb3IgaW1hZ2UgYW5kIHZpZGVvIHNvdXJjZXMsIGEgVVJMIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIHNvdXJjZXMsIGEgVVJMIG9yIGlubGluZSBHZW9KU09OIG11c3QgYmUgcHJvdmlkZWQuIgogICAgCX0KICAgIH07CiAgICB2YXIgc291cmNlID0gWwogICAgCSJzb3VyY2VfdmVjdG9yIiwKICAgIAkic291cmNlX3Jhc3RlciIsCiAgICAJInNvdXJjZV9yYXN0ZXJfZGVtIiwKICAgIAkic291cmNlX2dlb2pzb24iLAogICAgCSJzb3VyY2VfdmlkZW8iLAogICAgCSJzb3VyY2VfaW1hZ2UiCiAgICBdOwogICAgdmFyIHNvdXJjZV92ZWN0b3IgPSB7CiAgICAJdHlwZTogewogICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXZlY3RvcjogewogICAgCQkJCWRvYzogIkEgdmVjdG9yIHRpbGUgc291cmNlLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZG9jOiAiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS4iCiAgICAJfSwKICAgIAl1cmw6IHsKICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAJCWRvYzogIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxUaWxlc2V0IElEPmAuIgogICAgCX0sCiAgICAJdGlsZXM6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4iCiAgICAJfSwKICAgIAlib3VuZHM6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQlsZW5ndGg6IDQsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJLTE4MCwKICAgIAkJCS04NS4wNTExMjksCiAgICAJCQkxODAsCiAgICAJCQk4NS4wNTExMjkKICAgIAkJXSwKICAgIAkJZG9jOiAiQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBvZiB0aGUgc291dGh3ZXN0IGFuZCBub3J0aGVhc3QgY29ybmVycyBvZiB0aGUgc291cmNlJ3MgYm91bmRpbmcgYm94IGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6IGBbc3cubG5nLCBzdy5sYXQsIG5lLmxuZywgbmUubGF0XWAuIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBpbmNsdWRlZCBpbiBhIHNvdXJjZSwgbm8gdGlsZXMgb3V0c2lkZSBvZiB0aGUgZ2l2ZW4gYm91bmRzIGFyZSByZXF1ZXN0ZWQgYnkgTWFwYm94IEdMLiIKICAgIAl9LAogICAgCXNjaGVtZTogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJeHl6OiB7CiAgICAJCQkJZG9jOiAiU2xpcHB5IG1hcCB0aWxlbmFtZXMgc2NoZW1lLiIKICAgIAkJCX0sCiAgICAJCQl0bXM6IHsKICAgIAkJCQlkb2M6ICJPU0dlbyBzcGVjIHNjaGVtZS4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogInh5eiIsCiAgICAJCWRvYzogIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuIgogICAgCX0sCiAgICAJbWluem9vbTogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQlkb2M6ICJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiIKICAgIAl9LAogICAgCW1heHpvb206IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMjIsCiAgICAJCWRvYzogIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuIgogICAgCX0sCiAgICAJYXR0cmlidXRpb246IHsKICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAJCWRvYzogIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLiIKICAgIAl9LAogICAgCXByb21vdGVJZDogewogICAgCQl0eXBlOiAicHJvbW90ZUlkIiwKICAgIAkJZG9jOiAiQSBwcm9wZXJ0eSB0byB1c2UgYXMgYSBmZWF0dXJlIGlkIChmb3IgZmVhdHVyZSBzdGF0ZSkuIEVpdGhlciBhIHByb3BlcnR5IG5hbWUsIG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBgezxzb3VyY2VMYXllcj46IDxwcm9wZXJ0eU5hbWU+fWAuIElmIHNwZWNpZmllZCBhcyBhIHN0cmluZyBmb3IgYSB2ZWN0b3IgdGlsZSBzb3VyY2UsIHRoZSBzYW1lIHByb3BlcnR5IGlzIHVzZWQgYWNyb3NzIGFsbCBpdHMgc291cmNlIGxheWVycy4iCiAgICAJfSwKICAgIAl2b2xhdGlsZTogewogICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJCWRvYzogIkEgc2V0dGluZyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNvdXJjZSdzIHRpbGVzIGFyZSBjYWNoZWQgbG9jYWxseS4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlhbmRyb2lkOiAiOS4zLjAiLAogICAgCQkJCWlvczogIjUuMTAuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0sCiAgICAJIioiOiB7CiAgICAJCXR5cGU6ICIqIiwKICAgIAkJZG9jOiAiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLiIKICAgIAl9CiAgICB9OwogICAgdmFyIHNvdXJjZV9yYXN0ZXIgPSB7CiAgICAJdHlwZTogewogICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXJhc3RlcjogewogICAgCQkJCWRvYzogIkEgcmFzdGVyIHRpbGUgc291cmNlLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZG9jOiAiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS4iCiAgICAJfSwKICAgIAl1cmw6IHsKICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAJCWRvYzogIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxUaWxlc2V0IElEPmAuIgogICAgCX0sCiAgICAJdGlsZXM6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4iCiAgICAJfSwKICAgIAlib3VuZHM6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQlsZW5ndGg6IDQsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJLTE4MCwKICAgIAkJCS04NS4wNTExMjksCiAgICAJCQkxODAsCiAgICAJCQk4NS4wNTExMjkKICAgIAkJXSwKICAgIAkJZG9jOiAiQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBvZiB0aGUgc291dGh3ZXN0IGFuZCBub3J0aGVhc3QgY29ybmVycyBvZiB0aGUgc291cmNlJ3MgYm91bmRpbmcgYm94IGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6IGBbc3cubG5nLCBzdy5sYXQsIG5lLmxuZywgbmUubGF0XWAuIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBpbmNsdWRlZCBpbiBhIHNvdXJjZSwgbm8gdGlsZXMgb3V0c2lkZSBvZiB0aGUgZ2l2ZW4gYm91bmRzIGFyZSByZXF1ZXN0ZWQgYnkgTWFwYm94IEdMLiIKICAgIAl9LAogICAgCW1pbnpvb206IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMCwKICAgIAkJZG9jOiAiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4iCiAgICAJfSwKICAgIAltYXh6b29tOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDIyLAogICAgCQlkb2M6ICJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLiIKICAgIAl9LAogICAgCXRpbGVTaXplOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDUxMiwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy4iCiAgICAJfSwKICAgIAlzY2hlbWU6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXh5ejogewogICAgCQkJCWRvYzogIlNsaXBweSBtYXAgdGlsZW5hbWVzIHNjaGVtZS4iCiAgICAJCQl9LAogICAgCQkJdG1zOiB7CiAgICAJCQkJZG9jOiAiT1NHZW8gc3BlYyBzY2hlbWUuIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJ4eXoiLAogICAgCQlkb2M6ICJJbmZsdWVuY2VzIHRoZSB5IGRpcmVjdGlvbiBvZiB0aGUgdGlsZSBjb29yZGluYXRlcy4gVGhlIGdsb2JhbC1tZXJjYXRvciAoYWthIFNwaGVyaWNhbCBNZXJjYXRvcikgcHJvZmlsZSBpcyBhc3N1bWVkLiIKICAgIAl9LAogICAgCWF0dHJpYnV0aW9uOiB7CiAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJDb250YWlucyBhbiBhdHRyaWJ1dGlvbiB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgbWFwIGlzIHNob3duIHRvIGEgdXNlci4iCiAgICAJfSwKICAgIAl2b2xhdGlsZTogewogICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJCWRvYzogIkEgc2V0dGluZyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNvdXJjZSdzIHRpbGVzIGFyZSBjYWNoZWQgbG9jYWxseS4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlhbmRyb2lkOiAiOS4zLjAiLAogICAgCQkJCWlvczogIjUuMTAuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0sCiAgICAJIioiOiB7CiAgICAJCXR5cGU6ICIqIiwKICAgIAkJZG9jOiAiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLiIKICAgIAl9CiAgICB9OwogICAgdmFyIHNvdXJjZV9yYXN0ZXJfZGVtID0gewogICAgCXR5cGU6IHsKICAgIAkJcmVxdWlyZWQ6IHRydWUsCiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQkicmFzdGVyLWRlbSI6IHsKICAgIAkJCQlkb2M6ICJBIFJHQi1lbmNvZGVkIHJhc3RlciBERU0gc291cmNlIgogICAgCQkJfQogICAgCQl9LAogICAgCQlkb2M6ICJUaGUgdHlwZSBvZiB0aGUgc291cmNlLiIKICAgIAl9LAogICAgCXVybDogewogICAgCQl0eXBlOiAic3RyaW5nIiwKICAgIAkJZG9jOiAiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPFRpbGVzZXQgSUQ+YC4iCiAgICAJfSwKICAgIAl0aWxlczogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogInN0cmluZyIsCiAgICAJCWRvYzogIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiIKICAgIAl9LAogICAgCWJvdW5kczogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAJCWxlbmd0aDogNCwKICAgIAkJImRlZmF1bHQiOiBbCiAgICAJCQktMTgwLAogICAgCQkJLTg1LjA1MTEyOSwKICAgIAkJCTE4MCwKICAgIAkJCTg1LjA1MTEyOQogICAgCQldLAogICAgCQlkb2M6ICJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuIgogICAgCX0sCiAgICAJbWluem9vbTogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQlkb2M6ICJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiIKICAgIAl9LAogICAgCW1heHpvb206IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMjIsCiAgICAJCWRvYzogIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuIgogICAgCX0sCiAgICAJdGlsZVNpemU6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogNTEyLAogICAgCQl1bml0czogInBpeGVscyIsCiAgICAJCWRvYzogIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLiIKICAgIAl9LAogICAgCWF0dHJpYnV0aW9uOiB7CiAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJDb250YWlucyBhbiBhdHRyaWJ1dGlvbiB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgbWFwIGlzIHNob3duIHRvIGEgdXNlci4iCiAgICAJfSwKICAgIAllbmNvZGluZzogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJdGVycmFyaXVtOiB7CiAgICAJCQkJZG9jOiAiVGVycmFyaXVtIGZvcm1hdCBQTkcgdGlsZXMuIFNlZSBodHRwczovL2F3cy5hbWF6b24uY29tL2VzL3B1YmxpYy1kYXRhc2V0cy90ZXJyYWluLyBmb3IgbW9yZSBpbmZvLiIKICAgIAkJCX0sCiAgICAJCQltYXBib3g6IHsKICAgIAkJCQlkb2M6ICJNYXBib3ggVGVycmFpbiBSR0IgdGlsZXMuIFNlZSBodHRwczovL3d3dy5tYXBib3guY29tL2hlbHAvYWNjZXNzLWVsZXZhdGlvbi1kYXRhLyNtYXBib3gtdGVycmFpbi1yZ2IgZm9yIG1vcmUgaW5mby4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogIm1hcGJveCIsCiAgICAJCWRvYzogIlRoZSBlbmNvZGluZyB1c2VkIGJ5IHRoaXMgc291cmNlLiBNYXBib3ggVGVycmFpbiBSR0IgaXMgdXNlZCBieSBkZWZhdWx0IgogICAgCX0sCiAgICAJdm9sYXRpbGU6IHsKICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgCQlkb2M6ICJBIHNldHRpbmcgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzb3VyY2UncyB0aWxlcyBhcmUgY2FjaGVkIGxvY2FsbHkuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJYW5kcm9pZDogIjkuMy4wIiwKICAgIAkJCQlpb3M6ICI1LjEwLjAiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9LAogICAgCSIqIjogewogICAgCQl0eXBlOiAiKiIsCiAgICAJCWRvYzogIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS4iCiAgICAJfQogICAgfTsKICAgIHZhciBzb3VyY2VfZ2VvanNvbiA9IHsKICAgIAl0eXBlOiB7CiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJZ2VvanNvbjogewogICAgCQkJCWRvYzogIkEgR2VvSlNPTiBkYXRhIHNvdXJjZS4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWRvYzogIlRoZSBkYXRhIHR5cGUgb2YgdGhlIEdlb0pTT04gc291cmNlLiIKICAgIAl9LAogICAgCWRhdGE6IHsKICAgIAkJdHlwZTogIioiLAogICAgCQlkb2M6ICJBIFVSTCB0byBhIEdlb0pTT04gZmlsZSwgb3IgaW5saW5lIEdlb0pTT04uIgogICAgCX0sCiAgICAJbWF4em9vbTogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxOCwKICAgIAkJZG9jOiAiTWF4aW11bSB6b29tIGxldmVsIGF0IHdoaWNoIHRvIGNyZWF0ZSB2ZWN0b3IgdGlsZXMgKGhpZ2hlciBtZWFucyBncmVhdGVyIGRldGFpbCBhdCBoaWdoIHpvb20gbGV2ZWxzKS4iCiAgICAJfSwKICAgIAlhdHRyaWJ1dGlvbjogewogICAgCQl0eXBlOiAic3RyaW5nIiwKICAgIAkJZG9jOiAiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuIgogICAgCX0sCiAgICAJYnVmZmVyOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDEyOCwKICAgIAkJbWF4aW11bTogNTEyLAogICAgCQltaW5pbXVtOiAwLAogICAgCQlkb2M6ICJTaXplIG9mIHRoZSB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGUuIEEgdmFsdWUgb2YgMCBwcm9kdWNlcyBubyBidWZmZXIuIEEgdmFsdWUgb2YgNTEyIHByb2R1Y2VzIGEgYnVmZmVyIGFzIHdpZGUgYXMgdGhlIHRpbGUgaXRzZWxmLiBMYXJnZXIgdmFsdWVzIHByb2R1Y2UgZmV3ZXIgcmVuZGVyaW5nIGFydGlmYWN0cyBuZWFyIHRpbGUgZWRnZXMgYW5kIHNsb3dlciBwZXJmb3JtYW5jZS4iCiAgICAJfSwKICAgIAlmaWx0ZXI6IHsKICAgIAkJdHlwZTogIioiLAogICAgCQlkb2M6ICJBbiBleHByZXNzaW9uIGZvciBmaWx0ZXJpbmcgZmVhdHVyZXMgcHJpb3IgdG8gcHJvY2Vzc2luZyB0aGVtIGZvciByZW5kZXJpbmcuIgogICAgCX0sCiAgICAJdG9sZXJhbmNlOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAuMzc1LAogICAgCQlkb2M6ICJEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlciBnZW9tZXRyaWVzIGFuZCBmYXN0ZXIgcGVyZm9ybWFuY2UpLiIKICAgIAl9LAogICAgCWNsdXN0ZXI6IHsKICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgCQlkb2M6ICJJZiB0aGUgZGF0YSBpcyBhIGNvbGxlY3Rpb24gb2YgcG9pbnQgZmVhdHVyZXMsIHNldHRpbmcgdGhpcyB0byB0cnVlIGNsdXN0ZXJzIHRoZSBwb2ludHMgYnkgcmFkaXVzIGludG8gZ3JvdXBzLiBDbHVzdGVyIGdyb3VwcyBiZWNvbWUgbmV3IGBQb2ludGAgZmVhdHVyZXMgaW4gdGhlIHNvdXJjZSB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllczpcbiAqIGBjbHVzdGVyYCBJcyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGEgY2x1c3RlciBcbiAqIGBjbHVzdGVyX2lkYCBBIHVucWl1ZSBpZCBmb3IgdGhlIGNsdXN0ZXIgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBbY2x1c3RlciBpbnNwZWN0aW9uIG1ldGhvZHNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jZ2VvanNvbnNvdXJjZSNnZXRjbHVzdGVyZXhwYW5zaW9uem9vbSlcbiAqIGBwb2ludF9jb3VudGAgTnVtYmVyIG9mIG9yaWdpbmFsIHBvaW50cyBncm91cGVkIGludG8gdGhpcyBjbHVzdGVyXG4gKiBgcG9pbnRfY291bnRfYWJicmV2aWF0ZWRgIEFuIGFiYnJldmlhdGVkIHBvaW50IGNvdW50IgogICAgCX0sCiAgICAJY2x1c3RlclJhZGl1czogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiA1MCwKICAgIAkJbWluaW11bTogMCwKICAgIAkJZG9jOiAiUmFkaXVzIG9mIGVhY2ggY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIEEgdmFsdWUgb2YgNTEyIGluZGljYXRlcyBhIHJhZGl1cyBlcXVhbCB0byB0aGUgd2lkdGggb2YgYSB0aWxlLiIKICAgIAl9LAogICAgCWNsdXN0ZXJNYXhab29tOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQlkb2M6ICJNYXggem9vbSBvbiB3aGljaCB0byBjbHVzdGVyIHBvaW50cyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIERlZmF1bHRzIHRvIG9uZSB6b29tIGxlc3MgdGhhbiBtYXh6b29tIChzbyB0aGF0IGxhc3Qgem9vbSBmZWF0dXJlcyBhcmUgbm90IGNsdXN0ZXJlZCkuIENsdXN0ZXJzIGFyZSByZS1ldmFsdWF0ZWQgYXQgaW50ZWdlciB6b29tIGxldmVscyBzbyBzZXR0aW5nIGNsdXN0ZXJNYXhab29tIHRvIDE0IG1lYW5zIHRoZSBjbHVzdGVycyB3aWxsIGJlIGRpc3BsYXllZCB1bnRpbCB6MTUuIgogICAgCX0sCiAgICAJY2x1c3Rlck1pblBvaW50czogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiTWluaW11bSBudW1iZXIgb2YgcG9pbnRzIG5lY2Vzc2FyeSB0byBmb3JtIGEgY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIERlZmF1bHRzIHRvIGAyYC4iCiAgICAJfSwKICAgIAljbHVzdGVyUHJvcGVydGllczogewogICAgCQl0eXBlOiAiKiIsCiAgICAJCWRvYzogIkFuIG9iamVjdCBkZWZpbmluZyBjdXN0b20gcHJvcGVydGllcyBvbiB0aGUgZ2VuZXJhdGVkIGNsdXN0ZXJzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZCwgYWdncmVnYXRpbmcgdmFsdWVzIGZyb20gY2x1c3RlcmVkIHBvaW50cy4gSGFzIHRoZSBmb3JtIGB7XCJwcm9wZXJ0eV9uYW1lXCI6IFtvcGVyYXRvciwgbWFwX2V4cHJlc3Npb25dfWAuIGBvcGVyYXRvcmAgaXMgYW55IGV4cHJlc3Npb24gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGF0IGxlYXN0IDIgb3BlcmFuZHMgKGUuZy4gYFwiK1wiYCBvciBgXCJtYXhcImApIOKAlCBpdCBhY2N1bXVsYXRlcyB0aGUgcHJvcGVydHkgdmFsdWUgZnJvbSBjbHVzdGVycy9wb2ludHMgdGhlIGNsdXN0ZXIgY29udGFpbnM7IGBtYXBfZXhwcmVzc2lvbmAgcHJvZHVjZXMgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIHBvaW50LlxuXG5FeGFtcGxlOiBge1wic3VtXCI6IFtcIitcIiwgW1wiZ2V0XCIsIFwic2NhbGVyYW5rXCJdXX1gLlxuXG5Gb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIGluIHBsYWNlIG9mIGBvcGVyYXRvcmAsIHlvdSBjYW4gdXNlIGEgY3VzdG9tIHJlZHVjZSBleHByZXNzaW9uIHRoYXQgcmVmZXJlbmNlcyBhIHNwZWNpYWwgYFtcImFjY3VtdWxhdGVkXCJdYCB2YWx1ZSwgZS5nLjpcbmB7XCJzdW1cIjogW1tcIitcIiwgW1wiYWNjdW11bGF0ZWRcIl0sIFtcImdldFwiLCBcInN1bVwiXV0sIFtcImdldFwiLCBcInNjYWxlcmFua1wiXV19YCIKICAgIAl9LAogICAgCWxpbmVNZXRyaWNzOiB7CiAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgIAkJZG9jOiAiV2hldGhlciB0byBjYWxjdWxhdGUgbGluZSBkaXN0YW5jZSBtZXRyaWNzLiBUaGlzIGlzIHJlcXVpcmVkIGZvciBsaW5lIGxheWVycyB0aGF0IHNwZWNpZnkgYGxpbmUtZ3JhZGllbnRgIHZhbHVlcy4iCiAgICAJfSwKICAgIAlnZW5lcmF0ZUlkOiB7CiAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgIAkJZG9jOiAiV2hldGhlciB0byBnZW5lcmF0ZSBpZHMgZm9yIHRoZSBnZW9qc29uIGZlYXR1cmVzLiBXaGVuIGVuYWJsZWQsIHRoZSBgZmVhdHVyZS5pZGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvIGFzc2lnbmVkIGJhc2VkIG9uIGl0cyBpbmRleCBpbiB0aGUgYGZlYXR1cmVzYCBhcnJheSwgb3Zlci13cml0aW5nIGFueSBwcmV2aW91cyB2YWx1ZXMuIgogICAgCX0sCiAgICAJcHJvbW90ZUlkOiB7CiAgICAJCXR5cGU6ICJwcm9tb3RlSWQiLAogICAgCQlkb2M6ICJBIHByb3BlcnR5IHRvIHVzZSBhcyBhIGZlYXR1cmUgaWQgKGZvciBmZWF0dXJlIHN0YXRlKS4gRWl0aGVyIGEgcHJvcGVydHkgbmFtZSwgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7PHNvdXJjZUxheWVyPjogPHByb3BlcnR5TmFtZT59YC4iCiAgICAJfQogICAgfTsKICAgIHZhciBzb3VyY2VfdmlkZW8gPSB7CiAgICAJdHlwZTogewogICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXZpZGVvOiB7CiAgICAJCQkJZG9jOiAiQSB2aWRlbyBkYXRhIHNvdXJjZS4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWRvYzogIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHZpZGVvIHNvdXJjZS4iCiAgICAJfSwKICAgIAl1cmxzOiB7CiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogInN0cmluZyIsCiAgICAJCWRvYzogIlVSTHMgdG8gdmlkZW8gY29udGVudCBpbiBvcmRlciBvZiBwcmVmZXJyZWQgZm9ybWF0LiIKICAgIAl9LAogICAgCWNvb3JkaW5hdGVzOiB7CiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQlkb2M6ICJDb3JuZXJzIG9mIHZpZGVvIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLiIsCiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCWxlbmd0aDogNCwKICAgIAkJdmFsdWU6IHsKICAgIAkJCXR5cGU6ICJhcnJheSIsCiAgICAJCQlsZW5ndGg6IDIsCiAgICAJCQl2YWx1ZTogIm51bWJlciIsCiAgICAJCQlkb2M6ICJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuIgogICAgCQl9CiAgICAJfQogICAgfTsKICAgIHZhciBzb3VyY2VfaW1hZ2UgPSB7CiAgICAJdHlwZTogewogICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWltYWdlOiB7CiAgICAJCQkJZG9jOiAiQW4gaW1hZ2UgZGF0YSBzb3VyY2UuIgogICAgCQkJfQogICAgCQl9LAogICAgCQlkb2M6ICJUaGUgZGF0YSB0eXBlIG9mIHRoZSBpbWFnZSBzb3VyY2UuIgogICAgCX0sCiAgICAJdXJsOiB7CiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQl0eXBlOiAic3RyaW5nIiwKICAgIAkJZG9jOiAiVVJMIHRoYXQgcG9pbnRzIHRvIGFuIGltYWdlLiIKICAgIAl9LAogICAgCWNvb3JkaW5hdGVzOiB7CiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQlkb2M6ICJDb3JuZXJzIG9mIGltYWdlIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLiIsCiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCWxlbmd0aDogNCwKICAgIAkJdmFsdWU6IHsKICAgIAkJCXR5cGU6ICJhcnJheSIsCiAgICAJCQlsZW5ndGg6IDIsCiAgICAJCQl2YWx1ZTogIm51bWJlciIsCiAgICAJCQlkb2M6ICJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuIgogICAgCQl9CiAgICAJfQogICAgfTsKICAgIHZhciBsYXllciA9IHsKICAgIAlpZDogewogICAgCQl0eXBlOiAic3RyaW5nIiwKICAgIAkJZG9jOiAiVW5pcXVlIGxheWVyIG5hbWUuIiwKICAgIAkJcmVxdWlyZWQ6IHRydWUKICAgIAl9LAogICAgCXR5cGU6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWZpbGw6IHsKICAgIAkJCQlkb2M6ICJBIGZpbGxlZCBwb2x5Z29uIHdpdGggYW4gb3B0aW9uYWwgc3Ryb2tlZCBib3JkZXIuIiwKICAgIAkJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQkJCX0KICAgIAkJCQl9CiAgICAJCQl9LAogICAgCQkJbGluZTogewogICAgCQkJCWRvYzogIkEgc3Ryb2tlZCBsaW5lLiIsCiAgICAJCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJCQltYWNvczogIjAuMS4wIgogICAgCQkJCQl9CiAgICAJCQkJfQogICAgCQkJfSwKICAgIAkJCXN5bWJvbDogewogICAgCQkJCWRvYzogIkFuIGljb24gb3IgYSB0ZXh0IGxhYmVsLiIsCiAgICAJCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJCQltYWNvczogIjAuMS4wIgogICAgCQkJCQl9CiAgICAJCQkJfQogICAgCQkJfSwKICAgIAkJCWNpcmNsZTogewogICAgCQkJCWRvYzogIkEgZmlsbGVkIGNpcmNsZS4iLAogICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCQkJfQogICAgCQkJCX0KICAgIAkJCX0sCiAgICAJCQloZWF0bWFwOiB7CiAgICAJCQkJZG9jOiAiQSBoZWF0bWFwLiIsCiAgICAJCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCQl9CiAgICAJCQkJfQogICAgCQkJfSwKICAgIAkJCSJmaWxsLWV4dHJ1c2lvbiI6IHsKICAgIAkJCQlkb2M6ICJBbiBleHRydWRlZCAoM0QpIHBvbHlnb24uIiwKICAgIAkJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQkJanM6ICIwLjI3LjAiLAogICAgCQkJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgIAkJCQkJCWlvczogIjMuNi4wIiwKICAgIAkJCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQkJCX0KICAgIAkJCQl9CiAgICAJCQl9LAogICAgCQkJcmFzdGVyOiB7CiAgICAJCQkJZG9jOiAiUmFzdGVyIG1hcCB0ZXh0dXJlcyBzdWNoIGFzIHNhdGVsbGl0ZSBpbWFnZXJ5LiIsCiAgICAJCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJCQltYWNvczogIjAuMS4wIgogICAgCQkJCQl9CiAgICAJCQkJfQogICAgCQkJfSwKICAgIAkJCWhpbGxzaGFkZTogewogICAgCQkJCWRvYzogIkNsaWVudC1zaWRlIGhpbGxzaGFkaW5nIHZpc3VhbGl6YXRpb24gYmFzZWQgb24gREVNIGRhdGEuIEN1cnJlbnRseSwgdGhlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgTWFwYm94IFRlcnJhaW4gUkdCIGFuZCBNYXB6ZW4gVGVycmFyaXVtIHRpbGVzLiIsCiAgICAJCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJCWpzOiAiMC40My4wIiwKICAgIAkJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCQl9CiAgICAJCQkJfQogICAgCQkJfSwKICAgIAkJCWJhY2tncm91bmQ6IHsKICAgIAkJCQlkb2M6ICJUaGUgYmFja2dyb3VuZCBjb2xvciBvciBwYXR0ZXJuIG9mIHRoZSBtYXAuIiwKICAgIAkJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQkJCX0KICAgIAkJCQl9CiAgICAJCQl9LAogICAgCQkJc2t5OiB7CiAgICAJCQkJZG9jOiAiQSBzcGhlcmljYWwgZG9tZSBhcm91bmQgdGhlIG1hcCB0aGF0IGlzIGFsd2F5cyByZW5kZXJlZCBiZWhpbmQgYWxsIG90aGVyIGxheWVycy4iLAogICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCQlqczogIjIuMC4wIiwKICAgIAkJCQkJCWlvczogIjEwLjAuMCIsCiAgICAJCQkJCQlhbmRyb2lkOiAiMTAuMC4wIgogICAgCQkJCQl9CiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlkb2M6ICJSZW5kZXJpbmcgdHlwZSBvZiB0aGlzIGxheWVyLiIsCiAgICAJCXJlcXVpcmVkOiB0cnVlCiAgICAJfSwKICAgIAltZXRhZGF0YTogewogICAgCQl0eXBlOiAiKiIsCiAgICAJCWRvYzogIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBsYXllciwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy4iCiAgICAJfSwKICAgIAlzb3VyY2U6IHsKICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAJCWRvYzogIk5hbWUgb2YgYSBzb3VyY2UgZGVzY3JpcHRpb24gdG8gYmUgdXNlZCBmb3IgdGhpcyBsYXllci4gUmVxdWlyZWQgZm9yIGFsbCBsYXllciB0eXBlcyBleGNlcHQgYGJhY2tncm91bmRgLiIKICAgIAl9LAogICAgCSJzb3VyY2UtbGF5ZXIiOiB7CiAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgZm9yIHZlY3RvciB0aWxlIHNvdXJjZXM7IHByb2hpYml0ZWQgZm9yIGFsbCBvdGhlciBzb3VyY2UgdHlwZXMsIGluY2x1ZGluZyBHZW9KU09OIHNvdXJjZXMuIgogICAgCX0sCiAgICAJbWluem9vbTogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJbWluaW11bTogMCwKICAgIAkJbWF4aW11bTogMjQsCiAgICAJCWRvYzogIlRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBsYXllci4gQXQgem9vbSBsZXZlbHMgbGVzcyB0aGFuIHRoZSBtaW56b29tLCB0aGUgbGF5ZXIgd2lsbCBiZSBoaWRkZW4uIgogICAgCX0sCiAgICAJbWF4em9vbTogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJbWluaW11bTogMCwKICAgIAkJbWF4aW11bTogMjQsCiAgICAJCWRvYzogIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBsYXllci4gQXQgem9vbSBsZXZlbHMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRoZSBtYXh6b29tLCB0aGUgbGF5ZXIgd2lsbCBiZSBoaWRkZW4uIgogICAgCX0sCiAgICAJZmlsdGVyOiB7CiAgICAJCXR5cGU6ICJmaWx0ZXIiLAogICAgCQlkb2M6ICJBbiBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuIFpvb20gZXhwcmVzc2lvbnMgaW4gZmlsdGVycyBhcmUgb25seSBldmFsdWF0ZWQgYXQgaW50ZWdlciB6b29tIGxldmVscy4gVGhlIGBbXCJmZWF0dXJlLXN0YXRlXCIsIC4uLl1gIGV4cHJlc3Npb24gaXMgbm90IHN1cHBvcnRlZCBpbiBmaWx0ZXIgZXhwcmVzc2lvbnMuICBUaGUgYFtcInBpdGNoXCJdYCBhbmQgYFtcImRpc3RhbmNlLWZyb20tY2VudGVyXCJdYCBleHByZXNzaW9ucyBhcmUgc3VwcG9ydGVkIG9ubHkgZm9yIGZpbHRlciBleHByZXNzaW9ucyBvbiB0aGUgc3ltYm9sIGxheWVyLiIKICAgIAl9LAogICAgCWxheW91dDogewogICAgCQl0eXBlOiAibGF5b3V0IiwKICAgIAkJZG9jOiAiTGF5b3V0IHByb3BlcnRpZXMgZm9yIHRoZSBsYXllci4iCiAgICAJfSwKICAgIAlwYWludDogewogICAgCQl0eXBlOiAicGFpbnQiLAogICAgCQlkb2M6ICJEZWZhdWx0IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuIgogICAgCX0KICAgIH07CiAgICB2YXIgbGF5b3V0ID0gWwogICAgCSJsYXlvdXRfZmlsbCIsCiAgICAJImxheW91dF9saW5lIiwKICAgIAkibGF5b3V0X2NpcmNsZSIsCiAgICAJImxheW91dF9oZWF0bWFwIiwKICAgIAkibGF5b3V0X2ZpbGwtZXh0cnVzaW9uIiwKICAgIAkibGF5b3V0X3N5bWJvbCIsCiAgICAJImxheW91dF9yYXN0ZXIiLAogICAgCSJsYXlvdXRfaGlsbHNoYWRlIiwKICAgIAkibGF5b3V0X2JhY2tncm91bmQiLAogICAgCSJsYXlvdXRfc2t5IgogICAgXTsKICAgIHZhciBsYXlvdXRfYmFja2dyb3VuZCA9IHsKICAgIAl2aXNpYmlsaXR5OiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQl2aXNpYmxlOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIHNob3duLiIKICAgIAkJCX0sCiAgICAJCQlub25lOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIG5vdCBzaG93bi4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogInZpc2libGUiLAogICAgCQlkb2M6ICJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJjb25zdGFudCIKICAgIAl9CiAgICB9OwogICAgdmFyIGxheW91dF9za3kgPSB7CiAgICAJdmlzaWJpbGl0eTogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJdmlzaWJsZTogewogICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBzaG93bi4iCiAgICAJCQl9LAogICAgCQkJbm9uZTogewogICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBub3Qgc2hvd24uIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJ2aXNpYmxlIiwKICAgIAkJZG9jOiAiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuMC4wIiwKICAgIAkJCQlpb3M6ICIxMC4wLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC4wLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgbGF5b3V0X2ZpbGwgPSB7CiAgICAJImZpbGwtc29ydC1rZXkiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQlkb2M6ICJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIxLjIuMCIsCiAgICAJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgIAkJCQlpb3M6ICI1LjguMCIsCiAgICAJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIxLjIuMCIsCiAgICAJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgIAkJCQlpb3M6ICI1LjguMCIsCiAgICAJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCXZpc2liaWxpdHk6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXZpc2libGU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgCQkJfSwKICAgIAkJCW5vbmU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAJCWRvYzogIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgbGF5b3V0X2NpcmNsZSA9IHsKICAgIAkiY2lyY2xlLXNvcnQta2V5IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBhcHBlYXIgYWJvdmUgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMS4yLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI5LjIuMCIsCiAgICAJCQkJaW9zOiAiNS45LjAiLAogICAgCQkJCW1hY29zOiAiMC4xNi4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMS4yLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI5LjIuMCIsCiAgICAJCQkJaW9zOiAiNS45LjAiLAogICAgCQkJCW1hY29zOiAiMC4xNi4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAl2aXNpYmlsaXR5OiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQl2aXNpYmxlOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIHNob3duLiIKICAgIAkJCX0sCiAgICAJCQlub25lOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIG5vdCBzaG93bi4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogInZpc2libGUiLAogICAgCQlkb2M6ICJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJjb25zdGFudCIKICAgIAl9CiAgICB9OwogICAgdmFyIGxheW91dF9oZWF0bWFwID0gewogICAgCXZpc2liaWxpdHk6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXZpc2libGU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgCQkJfSwKICAgIAkJCW5vbmU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAJCWRvYzogIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgbGF5b3V0X2xpbmUgPSB7CiAgICAJImxpbmUtY2FwIjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJYnV0dDogewogICAgCQkJCWRvYzogIkEgY2FwIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gdG8gdGhlIGV4YWN0IGVuZHBvaW50IG9mIHRoZSBsaW5lLiIKICAgIAkJCX0sCiAgICAJCQlyb3VuZDogewogICAgCQkJCWRvYzogIkEgY2FwIHdpdGggYSByb3VuZGVkIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgcmFkaXVzIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGggYW5kIGNlbnRlcmVkIG9uIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZS4iCiAgICAJCQl9LAogICAgCQkJc3F1YXJlOiB7CiAgICAJCQkJZG9jOiAiQSBjYXAgd2l0aCBhIHNxdWFyZWQtb2ZmIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgZGlzdGFuY2Ugb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aC4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogImJ1dHQiLAogICAgCQlkb2M6ICJUaGUgZGlzcGxheSBvZiBsaW5lIGVuZGluZ3MuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIyLjMuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImxpbmUtam9pbiI6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWJldmVsOiB7CiAgICAJCQkJZG9jOiAiQSBqb2luIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIGRpc3RhbmNlIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGguIgogICAgCQkJfSwKICAgIAkJCXJvdW5kOiB7CiAgICAJCQkJZG9jOiAiQSBqb2luIHdpdGggYSByb3VuZGVkIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgcmFkaXVzIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGggYW5kIGNlbnRlcmVkIG9uIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZS4iCiAgICAJCQl9LAogICAgCQkJbWl0ZXI6IHsKICAgIAkJCQlkb2M6ICJBIGpvaW4gd2l0aCBhIHNoYXJwLCBhbmdsZWQgY29ybmVyIHdoaWNoIGlzIGRyYXduIHdpdGggdGhlIG91dGVyIHNpZGVzIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIHBhdGggdW50aWwgdGhleSBtZWV0LiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAibWl0ZXIiLAogICAgCQlkb2M6ICJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjQwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjIuMCIsCiAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgCQkJCW1hY29zOiAiMC42LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJsaW5lLW1pdGVyLWxpbWl0IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAyLAogICAgCQlkb2M6ICJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBtaXRlciBqb2lucyB0byBiZXZlbCBqb2lucyBmb3Igc2hhcnAgYW5nbGVzLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQl7CiAgICAJCQkJImxpbmUtam9pbiI6ICJtaXRlciIKICAgIAkJCX0KICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJsaW5lLXJvdW5kLWxpbWl0IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxLjA1LAogICAgCQlkb2M6ICJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCByb3VuZCBqb2lucyB0byBtaXRlciBqb2lucyBmb3Igc2hhbGxvdyBhbmdsZXMuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCXsKICAgIAkJCQkibGluZS1qb2luIjogInJvdW5kIgogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImxpbmUtc29ydC1rZXkiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQlkb2M6ICJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIxLjIuMCIsCiAgICAJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgIAkJCQlpb3M6ICI1LjguMCIsCiAgICAJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIxLjIuMCIsCiAgICAJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgIAkJCQlpb3M6ICI1LjguMCIsCiAgICAJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCXZpc2liaWxpdHk6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXZpc2libGU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgCQkJfSwKICAgIAkJCW5vbmU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAJCWRvYzogIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgbGF5b3V0X3N5bWJvbCA9IHsKICAgIAkic3ltYm9sLXBsYWNlbWVudCI6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXBvaW50OiB7CiAgICAJCQkJZG9jOiAiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGdlb21ldHJ5IGlzIGxvY2F0ZWQuIgogICAgCQkJfSwKICAgIAkJCWxpbmU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGFiZWwgaXMgcGxhY2VkIGFsb25nIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLiIKICAgIAkJCX0sCiAgICAJCQkibGluZS1jZW50ZXIiOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLiBOb3RlIHRoYXQgYSBzaW5nbGUgZmVhdHVyZSBpbiBhIHZlY3RvciB0aWxlIG1heSBjb250YWluIG11bHRpcGxlIGxpbmUgZ2VvbWV0cmllcy4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogInBvaW50IiwKICAgIAkJZG9jOiAiTGFiZWwgcGxhY2VtZW50IHJlbGF0aXZlIHRvIGl0cyBnZW9tZXRyeS4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiYGxpbmUtY2VudGVyYCB2YWx1ZSI6IHsKICAgIAkJCQlqczogIjAuNDcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuNC4wIiwKICAgIAkJCQlpb3M6ICI0LjMuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEwLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkic3ltYm9sLXNwYWNpbmciOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDI1MCwKICAgIAkJbWluaW11bTogMSwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJEaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycy4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJewogICAgCQkJCSJzeW1ib2wtcGxhY2VtZW50IjogImxpbmUiCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkic3ltYm9sLWF2b2lkLWVkZ2VzIjogewogICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJCWRvYzogIklmIHRydWUsIHRoZSBzeW1ib2xzIHdpbGwgbm90IGNyb3NzIHRpbGUgZWRnZXMgdG8gYXZvaWQgbXV0dWFsIGNvbGxpc2lvbnMuIFJlY29tbWVuZGVkIGluIGxheWVycyB0aGF0IGRvbid0IGhhdmUgZW5vdWdoIHBhZGRpbmcgaW4gdGhlIHZlY3RvciB0aWxlIHRvIHByZXZlbnQgY29sbGlzaW9ucywgb3IgaWYgaXQgaXMgYSBwb2ludCBzeW1ib2wgbGF5ZXIgcGxhY2VkIGFmdGVyIGEgbGluZSBzeW1ib2wgbGF5ZXIuIFdoZW4gdXNpbmcgYSBjbGllbnQgdGhhdCBzdXBwb3J0cyBnbG9iYWwgY29sbGlzaW9uIGRldGVjdGlvbiwgbGlrZSBNYXBib3ggR0wgSlMgdmVyc2lvbiAwLjQyLjAgb3IgZ3JlYXRlciwgZW5hYmxpbmcgdGhpcyBwcm9wZXJ0eSBpcyBub3QgbmVlZGVkIHRvIHByZXZlbnQgY2xpcHBlZCBsYWJlbHMgYXQgdGlsZSBib3VuZGFyaWVzLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInN5bWJvbC1zb3J0LWtleSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCWRvYzogIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGxvd2VyIHNvcnQga2V5cyBhcmUgZHJhd24gYW5kIHBsYWNlZCBmaXJzdC4gIFdoZW4gYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgYGZhbHNlYCwgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5IHdpbGwgaGF2ZSBwcmlvcml0eSBkdXJpbmcgcGxhY2VtZW50LiBXaGVuIGBpY29uLWFsbG93LW92ZXJsYXBgIG9yIGB0ZXh0LWFsbG93LW92ZXJsYXBgIGlzIHNldCB0byBgdHJ1ZWAsIGZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBvdmVybGFwIG92ZXIgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC41My4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNy40LjAiLAogICAgCQkJCWlvczogIjQuMTEuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjE0LjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjUzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI3LjQuMCIsCiAgICAJCQkJaW9zOiAiNC4xMS4wIiwKICAgIAkJCQltYWNvczogIjAuMTQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJInN5bWJvbC16LW9yZGVyIjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJYXV0bzogewogICAgCQkJCWRvYzogIlNvcnRzIHN5bWJvbHMgYnkgYHN5bWJvbC1zb3J0LWtleWAgaWYgc2V0LiBPdGhlcndpc2UsIHNvcnRzIHN5bWJvbHMgYnkgdGhlaXIgeS1wb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgaWYgYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCBvciBgaWNvbi1pZ25vcmUtcGxhY2VtZW50YCBvciBgdGV4dC1pZ25vcmUtcGxhY2VtZW50YCBpcyBgZmFsc2VgLiIKICAgIAkJCX0sCiAgICAJCQkidmlld3BvcnQteSI6IHsKICAgIAkJCQlkb2M6ICJTb3J0cyBzeW1ib2xzIGJ5IHRoZWlyIHktcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGlmIGBpY29uLWFsbG93LW92ZXJsYXBgIG9yIGB0ZXh0LWFsbG93LW92ZXJsYXBgIGlzIHNldCB0byBgdHJ1ZWAgb3IgYGljb24taWdub3JlLXBsYWNlbWVudGAgb3IgYHRleHQtaWdub3JlLXBsYWNlbWVudGAgaXMgYGZhbHNlYC4iCiAgICAJCQl9LAogICAgCQkJc291cmNlOiB7CiAgICAJCQkJZG9jOiAiU29ydHMgc3ltYm9scyBieSBgc3ltYm9sLXNvcnQta2V5YCBpZiBzZXQuIE90aGVyd2lzZSwgbm8gc29ydGluZyBpcyBhcHBsaWVkOyBzeW1ib2xzIGFyZSByZW5kZXJlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgc291cmNlIGRhdGEuIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJhdXRvIiwKICAgIAkJZG9jOiAiRGV0ZXJtaW5lcyB3aGV0aGVyIG92ZXJsYXBwaW5nIHN5bWJvbHMgaW4gdGhlIHNhbWUgbGF5ZXIgYXJlIHJlbmRlcmVkIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXBwZWFyIGluIHRoZSBkYXRhIHNvdXJjZSBvciBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC4gVG8gY29udHJvbCB0aGUgb3JkZXIgYW5kIHByaW9yaXRpemF0aW9uIG9mIHN5bWJvbHMgb3RoZXJ3aXNlLCB1c2UgYHN5bWJvbC1zb3J0LWtleWAuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQ5LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjYuMCIsCiAgICAJCQkJaW9zOiAiNC41LjAiLAogICAgCQkJCW1hY29zOiAiMC4xMi4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImljb24tYWxsb3ctb3ZlcmxhcCI6IHsKICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgCQlkb2M6ICJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImljb24taWdub3JlLXBsYWNlbWVudCI6IHsKICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgCQlkb2M6ICJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIGljb24uIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJpY29uLWltYWdlIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJpY29uLW9wdGlvbmFsIjogewogICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJCWRvYzogIklmIHRydWUsIHRleHQgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyBpY29ucyB3aGVuIHRoZSBpY29uIGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIHRleHQgZG9lcyBub3QuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJpY29uLWltYWdlIiwKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJpY29uLXJvdGF0aW9uLWFsaWdubWVudCI6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCW1hcDogewogICAgCQkJCWRvYzogIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCBhbGlnbnMgaWNvbnMgZWFzdC13ZXN0LiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIGFsaWducyBpY29uIHgtYXhlcyB3aXRoIHRoZSBsaW5lLiIKICAgIAkJCX0sCiAgICAJCQl2aWV3cG9ydDogewogICAgCQkJCWRvYzogIlByb2R1Y2VzIGljb25zIHdob3NlIHgtYXhlcyBhcmUgYWxpZ25lZCB3aXRoIHRoZSB4LWF4aXMgb2YgdGhlIHZpZXdwb3J0LCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgc3ltYm9sLXBsYWNlbWVudGAuIgogICAgCQkJfSwKICAgIAkJCWF1dG86IHsKICAgIAkJCQlkb2M6ICJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGB2aWV3cG9ydGAuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGBtYXBgLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAiYXV0byIsCiAgICAJCWRvYzogIkluIGNvbWJpbmF0aW9uIHdpdGggYHN5bWJvbC1wbGFjZW1lbnRgLCBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBiZWhhdmlvciBvZiBpY29ucy4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJgYXV0b2AgdmFsdWUiOiB7CiAgICAJCQkJanM6ICIwLjI1LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAJCQkJaW9zOiAiMy40LjAiLAogICAgCQkJCW1hY29zOiAiMC4zLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkiaWNvbi1zaXplIjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxLAogICAgCQltaW5pbXVtOiAwLAogICAgCQl1bml0czogImZhY3RvciBvZiB0aGUgb3JpZ2luYWwgaWNvbiBzaXplIiwKICAgIAkJZG9jOiAiU2NhbGVzIHRoZSBvcmlnaW5hbCBzaXplIG9mIHRoZSBpY29uIGJ5IHRoZSBwcm92aWRlZCBmYWN0b3IuIFRoZSBuZXcgcGl4ZWwgc2l6ZSBvZiB0aGUgaW1hZ2Ugd2lsbCBiZSB0aGUgb3JpZ2luYWwgcGl4ZWwgc2l6ZSBtdWx0aXBsaWVkIGJ5IGBpY29uLXNpemVgLiAxIGlzIHRoZSBvcmlnaW5hbCBzaXplOyAzIHRyaXBsZXMgdGhlIHNpemUgb2YgdGhlIGltYWdlLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkiaWNvbi1pbWFnZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjM1LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImljb24tdGV4dC1maXQiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQlub25lOiB7CiAgICAJCQkJZG9jOiAiVGhlIGljb24gaXMgZGlzcGxheWVkIGF0IGl0cyBpbnRyaW5zaWMgYXNwZWN0IHJhdGlvLiIKICAgIAkJCX0sCiAgICAJCQl3aWR0aDogewogICAgCQkJCWRvYzogIlRoZSBpY29uIGlzIHNjYWxlZCBpbiB0aGUgeC1kaW1lbnNpb24gdG8gZml0IHRoZSB3aWR0aCBvZiB0aGUgdGV4dC4iCiAgICAJCQl9LAogICAgCQkJaGVpZ2h0OiB7CiAgICAJCQkJZG9jOiAiVGhlIGljb24gaXMgc2NhbGVkIGluIHRoZSB5LWRpbWVuc2lvbiB0byBmaXQgdGhlIGhlaWdodCBvZiB0aGUgdGV4dC4iCiAgICAJCQl9LAogICAgCQkJYm90aDogewogICAgCQkJCWRvYzogIlRoZSBpY29uIGlzIHNjYWxlZCBpbiBib3RoIHgtIGFuZCB5LWRpbWVuc2lvbnMuIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJub25lIiwKICAgIAkJZG9jOiAiU2NhbGVzIHRoZSBpY29uIHRvIGZpdCBhcm91bmQgdGhlIGFzc29jaWF0ZWQgdGV4dC4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiLAogICAgCQkJInRleHQtZmllbGQiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4yMS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNC4yLjAiLAogICAgCQkJCWlvczogIjMuNC4wIiwKICAgIAkJCQltYWNvczogIjAuMi4xIgogICAgCQkJfSwKICAgIAkJCSJzdHJldGNoYWJsZSBpY29ucyI6IHsKICAgIAkJCQlqczogIjEuNi4wIiwKICAgIAkJCQlhbmRyb2lkOiAiOS4yLjAiLAogICAgCQkJCWlvczogIjUuOC4wIiwKICAgIAkJCQltYWNvczogIjAuMTUuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJpY29uLXRleHQtZml0LXBhZGRpbmciOiB7CiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJbGVuZ3RoOiA0LAogICAgCQkiZGVmYXVsdCI6IFsKICAgIAkJCTAsCiAgICAJCQkwLAogICAgCQkJMCwKICAgIAkJCTAKICAgIAkJXSwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYWRkZWQgdG8gZGltZW5zaW9ucyBkZXRlcm1pbmVkIGJ5IGBpY29uLXRleHQtZml0YCwgaW4gY2xvY2t3aXNlIG9yZGVyOiB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJpY29uLWltYWdlIiwKICAgIAkJCSJ0ZXh0LWZpZWxkIiwKICAgIAkJCXsKICAgIAkJCQkiaWNvbi10ZXh0LWZpdCI6IFsKICAgIAkJCQkJImJvdGgiLAogICAgCQkJCQkid2lkdGgiLAogICAgCQkJCQkiaGVpZ2h0IgogICAgCQkJCV0KICAgIAkJCX0KICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjIxLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAJCQkJaW9zOiAiMy40LjAiLAogICAgCQkJCW1hY29zOiAiMC4yLjEiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJpY29uLWltYWdlIjogewogICAgCQl0eXBlOiAicmVzb2x2ZWRJbWFnZSIsCiAgICAJCWRvYzogIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLiIsCiAgICAJCXRva2VuczogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjM1LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJpY29uLXJvdGF0ZSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMCwKICAgIAkJcGVyaW9kOiAzNjAsCiAgICAJCXVuaXRzOiAiZGVncmVlcyIsCiAgICAJCWRvYzogIlJvdGF0ZXMgdGhlIGljb24gY2xvY2t3aXNlLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkiaWNvbi1pbWFnZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjIxLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImljb24tcGFkZGluZyI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMiwKICAgIAkJbWluaW11bTogMCwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSBpY29uIGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJpY29uLWltYWdlIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImljb24ta2VlcC11cHJpZ2h0IjogewogICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJCWRvYzogIklmIHRydWUsIHRoZSBpY29uIG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiLAogICAgCQkJewogICAgCQkJCSJpY29uLXJvdGF0aW9uLWFsaWdubWVudCI6ICJtYXAiCiAgICAJCQl9LAogICAgCQkJewogICAgCQkJCSJzeW1ib2wtcGxhY2VtZW50IjogWwogICAgCQkJCQkibGluZSIsCiAgICAJCQkJCSJsaW5lLWNlbnRlciIKICAgIAkJCQldCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImljb24tb2Zmc2V0IjogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAJCWxlbmd0aDogMiwKICAgIAkJImRlZmF1bHQiOiBbCiAgICAJCQkwLAogICAgCQkJMAogICAgCQldLAogICAgCQlkb2M6ICJPZmZzZXQgZGlzdGFuY2Ugb2YgaWNvbiBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiBFYWNoIGNvbXBvbmVudCBpcyBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZSBvZiBgaWNvbi1zaXplYCB0byBvYnRhaW4gdGhlIGZpbmFsIG9mZnNldCBpbiBwaXhlbHMuIFdoZW4gY29tYmluZWQgd2l0aCBgaWNvbi1yb3RhdGVgIHRoZSBvZmZzZXQgd2lsbCBiZSBhcyBpZiB0aGUgcm90YXRlZCBkaXJlY3Rpb24gd2FzIHVwLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkiaWNvbi1pbWFnZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImljb24tYW5jaG9yIjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJY2VudGVyOiB7CiAgICAJCQkJZG9jOiAiVGhlIGNlbnRlciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQlsZWZ0OiB7CiAgICAJCQkJZG9jOiAiVGhlIGxlZnQgc2lkZSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQlyaWdodDogewogICAgCQkJCWRvYzogIlRoZSByaWdodCBzaWRlIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCXRvcDogewogICAgCQkJCWRvYzogIlRoZSB0b3Agb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJYm90dG9tOiB7CiAgICAJCQkJZG9jOiAiVGhlIGJvdHRvbSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQkidG9wLWxlZnQiOiB7CiAgICAJCQkJZG9jOiAiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQkidG9wLXJpZ2h0IjogewogICAgCQkJCWRvYzogIlRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCSJib3R0b20tbGVmdCI6IHsKICAgIAkJCQlkb2M6ICJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCSJib3R0b20tcmlnaHQiOiB7CiAgICAJCQkJZG9jOiAiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogImNlbnRlciIsCiAgICAJCWRvYzogIlBhcnQgb2YgdGhlIGljb24gcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC40MC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgCQkJCWlvczogIjMuNy4wIiwKICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC40MC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgCQkJCWlvczogIjMuNy4wIiwKICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiaWNvbi1waXRjaC1hbGlnbm1lbnQiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJUaGUgaWNvbiBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgbWFwLiIKICAgIAkJCX0sCiAgICAJCQl2aWV3cG9ydDogewogICAgCQkJCWRvYzogIlRoZSBpY29uIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSB2aWV3cG9ydC4iCiAgICAJCQl9LAogICAgCQkJYXV0bzogewogICAgCQkJCWRvYzogIkF1dG9tYXRpY2FsbHkgbWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGljb24tcm90YXRpb24tYWxpZ25tZW50YC4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogImF1dG8iLAogICAgCQlkb2M6ICJPcmllbnRhdGlvbiBvZiBpY29uIHdoZW4gbWFwIGlzIHBpdGNoZWQuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJpY29uLWltYWdlIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMzkuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMi4wIiwKICAgIAkJCQlpb3M6ICIzLjcuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJ0ZXh0LXBpdGNoLWFsaWdubWVudCI6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCW1hcDogewogICAgCQkJCWRvYzogIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuIgogICAgCQkJfSwKICAgIAkJCXZpZXdwb3J0OiB7CiAgICAJCQkJZG9jOiAiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LiIKICAgIAkJCX0sCiAgICAJCQlhdXRvOiB7CiAgICAJCQkJZG9jOiAiQXV0b21hdGljYWxseSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiBgdGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRgLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAiYXV0byIsCiAgICAJCWRvYzogIk9yaWVudGF0aW9uIG9mIHRleHQgd2hlbiBtYXAgaXMgcGl0Y2hlZC4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJInRleHQtZmllbGQiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4yMS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNC4yLjAiLAogICAgCQkJCWlvczogIjMuNC4wIiwKICAgIAkJCQltYWNvczogIjAuMi4xIgogICAgCQkJfSwKICAgIAkJCSJgYXV0b2AgdmFsdWUiOiB7CiAgICAJCQkJanM6ICIwLjI1LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAJCQkJaW9zOiAiMy40LjAiLAogICAgCQkJCW1hY29zOiAiMC4zLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIHRleHQgZWFzdC13ZXN0LiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIGFsaWducyB0ZXh0IHgtYXhlcyB3aXRoIHRoZSBsaW5lLiIKICAgIAkJCX0sCiAgICAJCQl2aWV3cG9ydDogewogICAgCQkJCWRvYzogIlByb2R1Y2VzIGdseXBocyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLiIKICAgIAkJCX0sCiAgICAJCQlhdXRvOiB7CiAgICAJCQkJZG9jOiAiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgbWFwYC4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogImF1dG8iLAogICAgCQlkb2M6ICJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgdGhlIGluZGl2aWR1YWwgZ2x5cGhzIGZvcm1pbmcgdGhlIHRleHQuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiYGF1dG9gIHZhbHVlIjogewogICAgCQkJCWpzOiAiMC4yNS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNC4yLjAiLAogICAgCQkJCWlvczogIjMuNC4wIiwKICAgIAkJCQltYWNvczogIjAuMy4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInRleHQtZmllbGQiOiB7CiAgICAJCXR5cGU6ICJmb3JtYXR0ZWQiLAogICAgCQkiZGVmYXVsdCI6ICIiLAogICAgCQl0b2tlbnM6IHRydWUsCiAgICAJCWRvYzogIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBJZiBhIHBsYWluIGBzdHJpbmdgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBgZm9ybWF0dGVkYCB3aXRoIGRlZmF1bHQvaW5oZXJpdGVkIGZvcm1hdHRpbmcgb3B0aW9ucy4gU0RGIGltYWdlcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBmb3JtYXR0ZWQgdGV4dCBhbmQgd2lsbCBiZSBpZ25vcmVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zMy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkidGV4dC1mb250IjogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogInN0cmluZyIsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJIk9wZW4gU2FucyBSZWd1bGFyIiwKICAgIAkJCSJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXIiCiAgICAJCV0sCiAgICAJCWRvYzogIkZvbnQgc3RhY2sgdG8gdXNlIGZvciBkaXNwbGF5aW5nIHRleHQuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJInRleHQtc2l6ZSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMTYsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiRm9udCBzaXplLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjM1LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJInRleHQtbWF4LXdpZHRoIjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxMCwKICAgIAkJbWluaW11bTogMCwKICAgIAkJdW5pdHM6ICJlbXMiLAogICAgCQlkb2M6ICJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIsCiAgICAJCQl7CiAgICAJCQkJInN5bWJvbC1wbGFjZW1lbnQiOiBbCiAgICAJCQkJCSJwb2ludCIKICAgIAkJCQldCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC40MC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgCQkJCWlvczogIjMuNy4wIiwKICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJ0ZXh0LWxpbmUtaGVpZ2h0IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxLjIsCiAgICAJCXVuaXRzOiAiZW1zIiwKICAgIAkJZG9jOiAiVGV4dCBsZWFkaW5nIHZhbHVlIGZvciBtdWx0aS1saW5lIHRleHQuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjIuMy4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJ0ZXh0LWxldHRlci1zcGFjaW5nIjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQl1bml0czogImVtcyIsCiAgICAJCWRvYzogIlRleHQgdHJhY2tpbmcgYW1vdW50LiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjQwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjIuMCIsCiAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgCQkJCW1hY29zOiAiMC42LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJInRleHQtanVzdGlmeSI6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWF1dG86IHsKICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvd2FyZHMgdGhlIGFuY2hvciBwb3NpdGlvbi4iCiAgICAJCQl9LAogICAgCQkJbGVmdDogewogICAgCQkJCWRvYzogIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIGxlZnQuIgogICAgCQkJfSwKICAgIAkJCWNlbnRlcjogewogICAgCQkJCWRvYzogIlRoZSB0ZXh0IGlzIGNlbnRlcmVkLiIKICAgIAkJCX0sCiAgICAJCQlyaWdodDogewogICAgCQkJCWRvYzogIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHJpZ2h0LiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAiY2VudGVyIiwKICAgIAkJZG9jOiAiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMzkuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMi4wIiwKICAgIAkJCQlpb3M6ICIzLjcuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgIAkJCX0sCiAgICAJCQlhdXRvOiB7CiAgICAJCQkJanM6ICIwLjU0LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI3LjQuMCIsCiAgICAJCQkJaW9zOiAiNC4xMC4wIiwKICAgIAkJCQltYWNvczogIjAuMTQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJInRleHQtcmFkaWFsLW9mZnNldCI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCXVuaXRzOiAiZW1zIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQlkb2M6ICJSYWRpYWwgb2Zmc2V0IG9mIHRleHQsIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN5bWJvbCdzIGFuY2hvci4gVXNlZnVsIGluIGNvbWJpbmF0aW9uIHdpdGggYHRleHQtdmFyaWFibGUtYW5jaG9yYCwgd2hpY2ggZGVmYXVsdHMgdG8gdXNpbmcgdGhlIHR3by1kaW1lbnNpb25hbCBgdGV4dC1vZmZzZXRgIGlmIHByZXNlbnQuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjU0LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI3LjQuMCIsCiAgICAJCQkJaW9zOiAiNC4xMC4wIiwKICAgIAkJCQltYWNvczogIjAuMTQuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuNTQuMCIsCiAgICAJCQkJYW5kcm9pZDogIjcuNC4wIiwKICAgIAkJCQlpb3M6ICI0LjEwLjAiLAogICAgCQkJCW1hY29zOiAiMC4xNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlyZXF1aXJlczogWwogICAgCQkJInRleHQtZmllbGQiCiAgICAJCV0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIiwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIKICAgIAkJCV0KICAgIAkJfQogICAgCX0sCiAgICAJInRleHQtdmFyaWFibGUtYW5jaG9yIjogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWNlbnRlcjogewogICAgCQkJCWRvYzogIlRoZSBjZW50ZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJbGVmdDogewogICAgCQkJCWRvYzogIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJcmlnaHQ6IHsKICAgIAkJCQlkb2M6ICJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQl0b3A6IHsKICAgIAkJCQlkb2M6ICJUaGUgdG9wIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCWJvdHRvbTogewogICAgCQkJCWRvYzogIlRoZSBib3R0b20gb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJInRvcC1sZWZ0IjogewogICAgCQkJCWRvYzogIlRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJInRvcC1yaWdodCI6IHsKICAgIAkJCQlkb2M6ICJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQkiYm90dG9tLWxlZnQiOiB7CiAgICAJCQkJZG9jOiAiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQkiYm90dG9tLXJpZ2h0IjogewogICAgCQkJCWRvYzogIlRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfQogICAgCQl9LAogICAgCQlyZXF1aXJlczogWwogICAgCQkJInRleHQtZmllbGQiLAogICAgCQkJewogICAgCQkJCSJzeW1ib2wtcGxhY2VtZW50IjogWwogICAgCQkJCQkicG9pbnQiCiAgICAJCQkJXQogICAgCQkJfQogICAgCQldLAogICAgCQlkb2M6ICJUbyBpbmNyZWFzZSB0aGUgY2hhbmNlIG9mIHBsYWNpbmcgaGlnaC1wcmlvcml0eSBsYWJlbHMgb24gdGhlIG1hcCwgeW91IGNhbiBwcm92aWRlIGFuIGFycmF5IG9mIGB0ZXh0LWFuY2hvcmAgbG9jYXRpb25zOiB0aGUgcmVuZGVyZXIgd2lsbCBhdHRlbXB0IHRvIHBsYWNlIHRoZSBsYWJlbCBhdCBlYWNoIGxvY2F0aW9uLCBpbiBvcmRlciwgYmVmb3JlIG1vdmluZyBvbnRvIHRoZSBuZXh0IGxhYmVsLiBVc2UgYHRleHQtanVzdGlmeTogYXV0b2AgdG8gY2hvb3NlIGp1c3RpZmljYXRpb24gYmFzZWQgb24gYW5jaG9yIHBvc2l0aW9uLiBUbyBhcHBseSBhbiBvZmZzZXQsIHVzZSB0aGUgYHRleHQtcmFkaWFsLW9mZnNldGAgb3IgdGhlIHR3by1kaW1lbnNpb25hbCBgdGV4dC1vZmZzZXRgLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC41NC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNy40LjAiLAogICAgCQkJCWlvczogIjQuMTAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjE0LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkidGV4dC1hbmNob3IiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQljZW50ZXI6IHsKICAgIAkJCQlkb2M6ICJUaGUgY2VudGVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCWxlZnQ6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGVmdCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCXJpZ2h0OiB7CiAgICAJCQkJZG9jOiAiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJdG9wOiB7CiAgICAJCQkJZG9jOiAiVGhlIHRvcCBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0sCiAgICAJCQlib3R0b206IHsKICAgIAkJCQlkb2M6ICJUaGUgYm90dG9tIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCSJ0b3AtbGVmdCI6IHsKICAgIAkJCQlkb2M6ICJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgCQkJfSwKICAgIAkJCSJ0b3AtcmlnaHQiOiB7CiAgICAJCQkJZG9jOiAiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJImJvdHRvbS1sZWZ0IjogewogICAgCQkJCWRvYzogIlRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAJCQl9LAogICAgCQkJImJvdHRvbS1yaWdodCI6IHsKICAgIAkJCQlkb2M6ICJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAiY2VudGVyIiwKICAgIAkJZG9jOiAiUGFydCBvZiB0aGUgdGV4dCBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIsCiAgICAJCQl7CiAgICAJCQkJIiEiOiAidGV4dC12YXJpYWJsZS1hbmNob3IiCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgCQkJCWlvczogIjMuNy4wIiwKICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkidGV4dC1tYXgtYW5nbGUiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDQ1LAogICAgCQl1bml0czogImRlZ3JlZXMiLAogICAgCQlkb2M6ICJNYXhpbXVtIGFuZ2xlIGNoYW5nZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIiwKICAgIAkJCXsKICAgIAkJCQkic3ltYm9sLXBsYWNlbWVudCI6IFsKICAgIAkJCQkJImxpbmUiLAogICAgCQkJCQkibGluZS1jZW50ZXIiCiAgICAJCQkJXQogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInRleHQtd3JpdGluZy1tb2RlIjogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWhvcml6b250YWw6IHsKICAgIAkJCQlkb2M6ICJJZiBhIHRleHQncyBsYW5ndWFnZSBzdXBwb3J0cyBob3Jpem9udGFsIHdyaXRpbmcgbW9kZSwgc3ltYm9scyB3b3VsZCBiZSBsYWlkIG91dCBob3Jpem9udGFsbHkuIgogICAgCQkJfSwKICAgIAkJCXZlcnRpY2FsOiB7CiAgICAJCQkJZG9jOiAiSWYgYSB0ZXh0J3MgbGFuZ3VhZ2Ugc3VwcG9ydHMgdmVydGljYWwgd3JpdGluZyBtb2RlLCBzeW1ib2xzIHdvdWxkIGJlIGxhaWQgb3V0IHZlcnRpY2FsbHkuIgogICAgCQkJfQogICAgCQl9LAogICAgCQlkb2M6ICJUaGUgcHJvcGVydHkgYWxsb3dzIGNvbnRyb2wgb3ZlciBhIHN5bWJvbCdzIG9yaWVudGF0aW9uLiBOb3RlIHRoYXQgdGhlIHByb3BlcnR5IHZhbHVlcyBhY3QgYXMgYSBoaW50LCBzbyB0aGF0IGEgc3ltYm9sIHdob3NlIGxhbmd1YWdlIGRvZXNu4oCZdCBzdXBwb3J0IHRoZSBwcm92aWRlZCBvcmllbnRhdGlvbiB3aWxsIGJlIGxhaWQgb3V0IGluIGl0cyBuYXR1cmFsIG9yaWVudGF0aW9uLiBFeGFtcGxlOiBFbmdsaXNoIHBvaW50IHN5bWJvbCB3aWxsIGJlIHJlbmRlcmVkIGhvcml6b250YWxseSBldmVuIGlmIGFycmF5IHZhbHVlIGNvbnRhaW5zIHNpbmdsZSAndmVydGljYWwnIGVudW0gdmFsdWUuIEZvciBzeW1ib2wgd2l0aCBwb2ludCBwbGFjZW1lbnQsIHRoZSBvcmRlciBvZiBlbGVtZW50cyBpbiBhbiBhcnJheSBkZWZpbmUgcHJpb3JpdHkgb3JkZXIgZm9yIHRoZSBwbGFjZW1lbnQgb2YgYW4gb3JpZW50YXRpb24gdmFyaWFudC4gRm9yIHN5bWJvbCB3aXRoIGxpbmUgcGxhY2VtZW50LCB0aGUgZGVmYXVsdCB0ZXh0IHdyaXRpbmcgbW9kZSBpcyBlaXRoZXIgWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ10gb3IgWyd2ZXJ0aWNhbCcsICdob3Jpem9udGFsJ10sIHRoZSBvcmRlciBkb2Vzbid0IGFmZmVjdCB0aGUgcGxhY2VtZW50LiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIxLjMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjguMy4wIiwKICAgIAkJCQlpb3M6ICI1LjMuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkidGV4dC1yb3RhdGUiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCXBlcmlvZDogMzYwLAogICAgCQl1bml0czogImRlZ3JlZXMiLAogICAgCQlkb2M6ICJSb3RhdGVzIHRoZSB0ZXh0IGNsb2Nrd2lzZS4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJInRleHQtZmllbGQiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zNS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgCQkJCWlvczogIjMuNi4wIiwKICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJ0ZXh0LXBhZGRpbmciOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDIsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFyb3VuZCB0aGUgdGV4dCBib3VuZGluZyBib3ggdXNlZCBmb3IgZGV0ZWN0aW5nIHN5bWJvbCBjb2xsaXNpb25zLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJ0ZXh0LWtlZXAtdXByaWdodCI6IHsKICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgCQkiZGVmYXVsdCI6IHRydWUsCiAgICAJCWRvYzogIklmIHRydWUsIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHZlcnRpY2FsbHkgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIsCiAgICAJCQl7CiAgICAJCQkJInRleHQtcm90YXRpb24tYWxpZ25tZW50IjogIm1hcCIKICAgIAkJCX0sCiAgICAJCQl7CiAgICAJCQkJInN5bWJvbC1wbGFjZW1lbnQiOiBbCiAgICAJCQkJCSJsaW5lIiwKICAgIAkJCQkJImxpbmUtY2VudGVyIgogICAgCQkJCV0KICAgIAkJCX0KICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkidGV4dC10cmFuc2Zvcm0iOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQlub25lOiB7CiAgICAJCQkJZG9jOiAiVGhlIHRleHQgaXMgbm90IGFsdGVyZWQuIgogICAgCQkJfSwKICAgIAkJCXVwcGVyY2FzZTogewogICAgCQkJCWRvYzogIkZvcmNlcyBhbGwgbGV0dGVycyB0byBiZSBkaXNwbGF5ZWQgaW4gdXBwZXJjYXNlLiIKICAgIAkJCX0sCiAgICAJCQlsb3dlcmNhc2U6IHsKICAgIAkJCQlkb2M6ICJGb3JjZXMgYWxsIGxldHRlcnMgdG8gYmUgZGlzcGxheWVkIGluIGxvd2VyY2FzZS4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogIm5vbmUiLAogICAgCQlkb2M6ICJTcGVjaWZpZXMgaG93IHRvIGNhcGl0YWxpemUgdGV4dCwgc2ltaWxhciB0byB0aGUgQ1NTIGB0ZXh0LXRyYW5zZm9ybWAgcHJvcGVydHkuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJInRleHQtb2Zmc2V0IjogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQlkb2M6ICJPZmZzZXQgZGlzdGFuY2Ugb2YgdGV4dCBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiBJZiB1c2VkIHdpdGggdGV4dC12YXJpYWJsZS1hbmNob3IsIGlucHV0IHZhbHVlcyB3aWxsIGJlIHRha2VuIGFzIGFic29sdXRlIHZhbHVlcy4gT2Zmc2V0cyBhbG9uZyB0aGUgeC0gYW5kIHktYXhpcyB3aWxsIGJlIGFwcGxpZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGUgYW5jaG9yIHBvc2l0aW9uLiIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJdW5pdHM6ICJlbXMiLAogICAgCQlsZW5ndGg6IDIsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJMCwKICAgIAkJCTAKICAgIAkJXSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIiwKICAgIAkJCXsKICAgIAkJCQkiISI6ICJ0ZXh0LXJhZGlhbC1vZmZzZXQiCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zNS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgCQkJCWlvczogIjMuNi4wIiwKICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJ0ZXh0LWFsbG93LW92ZXJsYXAiOiB7CiAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgIAkJZG9jOiAiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnQiOiB7CiAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgIAkJZG9jOiAiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSB0ZXh0LiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkidGV4dC1vcHRpb25hbCI6IHsKICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgCQlkb2M6ICJJZiB0cnVlLCBpY29ucyB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIHRleHQgd2hlbiB0aGUgdGV4dCBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSBpY29uIGRvZXMgbm90LiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIsCiAgICAJCQkiaWNvbi1pbWFnZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAl2aXNpYmlsaXR5OiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQl2aXNpYmxlOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIHNob3duLiIKICAgIAkJCX0sCiAgICAJCQlub25lOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIG5vdCBzaG93bi4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogInZpc2libGUiLAogICAgCQlkb2M6ICJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJjb25zdGFudCIKICAgIAl9CiAgICB9OwogICAgdmFyIGxheW91dF9yYXN0ZXIgPSB7CiAgICAJdmlzaWJpbGl0eTogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJdmlzaWJsZTogewogICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBzaG93bi4iCiAgICAJCQl9LAogICAgCQkJbm9uZTogewogICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBub3Qgc2hvd24uIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJ2aXNpYmxlIiwKICAgIAkJZG9jOiAiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY29uc3RhbnQiCiAgICAJfQogICAgfTsKICAgIHZhciBsYXlvdXRfaGlsbHNoYWRlID0gewogICAgCXZpc2liaWxpdHk6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCXZpc2libGU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgCQkJfSwKICAgIAkJCW5vbmU6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAJCWRvYzogIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgZmlsdGVyID0gewogICAgCXR5cGU6ICJhcnJheSIsCiAgICAJdmFsdWU6ICIqIiwKICAgIAlkb2M6ICJBIGZpbHRlciBzZWxlY3RzIHNwZWNpZmljIGZlYXR1cmVzIGZyb20gYSBsYXllci4iCiAgICB9OwogICAgdmFyIGZpbHRlcl9zeW1ib2wgPSB7CiAgICAJdHlwZTogImJvb2xlYW4iLAogICAgCWRvYzogIkV4cHJlc3Npb24gd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBkaXNwbGF5IGEgc3ltYm9sLiBTeW1ib2xzIHN1cHBvcnQgZHluYW1pYyBmaWx0ZXJpbmcsIG1lYW5pbmcgdGhpcyBleHByZXNzaW9uIGNhbiB1c2UgdGhlIGBbXCJwaXRjaFwiXWAgYW5kIGBbXCJkaXN0YW5jZS1mcm9tLWNlbnRlclwiXWAgZXhwcmVzc2lvbnMgdG8gcmVmZXJlbmNlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB2aWV3LiIsCiAgICAJImRlZmF1bHQiOiBmYWxzZSwKICAgIAl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIsCiAgICAJZXhwcmVzc2lvbjogewogICAgCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkiem9vbSIsCiAgICAJCQkiZmVhdHVyZSIsCiAgICAJCQkicGl0Y2giLAogICAgCQkJImRpc3RhbmNlLWZyb20tY2VudGVyIgogICAgCQldCiAgICAJfQogICAgfTsKICAgIHZhciBmaWx0ZXJfZmlsbCA9IHsKICAgIAl0eXBlOiAiYm9vbGVhbiIsCiAgICAJZG9jOiAiRXhwcmVzc2lvbiB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgYSBwb2x5Z29uLiBGaWxsIGxheWVyIGRvZXMgTk9UIHN1cHBvcnQgZHluYW1pYyBmaWx0ZXJpbmcsIG1lYW5pbmcgdGhpcyBleHByZXNzaW9uIGNhbiBOT1QgdXNlIHRoZSBgW1wicGl0Y2hcIl1gIGFuZCBgW1wiZGlzdGFuY2UtZnJvbS1jZW50ZXJcIl1gIGV4cHJlc3Npb25zIHRvIHJlZmVyZW5jZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdmlldy4iLAogICAgCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iLAogICAgCWV4cHJlc3Npb246IHsKICAgIAkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJcGFyYW1ldGVyczogWwogICAgCQkJInpvb20iLAogICAgCQkJImZlYXR1cmUiCiAgICAJCV0KICAgIAl9CiAgICB9OwogICAgdmFyIGZpbHRlcl9saW5lID0gewogICAgCXR5cGU6ICJib29sZWFuIiwKICAgIAlkb2M6ICJFeHByZXNzaW9uIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSBhIFBvbHlnb24gb3IgTGluZVN0cmluZy4gTGluZSBsYXllciBkb2VzIE5PVCBzdXBwb3J0IGR5bmFtaWMgZmlsdGVyaW5nLCBtZWFuaW5nIHRoaXMgZXhwcmVzc2lvbiBjYW4gTk9UIHVzZSB0aGUgYFtcInBpdGNoXCJdYCBhbmQgYFtcImRpc3RhbmNlLWZyb20tY2VudGVyXCJdYCBleHByZXNzaW9ucyB0byByZWZlcmVuY2UgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHZpZXcuIiwKICAgIAkiZGVmYXVsdCI6IGZhbHNlLAogICAgCXRyYW5zaXRpb246IGZhbHNlLAogICAgCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIiwKICAgIAlleHByZXNzaW9uOiB7CiAgICAJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCXBhcmFtZXRlcnM6IFsKICAgIAkJCSJ6b29tIiwKICAgIAkJCSJmZWF0dXJlIgogICAgCQldCiAgICAJfQogICAgfTsKICAgIHZhciBmaWx0ZXJfY2lyY2xlID0gewogICAgCXR5cGU6ICJib29sZWFuIiwKICAgIAlkb2M6ICJFeHByZXNzaW9uIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSBhIGNpcmNsZS4gQ2lyY2xlIGxheWVyIGRvZXMgTk9UIHN1cHBvcnQgZHluYW1pYyBmaWx0ZXJpbmcsIG1lYW5pbmcgdGhpcyBleHByZXNzaW9uIGNhbiBOT1QgdXNlIHRoZSBgW1wicGl0Y2hcIl1gIGFuZCBgW1wiZGlzdGFuY2UtZnJvbS1jZW50ZXJcIl1gIGV4cHJlc3Npb25zIHRvIHJlZmVyZW5jZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdmlldy4iLAogICAgCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iLAogICAgCWV4cHJlc3Npb246IHsKICAgIAkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJcGFyYW1ldGVyczogWwogICAgCQkJInpvb20iLAogICAgCQkJImZlYXR1cmUiCiAgICAJCV0KICAgIAl9CiAgICB9OwogICAgdmFyIGZpbHRlcl9oZWF0bWFwID0gewogICAgCXR5cGU6ICJib29sZWFuIiwKICAgIAlkb2M6ICJFeHByZXNzaW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwb2ludCBpcyBiZWluZyBkaXNwbGF5ZWQgb3Igbm90LiBIZWF0bWFwIGxheWVyIGRvZXMgTk9UIHN1cHBvcnQgZHluYW1pYyBmaWx0ZXJpbmcsIG1lYW5pbmcgdGhpcyBleHByZXNzaW9uIGNhbiBOT1QgdXNlIHRoZSBgW1wicGl0Y2hcIl1gIGFuZCBgW1wiZGlzdGFuY2UtZnJvbS1jZW50ZXJcIl1gIGV4cHJlc3Npb25zIHRvIHJlZmVyZW5jZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdmlldy4iLAogICAgCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iLAogICAgCWV4cHJlc3Npb246IHsKICAgIAkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJcGFyYW1ldGVyczogWwogICAgCQkJInpvb20iLAogICAgCQkJImZlYXR1cmUiCiAgICAJCV0KICAgIAl9CiAgICB9OwogICAgdmFyIGZpbHRlcl9vcGVyYXRvciA9IHsKICAgIAl0eXBlOiAiZW51bSIsCiAgICAJdmFsdWVzOiB7CiAgICAJCSI9PSI6IHsKICAgIAkJCWRvYzogImBbXCI9PVwiLCBrZXksIHZhbHVlXWAgZXF1YWxpdHk6IGBmZWF0dXJlW2tleV0gPSB2YWx1ZWAiCiAgICAJCX0sCiAgICAJCSIhPSI6IHsKICAgIAkJCWRvYzogImBbXCIhPVwiLCBrZXksIHZhbHVlXWAgaW5lcXVhbGl0eTogYGZlYXR1cmVba2V5XSDiiaAgdmFsdWVgIgogICAgCQl9LAogICAgCQkiPiI6IHsKICAgIAkJCWRvYzogImBbXCI+XCIsIGtleSwgdmFsdWVdYCBncmVhdGVyIHRoYW46IGBmZWF0dXJlW2tleV0gPiB2YWx1ZWAiCiAgICAJCX0sCiAgICAJCSI+PSI6IHsKICAgIAkJCWRvYzogImBbXCI+PVwiLCBrZXksIHZhbHVlXWAgZ3JlYXRlciB0aGFuIG9yIGVxdWFsOiBgZmVhdHVyZVtrZXldIOKJpSB2YWx1ZWAiCiAgICAJCX0sCiAgICAJCSI8IjogewogICAgCQkJZG9jOiAiYFtcIjxcIiwga2V5LCB2YWx1ZV1gIGxlc3MgdGhhbjogYGZlYXR1cmVba2V5XSA8IHZhbHVlYCIKICAgIAkJfSwKICAgIAkJIjw9IjogewogICAgCQkJZG9jOiAiYFtcIjw9XCIsIGtleSwgdmFsdWVdYCBsZXNzIHRoYW4gb3IgZXF1YWw6IGBmZWF0dXJlW2tleV0g4omkIHZhbHVlYCIKICAgIAkJfSwKICAgIAkJImluIjogewogICAgCQkJZG9jOiAiYFtcImluXCIsIGtleSwgdjAsIC4uLiwgdm5dYCBzZXQgaW5jbHVzaW9uOiBgZmVhdHVyZVtrZXldIOKIiCB7djAsIC4uLiwgdm59YCIKICAgIAkJfSwKICAgIAkJIiFpbiI6IHsKICAgIAkJCWRvYzogImBbXCIhaW5cIiwga2V5LCB2MCwgLi4uLCB2bl1gIHNldCBleGNsdXNpb246IGBmZWF0dXJlW2tleV0g4oiJIHt2MCwgLi4uLCB2bn1gIgogICAgCQl9LAogICAgCQlhbGw6IHsKICAgIAkJCWRvYzogImBbXCJhbGxcIiwgZjAsIC4uLiwgZm5dYCBsb2dpY2FsIGBBTkRgOiBgZjAg4oinIC4uLiDiiKcgZm5gIgogICAgCQl9LAogICAgCQlhbnk6IHsKICAgIAkJCWRvYzogImBbXCJhbnlcIiwgZjAsIC4uLiwgZm5dYCBsb2dpY2FsIGBPUmA6IGBmMCDiiKggLi4uIOKIqCBmbmAiCiAgICAJCX0sCiAgICAJCW5vbmU6IHsKICAgIAkJCWRvYzogImBbXCJub25lXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgTk9SYDogYMKsZjAg4oinIC4uLiDiiKcgwqxmbmAiCiAgICAJCX0sCiAgICAJCWhhczogewogICAgCQkJZG9jOiAiYFtcImhhc1wiLCBrZXldYCBgZmVhdHVyZVtrZXldYCBleGlzdHMiCiAgICAJCX0sCiAgICAJCSIhaGFzIjogewogICAgCQkJZG9jOiAiYFtcIiFoYXNcIiwga2V5XWAgYGZlYXR1cmVba2V5XWAgZG9lcyBub3QgZXhpc3QiCiAgICAJCX0sCiAgICAJCXdpdGhpbjogewogICAgCQkJZG9jOiAiYFtcIndpdGhpblwiLCBvYmplY3RdYCBmZWF0dXJlIGdlb21ldHJ5IGlzIHdpdGhpbiBvYmplY3QgZ2VvbWV0cnkiCiAgICAJCX0KICAgIAl9LAogICAgCWRvYzogIlRoZSBmaWx0ZXIgb3BlcmF0b3IuIgogICAgfTsKICAgIHZhciBnZW9tZXRyeV90eXBlID0gewogICAgCXR5cGU6ICJlbnVtIiwKICAgIAl2YWx1ZXM6IHsKICAgIAkJUG9pbnQ6IHsKICAgIAkJCWRvYzogIkZpbHRlciB0byBwb2ludCBnZW9tZXRyaWVzLiIKICAgIAkJfSwKICAgIAkJTGluZVN0cmluZzogewogICAgCQkJZG9jOiAiRmlsdGVyIHRvIGxpbmUgZ2VvbWV0cmllcy4iCiAgICAJCX0sCiAgICAJCVBvbHlnb246IHsKICAgIAkJCWRvYzogIkZpbHRlciB0byBwb2x5Z29uIGdlb21ldHJpZXMuIgogICAgCQl9CiAgICAJfSwKICAgIAlkb2M6ICJUaGUgZ2VvbWV0cnkgdHlwZSBmb3IgdGhlIGZpbHRlciB0byBzZWxlY3QuIgogICAgfTsKICAgIHZhciBmdW5jdGlvbl9zdG9wID0gewogICAgCXR5cGU6ICJhcnJheSIsCiAgICAJbWluaW11bTogMCwKICAgIAltYXhpbXVtOiAyNCwKICAgIAl2YWx1ZTogWwogICAgCQkibnVtYmVyIiwKICAgIAkJImNvbG9yIgogICAgCV0sCiAgICAJbGVuZ3RoOiAyLAogICAgCWRvYzogIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuIgogICAgfTsKICAgIHZhciBleHByZXNzaW9uJDEgPSB7CiAgICAJdHlwZTogImFycmF5IiwKICAgIAl2YWx1ZTogIioiLAogICAgCW1pbmltdW06IDEsCiAgICAJZG9jOiAiQW4gZXhwcmVzc2lvbiBkZWZpbmVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGF0YS1kcml2ZW4gc3R5bGUgcHJvcGVydGllcyBvciBmZWF0dXJlIGZpbHRlcnMuIgogICAgfTsKICAgIHZhciBleHByZXNzaW9uX25hbWUgPSB7CiAgICAJZG9jOiAiIiwKICAgIAl0eXBlOiAiZW51bSIsCiAgICAJdmFsdWVzOiB7CiAgICAJCSJsZXQiOiB7CiAgICAJCQlkb2M6ICJCaW5kcyBleHByZXNzaW9ucyB0byBuYW1lZCB2YXJpYWJsZXMsIHdoaWNoIGNhbiB0aGVuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIHJlc3VsdCBleHByZXNzaW9uIHVzaW5nIFtcInZhclwiLCBcInZhcmlhYmxlX25hbWVcIl0uIiwKICAgIAkJCWdyb3VwOiAiVmFyaWFibGUgYmluZGluZyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJInZhciI6IHsKICAgIAkJCWRvYzogIlJlZmVyZW5jZXMgdmFyaWFibGUgYm91bmQgdXNpbmcgXCJsZXRcIi4iLAogICAgCQkJZ3JvdXA6ICJWYXJpYWJsZSBiaW5kaW5nIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlsaXRlcmFsOiB7CiAgICAJCQlkb2M6ICJQcm92aWRlcyBhIGxpdGVyYWwgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlhcnJheTogewogICAgCQkJZG9jOiAiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCBpcyBhbiBhcnJheSAob3B0aW9uYWxseSB3aXRoIGEgc3BlY2lmaWMgaXRlbSB0eXBlIGFuZCBsZW5ndGgpLiAgSWYsIHdoZW4gdGhlIGlucHV0IGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLCBpdCBpcyBub3Qgb2YgdGhlIGFzc2VydGVkIHR5cGUsIHRoZW4gdGhpcyBhc3NlcnRpb24gd2lsbCBjYXVzZSB0aGUgd2hvbGUgZXhwcmVzc2lvbiB0byBiZSBhYm9ydGVkLiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlhdDogewogICAgCQkJZG9jOiAiUmV0cmlldmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS4iLAogICAgCQkJZ3JvdXA6ICJMb29rdXAiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJpbiI6IHsKICAgIAkJCWRvYzogIkRldGVybWluZXMgd2hldGhlciBhbiBpdGVtIGV4aXN0cyBpbiBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBleGlzdHMgaW4gYSBzdHJpbmcuIEluIHRoZSBzcGVjaWZpYyBjYXNlIHdoZW4gdGhlIHNlY29uZCBhbmQgdGhpcmQgYXJndW1lbnRzIGFyZSBzdHJpbmcgbGl0ZXJhbHMsIHlvdSBtdXN0IHdyYXAgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaW4gYSBbYGxpdGVyYWxgXSgjdHlwZXMtbGl0ZXJhbCkgZXhwcmVzc2lvbiB0byBoaW50IGNvcnJlY3QgaW50ZXJwcmV0YXRpb24gdG8gdGhlIFt0eXBlIHN5c3RlbV0oI3R5cGUtc3lzdGVtKS4iLAogICAgCQkJZ3JvdXA6ICJMb29rdXAiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjEuNi4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgIAkJCQkJaW9zOiAiNS44LjAiLAogICAgCQkJCQltYWNvczogIjAuMTUuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJpbmRleC1vZiI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIGFuIGl0ZW0gY2FuIGJlIGZvdW5kIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGNhbiBiZSBmb3VuZCBpbiBhIHN0cmluZywgb3IgYC0xYCBpZiB0aGUgaW5wdXQgY2Fubm90IGJlIGZvdW5kLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGluZGV4IGZyb20gd2hlcmUgdG8gYmVnaW4gdGhlIHNlYXJjaC4iLAogICAgCQkJZ3JvdXA6ICJMb29rdXAiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjEuMTAuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCXNsaWNlOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBmcm9tIGEgc3RyaW5nIGZyb20gYSBzcGVjaWZpZWQgc3RhcnQgaW5kZXgsIG9yIGJldHdlZW4gYSBzdGFydCBpbmRleCBhbmQgYW4gZW5kIGluZGV4IGlmIHNldC4gVGhlIHJldHVybiB2YWx1ZSBpcyBpbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGluZGV4IGJ1dCBub3Qgb2YgdGhlIGVuZCBpbmRleC4iLAogICAgCQkJZ3JvdXA6ICJMb29rdXAiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjEuMTAuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJjYXNlIjogewogICAgCQkJZG9jOiAiU2VsZWN0cyB0aGUgZmlyc3Qgb3V0cHV0IHdob3NlIGNvcnJlc3BvbmRpbmcgdGVzdCBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWUsIG9yIHRoZSBmYWxsYmFjayB2YWx1ZSBvdGhlcndpc2UuIiwKICAgIAkJCWdyb3VwOiAiRGVjaXNpb24iLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCW1hdGNoOiB7CiAgICAJCQlkb2M6ICJTZWxlY3RzIHRoZSBvdXRwdXQgZm9yIHdoaWNoIHRoZSBsYWJlbCB2YWx1ZSBtYXRjaGVzIHRoZSBpbnB1dCB2YWx1ZSwgb3IgdGhlIGZhbGxiYWNrIHZhbHVlIGlmIG5vIG1hdGNoIGlzIGZvdW5kLiBUaGUgaW5wdXQgY2FuIGJlIGFueSBleHByZXNzaW9uIChmb3IgZXhhbXBsZSwgYFtcImdldFwiLCBcImJ1aWxkaW5nX3R5cGVcIl1gKS4gRWFjaCBsYWJlbCBtdXN0IGJlIHVuaXF1ZSwgYW5kIG11c3QgYmUgZWl0aGVyOlxuIC0gYSBzaW5nbGUgbGl0ZXJhbCB2YWx1ZTsgb3JcbiAtIGFuIGFycmF5IG9mIGxpdGVyYWwgdmFsdWVzLCB0aGUgdmFsdWVzIG9mIHdoaWNoIG11c3QgYmUgYWxsIHN0cmluZ3Mgb3IgYWxsIG51bWJlcnMgKGZvciBleGFtcGxlIGBbMTAwLCAxMDFdYCBvciBgW1wiY1wiLCBcImJcIl1gKS5cblxuVGhlIGlucHV0IG1hdGNoZXMgaWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IG1hdGNoZXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5LCBzaW1pbGFyIHRvIHRoZSBgXCJpblwiYCBvcGVyYXRvci5cbklmIHRoZSBpbnB1dCB0eXBlIGRvZXMgbm90IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBsYWJlbHMsIHRoZSByZXN1bHQgd2lsbCBiZSB0aGUgZmFsbGJhY2sgdmFsdWUuIiwKICAgIAkJCWdyb3VwOiAiRGVjaXNpb24iLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWNvYWxlc2NlOiB7CiAgICAJCQlkb2M6ICJFdmFsdWF0ZXMgZWFjaCBleHByZXNzaW9uIGluIHR1cm4gdW50aWwgdGhlIGZpcnN0IHZhbGlkIHZhbHVlIGlzIG9idGFpbmVkLiBJbnZhbGlkIHZhbHVlcyBhcmUgYG51bGxgIGFuZCBbYCdpbWFnZSdgXSgjdHlwZXMtaW1hZ2UpIGV4cHJlc3Npb25zIHRoYXQgYXJlIHVuYXZhaWxhYmxlIGluIHRoZSBzdHlsZS4gSWYgYWxsIHZhbHVlcyBhcmUgaW52YWxpZCwgYGNvYWxlc2NlYCByZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBsaXN0ZWQuIiwKICAgIAkJCWdyb3VwOiAiRGVjaXNpb24iLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCXN0ZXA6IHsKICAgIAkJCWRvYzogIlByb2R1Y2VzIGRpc2NyZXRlLCBzdGVwcGVkIHJlc3VsdHMgYnkgZXZhbHVhdGluZyBhIHBpZWNld2lzZS1jb25zdGFudCBmdW5jdGlvbiBkZWZpbmVkIGJ5IHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcInN0b3BzXCIpLiBUaGUgYGlucHV0YCBtYXkgYmUgYW55IG51bWVyaWMgZXhwcmVzc2lvbiAoZS5nLiwgYFtcImdldFwiLCBcInBvcHVsYXRpb25cIl1gKS4gU3RvcCBpbnB1dHMgbXVzdCBiZSBudW1lcmljIGxpdGVyYWxzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4gUmV0dXJucyB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoZSBzdG9wIGp1c3QgbGVzcyB0aGFuIHRoZSBpbnB1dCwgb3IgdGhlIGZpcnN0IG91dHB1dCBpZiB0aGUgaW5wdXQgaXMgbGVzcyB0aGFuIHRoZSBmaXJzdCBzdG9wLiIsCiAgICAJCQlncm91cDogIlJhbXBzLCBzY2FsZXMsIGN1cnZlcyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40Mi4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJaW50ZXJwb2xhdGU6IHsKICAgIAkJCWRvYzogIlByb2R1Y2VzIGNvbnRpbnVvdXMsIHNtb290aCByZXN1bHRzIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXCJzdG9wc1wiKS4gVGhlIGBpbnB1dGAgbWF5IGJlIGFueSBudW1lcmljIGV4cHJlc3Npb24gKGUuZy4sIGBbXCJnZXRcIiwgXCJwb3B1bGF0aW9uXCJdYCkuIFN0b3AgaW5wdXRzIG11c3QgYmUgbnVtZXJpYyBsaXRlcmFscyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuIFRoZSBvdXRwdXQgdHlwZSBtdXN0IGJlIGBudW1iZXJgLCBgYXJyYXk8bnVtYmVyPmAsIG9yIGBjb2xvcmAuXG5cbkludGVycG9sYXRpb24gdHlwZXM6XG4tIGBbXCJsaW5lYXJcIl1gOiBJbnRlcnBvbGF0ZXMgbGluZWFybHkgYmV0d2VlbiB0aGUgcGFpciBvZiBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGlucHV0LlxuLSBgW1wiZXhwb25lbnRpYWxcIiwgYmFzZV1gOiBJbnRlcnBvbGF0ZXMgZXhwb25lbnRpYWxseSBiZXR3ZWVuIHRoZSBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGlucHV0LiBgYmFzZWAgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG91dHB1dCBpbmNyZWFzZXM6IGhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgb3V0cHV0IGluY3JlYXNlIG1vcmUgdG93YXJkcyB0aGUgaGlnaCBlbmQgb2YgdGhlIHJhbmdlLiBXaXRoIHZhbHVlcyBjbG9zZSB0byAxIHRoZSBvdXRwdXQgaW5jcmVhc2VzIGxpbmVhcmx5LlxuLSBgW1wiY3ViaWMtYmV6aWVyXCIsIHgxLCB5MSwgeDIsIHkyXWA6IEludGVycG9sYXRlcyB1c2luZyB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlIGRlZmluZWQgYnkgdGhlIGdpdmVuIGNvbnRyb2wgcG9pbnRzLiIsCiAgICAJCQlncm91cDogIlJhbXBzLCBzY2FsZXMsIGN1cnZlcyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40Mi4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImludGVycG9sYXRlLWhjbCI6IHsKICAgIAkJCWRvYzogIlByb2R1Y2VzIGNvbnRpbnVvdXMsIHNtb290aCByZXN1bHRzIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXCJzdG9wc1wiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgSHVlLUNocm9tYS1MdW1pbmFuY2UgY29sb3Igc3BhY2UuIiwKICAgIAkJCWdyb3VwOiAiUmFtcHMsIHNjYWxlcywgY3VydmVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ5LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkiaW50ZXJwb2xhdGUtbGFiIjogewogICAgCQkJZG9jOiAiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcInN0b3BzXCIpLiBXb3JrcyBsaWtlIGBpbnRlcnBvbGF0ZWAsIGJ1dCB0aGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgY29sb3JgLCBhbmQgdGhlIGludGVycG9sYXRpb24gaXMgcGVyZm9ybWVkIGluIHRoZSBDSUVMQUIgY29sb3Igc3BhY2UuIiwKICAgIAkJCWdyb3VwOiAiUmFtcHMsIHNjYWxlcywgY3VydmVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ5LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlsbjI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGxuKDIpLiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCXBpOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBtYXRoZW1hdGljYWwgY29uc3RhbnQgcGkuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZTogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGUuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJInR5cGVvZiI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuIiwKICAgIAkJCWdyb3VwOiAiVHlwZXMiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCXN0cmluZzogewogICAgCQkJZG9jOiAiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHN0cmluZy4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgc3RyaW5nIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIHN0cmluZ3MsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQludW1iZXI6IHsKICAgIAkJCWRvYzogIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYSBudW1iZXIuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIG51bWJlciBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBudW1iZXJzLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJYm9vbGVhbjogewogICAgCQkJZG9jOiAiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIGJvb2xlYW4uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIGJvb2xlYW4gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgYm9vbGVhbnMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlvYmplY3Q6IHsKICAgIAkJCWRvYzogIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gb2JqZWN0LiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYW4gb2JqZWN0IGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIG9iamVjdHMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQljb2xsYXRvcjogewogICAgCQkJZG9jOiAiUmV0dXJucyBhIGBjb2xsYXRvcmAgZm9yIHVzZSBpbiBsb2NhbGUtZGVwZW5kZW50IGNvbXBhcmlzb24gb3BlcmF0aW9ucy4gVGhlIGBjYXNlLXNlbnNpdGl2ZWAgYW5kIGBkaWFjcml0aWMtc2Vuc2l0aXZlYCBvcHRpb25zIGRlZmF1bHQgdG8gYGZhbHNlYC4gVGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgSUVURiBsYW5ndWFnZSB0YWcgb2YgdGhlIGxvY2FsZSB0byB1c2UuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGxvY2FsZSBpcyB1c2VkLiBJZiB0aGUgcmVxdWVzdGVkIGxvY2FsZSBpcyBub3QgYXZhaWxhYmxlLCB0aGUgYGNvbGxhdG9yYCB3aWxsIHVzZSBhIHN5c3RlbS1kZWZpbmVkIGZhbGxiYWNrIGxvY2FsZS4gVXNlIGByZXNvbHZlZC1sb2NhbGVgIHRvIHRlc3QgdGhlIHJlc3VsdHMgb2YgbG9jYWxlIGZhbGxiYWNrIGJlaGF2aW9yLiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgCQkJCQlpb3M6ICI0LjIuMCIsCiAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlmb3JtYXQ6IHsKICAgIAkJCWRvYzogIlJldHVybnMgYSBgZm9ybWF0dGVkYCBzdHJpbmcgZm9yIGRpc3BsYXlpbmcgbWl4ZWQtZm9ybWF0IHRleHQgaW4gdGhlIGB0ZXh0LWZpZWxkYCBwcm9wZXJ0eS4gVGhlIGlucHV0IG1heSBjb250YWluIGEgc3RyaW5nIGxpdGVyYWwgb3IgZXhwcmVzc2lvbiwgaW5jbHVkaW5nIGFuIFtgJ2ltYWdlJ2BdKCN0eXBlcy1pbWFnZSkgZXhwcmVzc2lvbi4gU3RyaW5ncyBtYXkgYmUgZm9sbG93ZWQgYnkgYSBzdHlsZSBvdmVycmlkZSBvYmplY3QgdGhhdCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4tIGBcInRleHQtZm9udFwiYDogT3ZlcnJpZGVzIHRoZSBmb250IHN0YWNrIHNwZWNpZmllZCBieSB0aGUgcm9vdCBsYXlvdXQgcHJvcGVydHkuXG4tIGBcInRleHQtY29sb3JcImA6IE92ZXJyaWRlcyB0aGUgY29sb3Igc3BlY2lmaWVkIGJ5IHRoZSByb290IHBhaW50IHByb3BlcnR5LlxuLSBgXCJmb250LXNjYWxlXCJgOiBBcHBsaWVzIGEgc2NhbGluZyBmYWN0b3Igb24gYHRleHQtc2l6ZWAgYXMgc3BlY2lmaWVkIGJ5IHRoZSByb290IGxheW91dCBwcm9wZXJ0eS4iLAogICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40OC4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuNy4wIiwKICAgIAkJCQkJaW9zOiAiNC42LjAiLAogICAgCQkJCQltYWNvczogIjAuMTIuMCIKICAgIAkJCQl9LAogICAgCQkJCSJ0ZXh0LWZvbnQiOiB7CiAgICAJCQkJCWpzOiAiMC40OC4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuNy4wIiwKICAgIAkJCQkJaW9zOiAiNC42LjAiLAogICAgCQkJCQltYWNvczogIjAuMTIuMCIKICAgIAkJCQl9LAogICAgCQkJCSJmb250LXNjYWxlIjogewogICAgCQkJCQlqczogIjAuNDguMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjcuMCIsCiAgICAJCQkJCWlvczogIjQuNi4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjEyLjAiCiAgICAJCQkJfSwKICAgIAkJCQkidGV4dC1jb2xvciI6IHsKICAgIAkJCQkJanM6ICIxLjMuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI3LjMuMCIsCiAgICAJCQkJCWlvczogIjQuMTAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC4xNC4wIgogICAgCQkJCX0sCiAgICAJCQkJaW1hZ2U6IHsKICAgIAkJCQkJanM6ICIxLjYuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI4LjYuMCIsCiAgICAJCQkJCWlvczogIjUuNy4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlpbWFnZTogewogICAgCQkJZG9jOiAiUmV0dXJucyBhIFtgUmVzb2x2ZWRJbWFnZWBdKC9tYXBib3gtZ2wtanMvc3R5bGUtc3BlYy90eXBlcy8jcmVzb2x2ZWRpbWFnZSkgZm9yIHVzZSBpbiBbYGljb24taW1hZ2VgXSgvbWFwYm94LWdsLWpzL3N0eWxlLXNwZWMvbGF5ZXJzLyNsYXlvdXQtc3ltYm9sLWljb24taW1hZ2UpLCBgKi1wYXR0ZXJuYCBlbnRyaWVzLCBhbmQgYXMgYSBzZWN0aW9uIGluIHRoZSBbYCdmb3JtYXQnYF0oI3R5cGVzLWZvcm1hdCkgZXhwcmVzc2lvbi4gQSBbYCdjb2FsZXNjZSdgXSgjY29hbGVzY2UpIGV4cHJlc3Npb24gY29udGFpbmluZyBgaW1hZ2VgIGV4cHJlc3Npb25zIHdpbGwgZXZhbHVhdGUgdG8gdGhlIGZpcnN0IGxpc3RlZCBpbWFnZSB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgc3R5bGUuIFRoaXMgdmFsaWRhdGlvbiBwcm9jZXNzIGlzIHN5bmNocm9ub3VzIGFuZCByZXF1aXJlcyB0aGUgaW1hZ2UgdG8gaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBzdHlsZSBiZWZvcmUgcmVxdWVzdGluZyBpdCBpbiB0aGUgYCdpbWFnZSdgIGFyZ3VtZW50LiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIxLjQuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI4LjYuMCIsCiAgICAJCQkJCWlvczogIjUuNy4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkibnVtYmVyLWZvcm1hdCI6IHsKICAgIAkJCWRvYzogIkNvbnZlcnRzIHRoZSBpbnB1dCBudW1iZXIgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiB1c2luZyB0aGUgcHJvdmlkaW5nIGZvcm1hdHRpbmcgcnVsZXMuIElmIHNldCwgdGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgbG9jYWxlIHRvIHVzZSwgYXMgYSBCQ1AgNDcgbGFuZ3VhZ2UgdGFnLiBJZiBzZXQsIHRoZSBgY3VycmVuY3lgIGFyZ3VtZW50IHNwZWNpZmllcyBhbiBJU08gNDIxNyBjb2RlIHRvIHVzZSBmb3IgY3VycmVuY3ktc3R5bGUgZm9ybWF0dGluZy4gSWYgc2V0LCB0aGUgYG1pbi1mcmFjdGlvbi1kaWdpdHNgIGFuZCBgbWF4LWZyYWN0aW9uLWRpZ2l0c2AgYXJndW1lbnRzIHNwZWNpZnkgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIGZyYWN0aW9uYWwgZGlnaXRzIHRvIGluY2x1ZGUuIiwKICAgIAkJCWdyb3VwOiAiVHlwZXMiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNTQuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI4LjQuMCIsCiAgICAJCQkJCWlvczogIjUuNC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkidG8tc3RyaW5nIjogewogICAgCQkJZG9jOiAiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgc3RyaW5nLiBJZiB0aGUgaW5wdXQgaXMgYG51bGxgLCB0aGUgcmVzdWx0IGlzIGBcIlwiYC4gSWYgdGhlIGlucHV0IGlzIGEgW2Bib29sZWFuYF0oI3R5cGVzLWJvb2xlYW4pLCB0aGUgcmVzdWx0IGlzIGBcInRydWVcImAgb3IgYFwiZmFsc2VcImAuIElmIHRoZSBpbnB1dCBpcyBhIG51bWJlciwgaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGFzIHNwZWNpZmllZCBieSB0aGUgW1wiTnVtYmVyVG9TdHJpbmdcIiBhbGdvcml0aG1dKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvc3RyaW5nLWFwcGxpZWQtdG8tdGhlLW51bWJlci10eXBlKSBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLiBJZiB0aGUgaW5wdXQgaXMgYSBbYGNvbG9yYF0oI2NvbG9yKSwgaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIG9mIHRoZSBmb3JtIGBcInJnYmEocixnLGIsYSlcImAsIHdoZXJlIGByYCwgYGdgLCBhbmQgYGJgIGFyZSBudW1lcmFscyByYW5naW5nIGZyb20gMCB0byAyNTUsIGFuZCBgYWAgcmFuZ2VzIGZyb20gMCB0byAxLiBJZiB0aGUgaW5wdXQgaXMgYW4gW2AnaW1hZ2UnYF0oI3R5cGVzLWltYWdlKSBleHByZXNzaW9uLCBgJ3RvLXN0cmluZydgIHJldHVybnMgdGhlIGltYWdlIG5hbWUuIE90aGVyd2lzZSwgdGhlIGlucHV0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSB0aGUgW2BKU09OLnN0cmluZ2lmeWBdKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5KSBmdW5jdGlvbiBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLiIsCiAgICAJCQlncm91cDogIlR5cGVzIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkidG8tbnVtYmVyIjogewogICAgCQkJZG9jOiAiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyLCBpZiBwb3NzaWJsZS4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCBvciBgZmFsc2VgLCB0aGUgcmVzdWx0IGlzIDAuIElmIHRoZSBpbnB1dCBpcyBgdHJ1ZWAsIHRoZSByZXN1bHQgaXMgMS4gSWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbXCJUb051bWJlciBBcHBsaWVkIHRvIHRoZSBTdHJpbmcgVHlwZVwiIGFsZ29yaXRobV0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXItYXBwbGllZC10by10aGUtc3RyaW5nLXR5cGUpIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBjb252ZXJzaW9uIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgY2FuIGJlIGNvbnZlcnRlZCwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuIiwKICAgIAkJCWdyb3VwOiAiVHlwZXMiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJ0by1ib29sZWFuIjogewogICAgCQkJZG9jOiAiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgYm9vbGVhbi4gVGhlIHJlc3VsdCBpcyBgZmFsc2VgIHdoZW4gdGhlbiBpbnB1dCBpcyBhbiBlbXB0eSBzdHJpbmcsIDAsIGBmYWxzZWAsIGBudWxsYCwgb3IgYE5hTmA7IG90aGVyd2lzZSBpdCBpcyBgdHJ1ZWAuIiwKICAgIAkJCWdyb3VwOiAiVHlwZXMiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJ0by1yZ2JhIjogewogICAgCQkJZG9jOiAiUmV0dXJucyBhIGZvdXItZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSBpbnB1dCBjb2xvcidzIHJlZCwgZ3JlZW4sIGJsdWUsIGFuZCBhbHBoYSBjb21wb25lbnRzLCBpbiB0aGF0IG9yZGVyLiIsCiAgICAJCQlncm91cDogIkNvbG9yIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkidG8tY29sb3IiOiB7CiAgICAJCQlkb2M6ICJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBjb2xvci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBjYW4gYmUgY29udmVydGVkLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJcmdiOiB7CiAgICAJCQlkb2M6ICJDcmVhdGVzIGEgY29sb3IgdmFsdWUgZnJvbSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IG9mIDEuIElmIGFueSBjb21wb25lbnQgaXMgb3V0IG9mIHJhbmdlLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgCQkJZ3JvdXA6ICJDb2xvciIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJcmdiYTogewogICAgCQkJZG9jOiAiQ3JlYXRlcyBhIGNvbG9yIHZhbHVlIGZyb20gcmVkLCBncmVlbiwgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLiBJZiBhbnkgY29tcG9uZW50IGlzIG91dCBvZiByYW5nZSwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuIiwKICAgIAkJCWdyb3VwOiAiQ29sb3IiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWdldDogewogICAgCQkJZG9jOiAiUmV0cmlldmVzIGEgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBmZWF0dXJlJ3MgcHJvcGVydGllcywgb3IgZnJvbSBhbm90aGVyIG9iamVjdCBpZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZC4gUmV0dXJucyBgbnVsbGAgaWYgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBtaXNzaW5nLiIsCiAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJaGFzOiB7CiAgICAJCQlkb2M6ICJUZXN0cyBmb3IgdGhlIHByZXNlbmNlIG9mIGFuIHByb3BlcnR5IHZhbHVlIGluIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLiIsCiAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJbGVuZ3RoOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBsZW5ndGggb2YgYW4gYXJyYXkgb3Igc3RyaW5nLiIsCiAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJcHJvcGVydGllczogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgZmVhdHVyZSBwcm9wZXJ0aWVzIG9iamVjdC4gIE5vdGUgdGhhdCBpbiBzb21lIGNhc2VzLCBpdCBtYXkgYmUgbW9yZSBlZmZpY2llbnQgdG8gdXNlIGBbXCJnZXRcIiwgXCJwcm9wZXJ0eV9uYW1lXCJdYCBkaXJlY3RseS4iLAogICAgCQkJZ3JvdXA6ICJGZWF0dXJlIGRhdGEiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJmZWF0dXJlLXN0YXRlIjogewogICAgCQkJZG9jOiAiUmV0cmlldmVzIGEgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBmZWF0dXJlJ3Mgc3RhdGUuIFJldHVybnMgYG51bGxgIGlmIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgb24gdGhlIGZlYXR1cmUncyBzdGF0ZS4gQSBmZWF0dXJlJ3Mgc3RhdGUgaXMgbm90IHBhcnQgb2YgdGhlIEdlb0pTT04gb3IgdmVjdG9yIHRpbGUgZGF0YSwgYW5kIG11c3QgYmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgb24gZWFjaCBmZWF0dXJlLiBGZWF0dXJlcyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBgaWRgIGF0dHJpYnV0ZSwgd2hpY2ggbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGNhc3QgdG8gYW4gaW50ZWdlci4gTm90ZSB0aGF0IFtcImZlYXR1cmUtc3RhdGVcIl0gY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHBhaW50IHByb3BlcnRpZXMgdGhhdCBzdXBwb3J0IGRhdGEtZHJpdmVuIHN0eWxpbmcuIiwKICAgIAkJCWdyb3VwOiAiRmVhdHVyZSBkYXRhIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ2LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkiZ2VvbWV0cnktdHlwZSI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSB0eXBlOiBgUG9pbnRgLCBgTXVsdGlQb2ludGAsIGBMaW5lU3RyaW5nYCwgYE11bHRpTGluZVN0cmluZ2AsIGBQb2x5Z29uYCwgYE11bHRpUG9seWdvbmAuIGBNdWx0aSpgIGZlYXR1cmUgdHlwZXMgYXJlIG9ubHkgcmV0dXJuZWQgaW4gR2VvSlNPTiBzb3VyY2VzLiBXaGVuIHdvcmtpbmcgd2l0aCB2ZWN0b3IgdGlsZSBzb3VyY2VzLCB1c2UgdGhlIHNpbmd1bGFyIGZvcm1zLiIsCiAgICAJCQlncm91cDogIkZlYXR1cmUgZGF0YSIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJaWQ6IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGZlYXR1cmUncyBpZCwgaWYgaXQgaGFzIG9uZS4iLAogICAgCQkJZ3JvdXA6ICJGZWF0dXJlIGRhdGEiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCXpvb206IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbC4gIE5vdGUgdGhhdCBpbiBzdHlsZSBsYXlvdXQgYW5kIHBhaW50IHByb3BlcnRpZXMsIFtcInpvb21cIl0gbWF5IG9ubHkgYXBwZWFyIGFzIHRoZSBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4iLAogICAgCQkJZ3JvdXA6ICJDYW1lcmEiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCXBpdGNoOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBjdXJyZW50IHBpdGNoIGluIGRlZ3JlZXMuIGBbXCJwaXRjaFwiXWAgbWF5IG9ubHkgYmUgdXNlZCBpbiB0aGUgYGZpbHRlcmAgZXhwcmVzc2lvbiBmb3IgYSBgc3ltYm9sYCBsYXllci4iLAogICAgCQkJZ3JvdXA6ICJDYW1lcmEiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjIuNi4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJImRpc3RhbmNlLWZyb20tY2VudGVyIjogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgZGlzdGFuY2Ugb2YgYSBgc3ltYm9sYCBpbnN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gVGhlIGRpc3RhbmNlIGlzIG1lYXN1cmVkIGluIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBoZWlnaHQgb2YgdGhlIG1hcCBjb250YWluZXIuIEl0IG1lYXN1cmVzIDAgYXQgdGhlIGNlbnRlciwgZGVjcmVhc2VzIHRvd2FyZHMgdGhlIGNhbWVyYSBhbmQgaW5jcmVhc2UgYXdheSBmcm9tIHRoZSBjYW1lcmEuIEZvciBleGFtcGxlLCBpZiB0aGUgaGVpZ2h0IG9mIHRoZSBtYXAgaXMgMTAwMHB4LCBhIHZhbHVlIG9mIC0xIG1lYW5zIDEwMDBweCBhd2F5IGZyb20gdGhlIGNlbnRlciB0b3dhcmRzIHRoZSBjYW1lcmEsIGFuZCBhIHZhbHVlIG9mIDEgbWVhbnMgYSBkaXN0YW5jZSBvZiAxMDAwcHggYXdheSBmcm9tIHRoZSBjYW1lcmEgZnJvbSB0aGUgY2VudGVyLiBgW1wiZGlzdGFuY2UtZnJvbS1jZW50ZXJcIl1gIG1heSBvbmx5IGJlIHVzZWQgaW4gdGhlIGBmaWx0ZXJgIGV4cHJlc3Npb24gZm9yIGEgYHN5bWJvbGAgbGF5ZXIuIiwKICAgIAkJCWdyb3VwOiAiQ2FtZXJhIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIyLjYuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJoZWF0bWFwLWRlbnNpdHkiOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBrZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uIG9mIGEgcGl4ZWwgaW4gYSBoZWF0bWFwIGxheWVyLCB3aGljaCBpcyBhIHJlbGF0aXZlIG1lYXN1cmUgb2YgaG93IG1hbnkgZGF0YSBwb2ludHMgYXJlIGNyb3dkZWQgYXJvdW5kIGEgcGFydGljdWxhciBwaXhlbC4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGhlYXRtYXAtY29sb3JgIHByb3BlcnR5LiIsCiAgICAJCQlncm91cDogIkhlYXRtYXAiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJsaW5lLXByb2dyZXNzIjogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgcHJvZ3Jlc3MgYWxvbmcgYSBncmFkaWVudCBsaW5lLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgbGluZS1ncmFkaWVudGAgcHJvcGVydHkuIiwKICAgIAkJCWdyb3VwOiAiRmVhdHVyZSBkYXRhIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgCQkJCQlpb3M6ICI0LjYuMCIsCiAgICAJCQkJCW1hY29zOiAiMC4xMi4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJInNreS1yYWRpYWwtcHJvZ3Jlc3MiOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBkaXN0YW5jZSBvZiBhIHBvaW50IG9uIHRoZSBza3kgZnJvbSB0aGUgc3VuIHBvc2l0aW9uLiBSZXR1cm5zIDAgYXQgc3VuIHBvc2l0aW9uIGFuZCAxIHdoZW4gdGhlIGRpc3RhbmNlIHJlYWNoZXMgYHNreS1ncmFkaWVudC1yYWRpdXNgLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgc2t5LWdyYWRpZW50YCBwcm9wZXJ0eS4iLAogICAgCQkJZ3JvdXA6ICJza3kiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjIuMC4wIiwKICAgIAkJCQkJaW9zOiAiMTAuMC4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjEwLjAuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWFjY3VtdWxhdGVkOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGNsdXN0ZXIgcHJvcGVydHkgYWNjdW11bGF0ZWQgc28gZmFyLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgY2x1c3RlclByb3BlcnRpZXNgIG9wdGlvbiBvZiBhIGNsdXN0ZXJlZCBHZW9KU09OIHNvdXJjZS4iLAogICAgCQkJZ3JvdXA6ICJGZWF0dXJlIGRhdGEiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNTMuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI4LjQuMCIsCiAgICAJCQkJCWlvczogIjUuNS4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkiKyI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIHN1bSBvZiB0aGUgaW5wdXRzLiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSIqIjogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGUgaW5wdXRzLiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSItIjogewogICAgCQkJZG9jOiAiRm9yIHR3byBpbnB1dHMsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyB0aGUgc2Vjb25kIGlucHV0IGZyb20gdGhlIGZpcnN0LiBGb3IgYSBzaW5nbGUgaW5wdXQsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyBpdCBmcm9tIDAuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJIi8iOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSByZXN1bHQgb2YgZmxvYXRpbmcgcG9pbnQgZGl2aXNpb24gb2YgdGhlIGZpcnN0IGlucHV0IGJ5IHRoZSBzZWNvbmQuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJIiUiOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSByZW1haW5kZXIgYWZ0ZXIgaW50ZWdlciBkaXZpc2lvbiBvZiB0aGUgZmlyc3QgaW5wdXQgYnkgdGhlIHNlY29uZC4iLAogICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkiXiI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIHJlc3VsdCBvZiByYWlzaW5nIHRoZSBmaXJzdCBpbnB1dCB0byB0aGUgcG93ZXIgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJc3FydDogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIGlucHV0LiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDIuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWxvZzEwOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBiYXNlLXRlbiBsb2dhcml0aG0gb2YgdGhlIGlucHV0LiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWxuOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJbG9nMjogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgYmFzZS10d28gbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC4iLAogICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlzaW46IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIHNpbmUgb2YgdGhlIGlucHV0LiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWNvczogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgY29zaW5lIG9mIHRoZSBpbnB1dC4iLAogICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQl0YW46IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIHRhbmdlbnQgb2YgdGhlIGlucHV0LiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWFzaW46IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGFyY3NpbmUgb2YgdGhlIGlucHV0LiIsCiAgICAJCQlncm91cDogIk1hdGgiLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWFjb3M6IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGFyY2Nvc2luZSBvZiB0aGUgaW5wdXQuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJYXRhbjogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgYXJjdGFuZ2VudCBvZiB0aGUgaW5wdXQuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJbWluOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBpbnB1dHMuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJbWF4OiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBpbnB1dHMuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJcm91bmQ6IHsKICAgIAkJCWRvYzogIlJvdW5kcyB0aGUgaW5wdXQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4gSGFsZndheSB2YWx1ZXMgYXJlIHJvdW5kZWQgYXdheSBmcm9tIHplcm8uIEZvciBleGFtcGxlLCBgW1wicm91bmRcIiwgLTEuNV1gIGV2YWx1YXRlcyB0byAtMi4iLAogICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlhYnM6IHsKICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBpbnB1dC4iLAogICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQljZWlsOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBzbWFsbGVzdCBpbnRlZ2VyIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dC4iLAogICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlmbG9vcjogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dC4iLAogICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlkaXN0YW5jZTogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgaW4gbWV0ZXJzIGJldHdlZW4gdGhlIGV2YWx1YXRlZCBmZWF0dXJlIGFuZCB0aGUgaW5wdXQgZ2VvbWV0cnkuIFRoZSBpbnB1dCB2YWx1ZSBjYW4gYmUgYSB2YWxpZCBHZW9KU09OIG9mIHR5cGUgYFBvaW50YCwgYE11bHRpUG9pbnRgLCBgTGluZVN0cmluZ2AsIGBNdWx0aUxpbmVTdHJpbmdgLCBgUG9seWdvbmAsIGBNdWx0aVBvbHlnb25gLCBgRmVhdHVyZWAsIG9yIGBGZWF0dXJlQ29sbGVjdGlvbmAuIERpc3RhbmNlIHZhbHVlcyByZXR1cm5lZCBtYXkgdmFyeSBpbiBwcmVjaXNpb24gZHVlIHRvIGxvc3MgaW4gcHJlY2lzaW9uIGZyb20gZW5jb2RpbmcgZ2VvbWV0cmllcywgcGFydGljdWxhcmx5IGJlbG93IHpvb20gbGV2ZWwgMTMuIiwKICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWFuZHJvaWQ6ICI5LjIuMCIsCiAgICAJCQkJCWlvczogIjUuOS4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjE2LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkiPT0iOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBjb21wYXJpc29uIGlzIHN0cmljdGx5IHR5cGVkOiB2YWx1ZXMgb2YgZGlmZmVyZW50IHJ1bnRpbWUgdHlwZXMgYXJlIGFsd2F5cyBjb25zaWRlcmVkIHVuZXF1YWwuIENhc2VzIHdoZXJlIHRoZSB0eXBlcyBhcmUga25vd24gdG8gYmUgZGlmZmVyZW50IGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW52YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLiIsCiAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfSwKICAgIAkJCQljb2xsYXRvcjogewogICAgCQkJCQlqczogIjAuNDUuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAJCQkJCWlvczogIjQuMi4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjkuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSIhPSI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIG5vdCBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBjb21wYXJpc29uIGlzIHN0cmljdGx5IHR5cGVkOiB2YWx1ZXMgb2YgZGlmZmVyZW50IHJ1bnRpbWUgdHlwZXMgYXJlIGFsd2F5cyBjb25zaWRlcmVkIHVuZXF1YWwuIENhc2VzIHdoZXJlIHRoZSB0eXBlcyBhcmUga25vd24gdG8gYmUgZGlmZmVyZW50IGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW52YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLiIsCiAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfSwKICAgIAkJCQljb2xsYXRvcjogewogICAgCQkJCQlqczogIjAuNDUuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAJCQkJCWlvczogIjQuMi4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjkuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSI+IjogewogICAgCQkJZG9jOiAiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLiIsCiAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfSwKICAgIAkJCQljb2xsYXRvcjogewogICAgCQkJCQlqczogIjAuNDUuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAJCQkJCWlvczogIjQuMi4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjkuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSI8IjogewogICAgCQkJZG9jOiAiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGxlc3MgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLiIsCiAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfSwKICAgIAkJCQljb2xsYXRvcjogewogICAgCQkJCQlqczogIjAuNDUuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAJCQkJCWlvczogIjQuMi4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjkuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSI+PSI6IHsKICAgIAkJCWRvYzogIlJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBpbnB1dCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBhcmd1bWVudHMgYXJlIHJlcXVpcmVkIHRvIGJlIGVpdGhlciBib3RoIHN0cmluZ3Mgb3IgYm90aCBudW1iZXJzOyBpZiBkdXJpbmcgZXZhbHVhdGlvbiB0aGV5IGFyZSBub3QsIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBwcm9kdWNlcyBhbiBlcnJvci4gQ2FzZXMgd2hlcmUgdGhpcyBjb25zdHJhaW50IGlzIGtub3duIG5vdCB0byBob2xkIGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW4gdmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy4iLAogICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0sCiAgICAJCQkJY29sbGF0b3I6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgCQkJCQlpb3M6ICI0LjIuMCIsCiAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkiPD0iOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuIiwKICAgIAkJCWdyb3VwOiAiRGVjaXNpb24iLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9LAogICAgCQkJCWNvbGxhdG9yOiB7CiAgICAJCQkJCWpzOiAiMC40NS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuNS4wIiwKICAgIAkJCQkJaW9zOiAiNC4yLjAiLAogICAgCQkJCQltYWNvczogIjAuOS4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJYWxsOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIGB0cnVlYCBpZiBhbGwgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0cyBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLCBhbmQgZXZhbHVhdGlvbiBpcyBzaG9ydC1jaXJjdWl0aW5nOiBvbmNlIGFuIGlucHV0IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGBmYWxzZWAsIHRoZSByZXN1bHQgaXMgYGZhbHNlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLiIsCiAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlhbnk6IHsKICAgIAkJCWRvYzogIlJldHVybnMgYHRydWVgIGlmIGFueSBvZiB0aGUgaW5wdXRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgaW5wdXRzIGFyZSBldmFsdWF0ZWQgaW4gb3JkZXIsIGFuZCBldmFsdWF0aW9uIGlzIHNob3J0LWNpcmN1aXRpbmc6IG9uY2UgYW4gaW5wdXQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYHRydWVgLCB0aGUgcmVzdWx0IGlzIGB0cnVlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLiIsCiAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQkiISI6IHsKICAgIAkJCWRvYzogIkxvZ2ljYWwgbmVnYXRpb24uIFJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBpcyBgZmFsc2VgLCBhbmQgYGZhbHNlYCBpZiB0aGUgaW5wdXQgaXMgYHRydWVgLiIsCiAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQl3aXRoaW46IHsKICAgIAkJCWRvYzogIlJldHVybnMgYHRydWVgIGlmIHRoZSBldmFsdWF0ZWQgZmVhdHVyZSBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIGEgYm91bmRhcnkgb2YgdGhlIGlucHV0IGdlb21ldHJ5LCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0IHZhbHVlIGNhbiBiZSBhIHZhbGlkIEdlb0pTT04gb2YgdHlwZSBgUG9seWdvbmAsIGBNdWx0aVBvbHlnb25gLCBgRmVhdHVyZWAsIG9yIGBGZWF0dXJlQ29sbGVjdGlvbmAuIFN1cHBvcnRlZCBmZWF0dXJlcyBmb3IgZXZhbHVhdGlvbjpcbi0gYFBvaW50YDogUmV0dXJucyBgZmFsc2VgIGlmIGEgcG9pbnQgaXMgb24gdGhlIGJvdW5kYXJ5IG9yIGZhbGxzIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuLSBgTGluZVN0cmluZ2A6IFJldHVybnMgYGZhbHNlYCBpZiBhbnkgcGFydCBvZiBhIGxpbmUgZmFsbHMgb3V0c2lkZSB0aGUgYm91bmRhcnksIHRoZSBsaW5lIGludGVyc2VjdHMgdGhlIGJvdW5kYXJ5LCBvciBhIGxpbmUncyBlbmRwb2ludCBpcyBvbiB0aGUgYm91bmRhcnkuIiwKICAgIAkJCWdyb3VwOiAiRGVjaXNpb24iLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjEuOS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgIAkJCQkJaW9zOiAiNS44LjAiLAogICAgCQkJCQltYWNvczogIjAuMTUuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJpcy1zdXBwb3J0ZWQtc2NyaXB0IjogewogICAgCQkJZG9jOiAiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHN0cmluZyBpcyBleHBlY3RlZCB0byByZW5kZXIgbGVnaWJseS4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBpbnB1dCBzdHJpbmcgY29udGFpbnMgc2VjdGlvbnMgdGhhdCBjYW5ub3QgYmUgcmVuZGVyZWQgd2l0aG91dCBwb3RlbnRpYWwgbG9zcyBvZiBtZWFuaW5nIChlLmcuIEluZGljIHNjcmlwdHMgdGhhdCByZXF1aXJlIGNvbXBsZXggdGV4dCBzaGFwaW5nLCBvciByaWdodC10by1sZWZ0IHNjcmlwdHMgaWYgdGhlIHRoZSBgbWFwYm94LWdsLXJ0bC10ZXh0YCBwbHVnaW4gaXMgbm90IGluIHVzZSBpbiBNYXBib3ggR0wgSlMpLiIsCiAgICAJCQlncm91cDogIlN0cmluZyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40NS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuNi4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJdXBjYXNlOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgY29udmVydGVkIHRvIHVwcGVyY2FzZS4gRm9sbG93cyB0aGUgVW5pY29kZSBEZWZhdWx0IENhc2UgQ29udmVyc2lvbiBhbGdvcml0aG0gYW5kIHRoZSBsb2NhbGUtaW5zZW5zaXRpdmUgY2FzZSBtYXBwaW5ncyBpbiB0aGUgVW5pY29kZSBDaGFyYWN0ZXIgRGF0YWJhc2UuIiwKICAgIAkJCWdyb3VwOiAiU3RyaW5nIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9LAogICAgCQlkb3duY2FzZTogewogICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgaW5wdXQgc3RyaW5nIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuIEZvbGxvd3MgdGhlIFVuaWNvZGUgRGVmYXVsdCBDYXNlIENvbnZlcnNpb24gYWxnb3JpdGhtIGFuZCB0aGUgbG9jYWxlLWluc2Vuc2l0aXZlIGNhc2UgbWFwcGluZ3MgaW4gdGhlIFVuaWNvZGUgQ2hhcmFjdGVyIERhdGFiYXNlLiIsCiAgICAJCQlncm91cDogIlN0cmluZyIsCiAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJfSwKICAgIAkJY29uY2F0OiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIGEgYHN0cmluZ2AgY29uc2lzdGluZyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgaW5wdXRzLiBFYWNoIGlucHV0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBhcyBpZiBieSBgdG8tc3RyaW5nYC4iLAogICAgCQkJZ3JvdXA6ICJTdHJpbmciLAogICAgCQkJInNkay1zdXBwb3J0IjogewogICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCQl9CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJyZXNvbHZlZC1sb2NhbGUiOiB7CiAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBJRVRGIGxhbmd1YWdlIHRhZyBvZiB0aGUgbG9jYWxlIGJlaW5nIHVzZWQgYnkgdGhlIHByb3ZpZGVkIGBjb2xsYXRvcmAuIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IHN5c3RlbSBsb2NhbGUsIG9yIHRvIGRldGVybWluZSBpZiBhIHJlcXVlc3RlZCBsb2NhbGUgd2FzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuIiwKICAgIAkJCWdyb3VwOiAiU3RyaW5nIiwKICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgCQkJCQlpb3M6ICI0LjIuMCIsCiAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAJCQkJfQogICAgCQkJfQogICAgCQl9CiAgICAJfQogICAgfTsKICAgIHZhciBmb2cgPSB7CiAgICAJcmFuZ2U6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJImRlZmF1bHQiOiBbCiAgICAJCQkwLjUsCiAgICAJCQkxMAogICAgCQldLAogICAgCQltaW5pbXVtOiAtMjAsCiAgICAJCW1heGltdW06IDIwLAogICAgCQlsZW5ndGg6IDIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJZG9jOiAiVGhlIHN0YXJ0IGFuZCBlbmQgZGlzdGFuY2UgcmFuZ2UgaW4gd2hpY2ggZm9nIGZhZGVzIGZyb20gZnVsbHkgdHJhbnNwYXJlbnQgdG8gZnVsbHkgb3BhcXVlLiBUaGUgZGlzdGFuY2UgdG8gdGhlIHBvaW50IGF0IHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBpcyBkZWZpbmVkIGFzIHplcm8sIHNvIHRoYXQgbmVnYXRpdmUgcmFuZ2UgdmFsdWVzIGFyZSBjbG9zZXIgdG8gdGhlIGNhbWVyYSwgYW5kIHBvc2l0aXZlIHZhbHVlcyBhcmUgZmFydGhlciBhd2F5LiIsCiAgICAJCWV4YW1wbGU6IFsKICAgIAkJCTAuNSwKICAgIAkJCTEwCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi4zLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC42LjAiLAogICAgCQkJCWlvczogIjEwLjYuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0sCiAgICAJY29sb3I6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIsCiAgICAJCSJkZWZhdWx0IjogIiNmZmZmZmYiLAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIlRoZSBjb2xvciBvZiB0aGUgYXRtb3NwaGVyZSByZWdpb24gaW1tZWRpYXRlbHkgYmVsb3cgdGhlIGhvcml6b24gYW5kIHdpdGhpbiB0aGUgYHJhbmdlYCBhbmQgYWJvdmUgdGhlIGhvcml6b24gYW5kIHdpdGhpbiBgaG9yaXpvbi1ibGVuZGAuIFVzaW5nIG9wYWNpdHkgaXMgcmVjb21tZW5kZWQgb25seSBmb3Igc21vb3RobHkgdHJhbnNpdGlvbmluZyBmb2cgb24vb2ZmIGFzIGFueXRoaW5nIGxlc3MgdGhhbiAxMDAlIG9wYWNpdHkgcmVzdWx0cyBpbiBtb3JlIHRpbGVzIGxvYWRlZCBhbmQgZHJhd24uIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIyLjMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjEwLjYuMCIsCiAgICAJCQkJaW9zOiAiMTAuNi4wIgogICAgCQkJfQogICAgCQl9CiAgICAJfSwKICAgIAkiaGlnaC1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIsCiAgICAJCSJkZWZhdWx0IjogIiMyNDVjZGYiLAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIlRoZSBjb2xvciBvZiB0aGUgYXRtb3NwaGVyZSByZWdpb24gYWJvdmUgdGhlIGhvcml6b24sIGBoaWdoLWNvbG9yYCBleHRlbmRzIGZ1cnRoZXIgYWJvdmUgdGhlIGhvcml6b24gdGhhbiB0aGUgYGNvbG9yYCBwcm9wZXJ0eSBhbmQgaXRzIHNwcmVhZCBjYW4gYmUgY29udHJvbGxlZCB3aXRoIGBob3Jpem9uLWJsZW5kYC4gVGhlIG9wYWNpdHkgY2FuIGJlIHNldCB0byBgMGAgdG8gcmVtb3ZlIHRoZSBoaWdoIGF0bW9zcGhlcmUgY29sb3IgY29udHJpYnV0aW9uLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi45LjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC42LjAiLAogICAgCQkJCWlvczogIjEwLjYuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0sCiAgICAJInNwYWNlLWNvbG9yIjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IiwKICAgIAkJImRlZmF1bHQiOiBbCiAgICAJCQkiaW50ZXJwb2xhdGUiLAogICAgCQkJWwogICAgCQkJCSJsaW5lYXIiCiAgICAJCQldLAogICAgCQkJWwogICAgCQkJCSJ6b29tIgogICAgCQkJXSwKICAgIAkJCTQsCiAgICAJCQkiIzAxMGIxOSIsCiAgICAJCQk3LAogICAgCQkJIiMzNjdhYjkiCiAgICAJCV0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJZG9jOiAiVGhlIGNvbG9yIG9mIHRoZSByZWdpb24gYWJvdmUgdGhlIGhvcml6b24gYW5kIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGBob3Jpem9uLWJsZW5kYCBjb250cmlidXRpb24uIFRoZSBvcGFjaXR5IGNhbiBiZSBzZXQgdG8gYDBgIHRvIGhhdmUgYSB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi45LjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC42LjAiLAogICAgCQkJCWlvczogIjEwLjYuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0sCiAgICAJImhvcml6b24tYmxlbmQiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IiwKICAgIAkJImRlZmF1bHQiOiBbCiAgICAJCQkiaW50ZXJwb2xhdGUiLAogICAgCQkJWwogICAgCQkJCSJsaW5lYXIiCiAgICAJCQldLAogICAgCQkJWwogICAgCQkJCSJ6b29tIgogICAgCQkJXSwKICAgIAkJCTQsCiAgICAJCQkwLjIsCiAgICAJCQk3LAogICAgCQkJMC4xCiAgICAJCV0sCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJZG9jOiAiSG9yaXpvbiBibGVuZCBhcHBsaWVzIGEgc21vb3RoIGZhZGUgZnJvbSB0aGUgY29sb3Igb2YgdGhlIGF0bW9zcGhlcmUgdG8gdGhlIGNvbG9yIG9mIHNwYWNlLiBBIHZhbHVlIG9mIHplcm8gbGVhdmVzIGEgc2hhcnAgdHJhbnNpdGlvbiBmcm9tIGF0bW9zcGhlcmUgdG8gc3BhY2UuIEluY3JlYXNpbmcgdGhlIHZhbHVlIGJsZW5kcyB0aGUgY29sb3Igb2YgYXRtb3NwaGVyZSBpbnRvIGluY3JlYXNpbmdseSBoaWdoIGFuZ2xlcyBvZiB0aGUgc2t5LiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi4zLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC42LjAiLAogICAgCQkJCWlvczogIjEwLjYuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0sCiAgICAJInN0YXItaW50ZW5zaXR5IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJImludGVycG9sYXRlIiwKICAgIAkJCVsKICAgIAkJCQkibGluZWFyIgogICAgCQkJXSwKICAgIAkJCVsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0sCiAgICAJCQk1LAogICAgCQkJMC4zNSwKICAgIAkJCTYsCiAgICAJCQkwCiAgICAJCV0sCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJZG9jOiAiQSB2YWx1ZSBjb250cm9sbGluZyB0aGUgc3RhciBpbnRlbnNpdHkgd2hlcmUgYDBgIHdpbGwgc2hvdyBubyBzdGFycyBhbmQgYDFgIHdpbGwgc2hvdyBzdGFycyBhdCB0aGVpciBtYXhpbXVtIGludGVuc2l0eS4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMTAuNi4wIiwKICAgIAkJCQlpb3M6ICIxMC42LjAiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9CiAgICB9OwogICAgdmFyIGxpZ2h0ID0gewogICAgCWFuY2hvcjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCSJkZWZhdWx0IjogInZpZXdwb3J0IiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgbWFwLiIKICAgIAkJCX0sCiAgICAJCQl2aWV3cG9ydDogewogICAgCQkJCWRvYzogIlRoZSBwb3NpdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlIGlzIGFsaWduZWQgdG8gdGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3cG9ydC4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJZG9jOiAiV2hldGhlciBleHRydWRlZCBnZW9tZXRyaWVzIGFyZSBsaXQgcmVsYXRpdmUgdG8gdGhlIG1hcCBvciB2aWV3cG9ydC4iLAogICAgCQlleGFtcGxlOiAibWFwIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9LAogICAgCXBvc2l0aW9uOiB7CiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJMS4xNSwKICAgIAkJCTIxMCwKICAgIAkJCTMwCiAgICAJCV0sCiAgICAJCWxlbmd0aDogMywKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQlkb2M6ICJQb3NpdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlIHJlbGF0aXZlIHRvIGxpdCAoZXh0cnVkZWQpIGdlb21ldHJpZXMsIGluIFtyIHJhZGlhbCBjb29yZGluYXRlLCBhIGF6aW11dGhhbCBhbmdsZSwgcCBwb2xhciBhbmdsZV0gd2hlcmUgciBpbmRpY2F0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgYmFzZSBvZiBhbiBvYmplY3QgdG8gaXRzIGxpZ2h0LCBhIGluZGljYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHJlbGF0aXZlIHRvIDDCsCAoMMKwIHdoZW4gYGxpZ2h0LmFuY2hvcmAgaXMgc2V0IHRvIGB2aWV3cG9ydGAgY29ycmVzcG9uZHMgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQsIG9yIDDCsCB3aGVuIGBsaWdodC5hbmNob3JgIGlzIHNldCB0byBgbWFwYCBjb3JyZXNwb25kcyB0byBkdWUgbm9ydGgsIGFuZCBkZWdyZWVzIHByb2NlZWQgY2xvY2t3aXNlKSwgYW5kIHAgaW5kaWNhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGxpZ2h0IChmcm9tIDDCsCwgZGlyZWN0bHkgYWJvdmUsIHRvIDE4MMKwLCBkaXJlY3RseSBiZWxvdykuIiwKICAgIAkJZXhhbXBsZTogWwogICAgCQkJMS41LAogICAgCQkJOTAsCiAgICAJCQk4MAogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0sCiAgICAJY29sb3I6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIsCiAgICAJCSJkZWZhdWx0IjogIiNmZmZmZmYiLAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIkNvbG9yIHRpbnQgZm9yIGxpZ2h0aW5nIGV4dHJ1ZGVkIGdlb21ldHJpZXMuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9LAogICAgCWludGVuc2l0eTogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIsCiAgICAJCSJkZWZhdWx0IjogMC41LAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAxLAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIkludGVuc2l0eSBvZiBsaWdodGluZyAob24gYSBzY2FsZSBmcm9tIDAgdG8gMSkuIEhpZ2hlciBudW1iZXJzIHdpbGwgcHJlc2VudCBhcyBtb3JlIGV4dHJlbWUgY29udHJhc3QuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9CiAgICB9OwogICAgdmFyIHByb2plY3Rpb24gPSB7CiAgICAJbmFtZTogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJYWxiZXJzOiB7CiAgICAJCQkJZG9jOiAiQW4gQWxiZXJzIGVxdWFsLWFyZWEgcHJvamVjdGlvbiBjZW50ZXJlZCBvbiB0aGUgY29udGluZW50YWwgVW5pdGVkIFN0YXRlcy4gWW91IGNhbiBjb25maWd1cmUgdGhlIHByb2plY3Rpb24gZm9yIGEgZGlmZmVyZW50IHJlZ2lvbiBieSBzZXR0aW5nIGBjZW50ZXJgIGFuZCBgcGFyYWxsZWxzYCBwcm9wZXJ0aWVzLiBZb3UgbWF5IHdhbnQgdG8gc2V0IG1heCBib3VuZHMgdG8gY29uc3RyYWluIHRoZSBtYXAgdG8gdGhlIHJlbGV2YW50IHJlZ2lvbi4iCiAgICAJCQl9LAogICAgCQkJZXF1YWxFYXJ0aDogewogICAgCQkJCWRvYzogIkFuIEVxdWFsIEVhcnRoIHByb2plY3Rpb24uIgogICAgCQkJfSwKICAgIAkJCWVxdWlyZWN0YW5ndWxhcjogewogICAgCQkJCWRvYzogIkFuIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLiBUaGlzIHByb2plY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBQbGF0ZSBDYXJyw6llIHByb2plY3Rpb24uIgogICAgCQkJfSwKICAgIAkJCWxhbWJlcnRDb25mb3JtYWxDb25pYzogewogICAgCQkJCWRvYzogIkEgTGFtYmVydCBjb25mb3JtYWwgY29uaWMgcHJvamVjdGlvbi4gWW91IGNhbiBjb25maWd1cmUgdGhlIHByb2plY3Rpb24gZm9yIGEgcmVnaW9uIGJ5IHNldHRpbmcgYGNlbnRlcmAgYW5kIGBwYXJhbGxlbHNgIHByb3BlcnRpZXMuIFlvdSBtYXkgd2FudCB0byBzZXQgbWF4IGJvdW5kcyB0byBjb25zdHJhaW4gdGhlIG1hcCB0byB0aGUgcmVsZXZhbnQgcmVnaW9uLiIKICAgIAkJCX0sCiAgICAJCQltZXJjYXRvcjogewogICAgCQkJCWRvYzogIlRoZSBNZXJjYXRvciBwcm9qZWN0aW9uIGlzIHRoZSBkZWZhdWx0IHByb2plY3Rpb24uIgogICAgCQkJfSwKICAgIAkJCW5hdHVyYWxFYXJ0aDogewogICAgCQkJCWRvYzogIkEgTmF0dXJhbCBFYXJ0aCBwcm9qZWN0aW9uLiIKICAgIAkJCX0sCiAgICAJCQl3aW5rZWxUcmlwZWw6IHsKICAgIAkJCQlkb2M6ICJBIFdpbmtlbCBUcmlwZWwgcHJvamVjdGlvbi4iCiAgICAJCQl9LAogICAgCQkJZ2xvYmU6IHsKICAgIAkJCQlkb2M6ICJBIGdsb2JlIHByb2plY3Rpb24uIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJtZXJjYXRvciIsCiAgICAJCWRvYzogIlRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0aW9uIHRvIGJlIHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgbWFwLiIsCiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuNi4wIgogICAgCQkJfQogICAgCQl9CiAgICAJfSwKICAgIAljZW50ZXI6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJbGVuZ3RoOiAyLAogICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiLAogICAgCQltaW5pbXVtOiBbCiAgICAJCQktMTgwLAogICAgCQkJLTkwCiAgICAJCV0sCiAgICAJCW1heGltdW06IFsKICAgIAkJCTE4MCwKICAgIAkJCTkwCiAgICAJCV0sCiAgICAJCXRyYW5zaXRpb246IGZhbHNlLAogICAgCQlkb2M6ICJUaGUgcmVmZXJlbmNlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHByb2plY3Rpb24uIGBjZW50ZXJgIHRha2VzIHRoZSBmb3JtIG9mIFtsbmcsIGxhdF0uIFRoaXMgcHJvcGVydHkgaXMgb25seSBjb25maWd1cmFibGUgZm9yIGNvbmljIHByb2plY3Rpb25zIChBbGJlcnMgYW5kIExhbWJlcnQgQ29uZm9ybWFsIENvbmljKS4gQWxsIG90aGVyIHByb2plY3Rpb25zIGFyZSBjZW50ZXJlZCBvbiBbMCwgMF0uIiwKICAgIAkJZXhhbXBsZTogWwogICAgCQkJLTk2LAogICAgCQkJMzcuNQogICAgCQldLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJewogICAgCQkJCW5hbWU6IFsKICAgIAkJCQkJImFsYmVycyIsCiAgICAJCQkJCSJsYW1iZXJ0Q29uZm9ybWFsQ29uaWMiCiAgICAJCQkJXQogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuNi4wIgogICAgCQkJfQogICAgCQl9CiAgICAJfSwKICAgIAlwYXJhbGxlbHM6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJbGVuZ3RoOiAyLAogICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiLAogICAgCQltaW5pbXVtOiBbCiAgICAJCQktOTAsCiAgICAJCQktOTAKICAgIAkJXSwKICAgIAkJbWF4aW11bTogWwogICAgCQkJOTAsCiAgICAJCQk5MAogICAgCQldLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJZG9jOiAiVGhlIHN0YW5kYXJkIHBhcmFsbGVscyBvZiB0aGUgcHJvamVjdGlvbiwgZGVub3RpbmcgdGhlIGRlc2lyZWQgbGF0aXR1ZGUgcmFuZ2Ugd2l0aCBtaW5pbWFsIGRpc3RvcnRpb24uIGBwYXJhbGxlbHNgIHRha2VzIHRoZSBmb3JtIG9mIFtsYXQwLCBsYXQxXS4gVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGNvbmZpZ3VyYWJsZSBmb3IgY29uaWMgcHJvamVjdGlvbnMgKEFsYmVycyBhbmQgTGFtYmVydCBDb25mb3JtYWwgQ29uaWMpLiIsCiAgICAJCWV4YW1wbGU6IFsKICAgIAkJCTI5LjUsCiAgICAJCQk0NS41CiAgICAJCV0sCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQl7CiAgICAJCQkJbmFtZTogWwogICAgCQkJCQkiYWxiZXJzIiwKICAgIAkJCQkJImxhbWJlcnRDb25mb3JtYWxDb25pYyIKICAgIAkJCQldCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi42LjAiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9CiAgICB9OwogICAgdmFyIHRlcnJhaW4gPSB7CiAgICAJc291cmNlOiB7CiAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJOYW1lIG9mIGEgc291cmNlIG9mIGByYXN0ZXJfZGVtYCB0eXBlIHRvIGJlIHVzZWQgZm9yIHRlcnJhaW4gZWxldmF0aW9uLiIsCiAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuMC4wIiwKICAgIAkJCQlpb3M6ICIxMC4wLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC4wLjAiCiAgICAJCQl9CiAgICAJCX0KICAgIAl9LAogICAgCWV4YWdnZXJhdGlvbjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIsCiAgICAJCSJkZWZhdWx0IjogMSwKICAgIAkJbWluaW11bTogMCwKICAgIAkJbWF4aW11bTogMTAwMCwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQlkb2M6ICJFeGFnZ2VyYXRlcyB0aGUgZWxldmF0aW9uIG9mIHRoZSB0ZXJyYWluIGJ5IG11bHRpcGx5aW5nIHRoZSBkYXRhIGZyb20gdGhlIERFTSB3aXRoIHRoaXMgdmFsdWUuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJzb3VyY2UiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi4wLjAiLAogICAgCQkJCWlvczogIjEwLjAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjEwLjAuMCIKICAgIAkJCX0KICAgIAkJfQogICAgCX0KICAgIH07CiAgICB2YXIgcGFpbnQgPSBbCiAgICAJInBhaW50X2ZpbGwiLAogICAgCSJwYWludF9saW5lIiwKICAgIAkicGFpbnRfY2lyY2xlIiwKICAgIAkicGFpbnRfaGVhdG1hcCIsCiAgICAJInBhaW50X2ZpbGwtZXh0cnVzaW9uIiwKICAgIAkicGFpbnRfc3ltYm9sIiwKICAgIAkicGFpbnRfcmFzdGVyIiwKICAgIAkicGFpbnRfaGlsbHNoYWRlIiwKICAgIAkicGFpbnRfYmFja2dyb3VuZCIsCiAgICAJInBhaW50X3NreSIKICAgIF07CiAgICB2YXIgcGFpbnRfZmlsbCA9IHsKICAgIAkiZmlsbC1hbnRpYWxpYXMiOiB7CiAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgIAkJImRlZmF1bHQiOiB0cnVlLAogICAgCQlkb2M6ICJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkiZmlsbC1vcGFjaXR5IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxLAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAxLAogICAgCQlkb2M6ICJUaGUgb3BhY2l0eSBvZiB0aGUgZW50aXJlIGZpbGwgbGF5ZXIuIEluIGNvbnRyYXN0IHRvIHRoZSBgZmlsbC1jb2xvcmAsIHRoaXMgdmFsdWUgd2lsbCBhbHNvIGFmZmVjdCB0aGUgMXB4IHN0cm9rZSBhcm91bmQgdGhlIGZpbGwsIGlmIHRoZSBzdHJva2UgaXMgdXNlZC4iLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMjEuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImZpbGwtY29sb3IiOiB7CiAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgCQlkb2M6ICJUaGUgY29sb3Igb2YgdGhlIGZpbGxlZCBwYXJ0IG9mIHRoaXMgbGF5ZXIuIFRoaXMgY29sb3IgY2FuIGJlIHNwZWNpZmllZCBhcyBgcmdiYWAgd2l0aCBhbiBhbHBoYSBjb21wb25lbnQgYW5kIHRoZSBjb2xvcidzIG9wYWNpdHkgd2lsbCBub3QgYWZmZWN0IHRoZSBvcGFjaXR5IG9mIHRoZSAxcHggc3Ryb2tlLCBpZiBpdCBpcyB1c2VkLiIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQl7CiAgICAJCQkJIiEiOiAiZmlsbC1wYXR0ZXJuIgogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMTkuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImZpbGwtb3V0bGluZS1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJZG9jOiAiVGhlIG91dGxpbmUgY29sb3Igb2YgdGhlIGZpbGwuIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBmaWxsLWNvbG9yYCBpZiB1bnNwZWNpZmllZC4iLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJewogICAgCQkJCSIhIjogImZpbGwtcGF0dGVybiIKICAgIAkJCX0sCiAgICAJCQl7CiAgICAJCQkJImZpbGwtYW50aWFsaWFzIjogdHJ1ZQogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMTkuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImZpbGwtdHJhbnNsYXRlIjogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAJCWxlbmd0aDogMiwKICAgIAkJImRlZmF1bHQiOiBbCiAgICAJCQkwLAogICAgCQkJMAogICAgCQldLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQl1bml0czogInBpeGVscyIsCiAgICAJCWRvYzogIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJmaWxsLXRyYW5zbGF0ZS1hbmNob3IiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuIgogICAgCQkJfSwKICAgIAkJCXZpZXdwb3J0OiB7CiAgICAJCQkJZG9jOiAiVGhlIGZpbGwgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIgogICAgCQkJfQogICAgCQl9LAogICAgCQlkb2M6ICJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC10cmFuc2xhdGVgLiIsCiAgICAJCSJkZWZhdWx0IjogIm1hcCIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkiZmlsbC10cmFuc2xhdGUiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImZpbGwtcGF0dGVybiI6IHsKICAgIAkJdHlwZTogInJlc29sdmVkSW1hZ2UiLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQlkb2M6ICJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgZmlsbHMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC40OS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgCQkJCW1hY29zOiAiMC4xMS4wIiwKICAgIAkJCQlpb3M6ICI0LjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuIgogICAgCX0KICAgIH07CiAgICB2YXIgcGFpbnRfbGluZSA9IHsKICAgIAkibGluZS1vcGFjaXR5IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi4iLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkibGluZS1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJZG9jOiAiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi4iLAogICAgCQkiZGVmYXVsdCI6ICIjMDAwMDAwIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCXsKICAgIAkJCQkiISI6ICJsaW5lLXBhdHRlcm4iCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yMy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkibGluZS10cmFuc2xhdGUiOiB7CiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJbGVuZ3RoOiAyLAogICAgCQkiZGVmYXVsdCI6IFsKICAgIAkJCTAsCiAgICAJCQkwCiAgICAJCV0sCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImxpbmUtdHJhbnNsYXRlLWFuY2hvciI6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCW1hcDogewogICAgCQkJCWRvYzogIlRoZSBsaW5lIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC4iCiAgICAJCQl9LAogICAgCQkJdmlld3BvcnQ6IHsKICAgIAkJCQlkb2M6ICJUaGUgbGluZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWRvYzogIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBsaW5lLXRyYW5zbGF0ZWAuIiwKICAgIAkJImRlZmF1bHQiOiAibWFwIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJsaW5lLXRyYW5zbGF0ZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkibGluZS13aWR0aCI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMSwKICAgIAkJbWluaW11bTogMCwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJTdHJva2UgdGhpY2tuZXNzLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgCQkJCWlvczogIjMuNy4wIiwKICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkibGluZS1nYXAtd2lkdGgiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCWRvYzogIkRyYXdzIGEgbGluZSBjYXNpbmcgb3V0c2lkZSBvZiBhIGxpbmUncyBhY3R1YWwgcGF0aC4gVmFsdWUgaW5kaWNhdGVzIHRoZSB3aWR0aCBvZiB0aGUgaW5uZXIgZ2FwLiIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJsaW5lLW9mZnNldCI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMCwKICAgIAkJZG9jOiAiVGhlIGxpbmUncyBvZmZzZXQuIEZvciBsaW5lYXIgZmVhdHVyZXMsIGEgcG9zaXRpdmUgdmFsdWUgb2Zmc2V0cyB0aGUgbGluZSB0byB0aGUgcmlnaHQsIHJlbGF0aXZlIHRvIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpbmUsIGFuZCBhIG5lZ2F0aXZlIHZhbHVlIHRvIHRoZSBsZWZ0LiBGb3IgcG9seWdvbiBmZWF0dXJlcywgYSBwb3NpdGl2ZSB2YWx1ZSByZXN1bHRzIGluIGFuIGluc2V0LCBhbmQgYSBuZWdhdGl2ZSB2YWx1ZSByZXN1bHRzIGluIGFuIG91dHNldC4iLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQl1bml0czogInBpeGVscyIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMi4xIiwKICAgIAkJCQlhbmRyb2lkOiAiMy4wLjAiLAogICAgCQkJCWlvczogIjMuMS4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkibGluZS1ibHVyIjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQltaW5pbXVtOiAwLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQl1bml0czogInBpeGVscyIsCiAgICAJCWRvYzogIkJsdXIgYXBwbGllZCB0byB0aGUgbGluZSwgaW4gcGl4ZWxzLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkibGluZS1kYXNoYXJyYXkiOiB7CiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiU3BlY2lmaWVzIHRoZSBsZW5ndGhzIG9mIHRoZSBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMgdGhhdCBmb3JtIHRoZSBkYXNoIHBhdHRlcm4uIFRoZSBsZW5ndGhzIGFyZSBsYXRlciBzY2FsZWQgYnkgdGhlIGxpbmUgd2lkdGguIFRvIGNvbnZlcnQgYSBkYXNoIGxlbmd0aCB0byBwaXhlbHMsIG11bHRpcGx5IHRoZSBsZW5ndGggYnkgdGhlIGN1cnJlbnQgbGluZSB3aWR0aC4gTm90ZSB0aGF0IEdlb0pTT04gc291cmNlcyB3aXRoIGBsaW5lTWV0cmljczogdHJ1ZWAgc3BlY2lmaWVkIHdvbid0IHJlbmRlciBkYXNoZWQgbGluZXMgdG8gdGhlIGV4cGVjdGVkIHNjYWxlLiBBbHNvIG5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuIiwKICAgIAkJbWluaW11bTogMCwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJdW5pdHM6ICJsaW5lIHdpZHRocyIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQl7CiAgICAJCQkJIiEiOiAibGluZS1wYXR0ZXJuIgogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjIuMy4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkibGluZS1wYXR0ZXJuIjogewogICAgCQl0eXBlOiAicmVzb2x2ZWRJbWFnZSIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC40OS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgCQkJCW1hY29zOiAiMC4xMS4wIiwKICAgIAkJCQlpb3M6ICI0LjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImxpbmUtZ3JhZGllbnQiOiB7CiAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAJCWRvYzogIkRlZmluZXMgYSBncmFkaWVudCB3aXRoIHdoaWNoIHRvIGNvbG9yIGEgbGluZSBmZWF0dXJlLiBDYW4gb25seSBiZSB1c2VkIHdpdGggR2VvSlNPTiBzb3VyY2VzIHRoYXQgc3BlY2lmeSBgXCJsaW5lTWV0cmljc1wiOiB0cnVlYC4iLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCXsKICAgIAkJCQkiISI6ICJsaW5lLXBhdHRlcm4iCiAgICAJCQl9LAogICAgCQkJewogICAgCQkJCXNvdXJjZTogImdlb2pzb24iLAogICAgCQkJCWhhczogewogICAgCQkJCQlsaW5lTWV0cmljczogdHJ1ZQogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQ1LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAJCQkJaW9zOiAiNC40LjAiLAogICAgCQkJCW1hY29zOiAiMC4xMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJImxpbmUtcHJvZ3Jlc3MiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbG9yLXJhbXAiCiAgICAJfSwKICAgIAkibGluZS10cmltLW9mZnNldCI6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQlkb2M6ICJUaGUgbGluZSBwYXJ0IGJldHdlZW4gW3RyaW0tc3RhcnQsIHRyaW0tZW5kXSB3aWxsIGJlIG1hcmtlZCBhcyB0cmFuc3BhcmVudCB0byBtYWtlIGEgcm91dGUgdmFuaXNoaW5nIGVmZmVjdC4gVGhlIGxpbmUgdHJpbS1vZmYgb2Zmc2V0IGlzIGJhc2VkIG9uIHRoZSB3aG9sZSBsaW5lIHJhbmdlIFswLjAsIDEuMF0uIiwKICAgIAkJbGVuZ3RoOiAyLAogICAgCQkiZGVmYXVsdCI6IFsKICAgIAkJCTAsCiAgICAJCQkwCiAgICAJCV0sCiAgICAJCW1pbmltdW06IFsKICAgIAkJCTAsCiAgICAJCQkwCiAgICAJCV0sCiAgICAJCW1heGltdW06IFsKICAgIAkJCTEsCiAgICAJCQkxCiAgICAJCV0sCiAgICAJCXRyYW5zaXRpb246IGZhbHNlLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJewogICAgCQkJCXNvdXJjZTogImdlb2pzb24iLAogICAgCQkJCWhhczogewogICAgCQkJCQlsaW5lTWV0cmljczogdHJ1ZQogICAgCQkJCX0KICAgIAkJCX0KICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIyLjkuMCIsCiAgICAJCQkJYW5kcm9pZDogIjEwLjUuMCIsCiAgICAJCQkJaW9zOiAiMTAuNS4wIiwKICAgIAkJCQltYWNvczogIjEwLjUuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY29uc3RhbnQiCiAgICAJfQogICAgfTsKICAgIHZhciBwYWludF9jaXJjbGUgPSB7CiAgICAJImNpcmNsZS1yYWRpdXMiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDUsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiQ2lyY2xlIHJhZGl1cy4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMTguMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImNpcmNsZS1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJImRlZmF1bHQiOiAiIzAwMDAwMCIsCiAgICAJCWRvYzogIlRoZSBmaWxsIGNvbG9yIG9mIHRoZSBjaXJjbGUuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjE4LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJjaXJjbGUtYmx1ciI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMCwKICAgIAkJZG9jOiAiQW1vdW50IHRvIGJsdXIgdGhlIGNpcmNsZS4gMSBibHVycyB0aGUgY2lyY2xlIHN1Y2ggdGhhdCBvbmx5IHRoZSBjZW50ZXJwb2ludCBpcyBmdWxsIG9wYWNpdHkuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjIwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJjaXJjbGUtb3BhY2l0eSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCWRvYzogIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBjaXJjbGUgd2lsbCBiZSBkcmF3bi4iLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiY2lyY2xlLXRyYW5zbGF0ZSI6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQlsZW5ndGg6IDIsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJMCwKICAgIAkJCTAKICAgIAkJXSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3IiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJUaGUgY2lyY2xlIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC4iCiAgICAJCQl9LAogICAgCQkJdmlld3BvcnQ6IHsKICAgIAkJCQlkb2M6ICJUaGUgY2lyY2xlIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZG9jOiAiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGNpcmNsZS10cmFuc2xhdGVgLiIsCiAgICAJCSJkZWZhdWx0IjogIm1hcCIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkiY2lyY2xlLXRyYW5zbGF0ZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkiY2lyY2xlLXBpdGNoLXNjYWxlIjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJbWFwOiB7CiAgICAJCQkJZG9jOiAiQ2lyY2xlcyBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBhcHBhcmVudCBkaXN0YW5jZSB0byB0aGUgY2FtZXJhLiIKICAgIAkJCX0sCiAgICAJCQl2aWV3cG9ydDogewogICAgCQkJCWRvYzogIkNpcmNsZXMgYXJlIG5vdCBzY2FsZWQuIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJtYXAiLAogICAgCQlkb2M6ICJDb250cm9scyB0aGUgc2NhbGluZyBiZWhhdmlvciBvZiB0aGUgY2lyY2xlIHdoZW4gdGhlIG1hcCBpcyBwaXRjaGVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4yMS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNC4yLjAiLAogICAgCQkJCWlvczogIjMuNC4wIiwKICAgIAkJCQltYWNvczogIjAuMi4xIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImNpcmNsZS1waXRjaC1hbGlnbm1lbnQiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJUaGUgY2lyY2xlIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuIgogICAgCQkJfSwKICAgIAkJCXZpZXdwb3J0OiB7CiAgICAJCQkJZG9jOiAiVGhlIGNpcmNsZSBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJ2aWV3cG9ydCIsCiAgICAJCWRvYzogIk9yaWVudGF0aW9uIG9mIGNpcmNsZSB3aGVuIG1hcCBpcyBwaXRjaGVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4zOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgCQkJCWlvczogIjMuNy4wIiwKICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImNpcmNsZS1zdHJva2Utd2lkdGgiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiVGhlIHdpZHRoIG9mIHRoZSBjaXJjbGUncyBzdHJva2UuIFN0cm9rZXMgYXJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBgY2lyY2xlLXJhZGl1c2AuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJjaXJjbGUtc3Ryb2tlLWNvbG9yIjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQkiZGVmYXVsdCI6ICIjMDAwMDAwIiwKICAgIAkJZG9jOiAiVGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgY2lyY2xlLiIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiY2lyY2xlLXN0cm9rZS1vcGFjaXR5IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS4iLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfQogICAgfTsKICAgIHZhciBwYWludF9oZWF0bWFwID0gewogICAgCSJoZWF0bWFwLXJhZGl1cyI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMzAsCiAgICAJCW1pbmltdW06IDEsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiUmFkaXVzIG9mIGluZmx1ZW5jZSBvZiBvbmUgaGVhdG1hcCBwb2ludCBpbiBwaXhlbHMuIEluY3JlYXNpbmcgdGhlIHZhbHVlIG1ha2VzIHRoZSBoZWF0bWFwIHNtb290aGVyLCBidXQgbGVzcyBkZXRhaWxlZC4gYHF1ZXJ5UmVuZGVyZWRGZWF0dXJlc2Agb24gaGVhdG1hcCBsYXllcnMgd2lsbCByZXR1cm4gcG9pbnRzIHdpdGhpbiB0aGlzIHJhZGl1cy4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuNDEuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImhlYXRtYXAtd2VpZ2h0IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxLAogICAgCQltaW5pbXVtOiAwLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJZG9jOiAiQSBtZWFzdXJlIG9mIGhvdyBtdWNoIGFuIGluZGl2aWR1YWwgcG9pbnQgY29udHJpYnV0ZXMgdG8gdGhlIGhlYXRtYXAuIEEgdmFsdWUgb2YgMTAgd291bGQgYmUgZXF1aXZhbGVudCB0byBoYXZpbmcgMTAgcG9pbnRzIG9mIHdlaWdodCAxIGluIHRoZSBzYW1lIHNwb3QuIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBjbHVzdGVyaW5nLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiaGVhdG1hcC1pbnRlbnNpdHkiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIlNpbWlsYXIgdG8gYGhlYXRtYXAtd2VpZ2h0YCBidXQgY29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgaGVhdG1hcCBnbG9iYWxseS4gUHJpbWFyaWx5IHVzZWQgZm9yIGFkanVzdGluZyB0aGUgaGVhdG1hcCBiYXNlZCBvbiB6b29tIGxldmVsLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC40MS4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkiaGVhdG1hcC1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJImRlZmF1bHQiOiBbCiAgICAJCQkiaW50ZXJwb2xhdGUiLAogICAgCQkJWwogICAgCQkJCSJsaW5lYXIiCiAgICAJCQldLAogICAgCQkJWwogICAgCQkJCSJoZWF0bWFwLWRlbnNpdHkiCiAgICAJCQldLAogICAgCQkJMCwKICAgIAkJCSJyZ2JhKDAsIDAsIDI1NSwgMCkiLAogICAgCQkJMC4xLAogICAgCQkJInJveWFsYmx1ZSIsCiAgICAJCQkwLjMsCiAgICAJCQkiY3lhbiIsCiAgICAJCQkwLjUsCiAgICAJCQkibGltZSIsCiAgICAJCQkwLjcsCiAgICAJCQkieWVsbG93IiwKICAgIAkJCTEsCiAgICAJCQkicmVkIgogICAgCQldLAogICAgCQlkb2M6ICJEZWZpbmVzIHRoZSBjb2xvciBvZiBlYWNoIHBpeGVsIGJhc2VkIG9uIGl0cyBkZW5zaXR5IHZhbHVlIGluIGEgaGVhdG1hcC4gIFNob3VsZCBiZSBhbiBleHByZXNzaW9uIHRoYXQgdXNlcyBgW1wiaGVhdG1hcC1kZW5zaXR5XCJdYCBhcyBpbnB1dC4iLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiaGVhdG1hcC1kZW5zaXR5IgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJjb2xvci1yYW1wIgogICAgCX0sCiAgICAJImhlYXRtYXAtb3BhY2l0eSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCWRvYzogIlRoZSBnbG9iYWwgb3BhY2l0eSBhdCB3aGljaCB0aGUgaGVhdG1hcCBsYXllciB3aWxsIGJlIGRyYXduLiIsCiAgICAJCSJkZWZhdWx0IjogMSwKICAgIAkJbWluaW11bTogMCwKICAgIAkJbWF4aW11bTogMSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQxLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9CiAgICB9OwogICAgdmFyIHBhaW50X3N5bWJvbCA9IHsKICAgIAkiaWNvbi1vcGFjaXR5IjogewogICAgCQlkb2M6ICJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaWNvbiB3aWxsIGJlIGRyYXduLiIsCiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkiaWNvbi1pbWFnZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjMzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJpY29uLWNvbG9yIjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQkiZGVmYXVsdCI6ICIjMDAwMDAwIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJZG9jOiAiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBbU0RGIGljb25zXSgvaGVscC90cm91Ymxlc2hvb3RpbmcvdXNpbmctcmVjb2xvcmFibGUtaW1hZ2VzLWluLW1hcGJveC1tYXBzLykuIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJpY29uLWltYWdlIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImljb24taGFsby1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJImRlZmF1bHQiOiAicmdiYSgwLCAwLCAwLCAwKSIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIlRoZSBjb2xvciBvZiB0aGUgaWNvbidzIGhhbG8uIEljb24gaGFsb3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFtTREYgaWNvbnNdKC9oZWxwL3Ryb3VibGVzaG9vdGluZy91c2luZy1yZWNvbG9yYWJsZS1pbWFnZXMtaW4tbWFwYm94LW1hcHMvKS4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zMy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiaWNvbi1oYWxvLXdpZHRoIjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQltaW5pbXVtOiAwLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQl1bml0czogInBpeGVscyIsCiAgICAJCWRvYzogIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGljb24gb3V0bGluZS4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zMy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiaWNvbi1oYWxvLWJsdXIiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiRmFkZSBvdXQgdGhlIGhhbG8gdG93YXJkcyB0aGUgb3V0c2lkZS4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImljb24taW1hZ2UiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zMy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiaWNvbi10cmFuc2xhdGUiOiB7CiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJbGVuZ3RoOiAyLAogICAgCQkiZGVmYXVsdCI6IFsKICAgIAkJCTAsCiAgICAJCQkwCiAgICAJCV0sCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiRGlzdGFuY2UgdGhhdCB0aGUgaWNvbidzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkiaWNvbi1pbWFnZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJpY29uLXRyYW5zbGF0ZS1hbmNob3IiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLiIKICAgIAkJCX0sCiAgICAJCQl2aWV3cG9ydDogewogICAgCQkJCWRvYzogIkljb25zIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWRvYzogIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBpY29uLXRyYW5zbGF0ZWAuIiwKICAgIAkJImRlZmF1bHQiOiAibWFwIiwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJpY29uLWltYWdlIiwKICAgIAkJCSJpY29uLXRyYW5zbGF0ZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkidGV4dC1vcGFjaXR5IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi4iLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjMzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJ0ZXh0LWNvbG9yIjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQlkb2M6ICJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLiIsCiAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQlvdmVycmlkYWJsZTogdHJ1ZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJInRleHQtaGFsby1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJImRlZmF1bHQiOiAicmdiYSgwLCAwLCAwLCAwKSIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCWRvYzogIlRoZSBjb2xvciBvZiB0aGUgdGV4dCdzIGhhbG8sIHdoaWNoIGhlbHBzIGl0IHN0YW5kIG91dCBmcm9tIGJhY2tncm91bmRzLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjMzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJ0ZXh0LWhhbG8td2lkdGgiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgZm9udCBvdXRsaW5lLiBNYXggdGV4dCBoYWxvIHdpZHRoIGlzIDEvNCBvZiB0aGUgZm9udC1zaXplLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQkJanM6ICIwLjMzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIsCiAgICAJCQkJImZlYXR1cmUiLAogICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJ0ZXh0LWhhbG8tYmx1ciI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMCwKICAgIAkJbWluaW11bTogMCwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJUaGUgaGFsbydzIGZhZGVvdXQgZGlzdGFuY2UgdG93YXJkcyB0aGUgb3V0c2lkZS4iLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJInRleHQtZmllbGQiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4zMy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgCQkJCWlvczogIjMuNS4wIiwKICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkidGV4dC10cmFuc2xhdGUiOiB7CiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJbGVuZ3RoOiAyLAogICAgCQkiZGVmYXVsdCI6IFsKICAgIAkJCTAsCiAgICAJCQkwCiAgICAJCV0sCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgIAkJZG9jOiAiRGlzdGFuY2UgdGhhdCB0aGUgdGV4dCdzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3IiOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQltYXA6IHsKICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuIgogICAgCQkJfSwKICAgIAkJCXZpZXdwb3J0OiB7CiAgICAJCQkJZG9jOiAiVGhlIHRleHQgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIgogICAgCQkJfQogICAgCQl9LAogICAgCQlkb2M6ICJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgdGV4dC10cmFuc2xhdGVgLiIsCiAgICAJCSJkZWZhdWx0IjogIm1hcCIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQkidGV4dC1maWVsZCIsCiAgICAJCQkidGV4dC10cmFuc2xhdGUiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgcGFpbnRfcmFzdGVyID0gewogICAgCSJyYXN0ZXItb3BhY2l0eSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCWRvYzogIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpbWFnZSB3aWxsIGJlIGRyYXduLiIsCiAgICAJCSJkZWZhdWx0IjogMSwKICAgIAkJbWluaW11bTogMCwKICAgIAkJbWF4aW11bTogMSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJyYXN0ZXItaHVlLXJvdGF0ZSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMCwKICAgIAkJcGVyaW9kOiAzNjAsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXVuaXRzOiAiZGVncmVlcyIsCiAgICAJCWRvYzogIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgCQkJCWlvczogIjIuMC4wIiwKICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkicmFzdGVyLWJyaWdodG5lc3MtbWluIjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJZG9jOiAiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIGJyaWdodG5lc3MuIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAxLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInJhc3Rlci1icmlnaHRuZXNzLW1heCI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCWRvYzogIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIFRoZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBicmlnaHRuZXNzLiIsCiAgICAJCSJkZWZhdWx0IjogMSwKICAgIAkJbWluaW11bTogMCwKICAgIAkJbWF4aW11bTogMSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJyYXN0ZXItc2F0dXJhdGlvbiI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCWRvYzogIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgc2F0dXJhdGlvbiBvZiB0aGUgaW1hZ2UuIiwKICAgIAkJImRlZmF1bHQiOiAwLAogICAgCQltaW5pbXVtOiAtMSwKICAgIAkJbWF4aW11bTogMSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJyYXN0ZXItY29udHJhc3QiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQlkb2M6ICJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS4iLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IC0xLAogICAgCQltYXhpbXVtOiAxLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInJhc3Rlci1yZXNhbXBsaW5nIjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCWRvYzogIlRoZSByZXNhbXBsaW5nL2ludGVycG9sYXRpb24gbWV0aG9kIHRvIHVzZSBmb3Igb3ZlcnNjYWxpbmcsIGFsc28ga25vd24gYXMgdGV4dHVyZSBtYWduaWZpY2F0aW9uIGZpbHRlciIsCiAgICAJCXZhbHVlczogewogICAgCQkJbGluZWFyOiB7CiAgICAJCQkJZG9jOiAiKEJpKWxpbmVhciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciBjbG9zZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbHMgY3JlYXRpbmcgYSBzbW9vdGggYnV0IGJsdXJyeSBsb29rIHdoZW4gb3ZlcnNjYWxlZCIKICAgIAkJCX0sCiAgICAJCQluZWFyZXN0OiB7CiAgICAJCQkJZG9jOiAiTmVhcmVzdCBuZWlnaGJvciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgbmVhcmVzdCBvcmlnaW5hbCBzb3VyY2UgcGl4ZWwgY3JlYXRpbmcgYSBzaGFycCBidXQgcGl4ZWxhdGVkIGxvb2sgd2hlbiBvdmVyc2NhbGVkIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJsaW5lYXIiLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuNDcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuMy4wIiwKICAgIAkJCQlpb3M6ICI0LjIuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjkuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJyYXN0ZXItZmFkZS1kdXJhdGlvbiI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMzAwLAogICAgCQltaW5pbXVtOiAwLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJdW5pdHM6ICJtaWxsaXNlY29uZHMiLAogICAgCQlkb2M6ICJGYWRlIGR1cmF0aW9uIHdoZW4gYSBuZXcgdGlsZSBpcyBhZGRlZC4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgcGFpbnRfaGlsbHNoYWRlID0gewogICAgCSJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvbiI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMzM1LAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAzNTksCiAgICAJCWRvYzogIlRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBoaWxsc2hhZGluZyB3aXRoIDAgYXMgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgaWYgYGhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yYCBpcyBzZXQgdG8gYHZpZXdwb3J0YCBhbmQgZHVlIG5vcnRoIGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGBtYXBgLiIsCiAgICAJCXRyYW5zaXRpb246IGZhbHNlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yIjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJbWFwOiB7CiAgICAJCQkJZG9jOiAiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG5vcnRoIGRpcmVjdGlvbi4iCiAgICAJCQl9LAogICAgCQkJdmlld3BvcnQ6IHsKICAgIAkJCQlkb2M6ICJUaGUgaGlsbHNoYWRlIGlsbHVtaW5hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogInZpZXdwb3J0IiwKICAgIAkJZG9jOiAiRGlyZWN0aW9uIG9mIGxpZ2h0IHNvdXJjZSB3aGVuIG1hcCBpcyByb3RhdGVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC40My4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgCQkJCWlvczogIjQuMC4wIiwKICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImhpbGxzaGFkZS1leGFnZ2VyYXRpb24iOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQlkb2M6ICJJbnRlbnNpdHkgb2YgdGhlIGhpbGxzaGFkZSIsCiAgICAJCSJkZWZhdWx0IjogMC41LAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAxLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImhpbGxzaGFkZS1zaGFkb3ctY29sb3IiOiB7CiAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgCQlkb2M6ICJUaGUgc2hhZGluZyBjb2xvciBvZiBhcmVhcyB0aGF0IGZhY2UgYXdheSBmcm9tIHRoZSBsaWdodCBzb3VyY2UuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJoaWxsc2hhZGUtaGlnaGxpZ2h0LWNvbG9yIjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQkiZGVmYXVsdCI6ICIjRkZGRkZGIiwKICAgIAkJZG9jOiAiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlcyB0b3dhcmRzIHRoZSBsaWdodCBzb3VyY2UuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJoaWxsc2hhZGUtYWNjZW50LWNvbG9yIjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQkiZGVmYXVsdCI6ICIjMDAwMDAwIiwKICAgIAkJZG9jOiAiVGhlIHNoYWRpbmcgY29sb3IgdXNlZCB0byBhY2NlbnR1YXRlIHJ1Z2dlZCB0ZXJyYWluIGxpa2Ugc2hhcnAgY2xpZmZzIGFuZCBnb3JnZXMuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9CiAgICB9OwogICAgdmFyIHBhaW50X2JhY2tncm91bmQgPSB7CiAgICAJImJhY2tncm91bmQtY29sb3IiOiB7CiAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgCQlkb2M6ICJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLiIsCiAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQl7CiAgICAJCQkJIiEiOiAiYmFja2dyb3VuZC1wYXR0ZXJuIgogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJImJhY2tncm91bmQtcGF0dGVybiI6IHsKICAgIAkJdHlwZTogInJlc29sdmVkSW1hZ2UiLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQlkb2M6ICJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAJCQl9LAogICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNyb3NzLWZhZGVkIgogICAgCX0sCiAgICAJImJhY2tncm91bmQtb3BhY2l0eSI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMSwKICAgIAkJbWluaW11bTogMCwKICAgIAkJbWF4aW11bTogMSwKICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi4iLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0KICAgIH07CiAgICB2YXIgcGFpbnRfc2t5ID0gewogICAgCSJza3ktdHlwZSI6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWdyYWRpZW50OiB7CiAgICAJCQkJZG9jOiAiUmVuZGVycyB0aGUgc2t5IHdpdGggYSBncmFkaWVudCB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHdpdGggYHNreS1ncmFkaWVudC1yYWRpdXNgIGFuZCBgc2t5LWdyYWRpZW50YC4iCiAgICAJCQl9LAogICAgCQkJYXRtb3NwaGVyZTogewogICAgCQkJCWRvYzogIlJlbmRlcnMgdGhlIHNreSB3aXRoIGEgc2ltdWxhdGVkIGF0bW9zcGhlcmljIHNjYXR0ZXJpbmcgYWxnb3JpdGhtLCB0aGUgc3VuIGRpcmVjdGlvbiBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGxpZ2h0IHBvc2l0aW9uIG9yIGV4cGxpY2l0bHkgc2V0IHRocm91Z2ggYHNreS1hdG1vc3BoZXJlLXN1bmAuIgogICAgCQkJfQogICAgCQl9LAogICAgCQkiZGVmYXVsdCI6ICJhdG1vc3BoZXJlIiwKICAgIAkJZG9jOiAiVGhlIHR5cGUgb2YgdGhlIHNreSIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi4wLjAiLAogICAgCQkJCWlvczogIjEwLjAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjEwLjAuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJza3ktYXRtb3NwaGVyZS1zdW4iOiB7CiAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgIAkJbGVuZ3RoOiAyLAogICAgCQl1bml0czogImRlZ3JlZXMiLAogICAgCQltaW5pbXVtOiBbCiAgICAJCQkwLAogICAgCQkJMAogICAgCQldLAogICAgCQltYXhpbXVtOiBbCiAgICAJCQkzNjAsCiAgICAJCQkxODAKICAgIAkJXSwKICAgIAkJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAJCWRvYzogIlBvc2l0aW9uIG9mIHRoZSBzdW4gY2VudGVyIFthIGF6aW11dGhhbCBhbmdsZSwgcCBwb2xhciBhbmdsZV0uIFRoZSBhemltdXRoYWwgYW5nbGUgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VuIHJlbGF0aXZlIHRvIDDCsCBub3J0aCwgd2hlcmUgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZS4gVGhlIHBvbGFyIGFuZ2xlIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBzdW4sIHdoZXJlIDDCsCBpcyBkaXJlY3RseSBhYm92ZSwgYXQgemVuaXRoLCBhbmQgOTDCsCBhdCB0aGUgaG9yaXpvbi4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIG9tbWl0dGVkLCB0aGUgc3VuIGNlbnRlciBpcyBkaXJlY3RseSBpbmhlcml0ZWQgZnJvbSB0aGUgbGlnaHQgcG9zaXRpb24uIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIyLjAuMCIsCiAgICAJCQkJaW9zOiAiMTAuMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMTAuMC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlyZXF1aXJlczogWwogICAgCQkJewogICAgCQkJCSJza3ktdHlwZSI6ICJhdG1vc3BoZXJlIgogICAgCQkJfQogICAgCQldLAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInNreS1hdG1vc3BoZXJlLXN1bi1pbnRlbnNpdHkiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJewogICAgCQkJCSJza3ktdHlwZSI6ICJhdG1vc3BoZXJlIgogICAgCQkJfQogICAgCQldLAogICAgCQkiZGVmYXVsdCI6IDEwLAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAxMDAsCiAgICAJCXRyYW5zaXRpb246IGZhbHNlLAogICAgCQlkb2M6ICJJbnRlbnNpdHkgb2YgdGhlIHN1biBhcyBhIGxpZ2h0IHNvdXJjZSBpbiB0aGUgYXRtb3NwaGVyZSAob24gYSBzY2FsZSBmcm9tIDAgdG8gYSAxMDApLiBTZXR0aW5nIGhpZ2hlciB2YWx1ZXMgd2lsbCBicmlnaHRlbiB1cCB0aGUgc2t5LiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi4wLjAiLAogICAgCQkJCWlvczogIjEwLjAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjEwLjAuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJza3ktZ3JhZGllbnQtY2VudGVyIjogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJewogICAgCQkJCSJza3ktdHlwZSI6ICJncmFkaWVudCIKICAgIAkJCX0KICAgIAkJXSwKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IFsKICAgIAkJCTAsCiAgICAJCQkwCiAgICAJCV0sCiAgICAJCWxlbmd0aDogMiwKICAgIAkJdW5pdHM6ICJkZWdyZWVzIiwKICAgIAkJbWluaW11bTogWwogICAgCQkJMCwKICAgIAkJCTAKICAgIAkJXSwKICAgIAkJbWF4aW11bTogWwogICAgCQkJMzYwLAogICAgCQkJMTgwCiAgICAJCV0sCiAgICAJCXRyYW5zaXRpb246IGZhbHNlLAogICAgCQlkb2M6ICJQb3NpdGlvbiBvZiB0aGUgZ3JhZGllbnQgY2VudGVyIFthIGF6aW11dGhhbCBhbmdsZSwgcCBwb2xhciBhbmdsZV0uIFRoZSBhemltdXRoYWwgYW5nbGUgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ3JhZGllbnQgY2VudGVyIHJlbGF0aXZlIHRvIDDCsCBub3J0aCwgd2hlcmUgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZS4gVGhlIHBvbGFyIGFuZ2xlIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBncmFkaWVudCBjZW50ZXIsIHdoZXJlIDDCsCBpcyBkaXJlY3RseSBhYm92ZSwgYXQgemVuaXRoLCBhbmQgOTDCsCBhdCB0aGUgaG9yaXpvbi4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuMC4wIiwKICAgIAkJCQlpb3M6ICIxMC4wLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC4wLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkic2t5LWdyYWRpZW50LXJhZGl1cyI6IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCXJlcXVpcmVzOiBbCiAgICAJCQl7CiAgICAJCQkJInNreS10eXBlIjogImdyYWRpZW50IgogICAgCQkJfQogICAgCQldLAogICAgCQkiZGVmYXVsdCI6IDkwLAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAxODAsCiAgICAJCXRyYW5zaXRpb246IGZhbHNlLAogICAgCQlkb2M6ICJUaGUgYW5ndWxhciBkaXN0YW5jZSAobWVhc3VyZWQgaW4gZGVncmVlcykgZnJvbSBgc2t5LWdyYWRpZW50LWNlbnRlcmAgdXAgdG8gd2hpY2ggdGhlIGdyYWRpZW50IGV4dGVuZHMuIEEgdmFsdWUgb2YgMTgwIGNhdXNlcyB0aGUgZ3JhZGllbnQgdG8gd3JhcCBhcm91bmQgdG8gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBmcm9tIGBza3ktZ3JhZGllbnQtY2VudGVyYC4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuMC4wIiwKICAgIAkJCQlpb3M6ICIxMC4wLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC4wLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkic2t5LWdyYWRpZW50IjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQkiZGVmYXVsdCI6IFsKICAgIAkJCSJpbnRlcnBvbGF0ZSIsCiAgICAJCQlbCiAgICAJCQkJImxpbmVhciIKICAgIAkJCV0sCiAgICAJCQlbCiAgICAJCQkJInNreS1yYWRpYWwtcHJvZ3Jlc3MiCiAgICAJCQldLAogICAgCQkJMC44LAogICAgCQkJIiM4N2NlZWIiLAogICAgCQkJMSwKICAgIAkJCSJ3aGl0ZSIKICAgIAkJXSwKICAgIAkJZG9jOiAiRGVmaW5lcyBhIHJhZGlhbCBjb2xvciBncmFkaWVudCB3aXRoIHdoaWNoIHRvIGNvbG9yIHRoZSBza3kuIFRoZSBjb2xvciB2YWx1ZXMgY2FuIGJlIGludGVycG9sYXRlZCB3aXRoIGFuIGV4cHJlc3Npb24gdXNpbmcgYHNreS1yYWRpYWwtcHJvZ3Jlc3NgLiBUaGUgcmFuZ2UgWzAsIDFdIGZvciB0aGUgaW50ZXJwb2xhbnQgY292ZXJzIGEgcmFkaWFsIGRpc3RhbmNlIChpbiBkZWdyZWVzKSBvZiBbMCwgYHNreS1ncmFkaWVudC1yYWRpdXNgXSBjZW50ZXJlZCBhdCB0aGUgcG9zaXRpb24gc3BlY2lmaWVkIGJ5IGBza3ktZ3JhZGllbnQtY2VudGVyYC4iLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCXsKICAgIAkJCQkic2t5LXR5cGUiOiAiZ3JhZGllbnQiCiAgICAJCQl9CiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMi4wLjAiLAogICAgCQkJCWlvczogIjEwLjAuMCIsCiAgICAJCQkJYW5kcm9pZDogIjEwLjAuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJza3ktcmFkaWFsLXByb2dyZXNzIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJjb2xvci1yYW1wIgogICAgCX0sCiAgICAJInNreS1hdG1vc3BoZXJlLWhhbG8tY29sb3IiOiB7CiAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAJCSJkZWZhdWx0IjogIndoaXRlIiwKICAgIAkJZG9jOiAiQSBjb2xvciBhcHBsaWVkIHRvIHRoZSBhdG1vc3BoZXJlIHN1biBoYWxvLiBUaGUgYWxwaGEgY2hhbm5lbCBkZXNjcmliZXMgaG93IHN0cm9uZ2x5IHRoZSBzdW4gaGFsbyBpcyByZXByZXNlbnRlZCBpbiBhbiBhdG1vc3BoZXJlIHNreSBsYXllci4iLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCXsKICAgIAkJCQkic2t5LXR5cGUiOiAiYXRtb3NwaGVyZSIKICAgIAkJCX0KICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIyLjAuMCIsCiAgICAJCQkJaW9zOiAiMTAuMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMTAuMC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInNreS1hdG1vc3BoZXJlLWNvbG9yIjogewogICAgCQl0eXBlOiAiY29sb3IiLAogICAgCQkiZGVmYXVsdCI6ICJ3aGl0ZSIsCiAgICAJCWRvYzogIkEgY29sb3IgdXNlZCB0byB0d2VhayB0aGUgbWFpbiBhdG1vc3BoZXJpYyBzY2F0dGVyaW5nIGNvZWZmaWNpZW50cy4gVXNpbmcgd2hpdGUgYXBwbGllcyB0aGUgZGVmYXVsdCBjb2VmZmljaWVudHMgZ2l2aW5nIHRoZSBuYXR1cmFsIGJsdWUgY29sb3IgdG8gdGhlIGF0bW9zcGhlcmUuIFRoaXMgY29sb3IgYWZmZWN0cyBob3cgaGVhdmlseSB0aGUgY29ycmVzcG9uZGluZyB3YXZlbGVuZ3RoIGlzIHJlcHJlc2VudGVkIGR1cmluZyBzY2F0dGVyaW5nLiBUaGUgYWxwaGEgY2hhbm5lbCBkZXNjcmliZXMgdGhlIGRlbnNpdHkgb2YgdGhlIGF0bW9zcGhlcmUsIHdpdGggMSBtYXhpbXVtIGRlbnNpdHkgYW5kIDAgbm8gZGVuc2l0eS4iLAogICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCXsKICAgIAkJCQkic2t5LXR5cGUiOiAiYXRtb3NwaGVyZSIKICAgIAkJCX0KICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIyLjAuMCIsCiAgICAJCQkJaW9zOiAiMTAuMC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiMTAuMC4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgCX0sCiAgICAJInNreS1vcGFjaXR5IjogewogICAgCQl0eXBlOiAibnVtYmVyIiwKICAgIAkJImRlZmF1bHQiOiAxLAogICAgCQltaW5pbXVtOiAwLAogICAgCQltYXhpbXVtOiAxLAogICAgCQlkb2M6ICJUaGUgb3BhY2l0eSBvZiB0aGUgZW50aXJlIHNreSBsYXllci4iLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjIuMC4wIiwKICAgIAkJCQlpb3M6ICIxMC4wLjAiLAogICAgCQkJCWFuZHJvaWQ6ICIxMC4wLjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9CiAgICB9OwogICAgdmFyIHRyYW5zaXRpb24gPSB7CiAgICAJZHVyYXRpb246IHsKICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAJCSJkZWZhdWx0IjogMzAwLAogICAgCQltaW5pbXVtOiAwLAogICAgCQl1bml0czogIm1pbGxpc2Vjb25kcyIsCiAgICAJCWRvYzogIlRpbWUgYWxsb3R0ZWQgZm9yIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlLiIKICAgIAl9LAogICAgCWRlbGF5OiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXVuaXRzOiAibWlsbGlzZWNvbmRzIiwKICAgIAkJZG9jOiAiTGVuZ3RoIG9mIHRpbWUgYmVmb3JlIGEgdHJhbnNpdGlvbiBiZWdpbnMuIgogICAgCX0KICAgIH07CiAgICB2YXIgcHJvbW90ZUlkID0gewogICAgCSIqIjogewogICAgCQl0eXBlOiAic3RyaW5nIiwKICAgIAkJZG9jOiAiQSBuYW1lIG9mIGEgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgSUQgZm9yIGZlYXR1cmUgc3RhdGUuIgogICAgCX0KICAgIH07CiAgICB2YXIgdjggPSB7CiAgICAJJHZlcnNpb246ICR2ZXJzaW9uLAogICAgCSRyb290OiAkcm9vdCwKICAgIAlzb3VyY2VzOiBzb3VyY2VzLAogICAgCXNvdXJjZTogc291cmNlLAogICAgCXNvdXJjZV92ZWN0b3I6IHNvdXJjZV92ZWN0b3IsCiAgICAJc291cmNlX3Jhc3Rlcjogc291cmNlX3Jhc3RlciwKICAgIAlzb3VyY2VfcmFzdGVyX2RlbTogc291cmNlX3Jhc3Rlcl9kZW0sCiAgICAJc291cmNlX2dlb2pzb246IHNvdXJjZV9nZW9qc29uLAogICAgCXNvdXJjZV92aWRlbzogc291cmNlX3ZpZGVvLAogICAgCXNvdXJjZV9pbWFnZTogc291cmNlX2ltYWdlLAogICAgCWxheWVyOiBsYXllciwKICAgIAlsYXlvdXQ6IGxheW91dCwKICAgIAlsYXlvdXRfYmFja2dyb3VuZDogbGF5b3V0X2JhY2tncm91bmQsCiAgICAJbGF5b3V0X3NreTogbGF5b3V0X3NreSwKICAgIAlsYXlvdXRfZmlsbDogbGF5b3V0X2ZpbGwsCiAgICAJbGF5b3V0X2NpcmNsZTogbGF5b3V0X2NpcmNsZSwKICAgIAlsYXlvdXRfaGVhdG1hcDogbGF5b3V0X2hlYXRtYXAsCiAgICAJImxheW91dF9maWxsLWV4dHJ1c2lvbiI6IHsKICAgIAl2aXNpYmlsaXR5OiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQl2aXNpYmxlOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIHNob3duLiIKICAgIAkJCX0sCiAgICAJCQlub25lOiB7CiAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIG5vdCBzaG93bi4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCSJkZWZhdWx0IjogInZpc2libGUiLAogICAgCQlkb2M6ICJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLiIsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgCQkJCWlvczogIjMuNi4wIiwKICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJjb25zdGFudCIKICAgIAl9CiAgICB9LAogICAgCWxheW91dF9saW5lOiBsYXlvdXRfbGluZSwKICAgIAlsYXlvdXRfc3ltYm9sOiBsYXlvdXRfc3ltYm9sLAogICAgCWxheW91dF9yYXN0ZXI6IGxheW91dF9yYXN0ZXIsCiAgICAJbGF5b3V0X2hpbGxzaGFkZTogbGF5b3V0X2hpbGxzaGFkZSwKICAgIAlmaWx0ZXI6IGZpbHRlciwKICAgIAlmaWx0ZXJfc3ltYm9sOiBmaWx0ZXJfc3ltYm9sLAogICAgCWZpbHRlcl9maWxsOiBmaWx0ZXJfZmlsbCwKICAgIAlmaWx0ZXJfbGluZTogZmlsdGVyX2xpbmUsCiAgICAJZmlsdGVyX2NpcmNsZTogZmlsdGVyX2NpcmNsZSwKICAgIAkiZmlsdGVyX2ZpbGwtZXh0cnVzaW9uIjogewogICAgCXR5cGU6ICJib29sZWFuIiwKICAgIAlkb2M6ICJFeHByZXNzaW9uIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSBhIFBvbHlnb24uIEZpbGwtZXh0cnVzaW9uIGxheWVyIGRvZXMgTk9UIHN1cHBvcnQgZHluYW1pYyBmaWx0ZXJpbmcsIG1lYW5pbmcgdGhpcyBleHByZXNzaW9uIGNhbiBOT1QgdXNlIHRoZSBgW1wicGl0Y2hcIl1gIGFuZCBgW1wiZGlzdGFuY2UtZnJvbS1jZW50ZXJcIl1gIGV4cHJlc3Npb25zIHRvIHJlZmVyZW5jZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdmlldy4iLAogICAgCSJkZWZhdWx0IjogZmFsc2UsCiAgICAJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iLAogICAgCWV4cHJlc3Npb246IHsKICAgIAkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJcGFyYW1ldGVyczogWwogICAgCQkJInpvb20iLAogICAgCQkJImZlYXR1cmUiCiAgICAJCV0KICAgIAl9CiAgICB9LAogICAgCWZpbHRlcl9oZWF0bWFwOiBmaWx0ZXJfaGVhdG1hcCwKICAgIAlmaWx0ZXJfb3BlcmF0b3I6IGZpbHRlcl9vcGVyYXRvciwKICAgIAlnZW9tZXRyeV90eXBlOiBnZW9tZXRyeV90eXBlLAogICAgCSJmdW5jdGlvbiI6IHsKICAgIAlleHByZXNzaW9uOiB7CiAgICAJCXR5cGU6ICJleHByZXNzaW9uIiwKICAgIAkJZG9jOiAiQW4gZXhwcmVzc2lvbi4iCiAgICAJfSwKICAgIAlzdG9wczogewogICAgCQl0eXBlOiAiYXJyYXkiLAogICAgCQlkb2M6ICJBbiBhcnJheSBvZiBzdG9wcy4iLAogICAgCQl2YWx1ZTogImZ1bmN0aW9uX3N0b3AiCiAgICAJfSwKICAgIAliYXNlOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCWRvYzogIlRoZSBleHBvbmVudGlhbCBiYXNlIG9mIHRoZSBpbnRlcnBvbGF0aW9uIGN1cnZlLiBJdCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgcmVzdWx0IGluY3JlYXNlcy4gSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSByZXN1bHQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggYDFgIHRoZSBzdG9wcyBhcmUgaW50ZXJwb2xhdGVkIGxpbmVhcmx5LiIKICAgIAl9LAogICAgCXByb3BlcnR5OiB7CiAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgCQlkb2M6ICJUaGUgbmFtZSBvZiBhIGZlYXR1cmUgcHJvcGVydHkgdG8gdXNlIGFzIHRoZSBmdW5jdGlvbiBpbnB1dC4iLAogICAgCQkiZGVmYXVsdCI6ICIkem9vbSIKICAgIAl9LAogICAgCXR5cGU6IHsKICAgIAkJdHlwZTogImVudW0iLAogICAgCQl2YWx1ZXM6IHsKICAgIAkJCWlkZW50aXR5OiB7CiAgICAJCQkJZG9jOiAiUmV0dXJuIHRoZSBpbnB1dCB2YWx1ZSBhcyB0aGUgb3V0cHV0IHZhbHVlLiIKICAgIAkJCX0sCiAgICAJCQlleHBvbmVudGlhbDogewogICAgCQkJCWRvYzogIkdlbmVyYXRlIGFuIG91dHB1dCBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBmdW5jdGlvbiBpbnB1dC4iCiAgICAJCQl9LAogICAgCQkJaW50ZXJ2YWw6IHsKICAgIAkJCQlkb2M6ICJSZXR1cm4gdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgZnVuY3Rpb24gaW5wdXQuIgogICAgCQkJfSwKICAgIAkJCWNhdGVnb3JpY2FsOiB7CiAgICAJCQkJZG9jOiAiUmV0dXJuIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AgZXF1YWwgdG8gdGhlIGZ1bmN0aW9uIGlucHV0LiIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZG9jOiAiVGhlIGludGVycG9sYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGluIGZ1bmN0aW9uIGV2YWx1YXRpb24uIiwKICAgIAkJImRlZmF1bHQiOiAiZXhwb25lbnRpYWwiCiAgICAJfSwKICAgIAljb2xvclNwYWNlOiB7CiAgICAJCXR5cGU6ICJlbnVtIiwKICAgIAkJdmFsdWVzOiB7CiAgICAJCQlyZ2I6IHsKICAgIAkJCQlkb2M6ICJVc2UgdGhlIFJHQiBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMiCiAgICAJCQl9LAogICAgCQkJbGFiOiB7CiAgICAJCQkJZG9jOiAiVXNlIHRoZSBMQUIgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzLiIKICAgIAkJCX0sCiAgICAJCQloY2w6IHsKICAgIAkJCQlkb2M6ICJVc2UgdGhlIEhDTCBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMsIGludGVycG9sYXRpbmcgdGhlIEh1ZSwgQ2hyb21hLCBhbmQgTHVtaW5hbmNlIGNoYW5uZWxzIGluZGl2aWR1YWxseS4iCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWRvYzogIlRoZSBjb2xvciBzcGFjZSBpbiB3aGljaCBjb2xvcnMgaW50ZXJwb2xhdGVkLiBJbnRlcnBvbGF0aW5nIGNvbG9ycyBpbiBwZXJjZXB0dWFsIGNvbG9yIHNwYWNlcyBsaWtlIExBQiBhbmQgSENMIHRlbmQgdG8gcHJvZHVjZSBjb2xvciByYW1wcyB0aGF0IGxvb2sgbW9yZSBjb25zaXN0ZW50IGFuZCBwcm9kdWNlIGNvbG9ycyB0aGF0IGNhbiBiZSBkaWZmZXJlbnRpYXRlZCBtb3JlIGVhc2lseSB0aGFuIHRob3NlIGludGVycG9sYXRlZCBpbiBSR0Igc3BhY2UuIiwKICAgIAkJImRlZmF1bHQiOiAicmdiIgogICAgCX0sCiAgICAJImRlZmF1bHQiOiB7CiAgICAJCXR5cGU6ICIqIiwKICAgIAkJcmVxdWlyZWQ6IGZhbHNlLAogICAgCQlkb2M6ICJBIHZhbHVlIHRvIHNlcnZlIGFzIGEgZmFsbGJhY2sgZnVuY3Rpb24gcmVzdWx0IHdoZW4gYSB2YWx1ZSBpc24ndCBvdGhlcndpc2UgYXZhaWxhYmxlLiBJdCBpcyB1c2VkIGluIHRoZSBmb2xsb3dpbmcgY2lyY3Vtc3RhbmNlczpcbiogSW4gY2F0ZWdvcmljYWwgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgc3RvcCBkb21haW4gdmFsdWVzLlxuKiBJbiBwcm9wZXJ0eSBhbmQgem9vbS1hbmQtcHJvcGVydHkgZnVuY3Rpb25zLCB3aGVuIGEgZmVhdHVyZSBkb2VzIG5vdCBjb250YWluIGEgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXG4qIEluIGlkZW50aXR5IGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBzdHlsZSBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGlmIHRoZSBmdW5jdGlvbiBpcyBiZWluZyB1c2VkIGZvciBhIGBjaXJjbGUtY29sb3JgIHByb3BlcnR5IGJ1dCB0aGUgZmVhdHVyZSBwcm9wZXJ0eSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcgb3Igbm90IGEgdmFsaWQgY29sb3IpLlxuKiBJbiBpbnRlcnZhbCBvciBleHBvbmVudGlhbCBwcm9wZXJ0eSBhbmQgem9vbS1hbmQtcHJvcGVydHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCBudW1lcmljLlxuSWYgbm8gZGVmYXVsdCBpcyBwcm92aWRlZCwgdGhlIHN0eWxlIHByb3BlcnR5J3MgZGVmYXVsdCBpcyB1c2VkIGluIHRoZXNlIGNpcmN1bXN0YW5jZXMuIgogICAgCX0KICAgIH0sCiAgICAJZnVuY3Rpb25fc3RvcDogZnVuY3Rpb25fc3RvcCwKICAgIAlleHByZXNzaW9uOiBleHByZXNzaW9uJDEsCiAgICAJZXhwcmVzc2lvbl9uYW1lOiBleHByZXNzaW9uX25hbWUsCiAgICAJZm9nOiBmb2csCiAgICAJbGlnaHQ6IGxpZ2h0LAogICAgCXByb2plY3Rpb246IHByb2plY3Rpb24sCiAgICAJdGVycmFpbjogdGVycmFpbiwKICAgIAlwYWludDogcGFpbnQsCiAgICAJcGFpbnRfZmlsbDogcGFpbnRfZmlsbCwKICAgIAkicGFpbnRfZmlsbC1leHRydXNpb24iOiB7CiAgICAJImZpbGwtZXh0cnVzaW9uLW9wYWNpdHkiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDEsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCW1heGltdW06IDEsCiAgICAJCWRvYzogIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgZmlsbCBleHRydXNpb24gbGF5ZXIuIFRoaXMgaXMgcmVuZGVyZWQgb24gYSBwZXItbGF5ZXIsIG5vdCBwZXItZmVhdHVyZSwgYmFzaXMsIGFuZCBkYXRhLWRyaXZlbiBzdHlsaW5nIGlzIG5vdCBhdmFpbGFibGUuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJmaWxsLWV4dHJ1c2lvbi1jb2xvciI6IHsKICAgIAkJdHlwZTogImNvbG9yIiwKICAgIAkJImRlZmF1bHQiOiAiIzAwMDAwMCIsCiAgICAJCWRvYzogIlRoZSBiYXNlIGNvbG9yIG9mIHRoZSBleHRydWRlZCBmaWxsLiBUaGUgZXh0cnVzaW9uJ3Mgc3VyZmFjZXMgd2lsbCBiZSBzaGFkZWQgZGlmZmVyZW50bHkgYmFzZWQgb24gdGhpcyBjb2xvciBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSByb290IGBsaWdodGAgc2V0dGluZ3MuIElmIHRoaXMgY29sb3IgaXMgc3BlY2lmaWVkIGFzIGByZ2JhYCB3aXRoIGFuIGFscGhhIGNvbXBvbmVudCwgdGhlIGFscGhhIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQ7IHVzZSBgZmlsbC1leHRydXNpb24tb3BhY2l0eWAgdG8gc2V0IGxheWVyIG9wYWNpdHkuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCXsKICAgIAkJCQkiISI6ICJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuIgogICAgCQkJfQogICAgCQldLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZSI6IHsKICAgIAkJdHlwZTogImFycmF5IiwKICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgCQlsZW5ndGg6IDIsCiAgICAJCSJkZWZhdWx0IjogWwogICAgCQkJMCwKICAgIAkJCTAKICAgIAkJXSwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgCQlkb2M6ICJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCAob24gdGhlIGZsYXQgcGxhbmUpLCByZXNwZWN0aXZlbHkuIiwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9LAogICAgCSJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUtYW5jaG9yIjogewogICAgCQl0eXBlOiAiZW51bSIsCiAgICAJCXZhbHVlczogewogICAgCQkJbWFwOiB7CiAgICAJCQkJZG9jOiAiVGhlIGZpbGwgZXh0cnVzaW9uIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC4iCiAgICAJCQl9LAogICAgCQkJdmlld3BvcnQ6IHsKICAgIAkJCQlkb2M6ICJUaGUgZmlsbCBleHRydXNpb24gaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIgogICAgCQkJfQogICAgCQl9LAogICAgCQlkb2M6ICJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC1leHRydXNpb24tdHJhbnNsYXRlYC4iLAogICAgCQkiZGVmYXVsdCI6ICJtYXAiLAogICAgCQlyZXF1aXJlczogWwogICAgCQkJImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZSIKICAgIAkJXSwKICAgIAkJInNkay1zdXBwb3J0IjogewogICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAJfSwKICAgIAkiZmlsbC1leHRydXNpb24tcGF0dGVybiI6IHsKICAgIAkJdHlwZTogInJlc29sdmVkSW1hZ2UiLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQlkb2M6ICJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2VzIG9uIGV4dHJ1ZGVkIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy4iLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuNDkuMCIsCiAgICAJCQkJYW5kcm9pZDogIjYuNS4wIiwKICAgIAkJCQltYWNvczogIjAuMTEuMCIsCiAgICAJCQkJaW9zOiAiNC40LjAiCiAgICAJCQl9CiAgICAJCX0sCiAgICAJCWV4cHJlc3Npb246IHsKICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIgogICAgCQkJXQogICAgCQl9LAogICAgCQkicHJvcGVydHktdHlwZSI6ICJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlbiIKICAgIAl9LAogICAgCSJmaWxsLWV4dHJ1c2lvbi1oZWlnaHQiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXVuaXRzOiAibWV0ZXJzIiwKICAgIAkJZG9jOiAiVGhlIGhlaWdodCB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhpcyBsYXllci4iLAogICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgIAkJCX0sCiAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgCQkJcGFyYW1ldGVyczogWwogICAgCQkJCSJ6b29tIiwKICAgIAkJCQkiZmVhdHVyZSIsCiAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAJCQldCiAgICAJCX0sCiAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgCX0sCiAgICAJImZpbGwtZXh0cnVzaW9uLWJhc2UiOiB7CiAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgCQkiZGVmYXVsdCI6IDAsCiAgICAJCW1pbmltdW06IDAsCiAgICAJCXVuaXRzOiAibWV0ZXJzIiwKICAgIAkJZG9jOiAiVGhlIGhlaWdodCB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhlIGJhc2Ugb2YgdGhpcyBsYXllci4gTXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYGZpbGwtZXh0cnVzaW9uLWhlaWdodGAuIiwKICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgIAkJcmVxdWlyZXM6IFsKICAgIAkJCSJmaWxsLWV4dHJ1c2lvbi1oZWlnaHQiCiAgICAJCV0sCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgCQkJCWlvczogIjMuNi4wIiwKICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgCQkJfSwKICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgCQkJCWlvczogIjMuNi4wIiwKICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgCQkJfQogICAgCQl9LAogICAgCQlleHByZXNzaW9uOiB7CiAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAJCQkJInpvb20iLAogICAgCQkJCSJmZWF0dXJlIiwKICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAJfSwKICAgIAkiZmlsbC1leHRydXNpb24tdmVydGljYWwtZ3JhZGllbnQiOiB7CiAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgIAkJImRlZmF1bHQiOiB0cnVlLAogICAgCQlkb2M6ICJXaGV0aGVyIHRvIGFwcGx5IGEgdmVydGljYWwgZ3JhZGllbnQgdG8gdGhlIHNpZGVzIG9mIGEgZmlsbC1leHRydXNpb24gbGF5ZXIuIElmIHRydWUsIHNpZGVzIHdpbGwgYmUgc2hhZGVkIHNsaWdodGx5IGRhcmtlciBmYXJ0aGVyIGRvd24uIiwKICAgIAkJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgCQkJCWpzOiAiMC41MC4wIiwKICAgIAkJCQlhbmRyb2lkOiAiNy4wLjAiLAogICAgCQkJCWlvczogIjQuNy4wIiwKICAgIAkJCQltYWNvczogIjAuMTMuMCIKICAgIAkJCX0KICAgIAkJfSwKICAgIAkJZXhwcmVzc2lvbjogewogICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgIAkJCQkiem9vbSIKICAgIAkJCV0KICAgIAkJfSwKICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgIAl9CiAgICB9LAogICAgCXBhaW50X2xpbmU6IHBhaW50X2xpbmUsCiAgICAJcGFpbnRfY2lyY2xlOiBwYWludF9jaXJjbGUsCiAgICAJcGFpbnRfaGVhdG1hcDogcGFpbnRfaGVhdG1hcCwKICAgIAlwYWludF9zeW1ib2w6IHBhaW50X3N5bWJvbCwKICAgIAlwYWludF9yYXN0ZXI6IHBhaW50X3Jhc3RlciwKICAgIAlwYWludF9oaWxsc2hhZGU6IHBhaW50X2hpbGxzaGFkZSwKICAgIAlwYWludF9iYWNrZ3JvdW5kOiBwYWludF9iYWNrZ3JvdW5kLAogICAgCXBhaW50X3NreTogcGFpbnRfc2t5LAogICAgCXRyYW5zaXRpb246IHRyYW5zaXRpb24sCiAgICAJInByb3BlcnR5LXR5cGUiOiB7CiAgICAJImRhdGEtZHJpdmVuIjogewogICAgCQl0eXBlOiAicHJvcGVydHktdHlwZSIsCiAgICAJCWRvYzogIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBhbmQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi4iCiAgICAJfSwKICAgIAkiY3Jvc3MtZmFkZWQiOiB7CiAgICAJCXR5cGU6ICJwcm9wZXJ0eS10eXBlIiwKICAgIAkJZG9jOiAiUHJvcGVydHkgaXMgbm9uLWludGVycG9sYWJsZTsgcmF0aGVyLCBpdHMgdmFsdWVzIHdpbGwgYmUgY3Jvc3MtZmFkZWQgdG8gc21vb3RobHkgdHJhbnNpdGlvbiBiZXR3ZWVuIGludGVnZXIgem9vbXMuIgogICAgCX0sCiAgICAJImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuIjogewogICAgCQl0eXBlOiAicHJvcGVydHktdHlwZSIsCiAgICAJCWRvYzogIlByb3BlcnR5IGlzIG5vbi1pbnRlcnBvbGFibGU7IHJhdGhlciwgaXRzIHZhbHVlcyB3aWxsIGJlIGNyb3NzLWZhZGVkIHRvIHNtb290aGx5IHRyYW5zaXRpb24gYmV0d2VlbiBpbnRlZ2VyIHpvb21zLiBJdCBjYW4gYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLiIKICAgIAl9LAogICAgCSJjb2xvci1yYW1wIjogewogICAgCQl0eXBlOiAicHJvcGVydHktdHlwZSIsCiAgICAJCWRvYzogIlByb3BlcnR5IHNob3VsZCBiZSBzcGVjaWZpZWQgdXNpbmcgYSBjb2xvciByYW1wIGZyb20gd2hpY2ggdGhlIG91dHB1dCBjb2xvciBjYW4gYmUgc2FtcGxlZCBiYXNlZCBvbiBhIHByb3BlcnR5IGNhbGN1bGF0aW9uLiIKICAgIAl9LAogICAgCSJkYXRhLWNvbnN0YW50IjogewogICAgCQl0eXBlOiAicHJvcGVydHktdHlwZSIsCiAgICAJCWRvYzogIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBidXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi4iCiAgICAJfSwKICAgIAljb25zdGFudDogewogICAgCQl0eXBlOiAicHJvcGVydHktdHlwZSIsCiAgICAJCWRvYzogIlByb3BlcnR5IGlzIGNvbnN0YW50IGFjcm9zcyBhbGwgem9vbSBsZXZlbHMgYW5kIHByb3BlcnR5IHZhbHVlcy4iCiAgICAJfQogICAgfSwKICAgIAlwcm9tb3RlSWQ6IHByb21vdGVJZAogICAgfTsKCiAgICB2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTsKCiAgICBmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbikgewogICAgICB2YXIgbW9kdWxlID0geyBleHBvcnRzOiB7fSB9OwogICAgCXJldHVybiBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7CiAgICB9CgogICAgZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICh0YXJnZXQpIHsKICAgIAl0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlICInICsgdGFyZ2V0ICsgJyIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvcHRpb24gb2YgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMgYXBwcm9wcmlhdGVseSBmb3IgdGhpcyByZXF1aXJlIGNhbGwgdG8gYmVoYXZlIHByb3Blcmx5LicpOwogICAgfQoKICAgIC8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovCgogICAgY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykgewogICAgKGZ1bmN0aW9uKHJvb3QpIHsKCiAgICAJLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqLwogICAgCXZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYKICAgIAkJIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICAgIAl2YXIgZnJlZU1vZHVsZSA9IG1vZHVsZSAmJgogICAgCQkhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTsKICAgIAl2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbDsKICAgIAlpZiAoCiAgICAJCWZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8CiAgICAJCWZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8CiAgICAJCWZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbAogICAgCSkgewogICAgCQlyb290ID0gZnJlZUdsb2JhbDsKICAgIAl9CgogICAgCS8qKgogICAgCSAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC4KICAgIAkgKiBAbmFtZSBwdW55Y29kZQogICAgCSAqIEB0eXBlIE9iamVjdAogICAgCSAqLwogICAgCXZhciBwdW55Y29kZSwKCiAgICAJLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqLwogICAgCW1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTEKCiAgICAJLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqLwogICAgCWJhc2UgPSAzNiwKICAgIAl0TWluID0gMSwKICAgIAl0TWF4ID0gMjYsCiAgICAJc2tldyA9IDM4LAogICAgCWRhbXAgPSA3MDAsCiAgICAJaW5pdGlhbEJpYXMgPSA3MiwKICAgIAlpbml0aWFsTiA9IDEyOCwgLy8gMHg4MAogICAgCWRlbGltaXRlciA9ICctJywgLy8gJ1x4MkQnCgogICAgCS8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovCiAgICAJcmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sCiAgICAJcmVnZXhOb25BU0NJSSA9IC9bXlx4MjAtXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFycwogICAgCXJlZ2V4U2VwYXJhdG9ycyA9IC9bXHgyRVx1MzAwMlx1RkYwRVx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9ycwoKICAgIAkvKiogRXJyb3IgbWVzc2FnZXMgKi8KICAgIAllcnJvcnMgPSB7CiAgICAJCSdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsCiAgICAJCSdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsCiAgICAJCSdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnCiAgICAJfSwKCiAgICAJLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqLwogICAgCWJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbiwKICAgIAlmbG9vciA9IE1hdGguZmxvb3IsCiAgICAJc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSwKCiAgICAJLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqLwogICAgCWtleTsKCiAgICAJLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovCgogICAgCS8qKgogICAgCSAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLgogICAgCSAqIEBwcml2YXRlCiAgICAJICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuCiAgICAJICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLgogICAgCSAqLwogICAgCWZ1bmN0aW9uIGVycm9yKHR5cGUpIHsKICAgIAkJdGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pOwogICAgCX0KCiAgICAJLyoqCiAgICAJICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uCiAgICAJICogQHByaXZhdGUKICAgIAkgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLgogICAgCSAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheQogICAgCSAqIGl0ZW0uCiAgICAJICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLgogICAgCSAqLwogICAgCWZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHsKICAgIAkJdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKICAgIAkJdmFyIHJlc3VsdCA9IFtdOwogICAgCQl3aGlsZSAobGVuZ3RoLS0pIHsKICAgIAkJCXJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7CiAgICAJCX0KICAgIAkJcmV0dXJuIHJlc3VsdDsKICAgIAl9CgogICAgCS8qKgogICAgCSAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbAogICAgCSAqIGFkZHJlc3Nlcy4KICAgIAkgKiBAcHJpdmF0ZQogICAgCSAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuCiAgICAJICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5CiAgICAJICogY2hhcmFjdGVyLgogICAgCSAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrCiAgICAJICogZnVuY3Rpb24uCiAgICAJICovCiAgICAJZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHsKICAgIAkJdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7CiAgICAJCXZhciByZXN1bHQgPSAnJzsKICAgIAkJaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHsKICAgIAkJCS8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmUKICAgIAkJCS8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuCiAgICAJCQlyZXN1bHQgPSBwYXJ0c1swXSArICdAJzsKICAgIAkJCXN0cmluZyA9IHBhcnRzWzFdOwogICAgCQl9CiAgICAJCS8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy4KICAgIAkJc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXHgyRScpOwogICAgCQl2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7CiAgICAJCXZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTsKICAgIAkJcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7CiAgICAJfQoKICAgIAkvKioKICAgIAkgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlCiAgICAJICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LAogICAgCSAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoCiAgICAJICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsCiAgICAJICogbWF0Y2hpbmcgVVRGLTE2LgogICAgCSAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYAogICAgCSAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPgogICAgCSAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyCiAgICAJICogQG5hbWUgZGVjb2RlCiAgICAJICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS4KICAgIAkgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuCiAgICAJICovCiAgICAJZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHsKICAgIAkJdmFyIG91dHB1dCA9IFtdLAogICAgCQkgICAgY291bnRlciA9IDAsCiAgICAJCSAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLAogICAgCQkgICAgdmFsdWUsCiAgICAJCSAgICBleHRyYTsKICAgIAkJd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHsKICAgIAkJCXZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTsKICAgIAkJCWlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHsKICAgIAkJCQkvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIKICAgIAkJCQlleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7CiAgICAJCQkJaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGUKICAgIAkJCQkJb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTsKICAgIAkJCQl9IGVsc2UgewogICAgCQkJCQkvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dAogICAgCQkJCQkvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIKICAgIAkJCQkJb3V0cHV0LnB1c2godmFsdWUpOwogICAgCQkJCQljb3VudGVyLS07CiAgICAJCQkJfQogICAgCQkJfSBlbHNlIHsKICAgIAkJCQlvdXRwdXQucHVzaCh2YWx1ZSk7CiAgICAJCQl9CiAgICAJCX0KICAgIAkJcmV0dXJuIG91dHB1dDsKICAgIAl9CgogICAgCS8qKgogICAgCSAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy4KICAgIAkgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWAKICAgIAkgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMgogICAgCSAqIEBuYW1lIGVuY29kZQogICAgCSAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuCiAgICAJICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLgogICAgCSAqLwogICAgCWZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHsKICAgIAkJcmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHsKICAgIAkJCXZhciBvdXRwdXQgPSAnJzsKICAgIAkJCWlmICh2YWx1ZSA+IDB4RkZGRikgewogICAgCQkJCXZhbHVlIC09IDB4MTAwMDA7CiAgICAJCQkJb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7CiAgICAJCQkJdmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGOwogICAgCQkJfQogICAgCQkJb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7CiAgICAJCQlyZXR1cm4gb3V0cHV0OwogICAgCQl9KS5qb2luKCcnKTsKICAgIAl9CgogICAgCS8qKgogICAgCSAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci4KICAgIAkgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWAKICAgIAkgKiBAcHJpdmF0ZQogICAgCSAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS4KICAgIAkgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW4KICAgIAkgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmCiAgICAJICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuCiAgICAJICovCiAgICAJZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkgewogICAgCQlpZiAoY29kZVBvaW50IC0gNDggPCAxMCkgewogICAgCQkJcmV0dXJuIGNvZGVQb2ludCAtIDIyOwogICAgCQl9CiAgICAJCWlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7CiAgICAJCQlyZXR1cm4gY29kZVBvaW50IC0gNjU7CiAgICAJCX0KICAgIAkJaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHsKICAgIAkJCXJldHVybiBjb2RlUG9pbnQgLSA5NzsKICAgIAkJfQogICAgCQlyZXR1cm4gYmFzZTsKICAgIAl9CgogICAgCS8qKgogICAgCSAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC4KICAgIAkgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWAKICAgIAkgKiBAcHJpdmF0ZQogICAgCSAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuCiAgICAJICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3IKICAgIAkgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZQogICAgCSAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpcwogICAgCSAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkCiAgICAJICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS4KICAgIAkgKi8KICAgIAlmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHsKICAgIAkJLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLloKICAgIAkJLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45CiAgICAJCXJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7CiAgICAJfQoKICAgIAkvKioKICAgIAkgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLgogICAgCSAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjQKICAgIAkgKiBAcHJpdmF0ZQogICAgCSAqLwogICAgCWZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkgewogICAgCQl2YXIgayA9IDA7CiAgICAJCWRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7CiAgICAJCWRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTsKICAgIAkJZm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHsKICAgIAkJCWRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTsKICAgIAkJfQogICAgCQlyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTsKICAgIAl9CgogICAgCS8qKgogICAgCSAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlCiAgICAJICogc3ltYm9scy4KICAgIAkgKiBAbWVtYmVyT2YgcHVueWNvZGUKICAgIAkgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuCiAgICAJICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLgogICAgCSAqLwogICAgCWZ1bmN0aW9uIGRlY29kZShpbnB1dCkgewogICAgCQkvLyBEb24ndCB1c2UgVUNTLTIKICAgIAkJdmFyIG91dHB1dCA9IFtdLAogICAgCQkgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsCiAgICAJCSAgICBvdXQsCiAgICAJCSAgICBpID0gMCwKICAgIAkJICAgIG4gPSBpbml0aWFsTiwKICAgIAkJICAgIGJpYXMgPSBpbml0aWFsQmlhcywKICAgIAkJICAgIGJhc2ljLAogICAgCQkgICAgaiwKICAgIAkJICAgIGluZGV4LAogICAgCQkgICAgb2xkaSwKICAgIAkJICAgIHcsCiAgICAJCSAgICBrLAogICAgCQkgICAgZGlnaXQsCiAgICAJCSAgICB0LAogICAgCQkgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovCiAgICAJCSAgICBiYXNlTWludXNUOwoKICAgIAkJLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlCiAgICAJCS8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5CiAgICAJCS8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LgoKICAgIAkJYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpOwogICAgCQlpZiAoYmFzaWMgPCAwKSB7CiAgICAJCQliYXNpYyA9IDA7CiAgICAJCX0KCiAgICAJCWZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7CiAgICAJCQkvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQKICAgIAkJCWlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHsKICAgIAkJCQllcnJvcignbm90LWJhc2ljJyk7CiAgICAJCQl9CiAgICAJCQlvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTsKICAgIAkJfQoKICAgIAkJLy8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZQogICAgCQkvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLgoKICAgIAkJZm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHsKCiAgICAJCQkvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuCiAgICAJCQkvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsCiAgICAJCQkvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llcgogICAgCQkJLy8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmcKICAgIAkJCS8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuCiAgICAJCQlmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7CgogICAgCQkJCWlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkgewogICAgCQkJCQllcnJvcignaW52YWxpZC1pbnB1dCcpOwogICAgCQkJCX0KCiAgICAJCQkJZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7CgogICAgCQkJCWlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHsKICAgIAkJCQkJZXJyb3IoJ292ZXJmbG93Jyk7CiAgICAJCQkJfQoKICAgIAkJCQlpICs9IGRpZ2l0ICogdzsKICAgIAkJCQl0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTsKCiAgICAJCQkJaWYgKGRpZ2l0IDwgdCkgewogICAgCQkJCQlicmVhazsKICAgIAkJCQl9CgogICAgCQkJCWJhc2VNaW51c1QgPSBiYXNlIC0gdDsKICAgIAkJCQlpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7CiAgICAJCQkJCWVycm9yKCdvdmVyZmxvdycpOwogICAgCQkJCX0KCiAgICAJCQkJdyAqPSBiYXNlTWludXNUOwoKICAgIAkJCX0KCiAgICAJCQlvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTsKICAgIAkJCWJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApOwoKICAgIAkJCS8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsCiAgICAJCQkvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OgogICAgCQkJaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikgewogICAgCQkJCWVycm9yKCdvdmVyZmxvdycpOwogICAgCQkJfQoKICAgIAkJCW4gKz0gZmxvb3IoaSAvIG91dCk7CiAgICAJCQlpICU9IG91dDsKCiAgICAJCQkvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0CiAgICAJCQlvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7CgogICAgCQl9CgogICAgCQlyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpOwogICAgCX0KCiAgICAJLyoqCiAgICAJICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGEKICAgIAkgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLgogICAgCSAqIEBtZW1iZXJPZiBwdW55Y29kZQogICAgCSAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy4KICAgIAkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuCiAgICAJICovCiAgICAJZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7CiAgICAJCXZhciBuLAogICAgCQkgICAgZGVsdGEsCiAgICAJCSAgICBoYW5kbGVkQ1BDb3VudCwKICAgIAkJICAgIGJhc2ljTGVuZ3RoLAogICAgCQkgICAgYmlhcywKICAgIAkJICAgIGosCiAgICAJCSAgICBtLAogICAgCQkgICAgcSwKICAgIAkJICAgIGssCiAgICAJCSAgICB0LAogICAgCQkgICAgY3VycmVudFZhbHVlLAogICAgCQkgICAgb3V0cHV0ID0gW10sCiAgICAJCSAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqLwogICAgCQkgICAgaW5wdXRMZW5ndGgsCiAgICAJCSAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi8KICAgIAkJICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSwKICAgIAkJICAgIGJhc2VNaW51c1QsCiAgICAJCSAgICBxTWludXNUOwoKICAgIAkJLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZQogICAgCQlpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpOwoKICAgIAkJLy8gQ2FjaGUgdGhlIGxlbmd0aAogICAgCQlpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDsKCiAgICAJCS8vIEluaXRpYWxpemUgdGhlIHN0YXRlCiAgICAJCW4gPSBpbml0aWFsTjsKICAgIAkJZGVsdGEgPSAwOwogICAgCQliaWFzID0gaW5pdGlhbEJpYXM7CgogICAgCQkvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzCiAgICAJCWZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CiAgICAJCQljdXJyZW50VmFsdWUgPSBpbnB1dFtqXTsKICAgIAkJCWlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7CiAgICAJCQkJb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpOwogICAgCQkJfQogICAgCQl9CgogICAgCQloYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDsKCiAgICAJCS8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkOwogICAgCQkvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuCgogICAgCQkvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXIKICAgIAkJaWYgKGJhc2ljTGVuZ3RoKSB7CiAgICAJCQlvdXRwdXQucHVzaChkZWxpbWl0ZXIpOwogICAgCQl9CgogICAgCQkvLyBNYWluIGVuY29kaW5nIGxvb3A6CiAgICAJCXdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7CgogICAgCQkJLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dAogICAgCQkJLy8gbGFyZ2VyIG9uZToKICAgIAkJCWZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CiAgICAJCQkJY3VycmVudFZhbHVlID0gaW5wdXRbal07CiAgICAJCQkJaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHsKICAgIAkJCQkJbSA9IGN1cnJlbnRWYWx1ZTsKICAgIAkJCQl9CiAgICAJCQl9CgogICAgCQkJLy8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LAogICAgCQkJLy8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cKICAgIAkJCWhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTsKICAgIAkJCWlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7CiAgICAJCQkJZXJyb3IoJ292ZXJmbG93Jyk7CiAgICAJCQl9CgogICAgCQkJZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTsKICAgIAkJCW4gPSBtOwoKICAgIAkJCWZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CiAgICAJCQkJY3VycmVudFZhbHVlID0gaW5wdXRbal07CgogICAgCQkJCWlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHsKICAgIAkJCQkJZXJyb3IoJ292ZXJmbG93Jyk7CiAgICAJCQkJfQoKICAgIAkJCQlpZiAoY3VycmVudFZhbHVlID09IG4pIHsKICAgIAkJCQkJLy8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIKICAgIAkJCQkJZm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkgewogICAgCQkJCQkJdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7CiAgICAJCQkJCQlpZiAocSA8IHQpIHsKICAgIAkJCQkJCQlicmVhazsKICAgIAkJCQkJCX0KICAgIAkJCQkJCXFNaW51c1QgPSBxIC0gdDsKICAgIAkJCQkJCWJhc2VNaW51c1QgPSBiYXNlIC0gdDsKICAgIAkJCQkJCW91dHB1dC5wdXNoKAogICAgCQkJCQkJCXN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSkKICAgIAkJCQkJCSk7CiAgICAJCQkJCQlxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpOwogICAgCQkJCQl9CgogICAgCQkJCQlvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7CiAgICAJCQkJCWJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7CiAgICAJCQkJCWRlbHRhID0gMDsKICAgIAkJCQkJKytoYW5kbGVkQ1BDb3VudDsKICAgIAkJCQl9CiAgICAJCQl9CgogICAgCQkJKytkZWx0YTsKICAgIAkJCSsrbjsKCiAgICAJCX0KICAgIAkJcmV0dXJuIG91dHB1dC5qb2luKCcnKTsKICAgIAl9CgogICAgCS8qKgogICAgCSAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MKICAgIAkgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuCiAgICAJICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuCiAgICAJICogY29udmVydGVkIHRvIFVuaWNvZGUuCiAgICAJICogQG1lbWJlck9mIHB1bnljb2RlCiAgICAJICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0bwogICAgCSAqIGNvbnZlcnQgdG8gVW5pY29kZS4KICAgIAkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGUKICAgIAkgKiBzdHJpbmcuCiAgICAJICovCiAgICAJZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7CiAgICAJCXJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykgewogICAgCQkJcmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpCiAgICAJCQkJPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpCiAgICAJCQkJOiBzdHJpbmc7CiAgICAJCX0pOwogICAgCX0KCiAgICAJLyoqCiAgICAJICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvCiAgICAJICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsCiAgICAJICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluCiAgICAJICogQVNDSUkuCiAgICAJICogQG1lbWJlck9mIHB1bnljb2RlCiAgICAJICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGEKICAgIAkgKiBVbmljb2RlIHN0cmluZy4KICAgIAkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yCiAgICAJICogZW1haWwgYWRkcmVzcy4KICAgIAkgKi8KICAgIAlmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7CiAgICAJCXJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykgewogICAgCQkJcmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpCiAgICAJCQkJPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKQogICAgCQkJCTogc3RyaW5nOwogICAgCQl9KTsKICAgIAl9CgogICAgCS8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLwoKICAgIAkvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovCiAgICAJcHVueWNvZGUgPSB7CiAgICAJCS8qKgogICAgCQkgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuCiAgICAJCSAqIEBtZW1iZXJPZiBwdW55Y29kZQogICAgCQkgKiBAdHlwZSBTdHJpbmcKICAgIAkJICovCiAgICAJCSd2ZXJzaW9uJzogJzEuMy4yJywKICAgIAkJLyoqCiAgICAJCSAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyCiAgICAJCSAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suCiAgICAJCSAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPgogICAgCQkgKiBAbWVtYmVyT2YgcHVueWNvZGUKICAgIAkJICogQHR5cGUgT2JqZWN0CiAgICAJCSAqLwogICAgCQkndWNzMic6IHsKICAgIAkJCSdkZWNvZGUnOiB1Y3MyZGVjb2RlLAogICAgCQkJJ2VuY29kZSc6IHVjczJlbmNvZGUKICAgIAkJfSwKICAgIAkJJ2RlY29kZSc6IGRlY29kZSwKICAgIAkJJ2VuY29kZSc6IGVuY29kZSwKICAgIAkJJ3RvQVNDSUknOiB0b0FTQ0lJLAogICAgCQkndG9Vbmljb2RlJzogdG9Vbmljb2RlCiAgICAJfTsKCiAgICAJLyoqIEV4cG9zZSBgcHVueWNvZGVgICovCiAgICAJLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zCiAgICAJLy8gbGlrZSB0aGUgZm9sbG93aW5nOgogICAgCWlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7CiAgICAJCWlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wKwogICAgCQkJZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7CiAgICAJCX0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtCiAgICAJCQlmb3IgKGtleSBpbiBwdW55Y29kZSkgewogICAgCQkJCXB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTsKICAgIAkJCX0KICAgIAkJfQogICAgCX0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXIKICAgIAkJcm9vdC5wdW55Y29kZSA9IHB1bnljb2RlOwogICAgCX0KCiAgICB9KGNvbW1vbmpzR2xvYmFsKSk7CiAgICB9KTsKCiAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KCiAgICAvLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nCiAgICAvLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay4KICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3CiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHsKICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOwogICAgfQoKICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykgewogICAgICBzZXAgPSBzZXAgfHwgJyYnOwogICAgICBlcSA9IGVxIHx8ICc9JzsKICAgICAgdmFyIG9iaiA9IHt9OwoKICAgICAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfQoKICAgICAgdmFyIHJlZ2V4cCA9IC9cKy9nOwogICAgICBxcyA9IHFzLnNwbGl0KHNlcCk7CgogICAgICB2YXIgbWF4S2V5cyA9IDEwMDA7CiAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7CiAgICAgICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5czsKICAgICAgfQoKICAgICAgdmFyIGxlbiA9IHFzLmxlbmd0aDsKICAgICAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50CiAgICAgIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7CiAgICAgICAgbGVuID0gbWF4S2V5czsKICAgICAgfQoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSwKICAgICAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSwKICAgICAgICAgICAga3N0ciwgdnN0ciwgaywgdjsKCiAgICAgICAgaWYgKGlkeCA+PSAwKSB7CiAgICAgICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTsKICAgICAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAga3N0ciA9IHg7CiAgICAgICAgICB2c3RyID0gJyc7CiAgICAgICAgfQoKICAgICAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpOwogICAgICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7CgogICAgICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkgewogICAgICAgICAgb2JqW2tdID0gdjsKICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkgewogICAgICAgICAgb2JqW2tdLnB1c2godik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG9iajsKICAgIH07CgogICAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCgogICAgdmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHsKICAgICAgc3dpdGNoICh0eXBlb2YgdikgewogICAgICAgIGNhc2UgJ3N0cmluZyc6CiAgICAgICAgICByZXR1cm4gdjsKCiAgICAgICAgY2FzZSAnYm9vbGVhbic6CiAgICAgICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7CgogICAgICAgIGNhc2UgJ251bWJlcic6CiAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7CgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gJyc7CiAgICAgIH0KICAgIH07CgogICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkgewogICAgICBzZXAgPSBzZXAgfHwgJyYnOwogICAgICBlcSA9IGVxIHx8ICc9JzsKICAgICAgaWYgKG9iaiA9PT0gbnVsbCkgewogICAgICAgIG9iaiA9IHVuZGVmaW5lZDsKICAgICAgfQoKICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHsKICAgICAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7CiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7CiAgICAgICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHsKICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTsKICAgICAgICAgICAgfSkuam9pbihzZXApOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTsKICAgICAgICAgIH0KICAgICAgICB9KS5qb2luKHNlcCk7CgogICAgICB9CgogICAgICBpZiAoIW5hbWUpIHJldHVybiAnJzsKICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgKwogICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTsKICAgIH07CgogICAgY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykgewoKICAgIGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IGRlY29kZTsKICAgIGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBlbmNvZGU7CiAgICB9KTsKCiAgICBmdW5jdGlvbiBleHRlbmQgKG91dHB1dCwgLi4uaW5wdXRzKSB7CiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHsKICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGlucHV0KSB7CiAgICAgICAgICAgICAgICBvdXRwdXRba10gPSBpbnB1dFtrXTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgfQoKICAgIGNsYXNzIFBhcnNpbmdFcnJvciQxIGV4dGVuZHMgRXJyb3IgewogICAgICAgIGNvbnN0cnVjdG9yKGtleSwgbWVzc2FnZSkgewogICAgICAgICAgICBzdXBlcihtZXNzYWdlKTsKICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7CiAgICAgICAgfQogICAgfQogICAgdmFyIFBhcnNpbmdFcnJvciQyID0gUGFyc2luZ0Vycm9yJDE7CgogICAgY2xhc3MgU2NvcGUgewogICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYmluZGluZ3MgPSBbXSkgewogICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDsKICAgICAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9OwogICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBleHByZXNzaW9uXSBvZiBiaW5kaW5ncykgewogICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tuYW1lXSA9IGV4cHJlc3Npb247CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uY2F0KGJpbmRpbmdzKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcywgYmluZGluZ3MpOwogICAgICAgIH0KICAgICAgICBnZXQobmFtZSkgewogICAgICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1tuYW1lXSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbbmFtZV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0KG5hbWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgbmFtZSB9IG5vdCBmb3VuZCBpbiBzY29wZS5gKTsKICAgICAgICB9CiAgICAgICAgaGFzKG5hbWUpIHsKICAgICAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbbmFtZV0pCiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaGFzKG5hbWUpIDogZmFsc2U7CiAgICAgICAgfQogICAgfQogICAgdmFyIFNjb3BlJDEgPSBTY29wZTsKCiAgICBjb25zdCBOdWxsVHlwZSA9IHsga2luZDogJ251bGwnIH07CiAgICBjb25zdCBOdW1iZXJUeXBlID0geyBraW5kOiAnbnVtYmVyJyB9OwogICAgY29uc3QgU3RyaW5nVHlwZSA9IHsga2luZDogJ3N0cmluZycgfTsKICAgIGNvbnN0IEJvb2xlYW5UeXBlID0geyBraW5kOiAnYm9vbGVhbicgfTsKICAgIGNvbnN0IENvbG9yVHlwZSA9IHsga2luZDogJ2NvbG9yJyB9OwogICAgY29uc3QgT2JqZWN0VHlwZSA9IHsga2luZDogJ29iamVjdCcgfTsKICAgIGNvbnN0IFZhbHVlVHlwZSA9IHsga2luZDogJ3ZhbHVlJyB9OwogICAgY29uc3QgRXJyb3JUeXBlID0geyBraW5kOiAnZXJyb3InIH07CiAgICBjb25zdCBDb2xsYXRvclR5cGUgPSB7IGtpbmQ6ICdjb2xsYXRvcicgfTsKICAgIGNvbnN0IEZvcm1hdHRlZFR5cGUgPSB7IGtpbmQ6ICdmb3JtYXR0ZWQnIH07CiAgICBjb25zdCBSZXNvbHZlZEltYWdlVHlwZSA9IHsga2luZDogJ3Jlc29sdmVkSW1hZ2UnIH07CiAgICBmdW5jdGlvbiBhcnJheSQxKGl0ZW1UeXBlLCBOKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAga2luZDogJ2FycmF5JywKICAgICAgICAgICAgaXRlbVR5cGUsCiAgICAgICAgICAgIE4KICAgICAgICB9OwogICAgfQogICAgZnVuY3Rpb24gdG9TdHJpbmckMSh0eXBlKSB7CiAgICAgICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5JykgewogICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHRvU3RyaW5nJDEodHlwZS5pdGVtVHlwZSk7CiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdHlwZS5OID09PSAnbnVtYmVyJyA/IGBhcnJheTwkeyBpdGVtVHlwZSB9LCAkeyB0eXBlLk4gfT5gIDogdHlwZS5pdGVtVHlwZS5raW5kID09PSAndmFsdWUnID8gJ2FycmF5JyA6IGBhcnJheTwkeyBpdGVtVHlwZSB9PmA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIHR5cGUua2luZDsKICAgICAgICB9CiAgICB9CiAgICBjb25zdCB2YWx1ZU1lbWJlclR5cGVzID0gWwogICAgICAgIE51bGxUeXBlLAogICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICBDb2xvclR5cGUsCiAgICAgICAgRm9ybWF0dGVkVHlwZSwKICAgICAgICBPYmplY3RUeXBlLAogICAgICAgIGFycmF5JDEoVmFsdWVUeXBlKSwKICAgICAgICBSZXNvbHZlZEltYWdlVHlwZQogICAgXTsKICAgIGZ1bmN0aW9uIGNoZWNrU3VidHlwZShleHBlY3RlZCwgdCkgewogICAgICAgIGlmICh0LmtpbmQgPT09ICdlcnJvcicpIHsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAnYXJyYXknKSB7CiAgICAgICAgICAgIGlmICh0LmtpbmQgPT09ICdhcnJheScgJiYgKHQuTiA9PT0gMCAmJiB0Lml0ZW1UeXBlLmtpbmQgPT09ICd2YWx1ZScgfHwgIWNoZWNrU3VidHlwZShleHBlY3RlZC5pdGVtVHlwZSwgdC5pdGVtVHlwZSkpICYmICh0eXBlb2YgZXhwZWN0ZWQuTiAhPT0gJ251bWJlcicgfHwgZXhwZWN0ZWQuTiA9PT0gdC5OKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09IHQua2luZCkgewogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXJUeXBlIG9mIHZhbHVlTWVtYmVyVHlwZXMpIHsKICAgICAgICAgICAgICAgIGlmICghY2hlY2tTdWJ0eXBlKG1lbWJlclR5cGUsIHQpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCAkeyB0b1N0cmluZyQxKGV4cGVjdGVkKSB9IGJ1dCBmb3VuZCAkeyB0b1N0cmluZyQxKHQpIH0gaW5zdGVhZC5gOwogICAgfQogICAgZnVuY3Rpb24gaXNWYWxpZFR5cGUocHJvdmlkZWQsIGFsbG93ZWRUeXBlcykgewogICAgICAgIHJldHVybiBhbGxvd2VkVHlwZXMuc29tZSh0ID0+IHQua2luZCA9PT0gcHJvdmlkZWQua2luZCk7CiAgICB9CiAgICBmdW5jdGlvbiBpc1ZhbGlkTmF0aXZlVHlwZShwcm92aWRlZCwgYWxsb3dlZFR5cGVzKSB7CiAgICAgICAgcmV0dXJuIGFsbG93ZWRUeXBlcy5zb21lKHQgPT4gewogICAgICAgICAgICBpZiAodCA9PT0gJ251bGwnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZWQgPT09IG51bGw7CiAgICAgICAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ2FycmF5JykgewogICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJvdmlkZWQpOwogICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZWQgJiYgIUFycmF5LmlzQXJyYXkocHJvdmlkZWQpICYmIHR5cGVvZiBwcm92aWRlZCA9PT0gJ29iamVjdCc7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdCA9PT0gdHlwZW9mIHByb3ZpZGVkOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9CgogICAgdmFyIGNzc2NvbG9ycGFyc2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykgewogICAgLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLgogICAgLy8KICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzCiAgICAvLwogICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weQogICAgLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgIlNvZnR3YXJlIiksIHRvCiAgICAvLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZQogICAgLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yCiAgICAvLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcwogICAgLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKICAgIC8vCiAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgogICAgLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAgICAvLwogICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IKICAgIC8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLAogICAgLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFCiAgICAvLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSCiAgICAvLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORwogICAgLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUwogICAgLy8gSU4gVEhFIFNPRlRXQVJFLgoKICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvCiAgICB2YXIga0NTU0NvbG9yVGFibGUgPSB7CiAgICAgICJ0cmFuc3BhcmVudCI6IFswLDAsMCwwXSwgImFsaWNlYmx1ZSI6IFsyNDAsMjQ4LDI1NSwxXSwKICAgICAgImFudGlxdWV3aGl0ZSI6IFsyNTAsMjM1LDIxNSwxXSwgImFxdWEiOiBbMCwyNTUsMjU1LDFdLAogICAgICAiYXF1YW1hcmluZSI6IFsxMjcsMjU1LDIxMiwxXSwgImF6dXJlIjogWzI0MCwyNTUsMjU1LDFdLAogICAgICAiYmVpZ2UiOiBbMjQ1LDI0NSwyMjAsMV0sICJiaXNxdWUiOiBbMjU1LDIyOCwxOTYsMV0sCiAgICAgICJibGFjayI6IFswLDAsMCwxXSwgImJsYW5jaGVkYWxtb25kIjogWzI1NSwyMzUsMjA1LDFdLAogICAgICAiYmx1ZSI6IFswLDAsMjU1LDFdLCAiYmx1ZXZpb2xldCI6IFsxMzgsNDMsMjI2LDFdLAogICAgICAiYnJvd24iOiBbMTY1LDQyLDQyLDFdLCAiYnVybHl3b29kIjogWzIyMiwxODQsMTM1LDFdLAogICAgICAiY2FkZXRibHVlIjogWzk1LDE1OCwxNjAsMV0sICJjaGFydHJldXNlIjogWzEyNywyNTUsMCwxXSwKICAgICAgImNob2NvbGF0ZSI6IFsyMTAsMTA1LDMwLDFdLCAiY29yYWwiOiBbMjU1LDEyNyw4MCwxXSwKICAgICAgImNvcm5mbG93ZXJibHVlIjogWzEwMCwxNDksMjM3LDFdLCAiY29ybnNpbGsiOiBbMjU1LDI0OCwyMjAsMV0sCiAgICAgICJjcmltc29uIjogWzIyMCwyMCw2MCwxXSwgImN5YW4iOiBbMCwyNTUsMjU1LDFdLAogICAgICAiZGFya2JsdWUiOiBbMCwwLDEzOSwxXSwgImRhcmtjeWFuIjogWzAsMTM5LDEzOSwxXSwKICAgICAgImRhcmtnb2xkZW5yb2QiOiBbMTg0LDEzNCwxMSwxXSwgImRhcmtncmF5IjogWzE2OSwxNjksMTY5LDFdLAogICAgICAiZGFya2dyZWVuIjogWzAsMTAwLDAsMV0sICJkYXJrZ3JleSI6IFsxNjksMTY5LDE2OSwxXSwKICAgICAgImRhcmtraGFraSI6IFsxODksMTgzLDEwNywxXSwgImRhcmttYWdlbnRhIjogWzEzOSwwLDEzOSwxXSwKICAgICAgImRhcmtvbGl2ZWdyZWVuIjogWzg1LDEwNyw0NywxXSwgImRhcmtvcmFuZ2UiOiBbMjU1LDE0MCwwLDFdLAogICAgICAiZGFya29yY2hpZCI6IFsxNTMsNTAsMjA0LDFdLCAiZGFya3JlZCI6IFsxMzksMCwwLDFdLAogICAgICAiZGFya3NhbG1vbiI6IFsyMzMsMTUwLDEyMiwxXSwgImRhcmtzZWFncmVlbiI6IFsxNDMsMTg4LDE0MywxXSwKICAgICAgImRhcmtzbGF0ZWJsdWUiOiBbNzIsNjEsMTM5LDFdLCAiZGFya3NsYXRlZ3JheSI6IFs0Nyw3OSw3OSwxXSwKICAgICAgImRhcmtzbGF0ZWdyZXkiOiBbNDcsNzksNzksMV0sICJkYXJrdHVycXVvaXNlIjogWzAsMjA2LDIwOSwxXSwKICAgICAgImRhcmt2aW9sZXQiOiBbMTQ4LDAsMjExLDFdLCAiZGVlcHBpbmsiOiBbMjU1LDIwLDE0NywxXSwKICAgICAgImRlZXBza3libHVlIjogWzAsMTkxLDI1NSwxXSwgImRpbWdyYXkiOiBbMTA1LDEwNSwxMDUsMV0sCiAgICAgICJkaW1ncmV5IjogWzEwNSwxMDUsMTA1LDFdLCAiZG9kZ2VyYmx1ZSI6IFszMCwxNDQsMjU1LDFdLAogICAgICAiZmlyZWJyaWNrIjogWzE3OCwzNCwzNCwxXSwgImZsb3JhbHdoaXRlIjogWzI1NSwyNTAsMjQwLDFdLAogICAgICAiZm9yZXN0Z3JlZW4iOiBbMzQsMTM5LDM0LDFdLCAiZnVjaHNpYSI6IFsyNTUsMCwyNTUsMV0sCiAgICAgICJnYWluc2Jvcm8iOiBbMjIwLDIyMCwyMjAsMV0sICJnaG9zdHdoaXRlIjogWzI0OCwyNDgsMjU1LDFdLAogICAgICAiZ29sZCI6IFsyNTUsMjE1LDAsMV0sICJnb2xkZW5yb2QiOiBbMjE4LDE2NSwzMiwxXSwKICAgICAgImdyYXkiOiBbMTI4LDEyOCwxMjgsMV0sICJncmVlbiI6IFswLDEyOCwwLDFdLAogICAgICAiZ3JlZW55ZWxsb3ciOiBbMTczLDI1NSw0NywxXSwgImdyZXkiOiBbMTI4LDEyOCwxMjgsMV0sCiAgICAgICJob25leWRldyI6IFsyNDAsMjU1LDI0MCwxXSwgImhvdHBpbmsiOiBbMjU1LDEwNSwxODAsMV0sCiAgICAgICJpbmRpYW5yZWQiOiBbMjA1LDkyLDkyLDFdLCAiaW5kaWdvIjogWzc1LDAsMTMwLDFdLAogICAgICAiaXZvcnkiOiBbMjU1LDI1NSwyNDAsMV0sICJraGFraSI6IFsyNDAsMjMwLDE0MCwxXSwKICAgICAgImxhdmVuZGVyIjogWzIzMCwyMzAsMjUwLDFdLCAibGF2ZW5kZXJibHVzaCI6IFsyNTUsMjQwLDI0NSwxXSwKICAgICAgImxhd25ncmVlbiI6IFsxMjQsMjUyLDAsMV0sICJsZW1vbmNoaWZmb24iOiBbMjU1LDI1MCwyMDUsMV0sCiAgICAgICJsaWdodGJsdWUiOiBbMTczLDIxNiwyMzAsMV0sICJsaWdodGNvcmFsIjogWzI0MCwxMjgsMTI4LDFdLAogICAgICAibGlnaHRjeWFuIjogWzIyNCwyNTUsMjU1LDFdLCAibGlnaHRnb2xkZW5yb2R5ZWxsb3ciOiBbMjUwLDI1MCwyMTAsMV0sCiAgICAgICJsaWdodGdyYXkiOiBbMjExLDIxMSwyMTEsMV0sICJsaWdodGdyZWVuIjogWzE0NCwyMzgsMTQ0LDFdLAogICAgICAibGlnaHRncmV5IjogWzIxMSwyMTEsMjExLDFdLCAibGlnaHRwaW5rIjogWzI1NSwxODIsMTkzLDFdLAogICAgICAibGlnaHRzYWxtb24iOiBbMjU1LDE2MCwxMjIsMV0sICJsaWdodHNlYWdyZWVuIjogWzMyLDE3OCwxNzAsMV0sCiAgICAgICJsaWdodHNreWJsdWUiOiBbMTM1LDIwNiwyNTAsMV0sICJsaWdodHNsYXRlZ3JheSI6IFsxMTksMTM2LDE1MywxXSwKICAgICAgImxpZ2h0c2xhdGVncmV5IjogWzExOSwxMzYsMTUzLDFdLCAibGlnaHRzdGVlbGJsdWUiOiBbMTc2LDE5NiwyMjIsMV0sCiAgICAgICJsaWdodHllbGxvdyI6IFsyNTUsMjU1LDIyNCwxXSwgImxpbWUiOiBbMCwyNTUsMCwxXSwKICAgICAgImxpbWVncmVlbiI6IFs1MCwyMDUsNTAsMV0sICJsaW5lbiI6IFsyNTAsMjQwLDIzMCwxXSwKICAgICAgIm1hZ2VudGEiOiBbMjU1LDAsMjU1LDFdLCAibWFyb29uIjogWzEyOCwwLDAsMV0sCiAgICAgICJtZWRpdW1hcXVhbWFyaW5lIjogWzEwMiwyMDUsMTcwLDFdLCAibWVkaXVtYmx1ZSI6IFswLDAsMjA1LDFdLAogICAgICAibWVkaXVtb3JjaGlkIjogWzE4Niw4NSwyMTEsMV0sICJtZWRpdW1wdXJwbGUiOiBbMTQ3LDExMiwyMTksMV0sCiAgICAgICJtZWRpdW1zZWFncmVlbiI6IFs2MCwxNzksMTEzLDFdLCAibWVkaXVtc2xhdGVibHVlIjogWzEyMywxMDQsMjM4LDFdLAogICAgICAibWVkaXVtc3ByaW5nZ3JlZW4iOiBbMCwyNTAsMTU0LDFdLCAibWVkaXVtdHVycXVvaXNlIjogWzcyLDIwOSwyMDQsMV0sCiAgICAgICJtZWRpdW12aW9sZXRyZWQiOiBbMTk5LDIxLDEzMywxXSwgIm1pZG5pZ2h0Ymx1ZSI6IFsyNSwyNSwxMTIsMV0sCiAgICAgICJtaW50Y3JlYW0iOiBbMjQ1LDI1NSwyNTAsMV0sICJtaXN0eXJvc2UiOiBbMjU1LDIyOCwyMjUsMV0sCiAgICAgICJtb2NjYXNpbiI6IFsyNTUsMjI4LDE4MSwxXSwgIm5hdmFqb3doaXRlIjogWzI1NSwyMjIsMTczLDFdLAogICAgICAibmF2eSI6IFswLDAsMTI4LDFdLCAib2xkbGFjZSI6IFsyNTMsMjQ1LDIzMCwxXSwKICAgICAgIm9saXZlIjogWzEyOCwxMjgsMCwxXSwgIm9saXZlZHJhYiI6IFsxMDcsMTQyLDM1LDFdLAogICAgICAib3JhbmdlIjogWzI1NSwxNjUsMCwxXSwgIm9yYW5nZXJlZCI6IFsyNTUsNjksMCwxXSwKICAgICAgIm9yY2hpZCI6IFsyMTgsMTEyLDIxNCwxXSwgInBhbGVnb2xkZW5yb2QiOiBbMjM4LDIzMiwxNzAsMV0sCiAgICAgICJwYWxlZ3JlZW4iOiBbMTUyLDI1MSwxNTIsMV0sICJwYWxldHVycXVvaXNlIjogWzE3NSwyMzgsMjM4LDFdLAogICAgICAicGFsZXZpb2xldHJlZCI6IFsyMTksMTEyLDE0NywxXSwgInBhcGF5YXdoaXAiOiBbMjU1LDIzOSwyMTMsMV0sCiAgICAgICJwZWFjaHB1ZmYiOiBbMjU1LDIxOCwxODUsMV0sICJwZXJ1IjogWzIwNSwxMzMsNjMsMV0sCiAgICAgICJwaW5rIjogWzI1NSwxOTIsMjAzLDFdLCAicGx1bSI6IFsyMjEsMTYwLDIyMSwxXSwKICAgICAgInBvd2RlcmJsdWUiOiBbMTc2LDIyNCwyMzAsMV0sICJwdXJwbGUiOiBbMTI4LDAsMTI4LDFdLAogICAgICAicmViZWNjYXB1cnBsZSI6IFsxMDIsNTEsMTUzLDFdLAogICAgICAicmVkIjogWzI1NSwwLDAsMV0sICJyb3N5YnJvd24iOiBbMTg4LDE0MywxNDMsMV0sCiAgICAgICJyb3lhbGJsdWUiOiBbNjUsMTA1LDIyNSwxXSwgInNhZGRsZWJyb3duIjogWzEzOSw2OSwxOSwxXSwKICAgICAgInNhbG1vbiI6IFsyNTAsMTI4LDExNCwxXSwgInNhbmR5YnJvd24iOiBbMjQ0LDE2NCw5NiwxXSwKICAgICAgInNlYWdyZWVuIjogWzQ2LDEzOSw4NywxXSwgInNlYXNoZWxsIjogWzI1NSwyNDUsMjM4LDFdLAogICAgICAic2llbm5hIjogWzE2MCw4Miw0NSwxXSwgInNpbHZlciI6IFsxOTIsMTkyLDE5MiwxXSwKICAgICAgInNreWJsdWUiOiBbMTM1LDIwNiwyMzUsMV0sICJzbGF0ZWJsdWUiOiBbMTA2LDkwLDIwNSwxXSwKICAgICAgInNsYXRlZ3JheSI6IFsxMTIsMTI4LDE0NCwxXSwgInNsYXRlZ3JleSI6IFsxMTIsMTI4LDE0NCwxXSwKICAgICAgInNub3ciOiBbMjU1LDI1MCwyNTAsMV0sICJzcHJpbmdncmVlbiI6IFswLDI1NSwxMjcsMV0sCiAgICAgICJzdGVlbGJsdWUiOiBbNzAsMTMwLDE4MCwxXSwgInRhbiI6IFsyMTAsMTgwLDE0MCwxXSwKICAgICAgInRlYWwiOiBbMCwxMjgsMTI4LDFdLCAidGhpc3RsZSI6IFsyMTYsMTkxLDIxNiwxXSwKICAgICAgInRvbWF0byI6IFsyNTUsOTksNzEsMV0sICJ0dXJxdW9pc2UiOiBbNjQsMjI0LDIwOCwxXSwKICAgICAgInZpb2xldCI6IFsyMzgsMTMwLDIzOCwxXSwgIndoZWF0IjogWzI0NSwyMjIsMTc5LDFdLAogICAgICAid2hpdGUiOiBbMjU1LDI1NSwyNTUsMV0sICJ3aGl0ZXNtb2tlIjogWzI0NSwyNDUsMjQ1LDFdLAogICAgICAieWVsbG93IjogWzI1NSwyNTUsMCwxXSwgInllbGxvd2dyZWVuIjogWzE1NCwyMDUsNTAsMV19OwoKICAgIGZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuCiAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuCiAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTsKICAgIH0KCiAgICBmdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC4KICAgICAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7CiAgICB9CgogICAgZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLgogICAgICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKQogICAgICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpOwogICAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7CiAgICB9CgogICAgZnVuY3Rpb24gcGFyc2VfY3NzX2Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS4KICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJykKICAgICAgICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7CiAgICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHsKICAgICAgaWYgKGggPCAwKSBoICs9IDE7CiAgICAgIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7CgogICAgICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjsKICAgICAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yOwogICAgICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2OwogICAgICByZXR1cm4gbTE7CiAgICB9CgogICAgZnVuY3Rpb24gcGFyc2VDU1NDb2xvcihjc3Nfc3RyKSB7CiAgICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLgogICAgICB2YXIgc3RyID0gY3NzX3N0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpOwoKICAgICAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLgogICAgICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLgoKICAgICAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguCiAgICAgIGlmIChzdHJbMF0gPT09ICcjJykgewogICAgICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7CiAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy4KICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uCiAgICAgICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLAogICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSwKICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLAogICAgICAgICAgICAgICAgICAxXTsKICAgICAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHsKICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLgogICAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi4KICAgICAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LAogICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsCiAgICAgICAgICAgICAgICAgIGl2ICYgMHhmZiwKICAgICAgICAgICAgICAgICAgMV07CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpOwogICAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkgewogICAgICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApOwogICAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTsKICAgICAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC4KICAgICAgICBzd2l0Y2ggKGZuYW1lKSB7CiAgICAgICAgICBjYXNlICdyZ2JhJzoKICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsOwogICAgICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpOwogICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guCiAgICAgICAgICBjYXNlICdyZ2InOgogICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIHJldHVybiBbcGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLAogICAgICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSwKICAgICAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksCiAgICAgICAgICAgICAgICAgICAgYWxwaGFdOwogICAgICAgICAgY2FzZSAnaHNsYSc6CiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDsKICAgICAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTsKICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLgogICAgICAgICAgY2FzZSAnaHNsJzoKICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsOwogICAgICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMQogICAgICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmUKICAgICAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLgogICAgICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pOwogICAgICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pOwogICAgICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogczsKICAgICAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjsKICAgICAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksCiAgICAgICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksCiAgICAgICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLAogICAgICAgICAgICAgICAgICAgIGFscGhhXTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CgogICAgdHJ5IHsgZXhwb3J0cy5wYXJzZUNTU0NvbG9yID0gcGFyc2VDU1NDb2xvcjsgfSBjYXRjaChlKSB7IH0KICAgIH0pOwoKICAgIGNsYXNzIENvbG9yIHsKICAgICAgICBjb25zdHJ1Y3RvcihyLCBnLCBiLCBhID0gMSkgewogICAgICAgICAgICB0aGlzLnIgPSByOwogICAgICAgICAgICB0aGlzLmcgPSBnOwogICAgICAgICAgICB0aGlzLmIgPSBiOwogICAgICAgICAgICB0aGlzLmEgPSBhOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgcGFyc2UoaW5wdXQpIHsKICAgICAgICAgICAgaWYgKCFpbnB1dCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikgewogICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHJnYmEgPSBjc3Njb2xvcnBhcnNlci5wYXJzZUNTU0NvbG9yKGlucHV0KTsKICAgICAgICAgICAgaWYgKCFyZ2JhKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmdiYVswXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbMV0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzJdIC8gMjU1ICogcmdiYVszXSwgcmdiYVszXSk7CiAgICAgICAgfQogICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICBjb25zdCBbciwgZywgYiwgYV0gPSB0aGlzLnRvQXJyYXkoKTsKICAgICAgICAgICAgcmV0dXJuIGByZ2JhKCR7IE1hdGgucm91bmQocikgfSwkeyBNYXRoLnJvdW5kKGcpIH0sJHsgTWF0aC5yb3VuZChiKSB9LCR7IGEgfSlgOwogICAgICAgIH0KICAgICAgICB0b0FycmF5KCkgewogICAgICAgICAgICBjb25zdCB7ciwgZywgYiwgYX0gPSB0aGlzOwogICAgICAgICAgICByZXR1cm4gYSA9PT0gMCA/IFsKICAgICAgICAgICAgICAgIDAsCiAgICAgICAgICAgICAgICAwLAogICAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICAgIDAKICAgICAgICAgICAgXSA6IFsKICAgICAgICAgICAgICAgIHIgKiAyNTUgLyBhLAogICAgICAgICAgICAgICAgZyAqIDI1NSAvIGEsCiAgICAgICAgICAgICAgICBiICogMjU1IC8gYSwKICAgICAgICAgICAgICAgIGEKICAgICAgICAgICAgXTsKICAgICAgICB9CiAgICAgICAgdG9BcnJheTAxKCkgewogICAgICAgICAgICBjb25zdCB7ciwgZywgYiwgYX0gPSB0aGlzOwogICAgICAgICAgICByZXR1cm4gYSA9PT0gMCA/IFsKICAgICAgICAgICAgICAgIDAsCiAgICAgICAgICAgICAgICAwLAogICAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICAgIDAKICAgICAgICAgICAgXSA6IFsKICAgICAgICAgICAgICAgIHIgLyBhLAogICAgICAgICAgICAgICAgZyAvIGEsCiAgICAgICAgICAgICAgICBiIC8gYSwKICAgICAgICAgICAgICAgIGEKICAgICAgICAgICAgXTsKICAgICAgICB9CiAgICAgICAgdG9BcnJheTAxUHJlbXVsdGlwbGllZEFscGhhKCkgewogICAgICAgICAgICBjb25zdCB7ciwgZywgYiwgYX0gPSB0aGlzOwogICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgciwKICAgICAgICAgICAgICAgIGcsCiAgICAgICAgICAgICAgICBiLAogICAgICAgICAgICAgICAgYQogICAgICAgICAgICBdOwogICAgICAgIH0KICAgIH0KICAgIENvbG9yLmJsYWNrID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpOwogICAgQ29sb3Iud2hpdGUgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7CiAgICBDb2xvci50cmFuc3BhcmVudCA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKTsKICAgIENvbG9yLnJlZCA9IG5ldyBDb2xvcigxLCAwLCAwLCAxKTsKICAgIENvbG9yLmJsdWUgPSBuZXcgQ29sb3IoMCwgMCwgMSwgMSk7CiAgICB2YXIgQ29sb3IkMSA9IENvbG9yOwoKICAgIGNsYXNzIENvbGxhdG9yIHsKICAgICAgICBjb25zdHJ1Y3RvcihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkgewogICAgICAgICAgICBpZiAoY2FzZVNlbnNpdGl2ZSkKICAgICAgICAgICAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBkaWFjcml0aWNTZW5zaXRpdmUgPyAndmFyaWFudCcgOiAnY2FzZSc7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBkaWFjcml0aWNTZW5zaXRpdmUgPyAnYWNjZW50JyA6ICdiYXNlJzsKICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7CiAgICAgICAgICAgIHRoaXMuY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10sIHsKICAgICAgICAgICAgICAgIHNlbnNpdGl2aXR5OiB0aGlzLnNlbnNpdGl2aXR5LAogICAgICAgICAgICAgICAgdXNhZ2U6ICdzZWFyY2gnCiAgICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBjb21wYXJlKGxocywgcmhzKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yLmNvbXBhcmUobGhzLCByaHMpOwogICAgICAgIH0KICAgICAgICByZXNvbHZlZExvY2FsZSgpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlOwogICAgICAgIH0KICAgIH0KCiAgICBjbGFzcyBGb3JtYXR0ZWRTZWN0aW9uIHsKICAgICAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBpbWFnZSwgc2NhbGUsIGZvbnRTdGFjaywgdGV4dENvbG9yKSB7CiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQubm9ybWFsaXplID8gdGV4dC5ub3JtYWxpemUoKSA6IHRleHQ7CiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTsKICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlOwogICAgICAgICAgICB0aGlzLmZvbnRTdGFjayA9IGZvbnRTdGFjazsKICAgICAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSB0ZXh0Q29sb3I7CiAgICAgICAgfQogICAgfQogICAgY2xhc3MgRm9ybWF0dGVkIHsKICAgICAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucykgewogICAgICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBmcm9tU3RyaW5nKHVuZm9ybWF0dGVkKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKFtuZXcgRm9ybWF0dGVkU2VjdGlvbih1bmZvcm1hdHRlZCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCldKTsKICAgICAgICB9CiAgICAgICAgaXNFbXB0eSgpIHsKICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKQogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIHJldHVybiAhdGhpcy5zZWN0aW9ucy5zb21lKHNlY3Rpb24gPT4gc2VjdGlvbi50ZXh0Lmxlbmd0aCAhPT0gMCB8fCBzZWN0aW9uLmltYWdlICYmIHNlY3Rpb24uaW1hZ2UubmFtZS5sZW5ndGggIT09IDApOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgZmFjdG9yeSh0ZXh0KSB7CiAgICAgICAgICAgIGlmICh0ZXh0IGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0ZXh0KTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0b1N0cmluZygpIHsKICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKQogICAgICAgICAgICAgICAgcmV0dXJuICcnOwogICAgICAgICAgICByZXR1cm4gdGhpcy5zZWN0aW9ucy5tYXAoc2VjdGlvbiA9PiBzZWN0aW9uLnRleHQpLmpvaW4oJycpOwogICAgICAgIH0KICAgICAgICBzZXJpYWxpemUoKSB7CiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddOwogICAgICAgICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5zZWN0aW9ucykgewogICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uaW1hZ2UpIHsKICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goWwogICAgICAgICAgICAgICAgICAgICAgICAnaW1hZ2UnLAogICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmltYWdlLm5hbWUKICAgICAgICAgICAgICAgICAgICBdKTsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChzZWN0aW9uLnRleHQpOwogICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9OwogICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uZm9udFN0YWNrKSB7CiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBbCiAgICAgICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJywKICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5mb250U3RhY2suc3BsaXQoJywnKQogICAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkgewogICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHsKICAgICAgICAgICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBbJ3JnYmEnXS5jb25jYXQoc2VjdGlvbi50ZXh0Q29sb3IudG9BcnJheSgpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChvcHRpb25zKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDsKICAgICAgICB9CiAgICB9CgogICAgY2xhc3MgUmVzb2x2ZWRJbWFnZSB7CiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7CiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlID0gb3B0aW9ucy5hdmFpbGFibGU7CiAgICAgICAgfQogICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgZnJvbVN0cmluZyhuYW1lKSB7CiAgICAgICAgICAgIGlmICghbmFtZSkKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkSW1hZ2UoewogICAgICAgICAgICAgICAgbmFtZSwKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogZmFsc2UKICAgICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICdpbWFnZScsCiAgICAgICAgICAgICAgICB0aGlzLm5hbWUKICAgICAgICAgICAgXTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gdmFsaWRhdGVSR0JBKHIsIGcsIGIsIGEpIHsKICAgICAgICBpZiAoISh0eXBlb2YgciA9PT0gJ251bWJlcicgJiYgciA+PSAwICYmIHIgPD0gMjU1ICYmIHR5cGVvZiBnID09PSAnbnVtYmVyJyAmJiBnID49IDAgJiYgZyA8PSAyNTUgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInICYmIGIgPj0gMCAmJiBiIDw9IDI1NSkpIHsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBbCiAgICAgICAgICAgICAgICByLAogICAgICAgICAgICAgICAgZywKICAgICAgICAgICAgICAgIGIsCiAgICAgICAgICAgICAgICBhCiAgICAgICAgICAgIF0gOiBbCiAgICAgICAgICAgICAgICByLAogICAgICAgICAgICAgICAgZywKICAgICAgICAgICAgICAgIGIKICAgICAgICAgICAgXTsKICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHJnYmEgdmFsdWUgWyR7IHZhbHVlLmpvaW4oJywgJykgfV06ICdyJywgJ2cnLCBhbmQgJ2InIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUuYDsKICAgICAgICB9CiAgICAgICAgaWYgKCEodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiBhID49IDAgJiYgYSA8PSAxKSkgewogICAgICAgICAgICByZXR1cm4gYEludmFsaWQgcmdiYSB2YWx1ZSBbJHsgWwogICAgICAgICAgICByLAogICAgICAgICAgICBnLAogICAgICAgICAgICBiLAogICAgICAgICAgICBhCiAgICAgICAgXS5qb2luKCcsICcpIH1dOiAnYScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuYDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBmdW5jdGlvbiBpc1ZhbHVlKG1peGVkKSB7CiAgICAgICAgaWYgKG1peGVkID09PSBudWxsKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnc3RyaW5nJykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnbnVtYmVyJykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sb3IkMSkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sbGF0b3IpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIEZvcm1hdHRlZCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWl4ZWQpKSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtaXhlZCkgewogICAgICAgICAgICAgICAgaWYgKCFpc1ZhbHVlKGl0ZW0pKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnb2JqZWN0JykgewogICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtaXhlZCkgewogICAgICAgICAgICAgICAgaWYgKCFpc1ZhbHVlKG1peGVkW2tleV0pKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiB0eXBlT2YodmFsdWUpIHsKICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHsKICAgICAgICAgICAgcmV0dXJuIE51bGxUeXBlOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgewogICAgICAgICAgICByZXR1cm4gU3RyaW5nVHlwZTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgICAgIHJldHVybiBCb29sZWFuVHlwZTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHsKICAgICAgICAgICAgcmV0dXJuIE51bWJlclR5cGU7CiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yJDEpIHsKICAgICAgICAgICAgcmV0dXJuIENvbG9yVHlwZTsKICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sbGF0b3IpIHsKICAgICAgICAgICAgcmV0dXJuIENvbGxhdG9yVHlwZTsKICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7CiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZWRUeXBlOwogICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlKSB7CiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlZEltYWdlVHlwZTsKICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7CiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsKICAgICAgICAgICAgbGV0IGl0ZW1UeXBlOwogICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0eXBlT2YoaXRlbSk7CiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1UeXBlKSB7CiAgICAgICAgICAgICAgICAgICAgaXRlbVR5cGUgPSB0OwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtVHlwZSA9PT0gdCkgewogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpdGVtVHlwZSA9IFZhbHVlVHlwZTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gYXJyYXkkMShpdGVtVHlwZSB8fCBWYWx1ZVR5cGUsIGxlbmd0aCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIE9iamVjdFR5cGU7CiAgICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHsKICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgewogICAgICAgICAgICByZXR1cm4gJyc7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHsKICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7CiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yJDEgfHwgdmFsdWUgaW5zdGFuY2VvZiBGb3JtYXR0ZWQgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlKSB7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7CiAgICAgICAgfQogICAgfQoKICAgIGNsYXNzIExpdGVyYWwgewogICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHZhbHVlKSB7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYCdsaXRlcmFsJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBidXQgZm91bmQgJHsgYXJncy5sZW5ndGggLSAxIH0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgaWYgKCFpc1ZhbHVlKGFyZ3NbMV0pKQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYGludmFsaWQgdmFsdWVgKTsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzFdOwogICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVPZih2YWx1ZSk7CiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gY29udGV4dC5leHBlY3RlZFR5cGU7CiAgICAgICAgICAgIGlmICh0eXBlLmtpbmQgPT09ICdhcnJheScgJiYgdHlwZS5OID09PSAwICYmIGV4cGVjdGVkICYmIGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScgJiYgKHR5cGVvZiBleHBlY3RlZC5OICE9PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5OID09PSAwKSkgewogICAgICAgICAgICAgICAgdHlwZSA9IGV4cGVjdGVkOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbCh0eXBlLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTsKICAgICAgICB9CiAgICAgICAgZWFjaENoaWxkKCkgewogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplKCkgewogICAgICAgICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdhcnJheScgfHwgdGhpcy50eXBlLmtpbmQgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJywKICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlCiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBDb2xvciQxKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gWydyZ2JhJ10uY29uY2F0KHRoaXMudmFsdWUudG9BcnJheSgpKTsKICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5zZXJpYWxpemUoKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAgdmFyIExpdGVyYWwkMSA9IExpdGVyYWw7CgogICAgY2xhc3MgUnVudGltZUVycm9yIHsKICAgICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7CiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdFeHByZXNzaW9uRXZhbHVhdGlvbkVycm9yJzsKICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICB9CiAgICAgICAgdG9KU09OKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlOwogICAgICAgIH0KICAgIH0KICAgIHZhciBSdW50aW1lRXJyb3IkMSA9IFJ1bnRpbWVFcnJvcjsKCiAgICBjb25zdCB0eXBlcyQxID0gewogICAgICAgIHN0cmluZzogU3RyaW5nVHlwZSwKICAgICAgICBudW1iZXI6IE51bWJlclR5cGUsCiAgICAgICAgYm9vbGVhbjogQm9vbGVhblR5cGUsCiAgICAgICAgb2JqZWN0OiBPYmplY3RUeXBlCiAgICB9OwogICAgY2xhc3MgQXNzZXJ0aW9uIHsKICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhcmdzKSB7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpCiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LmApOwogICAgICAgICAgICBsZXQgaSA9IDE7CiAgICAgICAgICAgIGxldCB0eXBlOwogICAgICAgICAgICBjb25zdCBuYW1lID0gYXJnc1swXTsKICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdhcnJheScpIHsKICAgICAgICAgICAgICAgIGxldCBpdGVtVHlwZTsKICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gYXJnc1sxXTsKICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICEodHlwZSBpbiB0eXBlcyQxKSB8fCB0eXBlID09PSAnb2JqZWN0JykKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBpdGVtIHR5cGUgYXJndW1lbnQgb2YgImFycmF5IiBtdXN0IGJlIG9uZSBvZiBzdHJpbmcsIG51bWJlciwgYm9vbGVhbicsIDEpOwogICAgICAgICAgICAgICAgICAgIGl0ZW1UeXBlID0gdHlwZXMkMVt0eXBlXTsKICAgICAgICAgICAgICAgICAgICBpKys7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbGV0IE47CiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbMl0gIT09IG51bGwgJiYgKHR5cGVvZiBhcmdzWzJdICE9PSAnbnVtYmVyJyB8fCBhcmdzWzJdIDwgMCB8fCBhcmdzWzJdICE9PSBNYXRoLmZsb29yKGFyZ3NbMl0pKSkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVGhlIGxlbmd0aCBhcmd1bWVudCB0byAiYXJyYXkiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxpdGVyYWwnLCAyKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgTiA9IGFyZ3NbMl07CiAgICAgICAgICAgICAgICAgICAgaSsrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdHlwZSA9IGFycmF5JDEoaXRlbVR5cGUsIE4pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVzJDFbbmFtZV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gW107CiAgICAgICAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7CiAgICAgICAgICAgICAgICBpZiAoIWlucHV0KQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goaW5wdXQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHR5cGUsIHBhcnNlZCk7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmFyZ3NbaV0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tTdWJ0eXBlKHRoaXMudHlwZSwgdHlwZU9mKHZhbHVlKSk7CiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IkMShgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSAkeyB0b1N0cmluZyQxKHRoaXMudHlwZSkgfSwgYnV0IGZvdW5kICR7IHRvU3RyaW5nJDEodHlwZU9mKHZhbHVlKSkgfSBpbnN0ZWFkLmApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pOwogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGFyZyA9PiBhcmcub3V0cHV0RGVmaW5lZCgpKTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplKCkgewogICAgICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlOwogICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gW3R5cGUua2luZF07CiAgICAgICAgICAgIGlmICh0eXBlLmtpbmQgPT09ICdhcnJheScpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gdHlwZS5pdGVtVHlwZTsKICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCBpdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCBpdGVtVHlwZS5raW5kID09PSAnYm9vbGVhbicpIHsKICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goaXRlbVR5cGUua2luZCk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgTiA9IHR5cGUuTjsKICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIE4gPT09ICdudW1iZXInIHx8IHRoaXMuYXJncy5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChOKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQuY29uY2F0KHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy5zZXJpYWxpemUoKSkpOwogICAgICAgIH0KICAgIH0KICAgIHZhciBBc3NlcnRpb24kMSA9IEFzc2VydGlvbjsKCiAgICBjbGFzcyBGb3JtYXRFeHByZXNzaW9uIHsKICAgICAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucykgewogICAgICAgICAgICB0aGlzLnR5cGUgPSBGb3JtYXR0ZWRUeXBlOwogICAgICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgZmlyc3RBcmcgPSBhcmdzWzFdOwogICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlyc3RBcmcpICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi5gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBzZWN0aW9ucyA9IFtdOwogICAgICAgICAgICBsZXQgbmV4dFRva2VuTWF5QmVPYmplY3QgPSBmYWxzZTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYXJncy5sZW5ndGggLSAxOyArK2kpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07CiAgICAgICAgICAgICAgICBpZiAobmV4dFRva2VuTWF5QmVPYmplY3QgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkgewogICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxlID0gbnVsbDsKICAgICAgICAgICAgICAgICAgICBpZiAoYXJnWydmb250LXNjYWxlJ10pIHsKICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBjb250ZXh0LnBhcnNlKGFyZ1snZm9udC1zY2FsZSddLCAxLCBOdW1iZXJUeXBlKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2FsZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsZXQgZm9udCA9IG51bGw7CiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ1sndGV4dC1mb250J10pIHsKICAgICAgICAgICAgICAgICAgICAgICAgZm9udCA9IGNvbnRleHQucGFyc2UoYXJnWyd0ZXh0LWZvbnQnXSwgMSwgYXJyYXkkMShTdHJpbmdUeXBlKSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9udCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dENvbG9yID0gbnVsbDsKICAgICAgICAgICAgICAgICAgICBpZiAoYXJnWyd0ZXh0LWNvbG9yJ10pIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yID0gY29udGV4dC5wYXJzZShhcmdbJ3RleHQtY29sb3InXSwgMSwgQ29sb3JUeXBlKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0Q29sb3IpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEV4cHJlc3Npb24gPSBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXTsKICAgICAgICAgICAgICAgICAgICBsYXN0RXhwcmVzc2lvbi5zY2FsZSA9IHNjYWxlOwogICAgICAgICAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLmZvbnQgPSBmb250OwogICAgICAgICAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLnRleHRDb2xvciA9IHRleHRDb2xvcjsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgMSwgVmFsdWVUeXBlKTsKICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQpCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBjb250ZW50LnR5cGUua2luZDsKICAgICAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3N0cmluZycgJiYga2luZCAhPT0gJ3ZhbHVlJyAmJiBraW5kICE9PSAnbnVsbCcgJiYga2luZCAhPT0gJ3Jlc29sdmVkSW1hZ2UnKQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRm9ybWF0dGVkIHRleHQgdHlwZSBtdXN0IGJlICdzdHJpbmcnLCAndmFsdWUnLCAnaW1hZ2UnIG9yICdudWxsJy5gKTsKICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW5NYXlCZU9iamVjdCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsCiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBudWxsLAogICAgICAgICAgICAgICAgICAgICAgICBmb250OiBudWxsLAogICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IG51bGwKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEV4cHJlc3Npb24oc2VjdGlvbnMpOwogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgY29uc3QgZXZhbHVhdGVTZWN0aW9uID0gc2VjdGlvbiA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBldmFsdWF0ZWRDb250ZW50ID0gc2VjdGlvbi5jb250ZW50LmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgICBpZiAodHlwZU9mKGV2YWx1YXRlZENvbnRlbnQpID09PSBSZXNvbHZlZEltYWdlVHlwZSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkU2VjdGlvbignJywgZXZhbHVhdGVkQ29udGVudCwgbnVsbCwgbnVsbCwgbnVsbCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdHRlZFNlY3Rpb24odG9TdHJpbmcoZXZhbHVhdGVkQ29udGVudCksIG51bGwsIHNlY3Rpb24uc2NhbGUgPyBzZWN0aW9uLnNjYWxlLmV2YWx1YXRlKGN0eCkgOiBudWxsLCBzZWN0aW9uLmZvbnQgPyBzZWN0aW9uLmZvbnQuZXZhbHVhdGUoY3R4KS5qb2luKCcsJykgOiBudWxsLCBzZWN0aW9uLnRleHRDb2xvciA/IHNlY3Rpb24udGV4dENvbG9yLmV2YWx1YXRlKGN0eCkgOiBudWxsKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWQodGhpcy5zZWN0aW9ucy5tYXAoZXZhbHVhdGVTZWN0aW9uKSk7CiAgICAgICAgfQogICAgICAgIGVhY2hDaGlsZChmbikgewogICAgICAgICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5zZWN0aW9ucykgewogICAgICAgICAgICAgICAgZm4oc2VjdGlvbi5jb250ZW50KTsKICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7CiAgICAgICAgICAgICAgICAgICAgZm4oc2VjdGlvbi5zY2FsZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbi5mb250KSB7CiAgICAgICAgICAgICAgICAgICAgZm4oc2VjdGlvbi5mb250KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikgewogICAgICAgICAgICAgICAgICAgIGZuKHNlY3Rpb24udGV4dENvbG9yKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFsnZm9ybWF0J107CiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiB0aGlzLnNlY3Rpb25zKSB7CiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi5jb250ZW50LnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTsKICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7CiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1snZm9udC1zY2FsZSddID0gc2VjdGlvbi5zY2FsZS5zZXJpYWxpemUoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLmZvbnQpIHsKICAgICAgICAgICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWZvbnQnXSA9IHNlY3Rpb24uZm9udC5zZXJpYWxpemUoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikgewogICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3RleHQtY29sb3InXSA9IHNlY3Rpb24udGV4dENvbG9yLnNlcmlhbGl6ZSgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKG9wdGlvbnMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICAgIH0KICAgIH0KCiAgICBjbGFzcyBJbWFnZUV4cHJlc3Npb24gewogICAgICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IFJlc29sdmVkSW1hZ2VUeXBlOwogICAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIHR3byBhcmd1bWVudHMuYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgU3RyaW5nVHlwZSk7CiAgICAgICAgICAgIGlmICghbmFtZSkKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBObyBpbWFnZSBuYW1lIHByb3ZpZGVkLmApOwogICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlRXhwcmVzc2lvbihuYW1lKTsKICAgICAgICB9CiAgICAgICAgZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRlZEltYWdlTmFtZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcoZXZhbHVhdGVkSW1hZ2VOYW1lKTsKICAgICAgICAgICAgaWYgKHZhbHVlICYmIGN0eC5hdmFpbGFibGVJbWFnZXMpCiAgICAgICAgICAgICAgICB2YWx1ZS5hdmFpbGFibGUgPSBjdHguYXZhaWxhYmxlSW1hZ2VzLmluZGV4T2YoZXZhbHVhdGVkSW1hZ2VOYW1lKSA+IC0xOwogICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgfQogICAgICAgIGVhY2hDaGlsZChmbikgewogICAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgICB9CiAgICAgICAgb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBzZXJpYWxpemUoKSB7CiAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAnaW1hZ2UnLAogICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKQogICAgICAgICAgICBdOwogICAgICAgIH0KICAgIH0KCiAgICBjb25zdCB0eXBlcyA9IHsKICAgICAgICAndG8tYm9vbGVhbic6IEJvb2xlYW5UeXBlLAogICAgICAgICd0by1jb2xvcic6IENvbG9yVHlwZSwKICAgICAgICAndG8tbnVtYmVyJzogTnVtYmVyVHlwZSwKICAgICAgICAndG8tc3RyaW5nJzogU3RyaW5nVHlwZQogICAgfTsKICAgIGNsYXNzIENvZXJjaW9uIHsKICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhcmdzKSB7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpCiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LmApOwogICAgICAgICAgICBjb25zdCBuYW1lID0gYXJnc1swXTsKICAgICAgICAgICAgaWYgKChuYW1lID09PSAndG8tYm9vbGVhbicgfHwgbmFtZSA9PT0gJ3RvLXN0cmluZycpICYmIGFyZ3MubGVuZ3RoICE9PSAyKQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIG9uZSBhcmd1bWVudC5gKTsKICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW25hbWVdOwogICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBbXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgVmFsdWVUeXBlKTsKICAgICAgICAgICAgICAgIGlmICghaW5wdXQpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgICBwYXJzZWQucHVzaChpbnB1dCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2VyY2lvbih0eXBlLCBwYXJzZWQpOwogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAnYm9vbGVhbicpIHsKICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2NvbG9yJykgewogICAgICAgICAgICAgICAgbGV0IGlucHV0OwogICAgICAgICAgICAgICAgbGV0IGVycm9yOwogICAgICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgdGhpcy5hcmdzKSB7CiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBhcmcuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7CiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IkMSkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBjdHgucGFyc2VDb2xvcihpbnB1dCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDwgMyB8fCBpbnB1dC5sZW5ndGggPiA0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGBJbnZhbGlkIHJiZ2EgdmFsdWUgJHsgSlNPTi5zdHJpbmdpZnkoaW5wdXQpIH06IGV4cGVjdGVkIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIHRocmVlIG9yIGZvdXIgbnVtZXJpYyB2YWx1ZXMuYDsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gdmFsaWRhdGVSR0JBKGlucHV0WzBdLCBpbnB1dFsxXSwgaW5wdXRbMl0sIGlucHV0WzNdKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJDEoaW5wdXRbMF0gLyAyNTUsIGlucHV0WzFdIC8gMjU1LCBpbnB1dFsyXSAvIDI1NSwgaW5wdXRbM10pOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvciQxKGVycm9yIHx8IGBDb3VsZCBub3QgcGFyc2UgY29sb3IgZnJvbSB2YWx1ZSAnJHsgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/IGlucHV0IDogU3RyaW5nKEpTT04uc3RyaW5naWZ5KGlucHV0KSkgfSdgKTsKICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiB0aGlzLmFyZ3MpIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZy5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKHZhbHVlKTsKICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtKSkKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IkMShgQ291bGQgbm90IGNvbnZlcnQgJHsgSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0gdG8gbnVtYmVyLmApOwogICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5raW5kID09PSAnZm9ybWF0dGVkJykgewogICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlZC5mcm9tU3RyaW5nKHRvU3RyaW5nKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKSk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykgewogICAgICAgICAgICAgICAgcmV0dXJuIFJlc29sdmVkSW1hZ2UuZnJvbVN0cmluZyh0b1N0cmluZyh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pOwogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGFyZyA9PiBhcmcub3V0cHV0RGVmaW5lZCgpKTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplKCkgewogICAgICAgICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdmb3JtYXR0ZWQnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEV4cHJlc3Npb24oW3sKICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5hcmdzWzBdLAogICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogbnVsbCwKICAgICAgICAgICAgICAgICAgICAgICAgZm9udDogbnVsbCwKICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiBudWxsCiAgICAgICAgICAgICAgICAgICAgfV0pLnNlcmlhbGl6ZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlRXhwcmVzc2lvbih0aGlzLmFyZ3NbMF0pLnNlcmlhbGl6ZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbYHRvLSR7IHRoaXMudHlwZS5raW5kIH1gXTsKICAgICAgICAgICAgdGhpcy5lYWNoQ2hpbGQoY2hpbGQgPT4gewogICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICAgIH0KICAgIH0KICAgIHZhciBDb2VyY2lvbiQxID0gQ29lcmNpb247CgogICAgY29uc3QgZ2VvbWV0cnlUeXBlcyA9IFsKICAgICAgICAnVW5rbm93bicsCiAgICAgICAgJ1BvaW50JywKICAgICAgICAnTGluZVN0cmluZycsCiAgICAgICAgJ1BvbHlnb24nCiAgICBdOwogICAgY2xhc3MgRXZhbHVhdGlvbkNvbnRleHQgewogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgICB0aGlzLmdsb2JhbHMgPSBudWxsOwogICAgICAgICAgICB0aGlzLmZlYXR1cmUgPSBudWxsOwogICAgICAgICAgICB0aGlzLmZlYXR1cmVTdGF0ZSA9IG51bGw7CiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkU2VjdGlvbiA9IG51bGw7CiAgICAgICAgICAgIHRoaXMuX3BhcnNlQ29sb3JDYWNoZSA9IHt9OwogICAgICAgICAgICB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IG51bGw7CiAgICAgICAgICAgIHRoaXMuY2Fub25pY2FsID0gbnVsbDsKICAgICAgICAgICAgdGhpcy5mZWF0dXJlVGlsZUNvb3JkID0gbnVsbDsKICAgICAgICAgICAgdGhpcy5mZWF0dXJlRGlzdGFuY2VEYXRhID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgaWQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgJ2lkJyBpbiB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmlkID8gdGhpcy5mZWF0dXJlLmlkIDogbnVsbDsKICAgICAgICB9CiAgICAgICAgZ2VvbWV0cnlUeXBlKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlID8gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID09PSAnbnVtYmVyJyA/IGdlb21ldHJ5VHlwZXNbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsOwogICAgICAgIH0KICAgICAgICBnZW9tZXRyeSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiAnZ2VvbWV0cnknIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5nZW9tZXRyeSA6IG51bGw7CiAgICAgICAgfQogICAgICAgIGNhbm9uaWNhbElEKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWw7CiAgICAgICAgfQogICAgICAgIHByb3BlcnRpZXMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLnByb3BlcnRpZXMgfHwge307CiAgICAgICAgfQogICAgICAgIGRpc3RhbmNlRnJvbUNlbnRlcigpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZVRpbGVDb29yZCAmJiB0aGlzLmZlYXR1cmVEaXN0YW5jZURhdGEpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmZlYXR1cmVEaXN0YW5jZURhdGEuY2VudGVyOwogICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmZlYXR1cmVEaXN0YW5jZURhdGEuc2NhbGU7CiAgICAgICAgICAgICAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmZlYXR1cmVUaWxlQ29vcmQ7CiAgICAgICAgICAgICAgICBjb25zdCBkWCA9IHggKiBzY2FsZSAtIGNbMF07CiAgICAgICAgICAgICAgICBjb25zdCBkWSA9IHkgKiBzY2FsZSAtIGNbMV07CiAgICAgICAgICAgICAgICBjb25zdCBiWCA9IHRoaXMuZmVhdHVyZURpc3RhbmNlRGF0YS5iZWFyaW5nWzBdOwogICAgICAgICAgICAgICAgY29uc3QgYlkgPSB0aGlzLmZlYXR1cmVEaXN0YW5jZURhdGEuYmVhcmluZ1sxXTsKICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBiWCAqIGRYICsgYlkgKiBkWTsKICAgICAgICAgICAgICAgIHJldHVybiBkaXN0OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBwYXJzZUNvbG9yKGlucHV0KSB7CiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9wYXJzZUNvbG9yQ2FjaGVbaW5wdXRdOwogICAgICAgICAgICBpZiAoIWNhY2hlZCkgewogICAgICAgICAgICAgICAgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XSA9IENvbG9yJDEucGFyc2UoaW5wdXQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7CiAgICAgICAgfQogICAgfQogICAgdmFyIEV2YWx1YXRpb25Db250ZXh0JDEgPSBFdmFsdWF0aW9uQ29udGV4dDsKCiAgICBjbGFzcyBDb21wb3VuZEV4cHJlc3Npb24gewogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGV2YWx1YXRlLCBhcmdzKSB7CiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICAgIHRoaXMuX2V2YWx1YXRlID0gZXZhbHVhdGU7CiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGUoY3R4LCB0aGlzLmFyZ3MpOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pOwogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIFt0aGlzLm5hbWVdLmNvbmNhdCh0aGlzLmFyZ3MubWFwKGFyZyA9PiBhcmcuc2VyaWFsaXplKCkpKTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgY29uc3Qgb3AgPSBhcmdzWzBdOwogICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zW29wXTsKICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgVW5rbm93biBleHByZXNzaW9uICIkeyBvcCB9Ii4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbImxpdGVyYWwiLCBbLi4uXV0uYCwgMCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgdHlwZSA9IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBkZWZpbml0aW9uWzBdIDogZGVmaW5pdGlvbi50eXBlOwogICAgICAgICAgICBjb25zdCBhdmFpbGFibGVPdmVybG9hZHMgPSBBcnJheS5pc0FycmF5KGRlZmluaXRpb24pID8gW1sKICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uWzFdLAogICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25bMl0KICAgICAgICAgICAgICAgIF1dIDogZGVmaW5pdGlvbi5vdmVybG9hZHM7CiAgICAgICAgICAgIGNvbnN0IG92ZXJsb2FkcyA9IGF2YWlsYWJsZU92ZXJsb2Fkcy5maWx0ZXIoKFtzaWduYXR1cmVdKSA9PiAhQXJyYXkuaXNBcnJheShzaWduYXR1cmUpIHx8IHNpZ25hdHVyZS5sZW5ndGggPT09IGFyZ3MubGVuZ3RoIC0gMSk7CiAgICAgICAgICAgIGxldCBzaWduYXR1cmVDb250ZXh0ID0gbnVsbDsKICAgICAgICAgICAgZm9yIChjb25zdCBbcGFyYW1zLCBldmFsdWF0ZV0gb2Ygb3ZlcmxvYWRzKSB7CiAgICAgICAgICAgICAgICBzaWduYXR1cmVDb250ZXh0ID0gbmV3IFBhcnNpbmdDb250ZXh0JDEoY29udGV4dC5yZWdpc3RyeSwgY29udGV4dC5wYXRoLCBudWxsLCBjb250ZXh0LnNjb3BlKTsKICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBhcmdQYXJzZUZhaWxlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBBcnJheS5pc0FycmF5KHBhcmFtcykgPyBwYXJhbXNbaSAtIDFdIDogcGFyYW1zLnR5cGU7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gc2lnbmF0dXJlQ29udGV4dC5wYXJzZShhcmcsIDEgKyBwYXJzZWRBcmdzLmxlbmd0aCwgZXhwZWN0ZWRUeXBlKTsKICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkgewogICAgICAgICAgICAgICAgICAgICAgICBhcmdQYXJzZUZhaWxlZCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChhcmdQYXJzZUZhaWxlZCkgewogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zKSkgewogICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSBwYXJzZWRBcmdzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVDb250ZXh0LmVycm9yKGBFeHBlY3RlZCAkeyBwYXJhbXMubGVuZ3RoIH0gYXJndW1lbnRzLCBidXQgZm91bmQgJHsgcGFyc2VkQXJncy5sZW5ndGggfSBpbnN0ZWFkLmApOwogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZEFyZ3MubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtc1tpXSA6IHBhcmFtcy50eXBlOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHBhcnNlZEFyZ3NbaV07CiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5jb25jYXQoaSArIDEpLmNoZWNrU3VidHlwZShleHBlY3RlZCwgYXJnLnR5cGUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuZXJyb3JzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRFeHByZXNzaW9uKG9wLCB0eXBlLCBldmFsdWF0ZSwgcGFyc2VkQXJncyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKG92ZXJsb2Fkcy5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goLi4uc2lnbmF0dXJlQ29udGV4dC5lcnJvcnMpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBvdmVybG9hZHMubGVuZ3RoID8gb3ZlcmxvYWRzIDogYXZhaWxhYmxlT3ZlcmxvYWRzOwogICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IGV4cGVjdGVkLm1hcCgoW3BhcmFtc10pID0+IHN0cmluZ2lmeVNpZ25hdHVyZShwYXJhbXMpKS5qb2luKCcgfCAnKTsKICAgICAgICAgICAgICAgIGNvbnN0IGFjdHVhbFR5cGVzID0gW107CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIDEgKyBhY3R1YWxUeXBlcy5sZW5ndGgpOwogICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICBhY3R1YWxUeXBlcy5wdXNoKHRvU3RyaW5nJDEocGFyc2VkLnR5cGUpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGFyZ3VtZW50cyBvZiB0eXBlICR7IHNpZ25hdHVyZXMgfSwgYnV0IGZvdW5kICgkeyBhY3R1YWxUeXBlcy5qb2luKCcsICcpIH0pIGluc3RlYWQuYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyByZWdpc3RlcihyZWdpc3RyeSwgZGVmaW5pdGlvbnMpIHsKICAgICAgICAgICAgQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7CiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWZpbml0aW9ucykgewogICAgICAgICAgICAgICAgcmVnaXN0cnlbbmFtZV0gPSBDb21wb3VuZEV4cHJlc3Npb247CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBzdHJpbmdpZnlTaWduYXR1cmUoc2lnbmF0dXJlKSB7CiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSkgewogICAgICAgICAgICByZXR1cm4gYCgkeyBzaWduYXR1cmUubWFwKHRvU3RyaW5nJDEpLmpvaW4oJywgJykgfSlgOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBgKCR7IHRvU3RyaW5nJDEoc2lnbmF0dXJlLnR5cGUpIH0uLi4pYDsKICAgICAgICB9CiAgICB9CiAgICB2YXIgQ29tcG91bmRFeHByZXNzaW9uJDEgPSBDb21wb3VuZEV4cHJlc3Npb247CgogICAgY2xhc3MgQ29sbGF0b3JFeHByZXNzaW9uIHsKICAgICAgICBjb25zdHJ1Y3RvcihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkgewogICAgICAgICAgICB0aGlzLnR5cGUgPSBDb2xsYXRvclR5cGU7CiAgICAgICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlOwogICAgICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlOwogICAgICAgICAgICB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSA9IGRpYWNyaXRpY1NlbnNpdGl2ZTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIG9uZSBhcmd1bWVudC5gKTsKICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbMV07CiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBDb2xsYXRvciBvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LmApOwogICAgICAgICAgICBjb25zdCBjYXNlU2Vuc2l0aXZlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10sIDEsIEJvb2xlYW5UeXBlKTsKICAgICAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIGNvbnN0IGRpYWNyaXRpY1NlbnNpdGl2ZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snZGlhY3JpdGljLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpOwogICAgICAgICAgICBpZiAoIWRpYWNyaXRpY1NlbnNpdGl2ZSkKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICBsZXQgbG9jYWxlID0gbnVsbDsKICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2xvY2FsZSddKSB7CiAgICAgICAgICAgICAgICBsb2NhbGUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2xvY2FsZSddLCAxLCBTdHJpbmdUeXBlKTsKICAgICAgICAgICAgICAgIGlmICghbG9jYWxlKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGF0b3JFeHByZXNzaW9uKGNhc2VTZW5zaXRpdmUsIGRpYWNyaXRpY1NlbnNpdGl2ZSwgbG9jYWxlKTsKICAgICAgICB9CiAgICAgICAgZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGF0b3IodGhpcy5jYXNlU2Vuc2l0aXZlLmV2YWx1YXRlKGN0eCksIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlLmV2YWx1YXRlKGN0eCksIHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUoY3R4KSA6IG51bGwpOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgZm4odGhpcy5jYXNlU2Vuc2l0aXZlKTsKICAgICAgICAgICAgZm4odGhpcy5kaWFjcml0aWNTZW5zaXRpdmUpOwogICAgICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHsKICAgICAgICAgICAgICAgIGZuKHRoaXMubG9jYWxlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9OwogICAgICAgICAgICBvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddID0gdGhpcy5jYXNlU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpOwogICAgICAgICAgICBvcHRpb25zWydkaWFjcml0aWMtc2Vuc2l0aXZlJ10gPSB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5zZXJpYWxpemUoKTsKICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zWydsb2NhbGUnXSA9IHRoaXMubG9jYWxlLnNlcmlhbGl6ZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAnY29sbGF0b3InLAogICAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICBdOwogICAgICAgIH0KICAgIH0KCiAgICBjb25zdCBFWFRFTlQgPSA4MTkyOwogICAgZnVuY3Rpb24gdXBkYXRlQkJveChiYm94LCBjb29yZCkgewogICAgICAgIGJib3hbMF0gPSBNYXRoLm1pbihiYm94WzBdLCBjb29yZFswXSk7CiAgICAgICAgYmJveFsxXSA9IE1hdGgubWluKGJib3hbMV0sIGNvb3JkWzFdKTsKICAgICAgICBiYm94WzJdID0gTWF0aC5tYXgoYmJveFsyXSwgY29vcmRbMF0pOwogICAgICAgIGJib3hbM10gPSBNYXRoLm1heChiYm94WzNdLCBjb29yZFsxXSk7CiAgICB9CiAgICBmdW5jdGlvbiBtZXJjYXRvclhmcm9tTG5nKGxuZykgewogICAgICAgIHJldHVybiAoMTgwICsgbG5nKSAvIDM2MDsKICAgIH0KICAgIGZ1bmN0aW9uIG1lcmNhdG9yWWZyb21MYXQobGF0KSB7CiAgICAgICAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwOwogICAgfQogICAgZnVuY3Rpb24gYm94V2l0aGluQm94KGJib3gxLCBiYm94MikgewogICAgICAgIGlmIChiYm94MVswXSA8PSBiYm94MlswXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmIChiYm94MVsyXSA+PSBiYm94MlsyXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmIChiYm94MVsxXSA8PSBiYm94MlsxXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmIChiYm94MVszXSA+PSBiYm94MlszXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgZnVuY3Rpb24gZ2V0VGlsZUNvb3JkaW5hdGVzKHAsIGNhbm9uaWNhbCkgewogICAgICAgIGNvbnN0IHggPSBtZXJjYXRvclhmcm9tTG5nKHBbMF0pOwogICAgICAgIGNvbnN0IHkgPSBtZXJjYXRvcllmcm9tTGF0KHBbMV0pOwogICAgICAgIGNvbnN0IHRpbGVzQXRab29tID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopOwogICAgICAgIHJldHVybiBbCiAgICAgICAgICAgIE1hdGgucm91bmQoeCAqIHRpbGVzQXRab29tICogRVhURU5UKSwKICAgICAgICAgICAgTWF0aC5yb3VuZCh5ICogdGlsZXNBdFpvb20gKiBFWFRFTlQpCiAgICAgICAgXTsKICAgIH0KICAgIGZ1bmN0aW9uIG9uQm91bmRhcnkocCwgcDEsIHAyKSB7CiAgICAgICAgY29uc3QgeDEgPSBwWzBdIC0gcDFbMF07CiAgICAgICAgY29uc3QgeTEgPSBwWzFdIC0gcDFbMV07CiAgICAgICAgY29uc3QgeDIgPSBwWzBdIC0gcDJbMF07CiAgICAgICAgY29uc3QgeTIgPSBwWzFdIC0gcDJbMV07CiAgICAgICAgcmV0dXJuIHgxICogeTIgLSB4MiAqIHkxID09PSAwICYmIHgxICogeDIgPD0gMCAmJiB5MSAqIHkyIDw9IDA7CiAgICB9CiAgICBmdW5jdGlvbiByYXlJbnRlcnNlY3QocCwgcDEsIHAyKSB7CiAgICAgICAgcmV0dXJuIHAxWzFdID4gcFsxXSAhPT0gcDJbMV0gPiBwWzFdICYmIHBbMF0gPCAocDJbMF0gLSBwMVswXSkgKiAocFsxXSAtIHAxWzFdKSAvIChwMlsxXSAtIHAxWzFdKSArIHAxWzBdOwogICAgfQogICAgZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCByaW5ncykgewogICAgICAgIGxldCBpbnNpZGUgPSBmYWxzZTsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgcmluZyA9IHJpbmdzW2ldOwogICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuMiA9IHJpbmcubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykgewogICAgICAgICAgICAgICAgaWYgKG9uQm91bmRhcnkocG9pbnQsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICBpZiAocmF5SW50ZXJzZWN0KHBvaW50LCByaW5nW2pdLCByaW5nW2ogKyAxXSkpCiAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gaW5zaWRlOwogICAgfQogICAgZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29ucyhwb2ludCwgcG9seWdvbnMpIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHBvbHlnb25zW2ldKSkKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBmdW5jdGlvbiBwZXJwKHYxLCB2MikgewogICAgICAgIHJldHVybiB2MVswXSAqIHYyWzFdIC0gdjFbMV0gKiB2MlswXTsKICAgIH0KICAgIGZ1bmN0aW9uIHR3b1NpZGVkKHAxLCBwMiwgcTEsIHEyKSB7CiAgICAgICAgY29uc3QgeDEgPSBwMVswXSAtIHExWzBdOwogICAgICAgIGNvbnN0IHkxID0gcDFbMV0gLSBxMVsxXTsKICAgICAgICBjb25zdCB4MiA9IHAyWzBdIC0gcTFbMF07CiAgICAgICAgY29uc3QgeTIgPSBwMlsxXSAtIHExWzFdOwogICAgICAgIGNvbnN0IHgzID0gcTJbMF0gLSBxMVswXTsKICAgICAgICBjb25zdCB5MyA9IHEyWzFdIC0gcTFbMV07CiAgICAgICAgY29uc3QgZGV0MSA9IHgxICogeTMgLSB4MyAqIHkxOwogICAgICAgIGNvbnN0IGRldDIgPSB4MiAqIHkzIC0geDMgKiB5MjsKICAgICAgICBpZiAoZGV0MSA+IDAgJiYgZGV0MiA8IDAgfHwgZGV0MSA8IDAgJiYgZGV0MiA+IDApCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RMaW5lKGEsIGIsIGMsIGQpIHsKICAgICAgICBjb25zdCB2ZWN0b3JQID0gWwogICAgICAgICAgICBiWzBdIC0gYVswXSwKICAgICAgICAgICAgYlsxXSAtIGFbMV0KICAgICAgICBdOwogICAgICAgIGNvbnN0IHZlY3RvclEgPSBbCiAgICAgICAgICAgIGRbMF0gLSBjWzBdLAogICAgICAgICAgICBkWzFdIC0gY1sxXQogICAgICAgIF07CiAgICAgICAgaWYgKHBlcnAodmVjdG9yUSwgdmVjdG9yUCkgPT09IDApCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICBpZiAodHdvU2lkZWQoYSwgYiwgYywgZCkgJiYgdHdvU2lkZWQoYywgZCwgYSwgYikpCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RQb2x5Z29uKHAxLCBwMiwgcG9seWdvbikgewogICAgICAgIGZvciAoY29uc3QgcmluZyBvZiBwb2x5Z29uKSB7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmluZy5sZW5ndGggLSAxOyArK2opIHsKICAgICAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0TGluZShwMSwgcDIsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIGZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb24pIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24obGluZVtpXSwgcG9seWdvbikpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgKytpKSB7CiAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0UG9seWdvbihsaW5lW2ldLCBsaW5lW2kgKyAxXSwgcG9seWdvbikpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIGZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29ucyhsaW5lLCBwb2x5Z29ucykgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb25zW2ldKSkKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBmdW5jdGlvbiBnZXRUaWxlUG9seWdvbihjb29yZGluYXRlcywgYmJveCwgY2Fub25pY2FsKSB7CiAgICAgICAgY29uc3QgcG9seWdvbiA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgcmluZyA9IFtdOwogICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvb3JkaW5hdGVzW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgICBjb25zdCBjb29yZCA9IGdldFRpbGVDb29yZGluYXRlcyhjb29yZGluYXRlc1tpXVtqXSwgY2Fub25pY2FsKTsKICAgICAgICAgICAgICAgIHVwZGF0ZUJCb3goYmJveCwgY29vcmQpOwogICAgICAgICAgICAgICAgcmluZy5wdXNoKGNvb3JkKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBwb2x5Z29uLnB1c2gocmluZyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwb2x5Z29uOwogICAgfQogICAgZnVuY3Rpb24gZ2V0VGlsZVBvbHlnb25zKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHsKICAgICAgICBjb25zdCBwb2x5Z29ucyA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgcG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBiYm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcG9seWdvbnM7CiAgICB9CiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludChwLCBiYm94LCBwb2x5QkJveCwgd29ybGRTaXplKSB7CiAgICAgICAgaWYgKHBbMF0gPCBwb2x5QkJveFswXSB8fCBwWzBdID4gcG9seUJCb3hbMl0pIHsKICAgICAgICAgICAgY29uc3QgaGFsZldvcmxkU2l6ZSA9IHdvcmxkU2l6ZSAqIDAuNTsKICAgICAgICAgICAgbGV0IHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzBdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFswXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDsKICAgICAgICAgICAgaWYgKHNoaWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICBzaGlmdCA9IHBbMF0gLSBwb2x5QkJveFsyXSA+IGhhbGZXb3JsZFNpemUgPyAtd29ybGRTaXplIDogcG9seUJCb3hbMl0gLSBwWzBdID4gaGFsZldvcmxkU2l6ZSA/IHdvcmxkU2l6ZSA6IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcFswXSArPSBzaGlmdDsKICAgICAgICB9CiAgICAgICAgdXBkYXRlQkJveChiYm94LCBwKTsKICAgIH0KICAgIGZ1bmN0aW9uIHJlc2V0QkJveChiYm94KSB7CiAgICAgICAgYmJveFswXSA9IGJib3hbMV0gPSBJbmZpbml0eTsKICAgICAgICBiYm94WzJdID0gYmJveFszXSA9IC1JbmZpbml0eTsKICAgIH0KICAgIGZ1bmN0aW9uIGdldFRpbGVQb2ludHMoZ2VvbWV0cnksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCkgewogICAgICAgIGNvbnN0IHdvcmxkU2l6ZSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KSAqIEVYVEVOVDsKICAgICAgICBjb25zdCBzaGlmdHMgPSBbCiAgICAgICAgICAgIGNhbm9uaWNhbC54ICogRVhURU5ULAogICAgICAgICAgICBjYW5vbmljYWwueSAqIEVYVEVOVAogICAgICAgIF07CiAgICAgICAgY29uc3QgdGlsZVBvaW50cyA9IFtdOwogICAgICAgIGlmICghZ2VvbWV0cnkpCiAgICAgICAgICAgIHJldHVybiB0aWxlUG9pbnRzOwogICAgICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIGdlb21ldHJ5KSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7CiAgICAgICAgICAgICAgICBjb25zdCBwID0gWwogICAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBzaGlmdHNbMF0sCiAgICAgICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXQogICAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICAgIHVwZGF0ZVBvaW50KHAsIHBvaW50QkJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSk7CiAgICAgICAgICAgICAgICB0aWxlUG9pbnRzLnB1c2gocCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRpbGVQb2ludHM7CiAgICB9CiAgICBmdW5jdGlvbiBnZXRUaWxlTGluZXMoZ2VvbWV0cnksIGxpbmVCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKSB7CiAgICAgICAgY29uc3Qgd29ybGRTaXplID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopICogRVhURU5UOwogICAgICAgIGNvbnN0IHNoaWZ0cyA9IFsKICAgICAgICAgICAgY2Fub25pY2FsLnggKiBFWFRFTlQsCiAgICAgICAgICAgIGNhbm9uaWNhbC55ICogRVhURU5UCiAgICAgICAgXTsKICAgICAgICBjb25zdCB0aWxlTGluZXMgPSBbXTsKICAgICAgICBpZiAoIWdlb21ldHJ5KQogICAgICAgICAgICByZXR1cm4gdGlsZUxpbmVzOwogICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBnZW9tZXRyeSkgewogICAgICAgICAgICBjb25zdCB0aWxlTGluZSA9IFtdOwogICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGxpbmUpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBbCiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCArIHNoaWZ0c1swXSwKICAgICAgICAgICAgICAgICAgICBwb2ludC55ICsgc2hpZnRzWzFdCiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgICAgdXBkYXRlQkJveChsaW5lQkJveCwgcCk7CiAgICAgICAgICAgICAgICB0aWxlTGluZS5wdXNoKHApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRpbGVMaW5lcy5wdXNoKHRpbGVMaW5lKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxpbmVCQm94WzJdIC0gbGluZUJCb3hbMF0gPD0gd29ybGRTaXplIC8gMikgewogICAgICAgICAgICByZXNldEJCb3gobGluZUJCb3gpOwogICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGlsZUxpbmVzKSB7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgbGluZSkgewogICAgICAgICAgICAgICAgICAgIHVwZGF0ZVBvaW50KHAsIGxpbmVCQm94LCBwb2x5QkJveCwgd29ybGRTaXplKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGlsZUxpbmVzOwogICAgfQogICAgZnVuY3Rpb24gcG9pbnRzV2l0aGluUG9seWdvbnMoY3R4LCBwb2x5Z29uR2VvbWV0cnkpIHsKICAgICAgICBjb25zdCBwb2ludEJCb3ggPSBbCiAgICAgICAgICAgIEluZmluaXR5LAogICAgICAgICAgICBJbmZpbml0eSwKICAgICAgICAgICAgLUluZmluaXR5LAogICAgICAgICAgICAtSW5maW5pdHkKICAgICAgICBdOwogICAgICAgIGNvbnN0IHBvbHlCQm94ID0gWwogICAgICAgICAgICBJbmZpbml0eSwKICAgICAgICAgICAgSW5maW5pdHksCiAgICAgICAgICAgIC1JbmZpbml0eSwKICAgICAgICAgICAgLUluZmluaXR5CiAgICAgICAgXTsKICAgICAgICBjb25zdCBjYW5vbmljYWwgPSBjdHguY2Fub25pY2FsSUQoKTsKICAgICAgICBpZiAoIWNhbm9uaWNhbCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7CiAgICAgICAgICAgIGNvbnN0IHRpbGVQb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24ocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTsKICAgICAgICAgICAgY29uc3QgdGlsZVBvaW50cyA9IGdldFRpbGVQb2ludHMoY3R4Lmdlb21ldHJ5KCksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7CiAgICAgICAgICAgIGlmICghYm94V2l0aGluQm94KHBvaW50QkJveCwgcG9seUJCb3gpKQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRpbGVQb2ludHMpIHsKICAgICAgICAgICAgICAgIGlmICghcG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCB0aWxlUG9seWdvbikpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHsKICAgICAgICAgICAgY29uc3QgdGlsZVBvbHlnb25zID0gZ2V0VGlsZVBvbHlnb25zKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7CiAgICAgICAgICAgIGNvbnN0IHRpbGVQb2ludHMgPSBnZXRUaWxlUG9pbnRzKGN0eC5nZW9tZXRyeSgpLCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICBpZiAoIWJveFdpdGhpbkJveChwb2ludEJCb3gsIHBvbHlCQm94KSkKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0aWxlUG9pbnRzKSB7CiAgICAgICAgICAgICAgICBpZiAoIXBvaW50V2l0aGluUG9seWdvbnMocG9pbnQsIHRpbGVQb2x5Z29ucykpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgZnVuY3Rpb24gbGluZXNXaXRoaW5Qb2x5Z29ucyhjdHgsIHBvbHlnb25HZW9tZXRyeSkgewogICAgICAgIGNvbnN0IGxpbmVCQm94ID0gWwogICAgICAgICAgICBJbmZpbml0eSwKICAgICAgICAgICAgSW5maW5pdHksCiAgICAgICAgICAgIC1JbmZpbml0eSwKICAgICAgICAgICAgLUluZmluaXR5CiAgICAgICAgXTsKICAgICAgICBjb25zdCBwb2x5QkJveCA9IFsKICAgICAgICAgICAgSW5maW5pdHksCiAgICAgICAgICAgIEluZmluaXR5LAogICAgICAgICAgICAtSW5maW5pdHksCiAgICAgICAgICAgIC1JbmZpbml0eQogICAgICAgIF07CiAgICAgICAgY29uc3QgY2Fub25pY2FsID0gY3R4LmNhbm9uaWNhbElEKCk7CiAgICAgICAgaWYgKCFjYW5vbmljYWwpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykgewogICAgICAgICAgICBjb25zdCB0aWxlUG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7CiAgICAgICAgICAgIGNvbnN0IHRpbGVMaW5lcyA9IGdldFRpbGVMaW5lcyhjdHguZ2VvbWV0cnkoKSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICBpZiAoIWJveFdpdGhpbkJveChsaW5lQkJveCwgcG9seUJCb3gpKQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGlsZUxpbmVzKSB7CiAgICAgICAgICAgICAgICBpZiAoIWxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHRpbGVQb2x5Z29uKSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykgewogICAgICAgICAgICBjb25zdCB0aWxlUG9seWdvbnMgPSBnZXRUaWxlUG9seWdvbnMocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTsKICAgICAgICAgICAgY29uc3QgdGlsZUxpbmVzID0gZ2V0VGlsZUxpbmVzKGN0eC5nZW9tZXRyeSgpLCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7CiAgICAgICAgICAgIGlmICghYm94V2l0aGluQm94KGxpbmVCQm94LCBwb2x5QkJveCkpCiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aWxlTGluZXMpIHsKICAgICAgICAgICAgICAgIGlmICghbGluZVN0cmluZ1dpdGhpblBvbHlnb25zKGxpbmUsIHRpbGVQb2x5Z29ucykpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgY2xhc3MgV2l0aGluIHsKICAgICAgICBjb25zdHJ1Y3RvcihnZW9qc29uLCBnZW9tZXRyaWVzKSB7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlOwogICAgICAgICAgICB0aGlzLmdlb2pzb24gPSBnZW9qc29uOwogICAgICAgICAgICB0aGlzLmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpCiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgJ3dpdGhpbicgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICR7IGFyZ3MubGVuZ3RoIC0gMSB9IGluc3RlYWQuYCk7CiAgICAgICAgICAgIGlmIChpc1ZhbHVlKGFyZ3NbMV0pKSB7CiAgICAgICAgICAgICAgICBjb25zdCBnZW9qc29uID0gYXJnc1sxXTsKICAgICAgICAgICAgICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb2pzb24uZmVhdHVyZXNbaV0uZ2VvbWV0cnkudHlwZTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXaXRoaW4oZ2VvanNvbiwgZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb2pzb24uZ2VvbWV0cnkudHlwZTsKICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24uZ2VvbWV0cnkpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvanNvbi50eXBlID09PSAnTXVsdGlQb2x5Z29uJykgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGAnd2l0aGluJyBleHByZXNzaW9uIHJlcXVpcmVzIHZhbGlkIGdlb2pzb24gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9seWdvbiBnZW9tZXRyeSB0eXBlLmApOwogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgaWYgKGN0eC5nZW9tZXRyeSgpICE9IG51bGwgJiYgY3R4LmNhbm9uaWNhbElEKCkgIT0gbnVsbCkgewogICAgICAgICAgICAgICAgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ1BvaW50JykgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ0xpbmVTdHJpbmcnKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzV2l0aGluUG9seWdvbnMoY3R4LCB0aGlzLmdlb21ldHJpZXMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgZWFjaENoaWxkKCkgewogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplKCkgewogICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgJ3dpdGhpbicsCiAgICAgICAgICAgICAgICB0aGlzLmdlb2pzb24KICAgICAgICAgICAgXTsKICAgICAgICB9CiAgICB9CiAgICB2YXIgV2l0aGluJDEgPSBXaXRoaW47CgogICAgZnVuY3Rpb24gaXNGZWF0dXJlQ29uc3RhbnQoZSkgewogICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uJDEpIHsKICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ2dldCcgJiYgZS5hcmdzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ2ZlYXR1cmUtc3RhdGUnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnaGFzJyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAncHJvcGVydGllcycgfHwgZS5uYW1lID09PSAnZ2VvbWV0cnktdHlwZScgfHwgZS5uYW1lID09PSAnaWQnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15maWx0ZXItLy50ZXN0KGUubmFtZSkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFdpdGhpbiQxKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgbGV0IHJlc3VsdCA9IHRydWU7CiAgICAgICAgZS5lYWNoQ2hpbGQoYXJnID0+IHsKICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNGZWF0dXJlQ29uc3RhbnQoYXJnKSkgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgZnVuY3Rpb24gaXNTdGF0ZUNvbnN0YW50KGUpIHsKICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiQxKSB7CiAgICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdmZWF0dXJlLXN0YXRlJykgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGxldCByZXN1bHQgPSB0cnVlOwogICAgICAgIGUuZWFjaENoaWxkKGFyZyA9PiB7CiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgIWlzU3RhdGVDb25zdGFudChhcmcpKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICBmdW5jdGlvbiBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZSwgcHJvcGVydGllcykgewogICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uJDEgJiYgcHJvcGVydGllcy5pbmRleE9mKGUubmFtZSkgPj0gMCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGxldCByZXN1bHQgPSB0cnVlOwogICAgICAgIGUuZWFjaENoaWxkKGFyZyA9PiB7CiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgIWlzR2xvYmFsUHJvcGVydHlDb25zdGFudChhcmcsIHByb3BlcnRpZXMpKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogICAgY2xhc3MgVmFyIHsKICAgICAgICBjb25zdHJ1Y3RvcihuYW1lLCBib3VuZEV4cHJlc3Npb24pIHsKICAgICAgICAgICAgdGhpcy50eXBlID0gYm91bmRFeHByZXNzaW9uLnR5cGU7CiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgICAgICAgIHRoaXMuYm91bmRFeHByZXNzaW9uID0gYm91bmRFeHByZXNzaW9uOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIgfHwgdHlwZW9mIGFyZ3NbMV0gIT09ICdzdHJpbmcnKQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYCd2YXInIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuYCk7CiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhcmdzWzFdOwogICAgICAgICAgICBpZiAoIWNvbnRleHQuc2NvcGUuaGFzKG5hbWUpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgVW5rbm93biB2YXJpYWJsZSAiJHsgbmFtZSB9Ii4gTWFrZSBzdXJlICIkeyBuYW1lIH0iIGhhcyBiZWVuIGJvdW5kIGluIGFuIGVuY2xvc2luZyAibGV0IiBleHByZXNzaW9uIGJlZm9yZSB1c2luZyBpdC5gLCAxKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IFZhcihuYW1lLCBjb250ZXh0LnNjb3BlLmdldChuYW1lKSk7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZEV4cHJlc3Npb24uZXZhbHVhdGUoY3R4KTsKICAgICAgICB9CiAgICAgICAgZWFjaENoaWxkKCkgewogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICd2YXInLAogICAgICAgICAgICAgICAgdGhpcy5uYW1lCiAgICAgICAgICAgIF07CiAgICAgICAgfQogICAgfQogICAgdmFyIFZhciQxID0gVmFyOwoKICAgIGNsYXNzIFBhcnNpbmdDb250ZXh0IHsKICAgICAgICBjb25zdHJ1Y3RvcihyZWdpc3RyeSwgcGF0aCA9IFtdLCBleHBlY3RlZFR5cGUsIHNjb3BlID0gbmV3IFNjb3BlJDEoKSwgZXJyb3JzID0gW10pIHsKICAgICAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHJlZ2lzdHJ5OwogICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoOwogICAgICAgICAgICB0aGlzLmtleSA9IHBhdGgubWFwKHBhcnQgPT4gYFskeyBwYXJ0IH1dYCkuam9pbignJyk7CiAgICAgICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTsKICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7CiAgICAgICAgICAgIHRoaXMuZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlOwogICAgICAgIH0KICAgICAgICBwYXJzZShleHByLCBpbmRleCwgZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncywgb3B0aW9ucyA9IHt9KSB7CiAgICAgICAgICAgIGlmIChpbmRleCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzKS5fcGFyc2UoZXhwciwgb3B0aW9ucyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlKGV4cHIsIG9wdGlvbnMpOwogICAgICAgIH0KICAgICAgICBfcGFyc2UoZXhwciwgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoZXhwciA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGV4cHIgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgZXhwciA9PT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICAgIGV4cHIgPSBbCiAgICAgICAgICAgICAgICAgICAgJ2xpdGVyYWwnLAogICAgICAgICAgICAgICAgICAgIGV4cHIKICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYW5ub3RhdGUocGFyc2VkLCB0eXBlLCB0eXBlQW5ub3RhdGlvbikgewogICAgICAgICAgICAgICAgaWYgKHR5cGVBbm5vdGF0aW9uID09PSAnYXNzZXJ0JykgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uJDEodHlwZSwgW3BhcnNlZF0pOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2NvZXJjZScpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvZXJjaW9uJDEodHlwZSwgW3BhcnNlZF0pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4cHIpKSB7CiAgICAgICAgICAgICAgICBpZiAoZXhwci5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbImxpdGVyYWwiLCBbXV0uYCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBvcCA9IGV4cHJbMF07CiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJykgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoYEV4cHJlc3Npb24gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZm91bmQgJHsgdHlwZW9mIG9wIH0gaW5zdGVhZC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbImxpdGVyYWwiLCBbLi4uXV0uYCwgMCk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBFeHByID0gdGhpcy5yZWdpc3RyeVtvcF07CiAgICAgICAgICAgICAgICBpZiAoRXhwcikgewogICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBFeHByLnBhcnNlKGV4cHIsIHRoaXMpOwogICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5leHBlY3RlZFR5cGUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSB0aGlzLmV4cGVjdGVkVHlwZTsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0dWFsID0gcGFyc2VkLnR5cGU7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZXhwZWN0ZWQua2luZCA9PT0gJ3N0cmluZycgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ251bWJlcicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2Jvb2xlYW4nIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdvYmplY3QnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScpICYmIGFjdHVhbC5raW5kID09PSAndmFsdWUnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdhc3NlcnQnKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoZXhwZWN0ZWQua2luZCA9PT0gJ2NvbG9yJyB8fCBleHBlY3RlZC5raW5kID09PSAnZm9ybWF0dGVkJyB8fCBleHBlY3RlZC5raW5kID09PSAncmVzb2x2ZWRJbWFnZScpICYmIChhY3R1YWwua2luZCA9PT0gJ3ZhbHVlJyB8fCBhY3R1YWwua2luZCA9PT0gJ3N0cmluZycpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdjb2VyY2UnKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrU3VidHlwZShleHBlY3RlZCwgYWN0dWFsKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyc2VkIGluc3RhbmNlb2YgTGl0ZXJhbCQxKSAmJiBwYXJzZWQudHlwZS5raW5kICE9PSAncmVzb2x2ZWRJbWFnZScgJiYgaXNDb25zdGFudChwYXJzZWQpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjID0gbmV3IEV2YWx1YXRpb25Db250ZXh0JDEoKTsKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IG5ldyBMaXRlcmFsJDEocGFyc2VkLnR5cGUsIHBhcnNlZC5ldmFsdWF0ZShlYykpOwogICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGUubWVzc2FnZSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYFVua25vd24gZXhwcmVzc2lvbiAiJHsgb3AgfSIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgWyJsaXRlcmFsIiwgWy4uLl1dLmAsIDApOwogICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYCd1bmRlZmluZWQnIHZhbHVlIGludmFsaWQuIFVzZSBudWxsIGluc3RlYWQuYCk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihgQmFyZSBvYmplY3RzIGludmFsaWQuIFVzZSBbImxpdGVyYWwiLCB7Li4ufV0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSwgYnV0IGZvdW5kICR7IHR5cGVvZiBleHByIH0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpIHsKICAgICAgICAgICAgY29uc3QgcGF0aCA9IHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyB0aGlzLnBhdGguY29uY2F0KGluZGV4KSA6IHRoaXMucGF0aDsKICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSBiaW5kaW5ncyA/IHRoaXMuc2NvcGUuY29uY2F0KGJpbmRpbmdzKSA6IHRoaXMuc2NvcGU7CiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2luZ0NvbnRleHQodGhpcy5yZWdpc3RyeSwgcGF0aCwgZXhwZWN0ZWRUeXBlIHx8IG51bGwsIHNjb3BlLCB0aGlzLmVycm9ycyk7CiAgICAgICAgfQogICAgICAgIGVycm9yKGVycm9yLCAuLi5rZXlzKSB7CiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAkeyB0aGlzLmtleSB9JHsga2V5cy5tYXAoayA9PiBgWyR7IGsgfV1gKS5qb2luKCcnKSB9YDsKICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2luZ0Vycm9yJDIoa2V5LCBlcnJvcikpOwogICAgICAgIH0KICAgICAgICBjaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpIHsKICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpOwogICAgICAgICAgICBpZiAoZXJyb3IpCiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTsKICAgICAgICAgICAgcmV0dXJuIGVycm9yOwogICAgICAgIH0KICAgIH0KICAgIHZhciBQYXJzaW5nQ29udGV4dCQxID0gUGFyc2luZ0NvbnRleHQ7CiAgICBmdW5jdGlvbiBpc0NvbnN0YW50KGV4cHJlc3Npb24pIHsKICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFZhciQxKSB7CiAgICAgICAgICAgIHJldHVybiBpc0NvbnN0YW50KGV4cHJlc3Npb24uYm91bmRFeHByZXNzaW9uKTsKICAgICAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24kMSAmJiBleHByZXNzaW9uLm5hbWUgPT09ICdlcnJvcicpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvbGxhdG9yRXhwcmVzc2lvbikgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgV2l0aGluJDEpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBjb25zdCBpc1R5cGVBbm5vdGF0aW9uID0gZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvZXJjaW9uJDEgfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFzc2VydGlvbiQxOwogICAgICAgIGxldCBjaGlsZHJlbkNvbnN0YW50ID0gdHJ1ZTsKICAgICAgICBleHByZXNzaW9uLmVhY2hDaGlsZChjaGlsZCA9PiB7CiAgICAgICAgICAgIGlmIChpc1R5cGVBbm5vdGF0aW9uKSB7CiAgICAgICAgICAgICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBpc0NvbnN0YW50KGNoaWxkKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNoaWxkcmVuQ29uc3RhbnQgPSBjaGlsZHJlbkNvbnN0YW50ICYmIGNoaWxkIGluc3RhbmNlb2YgTGl0ZXJhbCQxOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgaWYgKCFjaGlsZHJlbkNvbnN0YW50KSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGlzRmVhdHVyZUNvbnN0YW50KGV4cHJlc3Npb24pICYmIGlzR2xvYmFsUHJvcGVydHlDb25zdGFudChleHByZXNzaW9uLCBbCiAgICAgICAgICAgICd6b29tJywKICAgICAgICAgICAgJ2hlYXRtYXAtZGVuc2l0eScsCiAgICAgICAgICAgICdsaW5lLXByb2dyZXNzJywKICAgICAgICAgICAgJ3NreS1yYWRpYWwtcHJvZ3Jlc3MnLAogICAgICAgICAgICAnYWNjdW11bGF0ZWQnLAogICAgICAgICAgICAnaXMtc3VwcG9ydGVkLXNjcmlwdCcsCiAgICAgICAgICAgICdwaXRjaCcsCiAgICAgICAgICAgICdkaXN0YW5jZS1mcm9tLWNlbnRlcicKICAgICAgICBdKTsKICAgIH0KCiAgICBmdW5jdGlvbiBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHN0b3BzLCBpbnB1dCkgewogICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHN0b3BzLmxlbmd0aCAtIDE7CiAgICAgICAgbGV0IGxvd2VySW5kZXggPSAwOwogICAgICAgIGxldCB1cHBlckluZGV4ID0gbGFzdEluZGV4OwogICAgICAgIGxldCBjdXJyZW50SW5kZXggPSAwOwogICAgICAgIGxldCBjdXJyZW50VmFsdWUsIG5leHRWYWx1ZTsKICAgICAgICB3aGlsZSAobG93ZXJJbmRleCA8PSB1cHBlckluZGV4KSB7CiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IE1hdGguZmxvb3IoKGxvd2VySW5kZXggKyB1cHBlckluZGV4KSAvIDIpOwogICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXhdOwogICAgICAgICAgICBuZXh0VmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXggKyAxXTsKICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8PSBpbnB1dCkgewogICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gbGFzdEluZGV4IHx8IGlucHV0IDwgbmV4dFZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjdXJyZW50SW5kZXggKyAxOwogICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSA+IGlucHV0KSB7CiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gY3VycmVudEluZGV4IC0gMTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IkMSgnSW5wdXQgaXMgbm90IGEgbnVtYmVyLicpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAwOwogICAgfQoKICAgIGNsYXNzIFN0ZXAgewogICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIGlucHV0LCBzdG9wcykgewogICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgICAgIHRoaXMubGFiZWxzID0gW107CiAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtdOwogICAgICAgICAgICBmb3IgKGNvbnN0IFtsYWJlbCwgZXhwcmVzc2lvbl0gb2Ygc3RvcHMpIHsKICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLnB1c2gobGFiZWwpOwogICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHsgYXJncy5sZW5ndGggLSAxIH0uYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKChhcmdzLmxlbmd0aCAtIDEpICUgMiAhPT0gMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7CiAgICAgICAgICAgIGlmICghaW5wdXQpCiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgY29uc3Qgc3RvcHMgPSBbXTsKICAgICAgICAgICAgbGV0IG91dHB1dFR5cGUgPSBudWxsOwogICAgICAgICAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikgewogICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBpID09PSAxID8gLUluZmluaXR5IDogYXJnc1tpXTsKICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1tpICsgMV07CiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbEtleSA9IGk7CiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUtleSA9IGkgKyAxOwogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciAic3RlcCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgbGFiZWxLZXkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+PSBsYWJlbCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yICJzdGVwIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBsYWJlbEtleSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7CiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlOwogICAgICAgICAgICAgICAgc3RvcHMucHVzaChbCiAgICAgICAgICAgICAgICAgICAgbGFiZWwsCiAgICAgICAgICAgICAgICAgICAgcGFyc2VkCiAgICAgICAgICAgICAgICBdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IFN0ZXAob3V0cHV0VHlwZSwgaW5wdXQsIHN0b3BzKTsKICAgICAgICB9CiAgICAgICAgZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMubGFiZWxzOwogICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gdGhpcy5vdXRwdXRzOwogICAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgaWYgKHZhbHVlIDw9IGxhYmVsc1swXSkgewogICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBzdG9wQ291bnQgPSBsYWJlbHMubGVuZ3RoOwogICAgICAgICAgICBpZiAodmFsdWUgPj0gbGFiZWxzW3N0b3BDb3VudCAtIDFdKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0c1tzdG9wQ291bnQgLSAxXS5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhsYWJlbHMsIHZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgfQogICAgICAgIGVhY2hDaGlsZChmbikgewogICAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMub3V0cHV0cykgewogICAgICAgICAgICAgICAgZm4oZXhwcmVzc2lvbik7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShvdXQgPT4gb3V0Lm91dHB1dERlZmluZWQoKSk7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFsKICAgICAgICAgICAgICAgICdzdGVwJywKICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKCkKICAgICAgICAgICAgXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMubGFiZWxzW2ldKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbaV0uc2VyaWFsaXplKCkpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICAgIH0KICAgIH0KICAgIHZhciBTdGVwJDEgPSBTdGVwOwoKICAgIC8qCiAgICAgKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLgogICAgICoKICAgICAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dAogICAgICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zCiAgICAgKiBhcmUgbWV0OgogICAgICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQKICAgICAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci4KICAgICAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0CiAgICAgKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlCiAgICAgKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLgogICAgICoKICAgICAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgQVBQTEUgSU5DLiBgYEFTIElTJycgQU5EIEFOWQogICAgICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUKICAgICAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUgogICAgICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIEFQUExFIElOQy4gT1IKICAgICAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLAogICAgICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLAogICAgICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SCiAgICAgKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZCiAgICAgKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQKICAgICAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRQogICAgICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4KICAgICAqCiAgICAgKiBQb3J0ZWQgZnJvbSBXZWJraXQKICAgICAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmgKICAgICAqLwogICAgdmFyIHVuaXRiZXppZXIgPSBVbml0QmV6aWVyOwoKICAgIGZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7CiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS4KICAgICAgICB0aGlzLmN4ID0gMy4wICogcDF4OwogICAgICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7CiAgICAgICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4OwoKICAgICAgICB0aGlzLmN5ID0gMy4wICogcDF5OwogICAgICAgIHRoaXMuYnkgPSAzLjAgKiAocDJ5IC0gcDF5KSAtIHRoaXMuY3k7CiAgICAgICAgdGhpcy5heSA9IDEuMCAtIHRoaXMuY3kgLSB0aGlzLmJ5OwoKICAgICAgICB0aGlzLnAxeCA9IHAxeDsKICAgICAgICB0aGlzLnAxeSA9IHAyeTsKICAgICAgICB0aGlzLnAyeCA9IHAyeDsKICAgICAgICB0aGlzLnAyeSA9IHAyeTsKICAgIH0KCiAgICBVbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7CiAgICAgICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuCiAgICAgICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7CiAgICB9OwoKICAgIFVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uKHQpIHsKICAgICAgICByZXR1cm4gKCh0aGlzLmF5ICogdCArIHRoaXMuYnkpICogdCArIHRoaXMuY3kpICogdDsKICAgIH07CgogICAgVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCA9IGZ1bmN0aW9uKHQpIHsKICAgICAgICByZXR1cm4gKDMuMCAqIHRoaXMuYXggKiB0ICsgMi4wICogdGhpcy5ieCkgKiB0ICsgdGhpcy5jeDsKICAgIH07CgogICAgVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgZXBzaWxvbiA9IDFlLTY7CgogICAgICAgIHZhciB0MCwgdDEsIHQyLCB4MiwgaTsKCiAgICAgICAgLy8gRmlyc3QgdHJ5IGEgZmV3IGl0ZXJhdGlvbnMgb2YgTmV3dG9uJ3MgbWV0aG9kIC0tIG5vcm1hbGx5IHZlcnkgZmFzdC4KICAgICAgICBmb3IgKHQyID0geCwgaSA9IDA7IGkgPCA4OyBpKyspIHsKCiAgICAgICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpIC0geDsKICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IGVwc2lsb24pIHJldHVybiB0MjsKCiAgICAgICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7CiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkMikgPCAxZS02KSBicmVhazsKCiAgICAgICAgICAgIHQyID0gdDIgLSB4MiAvIGQyOwogICAgICAgIH0KCiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS4KICAgICAgICB0MCA9IDAuMDsKICAgICAgICB0MSA9IDEuMDsKICAgICAgICB0MiA9IHg7CgogICAgICAgIGlmICh0MiA8IHQwKSByZXR1cm4gdDA7CiAgICAgICAgaWYgKHQyID4gdDEpIHJldHVybiB0MTsKCiAgICAgICAgd2hpbGUgKHQwIDwgdDEpIHsKCiAgICAgICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpOwogICAgICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHJldHVybiB0MjsKCiAgICAgICAgICAgIGlmICh4ID4geDIpIHsKICAgICAgICAgICAgICAgIHQwID0gdDI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0MSA9IHQyOwogICAgICAgICAgICB9CgogICAgICAgICAgICB0MiA9ICh0MSAtIHQwKSAqIDAuNSArIHQwOwogICAgICAgIH0KCiAgICAgICAgLy8gRmFpbHVyZS4KICAgICAgICByZXR1cm4gdDI7CiAgICB9OwoKICAgIFVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikgewogICAgICAgIHJldHVybiB0aGlzLnNhbXBsZUN1cnZlWSh0aGlzLnNvbHZlQ3VydmVYKHgsIGVwc2lsb24pKTsKICAgIH07CgogICAgZnVuY3Rpb24gbnVtYmVyKGEsIGIsIHQpIHsKICAgICAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDsKICAgIH0KICAgIGZ1bmN0aW9uIGNvbG9yKGZyb20sIHRvLCB0KSB7CiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQxKG51bWJlcihmcm9tLnIsIHRvLnIsIHQpLCBudW1iZXIoZnJvbS5nLCB0by5nLCB0KSwgbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksIG51bWJlcihmcm9tLmEsIHRvLmEsIHQpKTsKICAgIH0KICAgIGZ1bmN0aW9uIGFycmF5KGZyb20sIHRvLCB0KSB7CiAgICAgICAgcmV0dXJuIGZyb20ubWFwKChkLCBpKSA9PiB7CiAgICAgICAgICAgIHJldHVybiBudW1iZXIoZCwgdG9baV0sIHQpOwogICAgICAgIH0pOwogICAgfQoKICAgIHZhciBpbnRlcnBvbGF0ZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHsKICAgICAgX19wcm90b19fOiBudWxsLAogICAgICBudW1iZXI6IG51bWJlciwKICAgICAgY29sb3I6IGNvbG9yLAogICAgICBhcnJheTogYXJyYXkKICAgIH0pOwoKICAgIGNvbnN0IFhuID0gMC45NTA0NywgWW4gPSAxLCBabiA9IDEuMDg4ODMsIHQwID0gNCAvIDI5LCB0MSA9IDYgLyAyOSwgdDIgPSAzICogdDEgKiB0MSwgdDMgPSB0MSAqIHQxICogdDEsIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwLCByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTsKICAgIGZ1bmN0aW9uIHh5ejJsYWIodCkgewogICAgICAgIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDsKICAgIH0KICAgIGZ1bmN0aW9uIGxhYjJ4eXoodCkgewogICAgICAgIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApOwogICAgfQogICAgZnVuY3Rpb24geHl6MnJnYih4KSB7CiAgICAgICAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7CiAgICB9CiAgICBmdW5jdGlvbiByZ2IyeHl6KHgpIHsKICAgICAgICB4IC89IDI1NTsKICAgICAgICByZXR1cm4geCA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTsKICAgIH0KICAgIGZ1bmN0aW9uIHJnYlRvTGFiKHJnYkNvbG9yKSB7CiAgICAgICAgY29uc3QgYiA9IHJnYjJ4eXoocmdiQ29sb3IuciksIGEgPSByZ2IyeHl6KHJnYkNvbG9yLmcpLCBsID0gcmdiMnh5eihyZ2JDb2xvci5iKSwgeCA9IHh5ejJsYWIoKDAuNDEyNDU2NCAqIGIgKyAwLjM1NzU3NjEgKiBhICsgMC4xODA0Mzc1ICogbCkgLyBYbiksIHkgPSB4eXoybGFiKCgwLjIxMjY3MjkgKiBiICsgMC43MTUxNTIyICogYSArIDAuMDcyMTc1ICogbCkgLyBZbiksIHogPSB4eXoybGFiKCgwLjAxOTMzMzkgKiBiICsgMC4xMTkxOTIgKiBhICsgMC45NTAzMDQxICogbCkgLyBabik7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgbDogMTE2ICogeSAtIDE2LAogICAgICAgICAgICBhOiA1MDAgKiAoeCAtIHkpLAogICAgICAgICAgICBiOiAyMDAgKiAoeSAtIHopLAogICAgICAgICAgICBhbHBoYTogcmdiQ29sb3IuYQogICAgICAgIH07CiAgICB9CiAgICBmdW5jdGlvbiBsYWJUb1JnYihsYWJDb2xvcikgewogICAgICAgIGxldCB5ID0gKGxhYkNvbG9yLmwgKyAxNikgLyAxMTYsIHggPSBpc05hTihsYWJDb2xvci5hKSA/IHkgOiB5ICsgbGFiQ29sb3IuYSAvIDUwMCwgeiA9IGlzTmFOKGxhYkNvbG9yLmIpID8geSA6IHkgLSBsYWJDb2xvci5iIC8gMjAwOwogICAgICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7CiAgICAgICAgeCA9IFhuICogbGFiMnh5eih4KTsKICAgICAgICB6ID0gWm4gKiBsYWIyeHl6KHopOwogICAgICAgIHJldHVybiBuZXcgQ29sb3IkMSh4eXoycmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIHh5ejJyZ2IoLTAuOTY5MjY2ICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NiAqIHopLCB4eXoycmdiKDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeiksIGxhYkNvbG9yLmFscGhhKTsKICAgIH0KICAgIGZ1bmN0aW9uIGludGVycG9sYXRlTGFiKGZyb20sIHRvLCB0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgbDogbnVtYmVyKGZyb20ubCwgdG8ubCwgdCksCiAgICAgICAgICAgIGE6IG51bWJlcihmcm9tLmEsIHRvLmEsIHQpLAogICAgICAgICAgICBiOiBudW1iZXIoZnJvbS5iLCB0by5iLCB0KSwKICAgICAgICAgICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdCkKICAgICAgICB9OwogICAgfQogICAgZnVuY3Rpb24gcmdiVG9IY2wocmdiQ29sb3IpIHsKICAgICAgICBjb25zdCB7bCwgYSwgYn0gPSByZ2JUb0xhYihyZ2JDb2xvcik7CiAgICAgICAgY29uc3QgaCA9IE1hdGguYXRhbjIoYiwgYSkgKiByYWQyZGVnOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGg6IGggPCAwID8gaCArIDM2MCA6IGgsCiAgICAgICAgICAgIGM6IE1hdGguc3FydChhICogYSArIGIgKiBiKSwKICAgICAgICAgICAgbCwKICAgICAgICAgICAgYWxwaGE6IHJnYkNvbG9yLmEKICAgICAgICB9OwogICAgfQogICAgZnVuY3Rpb24gaGNsVG9SZ2IoaGNsQ29sb3IpIHsKICAgICAgICBjb25zdCBoID0gaGNsQ29sb3IuaCAqIGRlZzJyYWQsIGMgPSBoY2xDb2xvci5jLCBsID0gaGNsQ29sb3IubDsKICAgICAgICByZXR1cm4gbGFiVG9SZ2IoewogICAgICAgICAgICBsLAogICAgICAgICAgICBhOiBNYXRoLmNvcyhoKSAqIGMsCiAgICAgICAgICAgIGI6IE1hdGguc2luKGgpICogYywKICAgICAgICAgICAgYWxwaGE6IGhjbENvbG9yLmFscGhhCiAgICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUh1ZShhLCBiLCB0KSB7CiAgICAgICAgY29uc3QgZCA9IGIgLSBhOwogICAgICAgIHJldHVybiBhICsgdCAqIChkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKTsKICAgIH0KICAgIGZ1bmN0aW9uIGludGVycG9sYXRlSGNsKGZyb20sIHRvLCB0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgaDogaW50ZXJwb2xhdGVIdWUoZnJvbS5oLCB0by5oLCB0KSwKICAgICAgICAgICAgYzogbnVtYmVyKGZyb20uYywgdG8uYywgdCksCiAgICAgICAgICAgIGw6IG51bWJlcihmcm9tLmwsIHRvLmwsIHQpLAogICAgICAgICAgICBhbHBoYTogbnVtYmVyKGZyb20uYWxwaGEsIHRvLmFscGhhLCB0KQogICAgICAgIH07CiAgICB9CiAgICBjb25zdCBsYWIgPSB7CiAgICAgICAgZm9yd2FyZDogcmdiVG9MYWIsCiAgICAgICAgcmV2ZXJzZTogbGFiVG9SZ2IsCiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlTGFiCiAgICB9OwogICAgY29uc3QgaGNsID0gewogICAgICAgIGZvcndhcmQ6IHJnYlRvSGNsLAogICAgICAgIHJldmVyc2U6IGhjbFRvUmdiLAogICAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZUhjbAogICAgfTsKCiAgICB2YXIgY29sb3JTcGFjZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7CiAgICAgIF9fcHJvdG9fXzogbnVsbCwKICAgICAgbGFiOiBsYWIsCiAgICAgIGhjbDogaGNsCiAgICB9KTsKCiAgICBjbGFzcyBJbnRlcnBvbGF0ZSB7CiAgICAgICAgY29uc3RydWN0b3IodHlwZSwgb3BlcmF0b3IsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wcykgewogICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7CiAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247CiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDsKICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTsKICAgICAgICAgICAgdGhpcy5vdXRwdXRzID0gW107CiAgICAgICAgICAgIGZvciAoY29uc3QgW2xhYmVsLCBleHByZXNzaW9uXSBvZiBzdG9wcykgewogICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7CiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dHMucHVzaChleHByZXNzaW9uKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzdGF0aWMgaW50ZXJwb2xhdGlvbkZhY3RvcihpbnRlcnBvbGF0aW9uLCBpbnB1dCwgbG93ZXIsIHVwcGVyKSB7CiAgICAgICAgICAgIGxldCB0ID0gMDsKICAgICAgICAgICAgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2V4cG9uZW50aWFsJykgewogICAgICAgICAgICAgICAgdCA9IGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgaW50ZXJwb2xhdGlvbi5iYXNlLCBsb3dlciwgdXBwZXIpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2xpbmVhcicpIHsKICAgICAgICAgICAgICAgIHQgPSBleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIDEsIGxvd2VyLCB1cHBlcik7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnY3ViaWMtYmV6aWVyJykgewogICAgICAgICAgICAgICAgY29uc3QgYyA9IGludGVycG9sYXRpb24uY29udHJvbFBvaW50czsKICAgICAgICAgICAgICAgIGNvbnN0IHViID0gbmV3IHVuaXRiZXppZXIoY1swXSwgY1sxXSwgY1syXSwgY1szXSk7CiAgICAgICAgICAgICAgICB0ID0gdWIuc29sdmUoZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCAxLCBsb3dlciwgdXBwZXIpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdDsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgbGV0IFtvcGVyYXRvciwgaW50ZXJwb2xhdGlvbiwgaW5wdXQsIC4uLnJlc3RdID0gYXJnczsKICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGludGVycG9sYXRpb24pIHx8IGludGVycG9sYXRpb24ubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gaW50ZXJwb2xhdGlvbiB0eXBlIGV4cHJlc3Npb24uYCwgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdsaW5lYXInKSB7CiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0geyBuYW1lOiAnbGluZWFyJyB9OwogICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdleHBvbmVudGlhbCcpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBpbnRlcnBvbGF0aW9uWzFdOwogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlICE9PSAnbnVtYmVyJykKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS5gLCAxLCAxKTsKICAgICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSB7CiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJywKICAgICAgICAgICAgICAgICAgICBiYXNlCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdjdWJpYy1iZXppZXInKSB7CiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sUG9pbnRzID0gaW50ZXJwb2xhdGlvbi5zbGljZSgxKTsKICAgICAgICAgICAgICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCAhPT0gNCB8fCBjb250cm9sUG9pbnRzLnNvbWUodCA9PiB0eXBlb2YgdCAhPT0gJ251bWJlcicgfHwgdCA8IDAgfHwgdCA+IDEpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0N1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLicsIDEpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHsKICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3ViaWMtYmV6aWVyJywKICAgICAgICAgICAgICAgICAgICBjb250cm9sUG9pbnRzOiBjb250cm9sUG9pbnRzCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYFVua25vd24gaW50ZXJwb2xhdGlvbiB0eXBlICR7IFN0cmluZyhpbnRlcnBvbGF0aW9uWzBdKSB9YCwgMSwgMCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHsgYXJncy5sZW5ndGggLSAxIH0uYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKChhcmdzLmxlbmd0aCAtIDEpICUgMiAhPT0gMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpbnB1dCA9IGNvbnRleHQucGFyc2UoaW5wdXQsIDIsIE51bWJlclR5cGUpOwogICAgICAgICAgICBpZiAoIWlucHV0KQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIGNvbnN0IHN0b3BzID0gW107CiAgICAgICAgICAgIGxldCBvdXRwdXRUeXBlID0gbnVsbDsKICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtaGNsJyB8fCBvcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWxhYicpIHsKICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBDb2xvclR5cGU7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdC5sZW5ndGg7IGkgKz0gMikgewogICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSByZXN0W2ldOwogICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0W2kgKyAxXTsKICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsS2V5ID0gaSArIDM7CiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUtleSA9IGkgKyA0OwogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciAiaW50ZXJwb2xhdGUiIGV4cHJlc3Npb25zIG11c3QgYmUgZGVmaW5lZCB1c2luZyBsaXRlcmFsIG51bWVyaWMgdmFsdWVzIChub3QgY29tcHV0ZWQgZXhwcmVzc2lvbnMpIGZvciB0aGUgaW5wdXQgdmFsdWVzLicsIGxhYmVsS2V5KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdG9wcy5sZW5ndGggJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMF0gPj0gbGFiZWwpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciAiaW50ZXJwb2xhdGUiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGxhYmVsS2V5KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGNvbnRleHQucGFyc2UodmFsdWUsIHZhbHVlS2V5LCBvdXRwdXRUeXBlKTsKICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7CiAgICAgICAgICAgICAgICBzdG9wcy5wdXNoKFsKICAgICAgICAgICAgICAgICAgICBsYWJlbCwKICAgICAgICAgICAgICAgICAgICBwYXJzZWQKICAgICAgICAgICAgICAgIF0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlLmtpbmQgIT09ICdudW1iZXInICYmIG91dHB1dFR5cGUua2luZCAhPT0gJ2NvbG9yJyAmJiAhKG91dHB1dFR5cGUua2luZCA9PT0gJ2FycmF5JyAmJiBvdXRwdXRUeXBlLml0ZW1UeXBlLmtpbmQgPT09ICdudW1iZXInICYmIHR5cGVvZiBvdXRwdXRUeXBlLk4gPT09ICdudW1iZXInKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYFR5cGUgJHsgdG9TdHJpbmckMShvdXRwdXRUeXBlKSB9IGlzIG5vdCBpbnRlcnBvbGF0YWJsZS5gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRlKG91dHB1dFR5cGUsIG9wZXJhdG9yLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgc3RvcHMpOwogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5sYWJlbHM7CiAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSB0aGlzLm91dHB1dHM7CiAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICBpZiAodmFsdWUgPD0gbGFiZWxzWzBdKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHN0b3BDb3VudCA9IGxhYmVscy5sZW5ndGg7CiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBsYWJlbHNbc3RvcENvdW50IC0gMV0pIHsKICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRzW3N0b3BDb3VudCAtIDFdLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKGxhYmVscywgdmFsdWUpOwogICAgICAgICAgICBjb25zdCBsb3dlciA9IGxhYmVsc1tpbmRleF07CiAgICAgICAgICAgIGNvbnN0IHVwcGVyID0gbGFiZWxzW2luZGV4ICsgMV07CiAgICAgICAgICAgIGNvbnN0IHQgPSBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvbiwgdmFsdWUsIGxvd2VyLCB1cHBlcik7CiAgICAgICAgICAgIGNvbnN0IG91dHB1dExvd2VyID0gb3V0cHV0c1tpbmRleF0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgY29uc3Qgb3V0cHV0VXBwZXIgPSBvdXRwdXRzW2luZGV4ICsgMV0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZScpIHsKICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVt0aGlzLnR5cGUua2luZC50b0xvd2VyQ2FzZSgpXShvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpOwogICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZS1oY2wnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaGNsLnJldmVyc2UoaGNsLmludGVycG9sYXRlKGhjbC5mb3J3YXJkKG91dHB1dExvd2VyKSwgaGNsLmZvcndhcmQob3V0cHV0VXBwZXIpLCB0KSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbGFiLnJldmVyc2UobGFiLmludGVycG9sYXRlKGxhYi5mb3J3YXJkKG91dHB1dExvd2VyKSwgbGFiLmZvcndhcmQob3V0cHV0VXBwZXIpLCB0KSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICAgIGZuKHRoaXMuaW5wdXQpOwogICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgdGhpcy5vdXRwdXRzKSB7CiAgICAgICAgICAgICAgICBmbihleHByZXNzaW9uKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KG91dCA9PiBvdXQub3V0cHV0RGVmaW5lZCgpKTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplKCkgewogICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGlvbjsKICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnbGluZWFyJykgewogICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFsnbGluZWFyJ107CiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb24uYmFzZSA9PT0gMSkgewogICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbJ2xpbmVhciddOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gWwogICAgICAgICAgICAgICAgICAgICAgICAnZXhwb25lbnRpYWwnLAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24uYmFzZQogICAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydjdWJpYy1iZXppZXInXS5jb25jYXQodGhpcy5pbnRlcnBvbGF0aW9uLmNvbnRyb2xQb2ludHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbCiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdG9yLAogICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiwKICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKCkKICAgICAgICAgICAgXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMubGFiZWxzW2ldLCB0aGlzLm91dHB1dHNbaV0uc2VyaWFsaXplKCkpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgYmFzZSwgbG93ZXJWYWx1ZSwgdXBwZXJWYWx1ZSkgewogICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB1cHBlclZhbHVlIC0gbG93ZXJWYWx1ZTsKICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGlucHV0IC0gbG93ZXJWYWx1ZTsKICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9IGVsc2UgaWYgKGJhc2UgPT09IDEpIHsKICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzIC8gZGlmZmVyZW5jZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gKE1hdGgucG93KGJhc2UsIHByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRpZmZlcmVuY2UpIC0gMSk7CiAgICAgICAgfQogICAgfQogICAgdmFyIEludGVycG9sYXRlJDEgPSBJbnRlcnBvbGF0ZTsKCiAgICBjbGFzcyBDb2FsZXNjZSB7CiAgICAgICAgY29uc3RydWN0b3IodHlwZSwgYXJncykgewogICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxldCBvdXRwdXRUeXBlID0gbnVsbDsKICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7CiAgICAgICAgICAgIGlmIChleHBlY3RlZFR5cGUgJiYgZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBleHBlY3RlZFR5cGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IFtdOwogICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzLnNsaWNlKDEpKSB7CiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKGFyZywgMSArIHBhcnNlZEFyZ3MubGVuZ3RoLCBvdXRwdXRUeXBlLCB1bmRlZmluZWQsIHsgdHlwZUFubm90YXRpb246ICdvbWl0JyB9KTsKICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7CiAgICAgICAgICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBuZWVkc0Fubm90YXRpb24gPSBleHBlY3RlZFR5cGUgJiYgcGFyc2VkQXJncy5zb21lKGFyZyA9PiBjaGVja1N1YnR5cGUoZXhwZWN0ZWRUeXBlLCBhcmcudHlwZSkpOwogICAgICAgICAgICByZXR1cm4gbmVlZHNBbm5vdGF0aW9uID8gbmV3IENvYWxlc2NlKFZhbHVlVHlwZSwgcGFyc2VkQXJncykgOiBuZXcgQ29hbGVzY2Uob3V0cHV0VHlwZSwgcGFyc2VkQXJncyk7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDsKICAgICAgICAgICAgbGV0IGFyZ0NvdW50ID0gMDsKICAgICAgICAgICAgbGV0IGZpcnN0SW1hZ2U7CiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJncykgewogICAgICAgICAgICAgICAgYXJnQ291bnQrKzsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFyZy5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlICYmICFyZXN1bHQuYXZhaWxhYmxlKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdEltYWdlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0SW1hZ2UgPSByZXN1bHQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7CiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ0NvdW50ID09PSB0aGlzLmFyZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdEltYWdlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTsKICAgICAgICB9CiAgICAgICAgb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShhcmcgPT4gYXJnLm91dHB1dERlZmluZWQoKSk7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFsnY29hbGVzY2UnXTsKICAgICAgICAgICAgdGhpcy5lYWNoQ2hpbGQoY2hpbGQgPT4gewogICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICAgIH0KICAgIH0KICAgIHZhciBDb2FsZXNjZSQxID0gQ29hbGVzY2U7CgogICAgY2xhc3MgTGV0IHsKICAgICAgICBjb25zdHJ1Y3RvcihiaW5kaW5ncywgcmVzdWx0KSB7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IHJlc3VsdC50eXBlOwogICAgICAgICAgICB0aGlzLmJpbmRpbmdzID0gW10uY29uY2F0KGJpbmRpbmdzKTsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQuZXZhbHVhdGUoY3R4KTsKICAgICAgICB9CiAgICAgICAgZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgYmluZGluZyBvZiB0aGlzLmJpbmRpbmdzKSB7CiAgICAgICAgICAgICAgICBmbihiaW5kaW5nWzFdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmbih0aGlzLnJlc3VsdCk7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpCiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCAkeyBhcmdzLmxlbmd0aCAtIDEgfSBpbnN0ZWFkLmApOwogICAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtdOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7CiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXJnc1tpXTsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgc3RyaW5nLCBidXQgZm91bmQgJHsgdHlwZW9mIG5hbWUgfSBpbnN0ZWFkLmAsIGkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKC9bXmEtekEtWjAtOV9dLy50ZXN0KG5hbWUpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYFZhcmlhYmxlIG5hbWVzIG11c3QgY29udGFpbiBvbmx5IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIG9yICdfJy5gLCBpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5wYXJzZShhcmdzW2kgKyAxXSwgaSArIDEpOwogICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goWwogICAgICAgICAgICAgICAgICAgIG5hbWUsCiAgICAgICAgICAgICAgICAgICAgdmFsdWUKICAgICAgICAgICAgICAgIF0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIGNvbnRleHQuZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncyk7CiAgICAgICAgICAgIGlmICghcmVzdWx0KQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIHJldHVybiBuZXcgTGV0KGJpbmRpbmdzLCByZXN1bHQpOwogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3V0cHV0RGVmaW5lZCgpOwogICAgICAgIH0KICAgICAgICBzZXJpYWxpemUoKSB7CiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2xldCddOwogICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBleHByXSBvZiB0aGlzLmJpbmRpbmdzKSB7CiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2gobmFtZSwgZXhwci5zZXJpYWxpemUoKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMucmVzdWx0LnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7CiAgICAgICAgfQogICAgfQogICAgdmFyIExldCQxID0gTGV0OwoKICAgIGNsYXNzIEF0IHsKICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBpbmRleCwgaW5wdXQpIHsKICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTsKICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4OwogICAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMykKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCAyIGFyZ3VtZW50cywgYnV0IGZvdW5kICR7IGFyZ3MubGVuZ3RoIC0gMSB9IGluc3RlYWQuYCk7CiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTsKICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIGFycmF5JDEoY29udGV4dC5leHBlY3RlZFR5cGUgfHwgVmFsdWVUeXBlKSk7CiAgICAgICAgICAgIGlmICghaW5kZXggfHwgIWlucHV0KQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIGNvbnN0IHQgPSBpbnB1dC50eXBlOwogICAgICAgICAgICByZXR1cm4gbmV3IEF0KHQuaXRlbVR5cGUsIGluZGV4LCBpbnB1dCk7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXguZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgY29uc3QgYXJyYXkgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IkMShgQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogJHsgaW5kZXggfSA8IDAuYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGluZGV4ID49IGFycmF5Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvciQxKGBBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiAkeyBpbmRleCB9ID4gJHsgYXJyYXkubGVuZ3RoIC0gMSB9LmApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gTWF0aC5mbG9vcihpbmRleCkpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IkMShgQXJyYXkgaW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZm91bmQgJHsgaW5kZXggfSBpbnN0ZWFkLmApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBhcnJheVtpbmRleF07CiAgICAgICAgfQogICAgICAgIGVhY2hDaGlsZChmbikgewogICAgICAgICAgICBmbih0aGlzLmluZGV4KTsKICAgICAgICAgICAgZm4odGhpcy5pbnB1dCk7CiAgICAgICAgfQogICAgICAgIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplKCkgewogICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgJ2F0JywKICAgICAgICAgICAgICAgIHRoaXMuaW5kZXguc2VyaWFsaXplKCksCiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpCiAgICAgICAgICAgIF07CiAgICAgICAgfQogICAgfQogICAgdmFyIEF0JDEgPSBBdDsKCiAgICBjbGFzcyBJbiB7CiAgICAgICAgY29uc3RydWN0b3IobmVlZGxlLCBoYXlzdGFjaykgewogICAgICAgICAgICB0aGlzLnR5cGUgPSBCb29sZWFuVHlwZTsKICAgICAgICAgICAgdGhpcy5uZWVkbGUgPSBuZWVkbGU7CiAgICAgICAgICAgIHRoaXMuaGF5c3RhY2sgPSBoYXlzdGFjazsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBmb3VuZCAkeyBhcmdzLmxlbmd0aCAtIDEgfSBpbnN0ZWFkLmApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IG5lZWRsZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTsKICAgICAgICAgICAgY29uc3QgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7CiAgICAgICAgICAgIGlmICghbmVlZGxlIHx8ICFoYXlzdGFjaykKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKG5lZWRsZS50eXBlLCBbCiAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgICAgIE51bGxUeXBlLAogICAgICAgICAgICAgICAgICAgIFZhbHVlVHlwZQogICAgICAgICAgICAgICAgXSkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAkeyB0b1N0cmluZyQxKG5lZWRsZS50eXBlKSB9IGluc3RlYWRgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IEluKG5lZWRsZSwgaGF5c3RhY2spOwogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgY29uc3QgbmVlZGxlID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgY29uc3QgaGF5c3RhY2sgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgIGlmIChoYXlzdGFjayA9PSBudWxsKQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKG5lZWRsZSwgWwogICAgICAgICAgICAgICAgICAgICdib29sZWFuJywKICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJywKICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJywKICAgICAgICAgICAgICAgICAgICAnbnVsbCcKICAgICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yJDEoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICR7IHRvU3RyaW5nJDEodHlwZU9mKG5lZWRsZSkpIH0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGhheXN0YWNrLCBbCiAgICAgICAgICAgICAgICAgICAgJ3N0cmluZycsCiAgICAgICAgICAgICAgICAgICAgJ2FycmF5JwogICAgICAgICAgICAgICAgXSkpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IkMShgRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJHsgdG9TdHJpbmckMSh0eXBlT2YoaGF5c3RhY2spKSB9IGluc3RlYWQuYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+PSAwOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgZm4odGhpcy5uZWVkbGUpOwogICAgICAgICAgICBmbih0aGlzLmhheXN0YWNrKTsKICAgICAgICB9CiAgICAgICAgb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICdpbicsCiAgICAgICAgICAgICAgICB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSwKICAgICAgICAgICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCkKICAgICAgICAgICAgXTsKICAgICAgICB9CiAgICB9CiAgICB2YXIgSW4kMSA9IEluOwoKICAgIGNsYXNzIEluZGV4T2YgewogICAgICAgIGNvbnN0cnVjdG9yKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCkgewogICAgICAgICAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlOwogICAgICAgICAgICB0aGlzLm5lZWRsZSA9IG5lZWRsZTsKICAgICAgICAgICAgdGhpcy5oYXlzdGFjayA9IGhheXN0YWNrOwogICAgICAgICAgICB0aGlzLmZyb21JbmRleCA9IGZyb21JbmRleDsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCAkeyBhcmdzLmxlbmd0aCAtIDEgfSBpbnN0ZWFkLmApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IG5lZWRsZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTsKICAgICAgICAgICAgY29uc3QgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7CiAgICAgICAgICAgIGlmICghbmVlZGxlIHx8ICFoYXlzdGFjaykKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKG5lZWRsZS50eXBlLCBbCiAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgICAgIE51bGxUeXBlLAogICAgICAgICAgICAgICAgICAgIFZhbHVlVHlwZQogICAgICAgICAgICAgICAgXSkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAkeyB0b1N0cmluZyQxKG5lZWRsZS50eXBlKSB9IGluc3RlYWRgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZyb21JbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgTnVtYmVyVHlwZSk7CiAgICAgICAgICAgICAgICBpZiAoIWZyb21JbmRleCkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrLCBmcm9tSW5kZXgpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2spOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICBjb25zdCBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICBjb25zdCBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFsKICAgICAgICAgICAgICAgICAgICAnYm9vbGVhbicsCiAgICAgICAgICAgICAgICAgICAgJ3N0cmluZycsCiAgICAgICAgICAgICAgICAgICAgJ251bWJlcicsCiAgICAgICAgICAgICAgICAgICAgJ251bGwnCiAgICAgICAgICAgICAgICBdKSkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvciQxKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAkeyB0b1N0cmluZyQxKHR5cGVPZihuZWVkbGUpKSB9IGluc3RlYWQuYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShoYXlzdGFjaywgWwogICAgICAgICAgICAgICAgICAgICdzdHJpbmcnLAogICAgICAgICAgICAgICAgICAgICdhcnJheScKICAgICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yJDEoYEV4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICR7IHRvU3RyaW5nJDEodHlwZU9mKGhheXN0YWNrKSkgfSBpbnN0ZWFkLmApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLmZyb21JbmRleCkgewogICAgICAgICAgICAgICAgY29uc3QgZnJvbUluZGV4ID0gdGhpcy5mcm9tSW5kZXguZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgZnJvbUluZGV4KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgZm4odGhpcy5uZWVkbGUpOwogICAgICAgICAgICBmbih0aGlzLmhheXN0YWNrKTsKICAgICAgICAgICAgaWYgKHRoaXMuZnJvbUluZGV4KSB7CiAgICAgICAgICAgICAgICBmbih0aGlzLmZyb21JbmRleCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBzZXJpYWxpemUoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmZyb21JbmRleCAhPSBudWxsICYmIHRoaXMuZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZyb21JbmRleCA9IHRoaXMuZnJvbUluZGV4LnNlcmlhbGl6ZSgpOwogICAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgICAnaW5kZXgtb2YnLAogICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCksCiAgICAgICAgICAgICAgICAgICAgZnJvbUluZGV4CiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAnaW5kZXgtb2YnLAogICAgICAgICAgICAgICAgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksCiAgICAgICAgICAgICAgICB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpCiAgICAgICAgICAgIF07CiAgICAgICAgfQogICAgfQogICAgdmFyIEluZGV4T2YkMSA9IEluZGV4T2Y7CgogICAgY2xhc3MgTWF0Y2ggewogICAgICAgIGNvbnN0cnVjdG9yKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpIHsKICAgICAgICAgICAgdGhpcy5pbnB1dFR5cGUgPSBpbnB1dFR5cGU7CiAgICAgICAgICAgIHRoaXMudHlwZSA9IG91dHB1dFR5cGU7CiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDsKICAgICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzOwogICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzOwogICAgICAgICAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNSkKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHsgYXJncy5sZW5ndGggLSAxIH0uYCk7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAlIDIgIT09IDEpCiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLmApOwogICAgICAgICAgICBsZXQgaW5wdXRUeXBlOwogICAgICAgICAgICBsZXQgb3V0cHV0VHlwZTsKICAgICAgICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBjYXNlcyA9IHt9OwogICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gW107CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHsKICAgICAgICAgICAgICAgIGxldCBsYWJlbHMgPSBhcmdzW2ldOwogICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzW2kgKyAxXTsKICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKSB7CiAgICAgICAgICAgICAgICAgICAgbGFiZWxzID0gW2xhYmVsc107CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbENvbnRleHQgPSBjb250ZXh0LmNvbmNhdChpKTsKICAgICAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGJyYW5jaCBsYWJlbC4nKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGxhYmVsICE9PSAnc3RyaW5nJykgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKGBCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLmApOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsID09PSAnbnVtYmVyJyAmJiBNYXRoLmFicyhsYWJlbCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKGBCcmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlcnMgbm8gbGFyZ2VyIHRoYW4gJHsgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfS5gKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihsYWJlbCkgIT09IGxhYmVsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoYE51bWVyaWMgYnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXIgdmFsdWVzLmApOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlucHV0VHlwZSkgewogICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPSB0eXBlT2YobGFiZWwpOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb250ZXh0LmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIHR5cGVPZihsYWJlbCkpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhc2VzW1N0cmluZyhsYWJlbCldICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdCcmFuY2ggbGFiZWxzIG11c3QgYmUgdW5pcXVlLicpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjYXNlc1tTdHJpbmcobGFiZWwpXSA9IG91dHB1dHMubGVuZ3RoOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29udGV4dC5wYXJzZSh2YWx1ZSwgaSwgb3V0cHV0VHlwZSk7CiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlOwogICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHJlc3VsdCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7CiAgICAgICAgICAgIGlmICghaW5wdXQpCiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7CiAgICAgICAgICAgIGlmICghb3RoZXJ3aXNlKQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIGlmIChpbnB1dC50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgY29udGV4dC5jb25jYXQoMSkuY2hlY2tTdWJ0eXBlKGlucHV0VHlwZSwgaW5wdXQudHlwZSkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2goaW5wdXRUeXBlLCBvdXRwdXRUeXBlLCBpbnB1dCwgY2FzZXMsIG91dHB1dHMsIG90aGVyd2lzZSk7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gdHlwZU9mKGlucHV0KSA9PT0gdGhpcy5pbnB1dFR5cGUgJiYgdGhpcy5vdXRwdXRzW3RoaXMuY2FzZXNbaW5wdXRdXSB8fCB0aGlzLm90aGVyd2lzZTsKICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5ldmFsdWF0ZShjdHgpOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgZm4odGhpcy5pbnB1dCk7CiAgICAgICAgICAgIHRoaXMub3V0cHV0cy5mb3JFYWNoKGZuKTsKICAgICAgICAgICAgZm4odGhpcy5vdGhlcndpc2UpOwogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KG91dCA9PiBvdXQub3V0cHV0RGVmaW5lZCgpKSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFsKICAgICAgICAgICAgICAgICdtYXRjaCcsCiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpCiAgICAgICAgICAgIF07CiAgICAgICAgICAgIGNvbnN0IHNvcnRlZExhYmVscyA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTsKICAgICAgICAgICAgY29uc3QgZ3JvdXBlZEJ5T3V0cHV0ID0gW107CiAgICAgICAgICAgIGNvbnN0IG91dHB1dExvb2t1cCA9IHt9OwogICAgICAgICAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIHNvcnRlZExhYmVscykgewogICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBvdXRwdXRMb29rdXBbdGhpcy5jYXNlc1tsYWJlbF1dOwogICAgICAgICAgICAgICAgaWYgKG91dHB1dEluZGV4ID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICBvdXRwdXRMb29rdXBbdGhpcy5jYXNlc1tsYWJlbF1dID0gZ3JvdXBlZEJ5T3V0cHV0Lmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICBncm91cGVkQnlPdXRwdXQucHVzaChbCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FzZXNbbGFiZWxdLAogICAgICAgICAgICAgICAgICAgICAgICBbbGFiZWxdCiAgICAgICAgICAgICAgICAgICAgXSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGdyb3VwZWRCeU91dHB1dFtvdXRwdXRJbmRleF1bMV0ucHVzaChsYWJlbCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgY29lcmNlTGFiZWwgPSBsYWJlbCA9PiB0aGlzLmlucHV0VHlwZS5raW5kID09PSAnbnVtYmVyJyA/IE51bWJlcihsYWJlbCkgOiBsYWJlbDsKICAgICAgICAgICAgZm9yIChjb25zdCBbb3V0cHV0SW5kZXgsIGxhYmVsc10gb2YgZ3JvdXBlZEJ5T3V0cHV0KSB7CiAgICAgICAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjb2VyY2VMYWJlbChsYWJlbHNbMF0pKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGxhYmVscy5tYXAoY29lcmNlTGFiZWwpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbb3V0cHV0SW5kZXhdLnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdGhlcndpc2Uuc2VyaWFsaXplKCkpOwogICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDsKICAgICAgICB9CiAgICB9CiAgICB2YXIgTWF0Y2gkMSA9IE1hdGNoOwoKICAgIGNsYXNzIENhc2UgewogICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpIHsKICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTsKICAgICAgICAgICAgdGhpcy5icmFuY2hlcyA9IGJyYW5jaGVzOwogICAgICAgICAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNCkKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHsgYXJncy5sZW5ndGggLSAxIH0uYCk7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAlIDIgIT09IDApCiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gb2RkIG51bWJlciBvZiBhcmd1bWVudHMuYCk7CiAgICAgICAgICAgIGxldCBvdXRwdXRUeXBlOwogICAgICAgICAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGJyYW5jaGVzID0gW107CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIEJvb2xlYW5UeXBlKTsKICAgICAgICAgICAgICAgIGlmICghdGVzdCkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpICsgMV0sIGkgKyAxLCBvdXRwdXRUeXBlKTsKICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgYnJhbmNoZXMucHVzaChbCiAgICAgICAgICAgICAgICAgICAgdGVzdCwKICAgICAgICAgICAgICAgICAgICByZXN1bHQKICAgICAgICAgICAgICAgIF0pOwogICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcmVzdWx0LnR5cGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7CiAgICAgICAgICAgIGlmICghb3RoZXJ3aXNlKQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FzZShvdXRwdXRUeXBlLCBicmFuY2hlcywgb3RoZXJ3aXNlKTsKICAgICAgICB9CiAgICAgICAgZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgW3Rlc3QsIGV4cHJlc3Npb25dIG9mIHRoaXMuYnJhbmNoZXMpIHsKICAgICAgICAgICAgICAgIGlmICh0ZXN0LmV2YWx1YXRlKGN0eCkpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZShjdHgpOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgZm9yIChjb25zdCBbdGVzdCwgZXhwcmVzc2lvbl0gb2YgdGhpcy5icmFuY2hlcykgewogICAgICAgICAgICAgICAgZm4odGVzdCk7CiAgICAgICAgICAgICAgICBmbihleHByZXNzaW9uKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmbih0aGlzLm90aGVyd2lzZSk7CiAgICAgICAgfQogICAgICAgIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmJyYW5jaGVzLmV2ZXJ5KChbXywgb3V0XSkgPT4gb3V0Lm91dHB1dERlZmluZWQoKSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpOwogICAgICAgIH0KICAgICAgICBzZXJpYWxpemUoKSB7CiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2Nhc2UnXTsKICAgICAgICAgICAgdGhpcy5lYWNoQ2hpbGQoY2hpbGQgPT4gewogICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICAgIH0KICAgIH0KICAgIHZhciBDYXNlJDEgPSBDYXNlOwoKICAgIGNsYXNzIFNsaWNlIHsKICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBpbnB1dCwgYmVnaW5JbmRleCwgZW5kSW5kZXgpIHsKICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTsKICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0OwogICAgICAgICAgICB0aGlzLmJlZ2luSW5kZXggPSBiZWdpbkluZGV4OwogICAgICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAyIHx8IGFyZ3MubGVuZ3RoID49IDUpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCAzIG9yIDQgYXJndW1lbnRzLCBidXQgZm91bmQgJHsgYXJncy5sZW5ndGggLSAxIH0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTsKICAgICAgICAgICAgY29uc3QgYmVnaW5JbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgTnVtYmVyVHlwZSk7CiAgICAgICAgICAgIGlmICghaW5wdXQgfHwgIWJlZ2luSW5kZXgpCiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShpbnB1dC50eXBlLCBbCiAgICAgICAgICAgICAgICAgICAgYXJyYXkkMShWYWx1ZVR5cGUpLAogICAgICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgICAgICAgICAgVmFsdWVUeXBlCiAgICAgICAgICAgICAgICBdKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJHsgdG9TdHJpbmckMShpbnB1dC50eXBlKSB9IGluc3RlYWRgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBOdW1iZXJUeXBlKTsKICAgICAgICAgICAgICAgIGlmICghZW5kSW5kZXgpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGlucHV0LnR5cGUsIGlucHV0LCBiZWdpbkluZGV4LCBlbmRJbmRleCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGlucHV0LnR5cGUsIGlucHV0LCBiZWdpbkluZGV4KTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgIGNvbnN0IGJlZ2luSW5kZXggPSB0aGlzLmJlZ2luSW5kZXguZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShpbnB1dCwgWwogICAgICAgICAgICAgICAgICAgICdzdHJpbmcnLAogICAgICAgICAgICAgICAgICAgICdhcnJheScKICAgICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yJDEoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJHsgdG9TdHJpbmckMSh0eXBlT2YoaW5wdXQpKSB9IGluc3RlYWQuYCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuZW5kSW5kZXgpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleC5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoYmVnaW5JbmRleCk7CiAgICAgICAgfQogICAgICAgIGVhY2hDaGlsZChmbikgewogICAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgICAgICAgZm4odGhpcy5iZWdpbkluZGV4KTsKICAgICAgICAgICAgaWYgKHRoaXMuZW5kSW5kZXgpIHsKICAgICAgICAgICAgICAgIGZuKHRoaXMuZW5kSW5kZXgpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplKCkgewogICAgICAgICAgICBpZiAodGhpcy5lbmRJbmRleCAhPSBudWxsICYmIHRoaXMuZW5kSW5kZXggIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0aGlzLmVuZEluZGV4LnNlcmlhbGl6ZSgpOwogICAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgICAnc2xpY2UnLAogICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgICAgICAgIGVuZEluZGV4CiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAnc2xpY2UnLAogICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSwKICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKQogICAgICAgICAgICBdOwogICAgICAgIH0KICAgIH0KICAgIHZhciBTbGljZSQxID0gU2xpY2U7CgogICAgZnVuY3Rpb24gaXNDb21wYXJhYmxlVHlwZShvcCwgdHlwZSkgewogICAgICAgIGlmIChvcCA9PT0gJz09JyB8fCBvcCA9PT0gJyE9JykgewogICAgICAgICAgICByZXR1cm4gdHlwZS5raW5kID09PSAnYm9vbGVhbicgfHwgdHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCB0eXBlLmtpbmQgPT09ICdudW1iZXInIHx8IHR5cGUua2luZCA9PT0gJ251bGwnIHx8IHR5cGUua2luZCA9PT0gJ3ZhbHVlJzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gdHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCB0eXBlLmtpbmQgPT09ICdudW1iZXInIHx8IHR5cGUua2luZCA9PT0gJ3ZhbHVlJzsKICAgICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBlcShjdHgsIGEsIGIpIHsKICAgICAgICByZXR1cm4gYSA9PT0gYjsKICAgIH0KICAgIGZ1bmN0aW9uIG5lcShjdHgsIGEsIGIpIHsKICAgICAgICByZXR1cm4gYSAhPT0gYjsKICAgIH0KICAgIGZ1bmN0aW9uIGx0KGN0eCwgYSwgYikgewogICAgICAgIHJldHVybiBhIDwgYjsKICAgIH0KICAgIGZ1bmN0aW9uIGd0KGN0eCwgYSwgYikgewogICAgICAgIHJldHVybiBhID4gYjsKICAgIH0KICAgIGZ1bmN0aW9uIGx0ZXEoY3R4LCBhLCBiKSB7CiAgICAgICAgcmV0dXJuIGEgPD0gYjsKICAgIH0KICAgIGZ1bmN0aW9uIGd0ZXEoY3R4LCBhLCBiKSB7CiAgICAgICAgcmV0dXJuIGEgPj0gYjsKICAgIH0KICAgIGZ1bmN0aW9uIGVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHsKICAgICAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID09PSAwOwogICAgfQogICAgZnVuY3Rpb24gbmVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHsKICAgICAgICByZXR1cm4gIWVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpOwogICAgfQogICAgZnVuY3Rpb24gbHRDb2xsYXRlKGN0eCwgYSwgYiwgYykgewogICAgICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPCAwOwogICAgfQogICAgZnVuY3Rpb24gZ3RDb2xsYXRlKGN0eCwgYSwgYiwgYykgewogICAgICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPiAwOwogICAgfQogICAgZnVuY3Rpb24gbHRlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7CiAgICAgICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA8PSAwOwogICAgfQogICAgZnVuY3Rpb24gZ3RlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7CiAgICAgICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA+PSAwOwogICAgfQogICAgZnVuY3Rpb24gbWFrZUNvbXBhcmlzb24ob3AsIGNvbXBhcmVCYXNpYywgY29tcGFyZVdpdGhDb2xsYXRvcikgewogICAgICAgIGNvbnN0IGlzT3JkZXJDb21wYXJpc29uID0gb3AgIT09ICc9PScgJiYgb3AgIT09ICchPSc7CiAgICAgICAgcmV0dXJuIGNsYXNzIENvbXBhcmlzb24gewogICAgICAgICAgICBjb25zdHJ1Y3RvcihsaHMsIHJocywgY29sbGF0b3IpIHsKICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlOwogICAgICAgICAgICAgICAgdGhpcy5saHMgPSBsaHM7CiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IHJoczsKICAgICAgICAgICAgICAgIHRoaXMuY29sbGF0b3IgPSBjb2xsYXRvcjsKICAgICAgICAgICAgICAgIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50ID0gbGhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCByaHMudHlwZS5raW5kID09PSAndmFsdWUnOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDMgJiYgYXJncy5sZW5ndGggIT09IDQpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIHR3byBvciB0aHJlZSBhcmd1bWVudHMuYCk7CiAgICAgICAgICAgICAgICBjb25zdCBvcCA9IGFyZ3NbMF07CiAgICAgICAgICAgICAgICBsZXQgbGhzID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpOwogICAgICAgICAgICAgICAgaWYgKCFsaHMpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcGFyYWJsZVR5cGUob3AsIGxocy50eXBlKSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmNhdCgxKS5lcnJvcihgIiR7IG9wIH0iIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICckeyB0b1N0cmluZyQxKGxocy50eXBlKSB9Jy5gKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxldCByaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7CiAgICAgICAgICAgICAgICBpZiAoIXJocykKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgIGlmICghaXNDb21wYXJhYmxlVHlwZShvcCwgcmhzLnR5cGUpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KDIpLmVycm9yKGAiJHsgb3AgfSIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgJyR7IHRvU3RyaW5nJDEocmhzLnR5cGUpIH0nLmApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgIT09IHJocy50eXBlLmtpbmQgJiYgbGhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kICE9PSAndmFsdWUnKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYENhbm5vdCBjb21wYXJlIHR5cGVzICckeyB0b1N0cmluZyQxKGxocy50eXBlKSB9JyBhbmQgJyR7IHRvU3RyaW5nJDEocmhzLnR5cGUpIH0nLmApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGlzT3JkZXJDb21wYXJpc29uKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgPT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgICAgICAgICBsaHMgPSBuZXcgQXNzZXJ0aW9uJDEocmhzLnR5cGUsIFtsaHNdKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgICAgICAgICByaHMgPSBuZXcgQXNzZXJ0aW9uJDEobGhzLnR5cGUsIFtyaHNdKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsZXQgY29sbGF0b3IgPSBudWxsOwogICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIHJocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgQ2Fubm90IHVzZSBjb2xsYXRvciB0byBjb21wYXJlIG5vbi1zdHJpbmcgdHlwZXMuYCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNvbGxhdG9yID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBDb2xsYXRvclR5cGUpOwogICAgICAgICAgICAgICAgICAgIGlmICghY29sbGF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wYXJpc29uKGxocywgcmhzLCBjb2xsYXRvcik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICAgICAgICBjb25zdCBsaHMgPSB0aGlzLmxocy5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgY29uc3QgcmhzID0gdGhpcy5yaHMuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgIGlmIChpc09yZGVyQ29tcGFyaXNvbiAmJiB0aGlzLmhhc1VudHlwZWRBcmd1bWVudCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGx0ID0gdHlwZU9mKGxocyk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnQgPSB0eXBlT2YocmhzKTsKICAgICAgICAgICAgICAgICAgICBpZiAobHQua2luZCAhPT0gcnQua2luZCB8fCAhKGx0LmtpbmQgPT09ICdzdHJpbmcnIHx8IGx0LmtpbmQgPT09ICdudW1iZXInKSkgewogICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yJDEoYEV4cGVjdGVkIGFyZ3VtZW50cyBmb3IgIiR7IG9wIH0iIHRvIGJlIChzdHJpbmcsIHN0cmluZykgb3IgKG51bWJlciwgbnVtYmVyKSwgYnV0IGZvdW5kICgkeyBsdC5raW5kIH0sICR7IHJ0LmtpbmQgfSkgaW5zdGVhZC5gKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXRvciAmJiAhaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBsdCA9IHR5cGVPZihsaHMpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ0ID0gdHlwZU9mKHJocyk7CiAgICAgICAgICAgICAgICAgICAgaWYgKGx0LmtpbmQgIT09ICdzdHJpbmcnIHx8IHJ0LmtpbmQgIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlQmFzaWMoY3R4LCBsaHMsIHJocyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGF0b3IgPyBjb21wYXJlV2l0aENvbGxhdG9yKGN0eCwgbGhzLCByaHMsIHRoaXMuY29sbGF0b3IuZXZhbHVhdGUoY3R4KSkgOiBjb21wYXJlQmFzaWMoY3R4LCBsaHMsIHJocyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICAgICAgICBmbih0aGlzLmxocyk7CiAgICAgICAgICAgICAgICBmbih0aGlzLnJocyk7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXRvcikgewogICAgICAgICAgICAgICAgICAgIGZuKHRoaXMuY29sbGF0b3IpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzZXJpYWxpemUoKSB7CiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gW29wXTsKICAgICAgICAgICAgICAgIHRoaXMuZWFjaENoaWxkKGNoaWxkID0+IHsKICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDsKICAgICAgICAgICAgfQogICAgICAgIH07CiAgICB9CiAgICBjb25zdCBFcXVhbHMgPSBtYWtlQ29tcGFyaXNvbignPT0nLCBlcSwgZXFDb2xsYXRlKTsKICAgIGNvbnN0IE5vdEVxdWFscyA9IG1ha2VDb21wYXJpc29uKCchPScsIG5lcSwgbmVxQ29sbGF0ZSk7CiAgICBjb25zdCBMZXNzVGhhbiA9IG1ha2VDb21wYXJpc29uKCc8JywgbHQsIGx0Q29sbGF0ZSk7CiAgICBjb25zdCBHcmVhdGVyVGhhbiA9IG1ha2VDb21wYXJpc29uKCc+JywgZ3QsIGd0Q29sbGF0ZSk7CiAgICBjb25zdCBMZXNzVGhhbk9yRXF1YWwgPSBtYWtlQ29tcGFyaXNvbignPD0nLCBsdGVxLCBsdGVxQ29sbGF0ZSk7CiAgICBjb25zdCBHcmVhdGVyVGhhbk9yRXF1YWwgPSBtYWtlQ29tcGFyaXNvbignPj0nLCBndGVxLCBndGVxQ29sbGF0ZSk7CgogICAgY2xhc3MgTnVtYmVyRm9ybWF0IHsKICAgICAgICBjb25zdHJ1Y3RvcihudW1iZXIsIGxvY2FsZSwgY3VycmVuY3ksIG1pbkZyYWN0aW9uRGlnaXRzLCBtYXhGcmFjdGlvbkRpZ2l0cykgewogICAgICAgICAgICB0aGlzLnR5cGUgPSBTdHJpbmdUeXBlOwogICAgICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjsKICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7CiAgICAgICAgICAgIHRoaXMuY3VycmVuY3kgPSBjdXJyZW5jeTsKICAgICAgICAgICAgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA9IG1pbkZyYWN0aW9uRGlnaXRzOwogICAgICAgICAgICB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID0gbWF4RnJhY3Rpb25EaWdpdHM7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMykKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCB0d28gYXJndW1lbnRzLmApOwogICAgICAgICAgICBjb25zdCBudW1iZXIgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpOwogICAgICAgICAgICBpZiAoIW51bWJlcikKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1syXTsKICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYE51bWJlckZvcm1hdCBvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LmApOwogICAgICAgICAgICBsZXQgbG9jYWxlID0gbnVsbDsKICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2xvY2FsZSddKSB7CiAgICAgICAgICAgICAgICBsb2NhbGUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2xvY2FsZSddLCAxLCBTdHJpbmdUeXBlKTsKICAgICAgICAgICAgICAgIGlmICghbG9jYWxlKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IG51bGw7CiAgICAgICAgICAgIGlmIChvcHRpb25zWydjdXJyZW5jeSddKSB7CiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snY3VycmVuY3knXSwgMSwgU3RyaW5nVHlwZSk7CiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbmN5KQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxldCBtaW5GcmFjdGlvbkRpZ2l0cyA9IG51bGw7CiAgICAgICAgICAgIGlmIChvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10pIHsKICAgICAgICAgICAgICAgIG1pbkZyYWN0aW9uRGlnaXRzID0gY29udGV4dC5wYXJzZShvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10sIDEsIE51bWJlclR5cGUpOwogICAgICAgICAgICAgICAgaWYgKCFtaW5GcmFjdGlvbkRpZ2l0cykKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZXQgbWF4RnJhY3Rpb25EaWdpdHMgPSBudWxsOwogICAgICAgICAgICBpZiAob3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddKSB7CiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbkRpZ2l0cyA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddLCAxLCBOdW1iZXJUeXBlKTsKICAgICAgICAgICAgICAgIGlmICghbWF4RnJhY3Rpb25EaWdpdHMpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJGb3JtYXQobnVtYmVyLCBsb2NhbGUsIGN1cnJlbmN5LCBtaW5GcmFjdGlvbkRpZ2l0cywgbWF4RnJhY3Rpb25EaWdpdHMpOwogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlLmV2YWx1YXRlKGN0eCkgOiBbXSwgewogICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMuY3VycmVuY3kgPyAnY3VycmVuY3knIDogJ2RlY2ltYWwnLAogICAgICAgICAgICAgICAgY3VycmVuY3k6IHRoaXMuY3VycmVuY3kgPyB0aGlzLmN1cnJlbmN5LmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWQsCiAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IHRoaXMubWluRnJhY3Rpb25EaWdpdHMgPyB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzLmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWQsCiAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgPyB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWQKICAgICAgICAgICAgfSkuZm9ybWF0KHRoaXMubnVtYmVyLmV2YWx1YXRlKGN0eCkpOwogICAgICAgIH0KICAgICAgICBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgZm4odGhpcy5udW1iZXIpOwogICAgICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHsKICAgICAgICAgICAgICAgIGZuKHRoaXMubG9jYWxlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5jdXJyZW5jeSkgewogICAgICAgICAgICAgICAgZm4odGhpcy5jdXJyZW5jeSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpIHsKICAgICAgICAgICAgICAgIGZuKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKSB7CiAgICAgICAgICAgICAgICBmbih0aGlzLm1heEZyYWN0aW9uRGlnaXRzKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9OwogICAgICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2xvY2FsZSddID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVuY3kpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2N1cnJlbmN5J10gPSB0aGlzLmN1cnJlbmN5LnNlcmlhbGl6ZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10gPSB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10gPSB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAnbnVtYmVyLWZvcm1hdCcsCiAgICAgICAgICAgICAgICB0aGlzLm51bWJlci5zZXJpYWxpemUoKSwKICAgICAgICAgICAgICAgIG9wdGlvbnMKICAgICAgICAgICAgXTsKICAgICAgICB9CiAgICB9CgogICAgY2xhc3MgTGVuZ3RoIHsKICAgICAgICBjb25zdHJ1Y3RvcihpbnB1dCkgewogICAgICAgICAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlOwogICAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikKICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgJHsgYXJncy5sZW5ndGggLSAxIH0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEpOwogICAgICAgICAgICBpZiAoIWlucHV0KQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIGlmIChpbnB1dC50eXBlLmtpbmQgIT09ICdhcnJheScgJiYgaW5wdXQudHlwZS5raW5kICE9PSAnc3RyaW5nJyAmJiBpbnB1dC50eXBlLmtpbmQgIT09ICd2YWx1ZScpCiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCAkeyB0b1N0cmluZyQxKGlucHV0LnR5cGUpIH0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBMZW5ndGgoaW5wdXQpOwogICAgICAgIH0KICAgICAgICBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQubGVuZ3RoOwogICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQubGVuZ3RoOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvciQxKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kICR7IHRvU3RyaW5nJDEodHlwZU9mKGlucHV0KSkgfSBpbnN0ZWFkLmApOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGVhY2hDaGlsZChmbikgewogICAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgICB9CiAgICAgICAgb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBzZXJpYWxpemUoKSB7CiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2xlbmd0aCddOwogICAgICAgICAgICB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiB7CiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7CiAgICAgICAgfQogICAgfQogICAgdmFyIExlbmd0aCQxID0gTGVuZ3RoOwoKICAgIGNvbnN0IGV4cHJlc3Npb25zID0gewogICAgICAgICc9PSc6IEVxdWFscywKICAgICAgICAnIT0nOiBOb3RFcXVhbHMsCiAgICAgICAgJz4nOiBHcmVhdGVyVGhhbiwKICAgICAgICAnPCc6IExlc3NUaGFuLAogICAgICAgICc+PSc6IEdyZWF0ZXJUaGFuT3JFcXVhbCwKICAgICAgICAnPD0nOiBMZXNzVGhhbk9yRXF1YWwsCiAgICAgICAgJ2FycmF5JzogQXNzZXJ0aW9uJDEsCiAgICAgICAgJ2F0JzogQXQkMSwKICAgICAgICAnYm9vbGVhbic6IEFzc2VydGlvbiQxLAogICAgICAgICdjYXNlJzogQ2FzZSQxLAogICAgICAgICdjb2FsZXNjZSc6IENvYWxlc2NlJDEsCiAgICAgICAgJ2NvbGxhdG9yJzogQ29sbGF0b3JFeHByZXNzaW9uLAogICAgICAgICdmb3JtYXQnOiBGb3JtYXRFeHByZXNzaW9uLAogICAgICAgICdpbWFnZSc6IEltYWdlRXhwcmVzc2lvbiwKICAgICAgICAnaW4nOiBJbiQxLAogICAgICAgICdpbmRleC1vZic6IEluZGV4T2YkMSwKICAgICAgICAnaW50ZXJwb2xhdGUnOiBJbnRlcnBvbGF0ZSQxLAogICAgICAgICdpbnRlcnBvbGF0ZS1oY2wnOiBJbnRlcnBvbGF0ZSQxLAogICAgICAgICdpbnRlcnBvbGF0ZS1sYWInOiBJbnRlcnBvbGF0ZSQxLAogICAgICAgICdsZW5ndGgnOiBMZW5ndGgkMSwKICAgICAgICAnbGV0JzogTGV0JDEsCiAgICAgICAgJ2xpdGVyYWwnOiBMaXRlcmFsJDEsCiAgICAgICAgJ21hdGNoJzogTWF0Y2gkMSwKICAgICAgICAnbnVtYmVyJzogQXNzZXJ0aW9uJDEsCiAgICAgICAgJ251bWJlci1mb3JtYXQnOiBOdW1iZXJGb3JtYXQsCiAgICAgICAgJ29iamVjdCc6IEFzc2VydGlvbiQxLAogICAgICAgICdzbGljZSc6IFNsaWNlJDEsCiAgICAgICAgJ3N0ZXAnOiBTdGVwJDEsCiAgICAgICAgJ3N0cmluZyc6IEFzc2VydGlvbiQxLAogICAgICAgICd0by1ib29sZWFuJzogQ29lcmNpb24kMSwKICAgICAgICAndG8tY29sb3InOiBDb2VyY2lvbiQxLAogICAgICAgICd0by1udW1iZXInOiBDb2VyY2lvbiQxLAogICAgICAgICd0by1zdHJpbmcnOiBDb2VyY2lvbiQxLAogICAgICAgICd2YXInOiBWYXIkMSwKICAgICAgICAnd2l0aGluJzogV2l0aGluJDEKICAgIH07CiAgICBmdW5jdGlvbiByZ2JhKGN0eCwgW3IsIGcsIGIsIGFdKSB7CiAgICAgICAgciA9IHIuZXZhbHVhdGUoY3R4KTsKICAgICAgICBnID0gZy5ldmFsdWF0ZShjdHgpOwogICAgICAgIGIgPSBiLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgY29uc3QgYWxwaGEgPSBhID8gYS5ldmFsdWF0ZShjdHgpIDogMTsKICAgICAgICBjb25zdCBlcnJvciA9IHZhbGlkYXRlUkdCQShyLCBnLCBiLCBhbHBoYSk7CiAgICAgICAgaWYgKGVycm9yKQogICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yJDEoZXJyb3IpOwogICAgICAgIHJldHVybiBuZXcgQ29sb3IkMShyIC8gMjU1ICogYWxwaGEsIGcgLyAyNTUgKiBhbHBoYSwgYiAvIDI1NSAqIGFscGhhLCBhbHBoYSk7CiAgICB9CiAgICBmdW5jdGlvbiBoYXMoa2V5LCBvYmopIHsKICAgICAgICByZXR1cm4ga2V5IGluIG9iajsKICAgIH0KICAgIGZ1bmN0aW9uIGdldChrZXksIG9iaikgewogICAgICAgIGNvbnN0IHYgPSBvYmpba2V5XTsKICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHY7CiAgICB9CiAgICBmdW5jdGlvbiBiaW5hcnlTZWFyY2godiwgYSwgaSwgaikgewogICAgICAgIHdoaWxlIChpIDw9IGopIHsKICAgICAgICAgICAgY29uc3QgbSA9IGkgKyBqID4+IDE7CiAgICAgICAgICAgIGlmIChhW21dID09PSB2KQogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIGlmIChhW21dID4gdikKICAgICAgICAgICAgICAgIGogPSBtIC0gMTsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgaSA9IG0gKyAxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBmdW5jdGlvbiB2YXJhcmdzKHR5cGUpIHsKICAgICAgICByZXR1cm4geyB0eXBlIH07CiAgICB9CiAgICBDb21wb3VuZEV4cHJlc3Npb24kMS5yZWdpc3RlcihleHByZXNzaW9ucywgewogICAgICAgICdlcnJvcic6IFsKICAgICAgICAgICAgRXJyb3JUeXBlLAogICAgICAgICAgICBbU3RyaW5nVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFt2XSkgPT4gewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvciQxKHYuZXZhbHVhdGUoY3R4KSk7CiAgICAgICAgICAgIH0KICAgICAgICBdLAogICAgICAgICd0eXBlb2YnOiBbCiAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgIFtWYWx1ZVR5cGVdLAogICAgICAgICAgICAoY3R4LCBbdl0pID0+IHRvU3RyaW5nJDEodHlwZU9mKHYuZXZhbHVhdGUoY3R4KSkpCiAgICAgICAgXSwKICAgICAgICAndG8tcmdiYSc6IFsKICAgICAgICAgICAgYXJyYXkkMShOdW1iZXJUeXBlLCA0KSwKICAgICAgICAgICAgW0NvbG9yVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFt2XSkgPT4gewogICAgICAgICAgICAgICAgcmV0dXJuIHYuZXZhbHVhdGUoY3R4KS50b0FycmF5KCk7CiAgICAgICAgICAgIH0KICAgICAgICBdLAogICAgICAgICdyZ2InOiBbCiAgICAgICAgICAgIENvbG9yVHlwZSwKICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgICBOdW1iZXJUeXBlCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIHJnYmEKICAgICAgICBdLAogICAgICAgICdyZ2JhJzogWwogICAgICAgICAgICBDb2xvclR5cGUsCiAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgIE51bWJlclR5cGUKICAgICAgICAgICAgXSwKICAgICAgICAgICAgcmdiYQogICAgICAgIF0sCiAgICAgICAgJ2hhcyc6IHsKICAgICAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsCiAgICAgICAgICAgIG92ZXJsb2FkczogWwogICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgIFtTdHJpbmdUeXBlXSwKICAgICAgICAgICAgICAgICAgICAoY3R4LCBba2V5XSkgPT4gaGFzKGtleS5ldmFsdWF0ZShjdHgpLCBjdHgucHJvcGVydGllcygpKQogICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdFR5cGUKICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgIChjdHgsIFtrZXksIG9ial0pID0+IGhhcyhrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpCiAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgIF0KICAgICAgICB9LAogICAgICAgICdnZXQnOiB7CiAgICAgICAgICAgIHR5cGU6IFZhbHVlVHlwZSwKICAgICAgICAgICAgb3ZlcmxvYWRzOiBbCiAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLAogICAgICAgICAgICAgICAgICAgIChjdHgsIFtrZXldKSA9PiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpCiAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0VHlwZQogICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgKGN0eCwgW2tleSwgb2JqXSkgPT4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBvYmouZXZhbHVhdGUoY3R4KSkKICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgXQogICAgICAgIH0sCiAgICAgICAgJ2ZlYXR1cmUtc3RhdGUnOiBbCiAgICAgICAgICAgIFZhbHVlVHlwZSwKICAgICAgICAgICAgW1N0cmluZ1R5cGVdLAogICAgICAgICAgICAoY3R4LCBba2V5XSkgPT4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBjdHguZmVhdHVyZVN0YXRlIHx8IHt9KQogICAgICAgIF0sCiAgICAgICAgJ3Byb3BlcnRpZXMnOiBbCiAgICAgICAgICAgIE9iamVjdFR5cGUsCiAgICAgICAgICAgIFtdLAogICAgICAgICAgICBjdHggPT4gY3R4LnByb3BlcnRpZXMoKQogICAgICAgIF0sCiAgICAgICAgJ2dlb21ldHJ5LXR5cGUnOiBbCiAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgIFtdLAogICAgICAgICAgICBjdHggPT4gY3R4Lmdlb21ldHJ5VHlwZSgpCiAgICAgICAgXSwKICAgICAgICAnaWQnOiBbCiAgICAgICAgICAgIFZhbHVlVHlwZSwKICAgICAgICAgICAgW10sCiAgICAgICAgICAgIGN0eCA9PiBjdHguaWQoKQogICAgICAgIF0sCiAgICAgICAgJ3pvb20nOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtdLAogICAgICAgICAgICBjdHggPT4gY3R4Lmdsb2JhbHMuem9vbQogICAgICAgIF0sCiAgICAgICAgJ3BpdGNoJzogWwogICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICBbXSwKICAgICAgICAgICAgY3R4ID0+IGN0eC5nbG9iYWxzLnBpdGNoIHx8IDAKICAgICAgICBdLAogICAgICAgICdkaXN0YW5jZS1mcm9tLWNlbnRlcic6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgW10sCiAgICAgICAgICAgIGN0eCA9PiBjdHguZGlzdGFuY2VGcm9tQ2VudGVyKCkKICAgICAgICBdLAogICAgICAgICdoZWF0bWFwLWRlbnNpdHknOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtdLAogICAgICAgICAgICBjdHggPT4gY3R4Lmdsb2JhbHMuaGVhdG1hcERlbnNpdHkgfHwgMAogICAgICAgIF0sCiAgICAgICAgJ2xpbmUtcHJvZ3Jlc3MnOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtdLAogICAgICAgICAgICBjdHggPT4gY3R4Lmdsb2JhbHMubGluZVByb2dyZXNzIHx8IDAKICAgICAgICBdLAogICAgICAgICdza3ktcmFkaWFsLXByb2dyZXNzJzogWwogICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICBbXSwKICAgICAgICAgICAgY3R4ID0+IGN0eC5nbG9iYWxzLnNreVJhZGlhbFByb2dyZXNzIHx8IDAKICAgICAgICBdLAogICAgICAgICdhY2N1bXVsYXRlZCc6IFsKICAgICAgICAgICAgVmFsdWVUeXBlLAogICAgICAgICAgICBbXSwKICAgICAgICAgICAgY3R4ID0+IGN0eC5nbG9iYWxzLmFjY3VtdWxhdGVkID09PSB1bmRlZmluZWQgPyBudWxsIDogY3R4Lmdsb2JhbHMuYWNjdW11bGF0ZWQKICAgICAgICBdLAogICAgICAgICcrJzogWwogICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLAogICAgICAgICAgICAoY3R4LCBhcmdzKSA9PiB7CiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDsKICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYXJnLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgICAgICB9CiAgICAgICAgXSwKICAgICAgICAnKic6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSwKICAgICAgICAgICAgKGN0eCwgYXJncykgPT4gewogICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDE7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICo9IGFyZy5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICAgICAgfQogICAgICAgIF0sCiAgICAgICAgJy0nOiB7CiAgICAgICAgICAgIHR5cGU6IE51bWJlclR5cGUsCiAgICAgICAgICAgIG92ZXJsb2FkczogWwogICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZQogICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgKGN0eCwgW2EsIGJdKSA9PiBhLmV2YWx1YXRlKGN0eCkgLSBiLmV2YWx1YXRlKGN0eCkKICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAgICAgICAgIChjdHgsIFthXSkgPT4gLWEuZXZhbHVhdGUoY3R4KQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAnLyc6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgIE51bWJlclR5cGUKICAgICAgICAgICAgXSwKICAgICAgICAgICAgKGN0eCwgW2EsIGJdKSA9PiBhLmV2YWx1YXRlKGN0eCkgLyBiLmV2YWx1YXRlKGN0eCkKICAgICAgICBdLAogICAgICAgICclJzogWwogICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICBbCiAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgTnVtYmVyVHlwZQogICAgICAgICAgICBdLAogICAgICAgICAgICAoY3R4LCBbYSwgYl0pID0+IGEuZXZhbHVhdGUoY3R4KSAlIGIuZXZhbHVhdGUoY3R4KQogICAgICAgIF0sCiAgICAgICAgJ2xuMic6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgW10sCiAgICAgICAgICAgICgpID0+IE1hdGguTE4yCiAgICAgICAgXSwKICAgICAgICAncGknOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtdLAogICAgICAgICAgICAoKSA9PiBNYXRoLlBJCiAgICAgICAgXSwKICAgICAgICAnZSc6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgW10sCiAgICAgICAgICAgICgpID0+IE1hdGguRQogICAgICAgIF0sCiAgICAgICAgJ14nOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgICBOdW1iZXJUeXBlCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIChjdHgsIFtiLCBlXSkgPT4gTWF0aC5wb3coYi5ldmFsdWF0ZShjdHgpLCBlLmV2YWx1YXRlKGN0eCkpCiAgICAgICAgXSwKICAgICAgICAnc3FydCc6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAoY3R4LCBbeF0pID0+IE1hdGguc3FydCh4LmV2YWx1YXRlKGN0eCkpCiAgICAgICAgXSwKICAgICAgICAnbG9nMTAnOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpIC8gTWF0aC5MTjEwCiAgICAgICAgXSwKICAgICAgICAnbG4nOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpCiAgICAgICAgXSwKICAgICAgICAnbG9nMic6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSkgLyBNYXRoLkxOMgogICAgICAgIF0sCiAgICAgICAgJ3Npbic6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguc2luKG4uZXZhbHVhdGUoY3R4KSkKICAgICAgICBdLAogICAgICAgICdjb3MnOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmNvcyhuLmV2YWx1YXRlKGN0eCkpCiAgICAgICAgXSwKICAgICAgICAndGFuJzogWwogICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFtuXSkgPT4gTWF0aC50YW4obi5ldmFsdWF0ZShjdHgpKQogICAgICAgIF0sCiAgICAgICAgJ2FzaW4nOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmFzaW4obi5ldmFsdWF0ZShjdHgpKQogICAgICAgIF0sCiAgICAgICAgJ2Fjb3MnOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmFjb3Mobi5ldmFsdWF0ZShjdHgpKQogICAgICAgIF0sCiAgICAgICAgJ2F0YW4nOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmF0YW4obi5ldmFsdWF0ZShjdHgpKQogICAgICAgIF0sCiAgICAgICAgJ21pbic6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSwKICAgICAgICAgICAgKGN0eCwgYXJncykgPT4gTWF0aC5taW4oLi4uYXJncy5tYXAoYXJnID0+IGFyZy5ldmFsdWF0ZShjdHgpKSkKICAgICAgICBdLAogICAgICAgICdtYXgnOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksCiAgICAgICAgICAgIChjdHgsIGFyZ3MpID0+IE1hdGgubWF4KC4uLmFyZ3MubWFwKGFyZyA9PiBhcmcuZXZhbHVhdGUoY3R4KSkpCiAgICAgICAgXSwKICAgICAgICAnYWJzJzogWwogICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFtuXSkgPT4gTWF0aC5hYnMobi5ldmFsdWF0ZShjdHgpKQogICAgICAgIF0sCiAgICAgICAgJ3JvdW5kJzogWwogICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFtuXSkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgdiA9IG4uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgIHJldHVybiB2IDwgMCA/IC1NYXRoLnJvdW5kKC12KSA6IE1hdGgucm91bmQodik7CiAgICAgICAgICAgIH0KICAgICAgICBdLAogICAgICAgICdmbG9vcic6IFsKICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguZmxvb3Iobi5ldmFsdWF0ZShjdHgpKQogICAgICAgIF0sCiAgICAgICAgJ2NlaWwnOiBbCiAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmNlaWwobi5ldmFsdWF0ZShjdHgpKQogICAgICAgIF0sCiAgICAgICAgJ2ZpbHRlci09PSc6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgXSwKICAgICAgICAgICAgKGN0eCwgW2ssIHZdKSA9PiBjdHgucHJvcGVydGllcygpW2sudmFsdWVdID09PSB2LnZhbHVlCiAgICAgICAgXSwKICAgICAgICAnZmlsdGVyLWlkLT09JzogWwogICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgW1ZhbHVlVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFt2XSkgPT4gY3R4LmlkKCkgPT09IHYudmFsdWUKICAgICAgICBdLAogICAgICAgICdmaWx0ZXItdHlwZS09PSc6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFtTdHJpbmdUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW3ZdKSA9PiBjdHguZ2VvbWV0cnlUeXBlKCkgPT09IHYudmFsdWUKICAgICAgICBdLAogICAgICAgICdmaWx0ZXItPCc6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgXSwKICAgICAgICAgICAgKGN0eCwgW2ssIHZdKSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTsKICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDwgYjsKICAgICAgICAgICAgfQogICAgICAgIF0sCiAgICAgICAgJ2ZpbHRlci1pZC08JzogWwogICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgW1ZhbHVlVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFt2XSkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgYSA9IGN0eC5pZCgpOwogICAgICAgICAgICAgICAgY29uc3QgYiA9IHYudmFsdWU7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPCBiOwogICAgICAgICAgICB9CiAgICAgICAgXSwKICAgICAgICAnZmlsdGVyLT4nOiBbCiAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICBbCiAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgVmFsdWVUeXBlCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIChjdHgsIFtrLCB2XSkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07CiAgICAgICAgICAgICAgICBjb25zdCBiID0gdi52YWx1ZTsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+IGI7CiAgICAgICAgICAgIH0KICAgICAgICBdLAogICAgICAgICdmaWx0ZXItaWQtPic6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFtWYWx1ZVR5cGVdLAogICAgICAgICAgICAoY3R4LCBbdl0pID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjdHguaWQoKTsKICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID4gYjsKICAgICAgICAgICAgfQogICAgICAgIF0sCiAgICAgICAgJ2ZpbHRlci08PSc6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgXSwKICAgICAgICAgICAgKGN0eCwgW2ssIHZdKSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTsKICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDw9IGI7CiAgICAgICAgICAgIH0KICAgICAgICBdLAogICAgICAgICdmaWx0ZXItaWQtPD0nOiBbCiAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICBbVmFsdWVUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW3ZdKSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBhID0gY3R4LmlkKCk7CiAgICAgICAgICAgICAgICBjb25zdCBiID0gdi52YWx1ZTsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8PSBiOwogICAgICAgICAgICB9CiAgICAgICAgXSwKICAgICAgICAnZmlsdGVyLT49JzogWwogICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgIFZhbHVlVHlwZQogICAgICAgICAgICBdLAogICAgICAgICAgICAoY3R4LCBbaywgdl0pID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjdHgucHJvcGVydGllcygpW2sudmFsdWVdOwogICAgICAgICAgICAgICAgY29uc3QgYiA9IHYudmFsdWU7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPj0gYjsKICAgICAgICAgICAgfQogICAgICAgIF0sCiAgICAgICAgJ2ZpbHRlci1pZC0+PSc6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFtWYWx1ZVR5cGVdLAogICAgICAgICAgICAoY3R4LCBbdl0pID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjdHguaWQoKTsKICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID49IGI7CiAgICAgICAgICAgIH0KICAgICAgICBdLAogICAgICAgICdmaWx0ZXItaGFzJzogWwogICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgW1ZhbHVlVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFtrXSkgPT4gay52YWx1ZSBpbiBjdHgucHJvcGVydGllcygpCiAgICAgICAgXSwKICAgICAgICAnZmlsdGVyLWhhcy1pZCc6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFtdLAogICAgICAgICAgICBjdHggPT4gY3R4LmlkKCkgIT09IG51bGwgJiYgY3R4LmlkKCkgIT09IHVuZGVmaW5lZAogICAgICAgIF0sCiAgICAgICAgJ2ZpbHRlci10eXBlLWluJzogWwogICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgW2FycmF5JDEoU3RyaW5nVHlwZSldLAogICAgICAgICAgICAoY3R4LCBbdl0pID0+IHYudmFsdWUuaW5kZXhPZihjdHguZ2VvbWV0cnlUeXBlKCkpID49IDAKICAgICAgICBdLAogICAgICAgICdmaWx0ZXItaWQtaW4nOiBbCiAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICBbYXJyYXkkMShWYWx1ZVR5cGUpXSwKICAgICAgICAgICAgKGN0eCwgW3ZdKSA9PiB2LnZhbHVlLmluZGV4T2YoY3R4LmlkKCkpID49IDAKICAgICAgICBdLAogICAgICAgICdmaWx0ZXItaW4tc21hbGwnOiBbCiAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICBbCiAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgYXJyYXkkMShWYWx1ZVR5cGUpCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIChjdHgsIFtrLCB2XSkgPT4gdi52YWx1ZS5pbmRleE9mKGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0pID49IDAKICAgICAgICBdLAogICAgICAgICdmaWx0ZXItaW4tbGFyZ2UnOiBbCiAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICBbCiAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgYXJyYXkkMShWYWx1ZVR5cGUpCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIChjdHgsIFtrLCB2XSkgPT4gYmluYXJ5U2VhcmNoKGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0sIHYudmFsdWUsIDAsIHYudmFsdWUubGVuZ3RoIC0gMSkKICAgICAgICBdLAogICAgICAgICdhbGwnOiB7CiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLAogICAgICAgICAgICBvdmVybG9hZHM6IFsKICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZQogICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgKGN0eCwgW2EsIGJdKSA9PiBhLmV2YWx1YXRlKGN0eCkgJiYgYi5ldmFsdWF0ZShjdHgpCiAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgIHZhcmFyZ3MoQm9vbGVhblR5cGUpLAogICAgICAgICAgICAgICAgICAgIChjdHgsIGFyZ3MpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcuZXZhbHVhdGUoY3R4KSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAnYW55JzogewogICAgICAgICAgICB0eXBlOiBCb29sZWFuVHlwZSwKICAgICAgICAgICAgb3ZlcmxvYWRzOiBbCiAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUKICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgIChjdHgsIFthLCBiXSkgPT4gYS5ldmFsdWF0ZShjdHgpIHx8IGIuZXZhbHVhdGUoY3R4KQogICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICB2YXJhcmdzKEJvb2xlYW5UeXBlKSwKICAgICAgICAgICAgICAgICAgICAoY3R4LCBhcmdzKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcuZXZhbHVhdGUoY3R4KSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICBdCiAgICAgICAgfSwKICAgICAgICAnISc6IFsKICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgIFtCb29sZWFuVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFtiXSkgPT4gIWIuZXZhbHVhdGUoY3R4KQogICAgICAgIF0sCiAgICAgICAgJ2lzLXN1cHBvcnRlZC1zY3JpcHQnOiBbCiAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICBbU3RyaW5nVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFtzXSkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgaXNTdXBwb3J0ZWRTY3JpcHQgPSBjdHguZ2xvYmFscyAmJiBjdHguZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDsKICAgICAgICAgICAgICAgIGlmIChpc1N1cHBvcnRlZFNjcmlwdCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZFNjcmlwdChzLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICBdLAogICAgICAgICd1cGNhc2UnOiBbCiAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgIFtTdHJpbmdUeXBlXSwKICAgICAgICAgICAgKGN0eCwgW3NdKSA9PiBzLmV2YWx1YXRlKGN0eCkudG9VcHBlckNhc2UoKQogICAgICAgIF0sCiAgICAgICAgJ2Rvd25jYXNlJzogWwogICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICBbU3RyaW5nVHlwZV0sCiAgICAgICAgICAgIChjdHgsIFtzXSkgPT4gcy5ldmFsdWF0ZShjdHgpLnRvTG93ZXJDYXNlKCkKICAgICAgICBdLAogICAgICAgICdjb25jYXQnOiBbCiAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgIHZhcmFyZ3MoVmFsdWVUeXBlKSwKICAgICAgICAgICAgKGN0eCwgYXJncykgPT4gYXJncy5tYXAoYXJnID0+IHRvU3RyaW5nKGFyZy5ldmFsdWF0ZShjdHgpKSkuam9pbignJykKICAgICAgICBdLAogICAgICAgICdyZXNvbHZlZC1sb2NhbGUnOiBbCiAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgIFtDb2xsYXRvclR5cGVdLAogICAgICAgICAgICAoY3R4LCBbY29sbGF0b3JdKSA9PiBjb2xsYXRvci5ldmFsdWF0ZShjdHgpLnJlc29sdmVkTG9jYWxlKCkKICAgICAgICBdCiAgICB9KTsKICAgIHZhciBkZWZpbml0aW9ucyA9IGV4cHJlc3Npb25zOwoKICAgIGZ1bmN0aW9uIHN1Y2Nlc3ModmFsdWUpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJywKICAgICAgICAgICAgdmFsdWUKICAgICAgICB9OwogICAgfQogICAgZnVuY3Rpb24gZXJyb3IodmFsdWUpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgICByZXN1bHQ6ICdlcnJvcicsCiAgICAgICAgICAgIHZhbHVlCiAgICAgICAgfTsKICAgIH0KCiAgICBmdW5jdGlvbiBzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihzcGVjKSB7CiAgICAgICAgcmV0dXJuIHNwZWNbJ3Byb3BlcnR5LXR5cGUnXSA9PT0gJ2RhdGEtZHJpdmVuJyB8fCBzcGVjWydwcm9wZXJ0eS10eXBlJ10gPT09ICdjcm9zcy1mYWRlZC1kYXRhLWRyaXZlbic7CiAgICB9CiAgICBmdW5jdGlvbiBzdXBwb3J0c1pvb21FeHByZXNzaW9uKHNwZWMpIHsKICAgICAgICByZXR1cm4gISFzcGVjLmV4cHJlc3Npb24gJiYgc3BlYy5leHByZXNzaW9uLnBhcmFtZXRlcnMuaW5kZXhPZignem9vbScpID4gLTE7CiAgICB9CiAgICBmdW5jdGlvbiBzdXBwb3J0c0ludGVycG9sYXRpb24oc3BlYykgewogICAgICAgIHJldHVybiAhIXNwZWMuZXhwcmVzc2lvbiAmJiBzcGVjLmV4cHJlc3Npb24uaW50ZXJwb2xhdGVkOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldFR5cGUodmFsKSB7CiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikgewogICAgICAgICAgICByZXR1cm4gJ251bWJlcic7CiAgICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTdHJpbmcpIHsKICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnOwogICAgICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm9vbGVhbikgewogICAgICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nOwogICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7CiAgICAgICAgICAgIHJldHVybiAnYXJyYXknOwogICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7CiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWw7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsKICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7CiAgICB9CiAgICBmdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKHgpIHsKICAgICAgICByZXR1cm4geDsKICAgIH0KICAgIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykgewogICAgICAgIGNvbnN0IGlzQ29sb3IgPSBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJzsKICAgICAgICBjb25zdCB6b29tQW5kRmVhdHVyZURlcGVuZGVudCA9IHBhcmFtZXRlcnMuc3RvcHMgJiYgdHlwZW9mIHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0gPT09ICdvYmplY3QnOwogICAgICAgIGNvbnN0IGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7CiAgICAgICAgY29uc3Qgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50OwogICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbWV0ZXJzLnR5cGUgfHwgKHN1cHBvcnRzSW50ZXJwb2xhdGlvbihwcm9wZXJ0eVNwZWMpID8gJ2V4cG9uZW50aWFsJyA6ICdpbnRlcnZhbCcpOwogICAgICAgIGlmIChpc0NvbG9yKSB7CiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBleHRlbmQoe30sIHBhcmFtZXRlcnMpOwogICAgICAgICAgICBpZiAocGFyYW1ldGVycy5zdG9wcykgewogICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zdG9wcyA9IHBhcmFtZXRlcnMuc3RvcHMubWFwKHN0b3AgPT4gewogICAgICAgICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BbMF0sCiAgICAgICAgICAgICAgICAgICAgICAgIENvbG9yJDEucGFyc2Uoc3RvcFsxXSkKICAgICAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZGVmYXVsdCkgewogICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0ID0gQ29sb3IkMS5wYXJzZShwYXJhbWV0ZXJzLmRlZmF1bHQpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0ID0gQ29sb3IkMS5wYXJzZShwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InICYmICFjb2xvclNwYWNlc1twYXJhbWV0ZXJzLmNvbG9yU3BhY2VdKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb2xvciBzcGFjZTogJHsgcGFyYW1ldGVycy5jb2xvclNwYWNlIH1gKTsKICAgICAgICB9CiAgICAgICAgbGV0IGlubmVyRnVuOwogICAgICAgIGxldCBoYXNoZWRTdG9wczsKICAgICAgICBsZXQgY2F0ZWdvcmljYWxLZXlUeXBlOwogICAgICAgIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7CiAgICAgICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykgewogICAgICAgICAgICBpbm5lckZ1biA9IGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbjsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXRlZ29yaWNhbCcpIHsKICAgICAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb247CiAgICAgICAgICAgIGhhc2hlZFN0b3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgICAgICAgICAgZm9yIChjb25zdCBzdG9wIG9mIHBhcmFtZXRlcnMuc3RvcHMpIHsKICAgICAgICAgICAgICAgIGhhc2hlZFN0b3BzW3N0b3BbMF1dID0gc3RvcFsxXTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXRlZ29yaWNhbEtleVR5cGUgPSB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZGVudGl0eScpIHsKICAgICAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb247CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZ1bmN0aW9uIHR5cGUgIiR7IHR5cGUgfSJgKTsKICAgICAgICB9CiAgICAgICAgaWYgKHpvb21BbmRGZWF0dXJlRGVwZW5kZW50KSB7CiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVGdW5jdGlvbnMgPSB7fTsKICAgICAgICAgICAgY29uc3Qgem9vbVN0b3BzID0gW107CiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7IHMrKykgewogICAgICAgICAgICAgICAgY29uc3Qgc3RvcCA9IHBhcmFtZXRlcnMuc3RvcHNbc107CiAgICAgICAgICAgICAgICBjb25zdCB6b29tID0gc3RvcFswXS56b29tOwogICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvbnNbem9vbV0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20sCiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtZXRlcnMudHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcmFtZXRlcnMucHJvcGVydHksCiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHBhcmFtZXRlcnMuZGVmYXVsdCwKICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHM6IFtdCiAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICB6b29tU3RvcHMucHVzaCh6b29tKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0uc3RvcHMucHVzaChbCiAgICAgICAgICAgICAgICAgICAgc3RvcFswXS52YWx1ZSwKICAgICAgICAgICAgICAgICAgICBzdG9wWzFdCiAgICAgICAgICAgICAgICBdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBmZWF0dXJlRnVuY3Rpb25TdG9wcyA9IFtdOwogICAgICAgICAgICBmb3IgKGNvbnN0IHogb2Ygem9vbVN0b3BzKSB7CiAgICAgICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wcy5wdXNoKFsKICAgICAgICAgICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25zW3pdLnpvb20sCiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uc1t6XSwgcHJvcGVydHlTcGVjKQogICAgICAgICAgICAgICAgXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvblR5cGUgPSB7IG5hbWU6ICdsaW5lYXInIH07CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICBraW5kOiAnY29tcG9zaXRlJywKICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25UeXBlLAogICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUkMS5pbnRlcnBvbGF0aW9uRmFjdG9yLmJpbmQodW5kZWZpbmVkLCBpbnRlcnBvbGF0aW9uVHlwZSksCiAgICAgICAgICAgICAgICB6b29tU3RvcHM6IGZlYXR1cmVGdW5jdGlvblN0b3BzLm1hcChzID0+IHNbMF0pLAogICAgICAgICAgICAgICAgZXZhbHVhdGUoe3pvb219LCBwcm9wZXJ0aWVzKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbih7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BzOiBmZWF0dXJlRnVuY3Rpb25TdG9wcywKICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTogcGFyYW1ldGVycy5iYXNlCiAgICAgICAgICAgICAgICAgICAgfSwgcHJvcGVydHlTcGVjLCB6b29tKS5ldmFsdWF0ZSh6b29tLCBwcm9wZXJ0aWVzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHsKICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvblR5cGUgPSB0eXBlID09PSAnZXhwb25lbnRpYWwnID8gewogICAgICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJywKICAgICAgICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMQogICAgICAgICAgICB9IDogbnVsbDsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIGtpbmQ6ICdjYW1lcmEnLAogICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGUsCiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uRmFjdG9yOiBJbnRlcnBvbGF0ZSQxLmludGVycG9sYXRpb25GYWN0b3IuYmluZCh1bmRlZmluZWQsIGludGVycG9sYXRpb25UeXBlKSwKICAgICAgICAgICAgICAgIHpvb21TdG9wczogcGFyYW1ldGVycy5zdG9wcy5tYXAocyA9PiBzWzBdKSwKICAgICAgICAgICAgICAgIGV2YWx1YXRlOiAoe3pvb219KSA9PiBpbm5lckZ1bihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHpvb20sIGhhc2hlZFN0b3BzLCBjYXRlZ29yaWNhbEtleVR5cGUpCiAgICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIGtpbmQ6ICdzb3VyY2UnLAogICAgICAgICAgICAgICAgZXZhbHVhdGUoXywgZmVhdHVyZSkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmVhdHVyZSAmJiBmZWF0dXJlLnByb3BlcnRpZXMgPyBmZWF0dXJlLnByb3BlcnRpZXNbcGFyYW1ldGVycy5wcm9wZXJ0eV0gOiB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvYWxlc2NlJDEocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckZ1bihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHZhbHVlLCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBjb2FsZXNjZSQxKGEsIGIsIGMpIHsKICAgICAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKQogICAgICAgICAgICByZXR1cm4gYTsKICAgICAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKQogICAgICAgICAgICByZXR1cm4gYjsKICAgICAgICBpZiAoYyAhPT0gdW5kZWZpbmVkKQogICAgICAgICAgICByZXR1cm4gYzsKICAgIH0KICAgIGZ1bmN0aW9uIGV2YWx1YXRlQ2F0ZWdvcmljYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0LCBoYXNoZWRTdG9wcywga2V5VHlwZSkgewogICAgICAgIGNvbnN0IGV2YWx1YXRlZCA9IHR5cGVvZiBpbnB1dCA9PT0ga2V5VHlwZSA/IGhhc2hlZFN0b3BzW2lucHV0XSA6IHVuZGVmaW5lZDsKICAgICAgICByZXR1cm4gY29hbGVzY2UkMShldmFsdWF0ZWQsIHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpOwogICAgfQogICAgZnVuY3Rpb24gZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHsKICAgICAgICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKQogICAgICAgICAgICByZXR1cm4gY29hbGVzY2UkMShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTsKICAgICAgICBjb25zdCBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7CiAgICAgICAgaWYgKG4gPT09IDEpCiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdOwogICAgICAgIGlmIChpbnB1dCA8PSBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdKQogICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTsKICAgICAgICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pCiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVsxXTsKICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8ocGFyYW1ldGVycy5zdG9wcy5tYXAoc3RvcCA9PiBzdG9wWzBdKSwgaW5wdXQpOwogICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTsKICAgIH0KICAgIGZ1bmN0aW9uIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7CiAgICAgICAgY29uc3QgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTsKICAgICAgICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKQogICAgICAgICAgICByZXR1cm4gY29hbGVzY2UkMShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTsKICAgICAgICBjb25zdCBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7CiAgICAgICAgaWYgKG4gPT09IDEpCiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdOwogICAgICAgIGlmIChpbnB1dCA8PSBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdKQogICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTsKICAgICAgICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pCiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVsxXTsKICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8ocGFyYW1ldGVycy5zdG9wcy5tYXAoc3RvcCA9PiBzdG9wWzBdKSwgaW5wdXQpOwogICAgICAgIGNvbnN0IHQgPSBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBiYXNlLCBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVswXSwgcGFyYW1ldGVycy5zdG9wc1tpbmRleCArIDFdWzBdKTsKICAgICAgICBjb25zdCBvdXRwdXRMb3dlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdOwogICAgICAgIGNvbnN0IG91dHB1dFVwcGVyID0gcGFyYW1ldGVycy5zdG9wc1tpbmRleCArIDFdWzFdOwogICAgICAgIGxldCBpbnRlcnAgPSBpbnRlcnBvbGF0ZVtwcm9wZXJ0eVNwZWMudHlwZV0gfHwgaWRlbnRpdHlGdW5jdGlvbjsKICAgICAgICBpZiAocGFyYW1ldGVycy5jb2xvclNwYWNlICYmIHBhcmFtZXRlcnMuY29sb3JTcGFjZSAhPT0gJ3JnYicpIHsKICAgICAgICAgICAgY29uc3QgY29sb3JzcGFjZSA9IGNvbG9yU3BhY2VzW3BhcmFtZXRlcnMuY29sb3JTcGFjZV07CiAgICAgICAgICAgIGludGVycCA9IChhLCBiKSA9PiBjb2xvcnNwYWNlLnJldmVyc2UoY29sb3JzcGFjZS5pbnRlcnBvbGF0ZShjb2xvcnNwYWNlLmZvcndhcmQoYSksIGNvbG9yc3BhY2UuZm9yd2FyZChiKSwgdCkpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIG91dHB1dExvd2VyLmV2YWx1YXRlID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICBldmFsdWF0ZSguLi5hcmdzKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZhbHVhdGVkTG93ZXIgPSBvdXRwdXRMb3dlci5ldmFsdWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRlZFVwcGVyID0gb3V0cHV0VXBwZXIuZXZhbHVhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsKICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGVkTG93ZXIgPT09IHVuZGVmaW5lZCB8fCBldmFsdWF0ZWRVcHBlciA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnAoZXZhbHVhdGVkTG93ZXIsIGV2YWx1YXRlZFVwcGVyLCB0KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGludGVycChvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpOwogICAgfQogICAgZnVuY3Rpb24gZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHsKICAgICAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicpIHsKICAgICAgICAgICAgaW5wdXQgPSBDb2xvciQxLnBhcnNlKGlucHV0KTsKICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnZm9ybWF0dGVkJykgewogICAgICAgICAgICBpbnB1dCA9IEZvcm1hdHRlZC5mcm9tU3RyaW5nKGlucHV0LnRvU3RyaW5nKCkpOwogICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdyZXNvbHZlZEltYWdlJykgewogICAgICAgICAgICBpbnB1dCA9IFJlc29sdmVkSW1hZ2UuZnJvbVN0cmluZyhpbnB1dC50b1N0cmluZygpKTsKICAgICAgICB9IGVsc2UgaWYgKGdldFR5cGUoaW5wdXQpICE9PSBwcm9wZXJ0eVNwZWMudHlwZSAmJiAocHJvcGVydHlTcGVjLnR5cGUgIT09ICdlbnVtJyB8fCAhcHJvcGVydHlTcGVjLnZhbHVlc1tpbnB1dF0pKSB7CiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY29hbGVzY2UkMShpbnB1dCwgcGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7CiAgICB9CiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7CiAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlOwogICAgICAgIGNvbnN0IHByb2dyZXNzID0gaW5wdXQgLSBsb3dlclZhbHVlOwogICAgICAgIGlmIChkaWZmZXJlbmNlID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0gZWxzZSBpZiAoYmFzZSA9PT0gMSkgewogICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3MgLyBkaWZmZXJlbmNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiAoTWF0aC5wb3coYmFzZSwgcHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgZGlmZmVyZW5jZSkgLSAxKTsKICAgICAgICB9CiAgICB9CgogICAgY2xhc3MgU3R5bGVFeHByZXNzaW9uIHsKICAgICAgICBjb25zdHJ1Y3RvcihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHsKICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjsKICAgICAgICAgICAgdGhpcy5fd2FybmluZ0hpc3RvcnkgPSB7fTsKICAgICAgICAgICAgdGhpcy5fZXZhbHVhdG9yID0gbmV3IEV2YWx1YXRpb25Db250ZXh0JDEoKTsKICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gcHJvcGVydHlTcGVjID8gZ2V0RGVmYXVsdFZhbHVlKHByb3BlcnR5U3BlYykgOiBudWxsOwogICAgICAgICAgICB0aGlzLl9lbnVtVmFsdWVzID0gcHJvcGVydHlTcGVjICYmIHByb3BlcnR5U3BlYy50eXBlID09PSAnZW51bScgPyBwcm9wZXJ0eVNwZWMudmFsdWVzIDogbnVsbDsKICAgICAgICB9CiAgICAgICAgZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uLCBmZWF0dXJlVGlsZUNvb3JkLCBmZWF0dXJlRGlzdGFuY2VEYXRhKSB7CiAgICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5nbG9iYWxzID0gZ2xvYmFsczsKICAgICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlOwogICAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gZmVhdHVyZVN0YXRlOwogICAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gY2Fub25pY2FsIHx8IG51bGw7CiAgICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5hdmFpbGFibGVJbWFnZXMgPSBhdmFpbGFibGVJbWFnZXMgfHwgbnVsbDsKICAgICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZvcm1hdHRlZFNlY3Rpb24gPSBmb3JtYXR0ZWRTZWN0aW9uOwogICAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVRpbGVDb29yZCA9IGZlYXR1cmVUaWxlQ29vcmQgfHwgbnVsbDsKICAgICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVEaXN0YW5jZURhdGEgPSBmZWF0dXJlRGlzdGFuY2VEYXRhIHx8IG51bGw7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTsKICAgICAgICB9CiAgICAgICAgZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbiwgZmVhdHVyZVRpbGVDb29yZCwgZmVhdHVyZURpc3RhbmNlRGF0YSkgewogICAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGdsb2JhbHM7CiAgICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZmVhdHVyZSB8fCBudWxsOwogICAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gZmVhdHVyZVN0YXRlIHx8IG51bGw7CiAgICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWwgfHwgbnVsbDsKICAgICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsOwogICAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb24gfHwgbnVsbDsKICAgICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVUaWxlQ29vcmQgPSBmZWF0dXJlVGlsZUNvb3JkIHx8IG51bGw7CiAgICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlRGlzdGFuY2VEYXRhID0gZmVhdHVyZURpc3RhbmNlRGF0YSB8fCBudWxsOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7CiAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCAhPT0gdmFsKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbnVtVmFsdWVzICYmICEodmFsIGluIHRoaXMuX2VudW1WYWx1ZXMpKSB7CiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvciQxKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBvbmUgb2YgJHsgT2JqZWN0LmtleXModGhpcy5fZW51bVZhbHVlcykubWFwKHYgPT4gSlNPTi5zdHJpbmdpZnkodikpLmpvaW4oJywgJykgfSwgYnV0IGZvdW5kICR7IEpTT04uc3RyaW5naWZ5KHZhbCkgfSBpbnN0ZWFkLmApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93YXJuaW5nSGlzdG9yeVtlLm1lc3NhZ2VdKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2FybmluZ0hpc3RvcnlbZS5tZXNzYWdlXSA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZS5tZXNzYWdlKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uJDEoZXhwcmVzc2lvbikgewogICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGV4cHJlc3Npb24pICYmIGV4cHJlc3Npb24ubGVuZ3RoID4gMCAmJiB0eXBlb2YgZXhwcmVzc2lvblswXSA9PT0gJ3N0cmluZycgJiYgZXhwcmVzc2lvblswXSBpbiBkZWZpbml0aW9uczsKICAgIH0KICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7CiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNpbmdDb250ZXh0JDEoZGVmaW5pdGlvbnMsIFtdLCBwcm9wZXJ0eVNwZWMgPyBnZXRFeHBlY3RlZFR5cGUocHJvcGVydHlTcGVjKSA6IHVuZGVmaW5lZCk7CiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlKGV4cHJlc3Npb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyB7IHR5cGVBbm5vdGF0aW9uOiAnY29lcmNlJyB9IDogdW5kZWZpbmVkKTsKICAgICAgICBpZiAoIXBhcnNlZCkgewogICAgICAgICAgICByZXR1cm4gZXJyb3IocGFyc2VyLmVycm9ycyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzdWNjZXNzKG5ldyBTdHlsZUV4cHJlc3Npb24ocGFyc2VkLCBwcm9wZXJ0eVNwZWMpKTsKICAgIH0KICAgIGNsYXNzIFpvb21Db25zdGFudEV4cHJlc3Npb24gewogICAgICAgIGNvbnN0cnVjdG9yKGtpbmQsIGV4cHJlc3Npb24pIHsKICAgICAgICAgICAgdGhpcy5raW5kID0ga2luZDsKICAgICAgICAgICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjsKICAgICAgICAgICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NvbnN0YW50JyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb24uZXhwcmVzc2lvbik7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTsKICAgICAgICB9CiAgICB9CiAgICBjbGFzcyBab29tRGVwZW5kZW50RXhwcmVzc2lvbiB7CiAgICAgICAgY29uc3RydWN0b3Ioa2luZCwgZXhwcmVzc2lvbiwgem9vbVN0b3BzLCBpbnRlcnBvbGF0aW9uVHlwZSkgewogICAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kOwogICAgICAgICAgICB0aGlzLnpvb21TdG9wcyA9IHpvb21TdG9wczsKICAgICAgICAgICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjsKICAgICAgICAgICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NhbWVyYScgJiYgIWlzU3RhdGVDb25zdGFudChleHByZXNzaW9uLmV4cHJlc3Npb24pOwogICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID0gaW50ZXJwb2xhdGlvblR5cGU7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7CiAgICAgICAgfQogICAgICAgIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTsKICAgICAgICB9CiAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcihpbnB1dCwgbG93ZXIsIHVwcGVyKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb25UeXBlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gSW50ZXJwb2xhdGUkMS5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvblR5cGUsIGlucHV0LCBsb3dlciwgdXBwZXIpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7CiAgICAgICAgZXhwcmVzc2lvbiA9IGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKTsKICAgICAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHsKICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247CiAgICAgICAgfQogICAgICAgIGNvbnN0IHBhcnNlZCA9IGV4cHJlc3Npb24udmFsdWUuZXhwcmVzc2lvbjsKICAgICAgICBjb25zdCBpc0ZlYXR1cmVDb25zdGFudCQxID0gaXNGZWF0dXJlQ29uc3RhbnQocGFyc2VkKTsKICAgICAgICBpZiAoIWlzRmVhdHVyZUNvbnN0YW50JDEgJiYgIXN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHByb3BlcnR5U3BlYykpIHsKICAgICAgICAgICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yJDIoJycsICdkYXRhIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWQnKV0pOwogICAgICAgIH0KICAgICAgICBjb25zdCBpc1pvb21Db25zdGFudCA9IGlzR2xvYmFsUHJvcGVydHlDb25zdGFudChwYXJzZWQsIFsKICAgICAgICAgICAgJ3pvb20nLAogICAgICAgICAgICAncGl0Y2gnLAogICAgICAgICAgICAnZGlzdGFuY2UtZnJvbS1jZW50ZXInCiAgICAgICAgXSk7CiAgICAgICAgaWYgKCFpc1pvb21Db25zdGFudCAmJiAhc3VwcG9ydHNab29tRXhwcmVzc2lvbihwcm9wZXJ0eVNwZWMpKSB7CiAgICAgICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvciQyKCcnLCAnem9vbSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkJyldKTsKICAgICAgICB9CiAgICAgICAgY29uc3Qgem9vbUN1cnZlID0gZmluZFpvb21DdXJ2ZShwYXJzZWQpOwogICAgICAgIGlmICghem9vbUN1cnZlICYmICFpc1pvb21Db25zdGFudCkgewogICAgICAgICAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IkMignJywgJyJ6b29tIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgInN0ZXAiIG9yICJpbnRlcnBvbGF0ZSIgZXhwcmVzc2lvbi4nKV0pOwogICAgICAgIH0gZWxzZSBpZiAoem9vbUN1cnZlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yJDIpIHsKICAgICAgICAgICAgcmV0dXJuIGVycm9yKFt6b29tQ3VydmVdKTsKICAgICAgICB9IGVsc2UgaWYgKHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlJDEgJiYgIXN1cHBvcnRzSW50ZXJwb2xhdGlvbihwcm9wZXJ0eVNwZWMpKSB7CiAgICAgICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvciQyKCcnLCAnImludGVycG9sYXRlIiBleHByZXNzaW9ucyBjYW5ub3QgYmUgdXNlZCB3aXRoIHRoaXMgcHJvcGVydHknKV0pOwogICAgICAgIH0KICAgICAgICBpZiAoIXpvb21DdXJ2ZSkgewogICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyhpc0ZlYXR1cmVDb25zdGFudCQxID8gbmV3IFpvb21Db25zdGFudEV4cHJlc3Npb24oJ2NvbnN0YW50JywgZXhwcmVzc2lvbi52YWx1ZSkgOiBuZXcgWm9vbUNvbnN0YW50RXhwcmVzc2lvbignc291cmNlJywgZXhwcmVzc2lvbi52YWx1ZSkpOwogICAgICAgIH0KICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uVHlwZSA9IHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlJDEgPyB6b29tQ3VydmUuaW50ZXJwb2xhdGlvbiA6IHVuZGVmaW5lZDsKICAgICAgICByZXR1cm4gc3VjY2Vzcyhpc0ZlYXR1cmVDb25zdGFudCQxID8gbmV3IFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKCdjYW1lcmEnLCBleHByZXNzaW9uLnZhbHVlLCB6b29tQ3VydmUubGFiZWxzLCBpbnRlcnBvbGF0aW9uVHlwZSkgOiBuZXcgWm9vbURlcGVuZGVudEV4cHJlc3Npb24oJ2NvbXBvc2l0ZScsIGV4cHJlc3Npb24udmFsdWUsIHpvb21DdXJ2ZS5sYWJlbHMsIGludGVycG9sYXRpb25UeXBlKSk7CiAgICB9CiAgICBjbGFzcyBTdHlsZVByb3BlcnR5RnVuY3Rpb24gewogICAgICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIHNwZWNpZmljYXRpb24pIHsKICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7CiAgICAgICAgICAgIHRoaXMuX3NwZWNpZmljYXRpb24gPSBzcGVjaWZpY2F0aW9uOwogICAgICAgICAgICBleHRlbmQodGhpcywgY3JlYXRlRnVuY3Rpb24odGhpcy5fcGFyYW1ldGVycywgdGhpcy5fc3BlY2lmaWNhdGlvbikpOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFN0eWxlUHJvcGVydHlGdW5jdGlvbihzZXJpYWxpemVkLl9wYXJhbWV0ZXJzLCBzZXJpYWxpemVkLl9zcGVjaWZpY2F0aW9uKTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgX3BhcmFtZXRlcnM6IGlucHV0Ll9wYXJhbWV0ZXJzLAogICAgICAgICAgICAgICAgX3NwZWNpZmljYXRpb246IGlucHV0Ll9zcGVjaWZpY2F0aW9uCiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKSB7CiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTsKICAgICAgICB9IGVsc2UgaWYgKGlzRXhwcmVzc2lvbiQxKHZhbHVlKSkgewogICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTsKICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwcmVzc2lvbi52YWx1ZS5tYXAoZXJyID0+IGAkeyBlcnIua2V5IH06ICR7IGVyci5tZXNzYWdlIH1gKS5qb2luKCcsICcpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi52YWx1ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBsZXQgY29uc3RhbnQgPSB2YWx1ZTsKICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgc3BlY2lmaWNhdGlvbi50eXBlID09PSAnY29sb3InKSB7CiAgICAgICAgICAgICAgICBjb25zdGFudCA9IENvbG9yJDEucGFyc2UodmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICBraW5kOiAnY29uc3RhbnQnLAogICAgICAgICAgICAgICAgZXZhbHVhdGU6ICgpID0+IGNvbnN0YW50CiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZmluZFpvb21DdXJ2ZShleHByZXNzaW9uKSB7CiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7CiAgICAgICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBMZXQkMSkgewogICAgICAgICAgICByZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24ucmVzdWx0KTsKICAgICAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2FsZXNjZSQxKSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGV4cHJlc3Npb24uYXJncykgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gZmluZFpvb21DdXJ2ZShhcmcpOwogICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICgoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0ZXAkMSB8fCBleHByZXNzaW9uIGluc3RhbmNlb2YgSW50ZXJwb2xhdGUkMSkgJiYgZXhwcmVzc2lvbi5pbnB1dCBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiQxICYmIGV4cHJlc3Npb24uaW5wdXQubmFtZSA9PT0gJ3pvb20nKSB7CiAgICAgICAgICAgIHJlc3VsdCA9IGV4cHJlc3Npb247CiAgICAgICAgfQogICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IkMikgewogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICBleHByZXNzaW9uLmVhY2hDaGlsZChjaGlsZCA9PiB7CiAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVzdWx0ID0gZmluZFpvb21DdXJ2ZShjaGlsZCk7CiAgICAgICAgICAgIGlmIChjaGlsZFJlc3VsdCBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvciQyKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBjaGlsZFJlc3VsdDsKICAgICAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0ICYmIGNoaWxkUmVzdWx0KSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgUGFyc2luZ0Vycm9yJDIoJycsICciem9vbSIgZXhwcmVzc2lvbiBtYXkgb25seSBiZSB1c2VkIGFzIGlucHV0IHRvIGEgdG9wLWxldmVsICJzdGVwIiBvciAiaW50ZXJwb2xhdGUiIGV4cHJlc3Npb24uJyk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICYmIGNoaWxkUmVzdWx0ICYmIHJlc3VsdCAhPT0gY2hpbGRSZXN1bHQpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBQYXJzaW5nRXJyb3IkMignJywgJ09ubHkgb25lIHpvb20tYmFzZWQgInN0ZXAiIG9yICJpbnRlcnBvbGF0ZSIgc3ViZXhwcmVzc2lvbiBtYXkgYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uLicpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIGZ1bmN0aW9uIGdldEV4cGVjdGVkVHlwZShzcGVjKSB7CiAgICAgICAgY29uc3QgdHlwZXMgPSB7CiAgICAgICAgICAgIGNvbG9yOiBDb2xvclR5cGUsCiAgICAgICAgICAgIHN0cmluZzogU3RyaW5nVHlwZSwKICAgICAgICAgICAgbnVtYmVyOiBOdW1iZXJUeXBlLAogICAgICAgICAgICBlbnVtOiBTdHJpbmdUeXBlLAogICAgICAgICAgICBib29sZWFuOiBCb29sZWFuVHlwZSwKICAgICAgICAgICAgZm9ybWF0dGVkOiBGb3JtYXR0ZWRUeXBlLAogICAgICAgICAgICByZXNvbHZlZEltYWdlOiBSZXNvbHZlZEltYWdlVHlwZQogICAgICAgIH07CiAgICAgICAgaWYgKHNwZWMudHlwZSA9PT0gJ2FycmF5JykgewogICAgICAgICAgICByZXR1cm4gYXJyYXkkMSh0eXBlc1tzcGVjLnZhbHVlXSB8fCBWYWx1ZVR5cGUsIHNwZWMubGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHR5cGVzW3NwZWMudHlwZV07CiAgICB9CiAgICBmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoc3BlYykgewogICAgICAgIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicgJiYgKGlzRnVuY3Rpb24oc3BlYy5kZWZhdWx0KSB8fCBBcnJheS5pc0FycmF5KHNwZWMuZGVmYXVsdCkpKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkMSgwLCAwLCAwLCAwKTsKICAgICAgICB9IGVsc2UgaWYgKHNwZWMudHlwZSA9PT0gJ2NvbG9yJykgewogICAgICAgICAgICByZXR1cm4gQ29sb3IkMS5wYXJzZShzcGVjLmRlZmF1bHQpIHx8IG51bGw7CiAgICAgICAgfSBlbHNlIGlmIChzcGVjLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gc3BlYy5kZWZhdWx0OwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSB7CiAgICAgICAgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBmaWx0ZXIgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSB8fCBmaWx0ZXIubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgc3dpdGNoIChmaWx0ZXJbMF0pIHsKICAgICAgICBjYXNlICdoYXMnOgogICAgICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCA+PSAyICYmIGZpbHRlclsxXSAhPT0gJyRpZCcgJiYgZmlsdGVyWzFdICE9PSAnJHR5cGUnOwogICAgICAgIGNhc2UgJ2luJzoKICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMyAmJiAodHlwZW9mIGZpbHRlclsxXSAhPT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pKTsKICAgICAgICBjYXNlICchaW4nOgogICAgICAgIGNhc2UgJyFoYXMnOgogICAgICAgIGNhc2UgJ25vbmUnOgogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgY2FzZSAnPT0nOgogICAgICAgIGNhc2UgJyE9JzoKICAgICAgICBjYXNlICc+JzoKICAgICAgICBjYXNlICc+PSc6CiAgICAgICAgY2FzZSAnPCc6CiAgICAgICAgY2FzZSAnPD0nOgogICAgICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCAhPT0gMyB8fCAoQXJyYXkuaXNBcnJheShmaWx0ZXJbMV0pIHx8IEFycmF5LmlzQXJyYXkoZmlsdGVyWzJdKSk7CiAgICAgICAgY2FzZSAnYW55JzoKICAgICAgICBjYXNlICdhbGwnOgogICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgZmlsdGVyLnNsaWNlKDEpKSB7CiAgICAgICAgICAgICAgICBpZiAoIWlzRXhwcmVzc2lvbkZpbHRlcihmKSAmJiB0eXBlb2YgZiAhPT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgIH0KCiAgICAvKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNC4xNSAqLwoKICAgIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHsKICAgIC8qCiAgICAgIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOgoKICAgICAgUGFyc2VyOiB7CiAgICAgICAgeXk6IHt9CiAgICAgIH0KCiAgICAgIFBhcnNlci5wcm90b3R5cGU6IHsKICAgICAgICB5eToge30sCiAgICAgICAgdHJhY2U6IGZ1bmN0aW9uKCksCiAgICAgICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LAogICAgICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LAogICAgICAgIHByb2R1Y3Rpb25zXzogWy4uLl0sCiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCksCiAgICAgICAgdGFibGU6IFsuLi5dLAogICAgICAgIGRlZmF1bHRBY3Rpb25zOiB7Li4ufSwKICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLAogICAgICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksCgogICAgICAgIGxleGVyOiB7CiAgICAgICAgICAgIEVPRjogMSwKICAgICAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSwKICAgICAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSwKICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksCiAgICAgICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLAogICAgICAgICAgICBtb3JlOiBmdW5jdGlvbigpLAogICAgICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSwKICAgICAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLAogICAgICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLAogICAgICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksCiAgICAgICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSwKICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSwKICAgICAgICAgICAgbGV4OiBmdW5jdGlvbigpLAogICAgICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSwKICAgICAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksCiAgICAgICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksCiAgICAgICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLAogICAgICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksCgogICAgICAgICAgICBvcHRpb25zOiB7CiAgICAgICAgICAgICAgICByYW5nZXM6IGJvb2xlYW4gICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIpCiAgICAgICAgICAgICAgICBmbGV4OiBib29sZWFuICAgICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWQgZXhoYXVzdGl2ZWx5IHRvIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gpCiAgICAgICAgICAgICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW4gIChvcHRpb25hbDogdHJ1ZSA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgZWFjaCBtYXRjaGluZyByZWdleCB0aGUgYWN0aW9uIGNvZGUgaXMgaW52b2tlZDsgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZSkKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSwKICAgICAgICAgICAgcnVsZXM6IFsuLi5dLAogICAgICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSwKICAgICAgICB9CiAgICAgIH0KCgogICAgICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7CiAgICAgICAgZmlyc3RfbGluZTogbiwKICAgICAgICBsYXN0X2xpbmU6IG4sCiAgICAgICAgZmlyc3RfY29sdW1uOiBuLAogICAgICAgIGxhc3RfY29sdW1uOiBuLAogICAgICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXSAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCByZWd1bGFyIHplcm8tYmFzZWQpCiAgICAgIH0KCgogICAgICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczogewogICAgICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KQogICAgICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpCiAgICAgICAgbGluZTogICAgICAgICh5eWxpbmVubykKICAgICAgfQogICAgICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHsKICAgICAgICBsb2M6ICAgICAgICAgKHl5bGxvYykKICAgICAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKQogICAgICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcikKICAgICAgfQogICAgKi8KICAgIHZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXsKICAgIHZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSwxMl0sJFYxPVsxLDEzXSwkVjI9WzEsOV0sJFYzPVsxLDEwXSwkVjQ9WzEsMTFdLCRWNT1bMSwxNF0sJFY2PVsxLDE1XSwkVjc9WzE0LDE4LDIyLDI0XSwkVjg9WzE4LDIyXSwkVjk9WzIyLDI0XTsKICAgIHZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LAogICAgeXk6IHt9LAogICAgc3ltYm9sc186IHsiZXJyb3IiOjIsIkpTT05TdHJpbmciOjMsIlNUUklORyI6NCwiSlNPTk51bWJlciI6NSwiTlVNQkVSIjo2LCJKU09OTnVsbExpdGVyYWwiOjcsIk5VTEwiOjgsIkpTT05Cb29sZWFuTGl0ZXJhbCI6OSwiVFJVRSI6MTAsIkZBTFNFIjoxMSwiSlNPTlRleHQiOjEyLCJKU09OVmFsdWUiOjEzLCJFT0YiOjE0LCJKU09OT2JqZWN0IjoxNSwiSlNPTkFycmF5IjoxNiwieyI6MTcsIn0iOjE4LCJKU09OTWVtYmVyTGlzdCI6MTksIkpTT05NZW1iZXIiOjIwLCI6IjoyMSwiLCI6MjIsIlsiOjIzLCJdIjoyNCwiSlNPTkVsZW1lbnRMaXN0IjoyNSwiJGFjY2VwdCI6MCwiJGVuZCI6MX0sCiAgICB0ZXJtaW5hbHNfOiB7MjoiZXJyb3IiLDQ6IlNUUklORyIsNjoiTlVNQkVSIiw4OiJOVUxMIiwxMDoiVFJVRSIsMTE6IkZBTFNFIiwxNDoiRU9GIiwxNzoieyIsMTg6In0iLDIxOiI6IiwyMjoiLCIsMjM6IlsiLDI0OiJdIn0sCiAgICBwcm9kdWN0aW9uc186IFswLFszLDFdLFs1LDFdLFs3LDFdLFs5LDFdLFs5LDFdLFsxMiwyXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTUsMl0sWzE1LDNdLFsyMCwzXSxbMTksMV0sWzE5LDNdLFsxNiwyXSxbMTYsM10sWzI1LDFdLFsyNSwzXV0sCiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7CiAgICAvKiB0aGlzID09IHl5dmFsICovCgogICAgdmFyICQwID0gJCQubGVuZ3RoIC0gMTsKICAgIHN3aXRjaCAoeXlzdGF0ZSkgewogICAgY2FzZSAxOgogICAgIC8vIHJlcGxhY2UgZXNjYXBlZCBjaGFyYWN0ZXJzIHdpdGggYWN0dWFsIGNoYXJhY3RlcgogICAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBTdHJpbmcoeXl0ZXh0LnJlcGxhY2UoL1xcKFxcfCIpL2csICIkIisiMSIpCiAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csJ1xuJykKICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywnXHInKQogICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCdcdCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx2L2csJ1x2JykKICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXGYvZywnXGYnKQogICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYi9nLCdcYicpKTsKICAgICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSAgdGhpcy5fJC5maXJzdF9saW5lOwogICAgICAgICAgICAKICAgIGJyZWFrOwogICAgY2FzZSAyOgoKICAgICAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBOdW1iZXIoeXl0ZXh0KTsKICAgICAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9ICB0aGlzLl8kLmZpcnN0X2xpbmU7CiAgICAgICAgICAgIAogICAgYnJlYWs7CiAgICBjYXNlIDM6CgogICAgICAgICAgICAgICAgdGhpcy4kID0gbnVsbDsKICAgICAgICAgICAgCiAgICBicmVhazsKICAgIGNhc2UgNDoKCiAgICAgICAgICAgICAgICB0aGlzLiQgPSBuZXcgQm9vbGVhbih0cnVlKTsKICAgICAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9IHRoaXMuXyQuZmlyc3RfbGluZTsKICAgICAgICAgICAgCiAgICBicmVhazsKICAgIGNhc2UgNToKCiAgICAgICAgICAgICAgICB0aGlzLiQgPSBuZXcgQm9vbGVhbihmYWxzZSk7CiAgICAgICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7CiAgICAgICAgICAgIAogICAgYnJlYWs7CiAgICBjYXNlIDY6CiAgICByZXR1cm4gdGhpcy4kID0gJCRbJDAtMV07CiAgICBjYXNlIDEzOgogICAgdGhpcy4kID0ge307IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHsKICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsCiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgICAgICAgICB9KTsKICAgIGJyZWFrOwogICAgY2FzZSAxNDogY2FzZSAxOToKICAgIHRoaXMuJCA9ICQkWyQwLTFdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7CiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLAogICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgICAgICAgICAgfSk7CiAgICBicmVhazsKICAgIGNhc2UgMTU6CiAgICB0aGlzLiQgPSBbJCRbJDAtMl0sICQkWyQwXV07CiAgICBicmVhazsKICAgIGNhc2UgMTY6CiAgICB0aGlzLiQgPSB7fTsgdGhpcy4kWyQkWyQwXVswXV0gPSAkJFskMF1bMV07CiAgICBicmVhazsKICAgIGNhc2UgMTc6CiAgICB0aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl1bJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTsKICAgIGJyZWFrOwogICAgY2FzZSAxODoKICAgIHRoaXMuJCA9IFtdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7CiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLAogICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgICAgICAgICAgfSk7CiAgICBicmVhazsKICAgIGNhc2UgMjA6CiAgICB0aGlzLiQgPSBbJCRbJDBdXTsKICAgIGJyZWFrOwogICAgY2FzZSAyMToKICAgIHRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5wdXNoKCQkWyQwXSk7CiAgICBicmVhazsKICAgIH0KICAgIH0sCiAgICB0YWJsZTogW3szOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMjoxLDEzOjIsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LHsxOlszXX0sezE0OlsxLDE2XX0sbygkVjcsWzIsN10pLG8oJFY3LFsyLDhdKSxvKCRWNyxbMiw5XSksbygkVjcsWzIsMTBdKSxvKCRWNyxbMiwxMV0pLG8oJFY3LFsyLDEyXSksbygkVjcsWzIsM10pLG8oJFY3LFsyLDRdKSxvKCRWNyxbMiw1XSksbyhbMTQsMTgsMjEsMjIsMjRdLFsyLDFdKSxvKCRWNyxbMiwyXSksezM6MjAsNDokVjAsMTg6WzEsMTddLDE5OjE4LDIwOjE5fSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MjMsMTU6NywxNjo4LDE3OiRWNSwyMzokVjYsMjQ6WzEsMjFdLDI1OjIyfSx7MTpbMiw2XX0sbygkVjcsWzIsMTNdKSx7MTg6WzEsMjRdLDIyOlsxLDI1XX0sbygkVjgsWzIsMTZdKSx7MjE6WzEsMjZdfSxvKCRWNyxbMiwxOF0pLHsyMjpbMSwyOF0sMjQ6WzEsMjddfSxvKCRWOSxbMiwyMF0pLG8oJFY3LFsyLDE0XSksezM6MjAsNDokVjAsMjA6Mjl9LHszOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMzozMCwxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNn0sbygkVjcsWzIsMTldKSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MzEsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LG8oJFY4LFsyLDE3XSksbygkVjgsWzIsMTVdKSxvKCRWOSxbMiwyMV0pXSwKICAgIGRlZmF1bHRBY3Rpb25zOiB7MTY6WzIsNl19LAogICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHsKICAgICAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkgewogICAgICAgICAgICB0aGlzLnRyYWNlKHN0cik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7CiAgICAgICAgfQogICAgfSwKICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkgewogICAgICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gJycsIHl5bGluZW5vID0gMCwgeXlsZW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTsKICAgICAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CiAgICAgICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTsKICAgICAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9OwogICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkgewogICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7CiAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTsKICAgICAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyOwogICAgICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7CiAgICAgICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgbGV4ZXIueXlsbG9jID0ge307CiAgICAgICAgfQogICAgICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYzsKICAgICAgICBsc3RhY2sucHVzaCh5eWxvYyk7CiAgICAgICAgdmFyIHJhbmdlcyA9IGxleGVyLm9wdGlvbnMgJiYgbGV4ZXIub3B0aW9ucy5yYW5nZXM7CiAgICAgICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7CiAgICAgICAgfQogICAgICAgIAogICAgICAgICAgICBmdW5jdGlvbiBsZXgoKSB7CiAgICAgICAgICAgICAgICB2YXIgdG9rZW47CiAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLmxleCgpIHx8IEVPRjsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgICAgICAgfQogICAgICAgIHZhciBzeW1ib2wsIHN0YXRlLCBhY3Rpb24sIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07CiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkgewogICAgICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTsKICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkgewogICAgICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJzsKICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdOwogICAgICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcJycgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyAnXCcnKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6XG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyAnXG5FeHBlY3RpbmcgJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnLCBnb3QgXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXCcnOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXCcnKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwgewogICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCwKICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCwKICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sCiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsCiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZAogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkgewogICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7CiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpOwogICAgICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIueXlsbG9jKTsKICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTsKICAgICAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7CiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nOwogICAgICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDsKICAgICAgICAgICAgICAgICAgICB5eWxpbmVubyA9IGxleGVyLnl5bGluZW5vOwogICAgICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07CiAgICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dOwogICAgICAgICAgICAgICAgeXl2YWwuXyQgPSB7CiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9saW5lLAogICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsCiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbiwKICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2NvbHVtbgogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIGlmIChyYW5nZXMpIHsKICAgICAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFsKICAgICAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5yYW5nZVswXSwKICAgICAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXQogICAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmFwcGx5KHl5dmFsLCBbCiAgICAgICAgICAgICAgICAgICAgeXl0ZXh0LAogICAgICAgICAgICAgICAgICAgIHl5bGVuZywKICAgICAgICAgICAgICAgICAgICB5eWxpbmVubywKICAgICAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eSwKICAgICAgICAgICAgICAgICAgICBhY3Rpb25bMV0sCiAgICAgICAgICAgICAgICAgICAgdnN0YWNrLAogICAgICAgICAgICAgICAgICAgIGxzdGFjawogICAgICAgICAgICAgICAgXS5jb25jYXQoYXJncykpOwogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgICAgIHJldHVybiByOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTsKICAgICAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pOwogICAgICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pOwogICAgICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7CiAgICAgICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7CiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07CiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH19OwogICAgLyogZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjMuNCAqLwogICAgdmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7CiAgICB2YXIgbGV4ZXIgPSAoewoKICAgIEVPRjoxLAoKICAgIHBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHsKICAgICAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7CiAgICAgICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXQKICAgIHNldElucHV0OmZ1bmN0aW9uIChpbnB1dCwgeXkpIHsKICAgICAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307CiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7CiAgICAgICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDsKICAgICAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7CiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTsKICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7CiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiAxLAogICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiAwLAogICAgICAgICAgICAgICAgbGFzdF9saW5lOiAxLAogICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IDAKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHsKICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsMF07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9LAoKICAgIC8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0CiAgICBpbnB1dDpmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdOwogICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDsKICAgICAgICAgICAgdGhpcy55eWxlbmcrKzsKICAgICAgICAgICAgdGhpcy5vZmZzZXQrKzsKICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDsKICAgICAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoOwogICAgICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XHJcbj98XG4pLiovZyk7CiAgICAgICAgICAgIGlmIChsaW5lcykgewogICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubysrOwogICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7CiAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrOwogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpOwogICAgICAgICAgICByZXR1cm4gY2g7CiAgICAgICAgfSwKCiAgICAvLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0CiAgICB1bnB1dDpmdW5jdGlvbiAoY2gpIHsKICAgICAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDsKICAgICAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/OlxyXG4/fFxuKS9nKTsKCiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDsKICAgICAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTsKICAgICAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47CiAgICAgICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjsKICAgICAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XHJcbj98XG4pL2cpOwogICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTsKICAgICAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7CgogICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7CgogICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHsKICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsCiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLAogICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sCiAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgPwogICAgICAgICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApCiAgICAgICAgICAgICAgICAgICAgICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOgogICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW4KICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7CiAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9LAoKICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uCiAgICBtb3JlOmZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0sCgogICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC4KICAgIHJlamVjdDpmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHsKICAgICAgICAgICAgICAgICAgICB0ZXh0OiAiIiwKICAgICAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCwKICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vCiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfSwKCiAgICAvLyByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaAogICAgbGVzczpmdW5jdGlvbiAobikgewogICAgICAgICAgICB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpOwogICAgICAgIH0sCgogICAgLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlcwogICAgcGFzdElucHV0OmZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7CiAgICAgICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXG4vZywgIiIpOwogICAgICAgIH0sCgogICAgLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzCiAgICB1cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoOwogICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkgewogICAgICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cbi9nLCAiIik7CiAgICAgICAgfSwKCiAgICAvLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzCiAgICBzaG93UG9zaXRpb246ZnVuY3Rpb24gKCkgewogICAgICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTsKICAgICAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oIi0iKTsKICAgICAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgIlxuIiArIGMgKyAiXiI7CiAgICAgICAgfSwKCiAgICAvLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW4KICAgIHRlc3RfbWF0Y2g6ZnVuY3Rpb24gKG1hdGNoLCBpbmRleGVkX3J1bGUpIHsKICAgICAgICAgICAgdmFyIHRva2VuLAogICAgICAgICAgICAgICAgbGluZXMsCiAgICAgICAgICAgICAgICBiYWNrdXA7CgogICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikgewogICAgICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0CiAgICAgICAgICAgICAgICBiYWNrdXAgPSB7CiAgICAgICAgICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sCiAgICAgICAgICAgICAgICAgICAgeXlsbG9jOiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsCiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsCiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLAogICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsCiAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsCiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLAogICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCwKICAgICAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLAogICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsCiAgICAgICAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsCiAgICAgICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCwKICAgICAgICAgICAgICAgICAgICB5eTogdGhpcy55eSwKICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSwKICAgICAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmUKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgewogICAgICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XHJcbj98XG4pLiovZyk7CiAgICAgICAgICAgIGlmIChsaW5lcykgewogICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7CiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsCiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLAogICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiwKICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xyP1xuPy8pWzBdLmxlbmd0aCA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGgKICAgICAgICAgICAgfTsKICAgICAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07CiAgICAgICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07CiAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoOwogICAgICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDsKICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHsKICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlOwogICAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpOwogICAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07CiAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pOwogICAgICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7CiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodG9rZW4pIHsKICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHsKICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dAogICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHsKICAgICAgICAgICAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0sCgogICAgLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXQKICAgIG5leHQ6ZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkgewogICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIHRva2VuLAogICAgICAgICAgICAgICAgbWF0Y2gsCiAgICAgICAgICAgICAgICB0ZW1wTWF0Y2gsCiAgICAgICAgICAgICAgICBpbmRleDsKICAgICAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7CiAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnOwogICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7CiAgICAgICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHsKICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDsKICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC4KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAobWF0Y2gpIHsKICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pOwogICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSkKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09ICIiKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7CiAgICAgICAgICAgICAgICAgICAgdGV4dDogIiIsCiAgICAgICAgICAgICAgICAgICAgdG9rZW46IG51bGwsCiAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVubwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgIC8vIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW4KICAgIGxleDpmdW5jdGlvbiBsZXgoKSB7CiAgICAgICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7CiAgICAgICAgICAgIGlmIChyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpOwogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAvLyBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKQogICAgYmVnaW46ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7CiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pOwogICAgICAgIH0sCgogICAgLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2sKICAgIHBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkgewogICAgICAgICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTsKICAgICAgICAgICAgaWYgKG4gPiAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdOwogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAvLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZQogICAgX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkgewogICAgICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zWyJJTklUSUFMIl0ucnVsZXM7CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgIC8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGUKICAgIHRvcFN0YXRlOmZ1bmN0aW9uIHRvcFN0YXRlKG4pIHsKICAgICAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7CiAgICAgICAgICAgIGlmIChuID49IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuICJJTklUSUFMIjsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbikKICAgIHB1c2hTdGF0ZTpmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7CiAgICAgICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTsKICAgICAgICB9LAoKICAgIC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrCiAgICBzdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoOwogICAgICAgIH0sCiAgICBvcHRpb25zOiB7fSwKICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkgewogICAgc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHsKICAgIGNhc2UgMDovKiBza2lwIHdoaXRlc3BhY2UgKi8KICAgIGJyZWFrOwogICAgY2FzZSAxOnJldHVybiA2CiAgICBjYXNlIDI6eXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDEseXlfLnl5bGVuZy0yKTsgcmV0dXJuIDQKICAgIGNhc2UgMzpyZXR1cm4gMTcKICAgIGNhc2UgNDpyZXR1cm4gMTgKICAgIGNhc2UgNTpyZXR1cm4gMjMKICAgIGNhc2UgNjpyZXR1cm4gMjQKICAgIGNhc2UgNzpyZXR1cm4gMjIKICAgIGNhc2UgODpyZXR1cm4gMjEKICAgIGNhc2UgOTpyZXR1cm4gMTAKICAgIGNhc2UgMTA6cmV0dXJuIDExCiAgICBjYXNlIDExOnJldHVybiA4CiAgICBjYXNlIDEyOnJldHVybiAxNAogICAgY2FzZSAxMzpyZXR1cm4gJ0lOVkFMSUQnCiAgICB9CiAgICB9LAogICAgcnVsZXM6IFsvXig/OlxzKykvLC9eKD86KC0/KFswLTldfFsxLTldWzAtOV0rKSkoXC5bMC05XSspPyhbZUVdWy0rXT9bMC05XSspP1xiKS8sL14oPzoiKD86XFxbXFwiYmZucnQvXXxcXHVbYS1mQS1GMC05XXs0fXxbXlxcXDAtXHgwOVx4MGEtXHgxZiJdKSoiKS8sL14oPzpceykvLC9eKD86XH0pLywvXig/OlxbKS8sL14oPzpcXSkvLC9eKD86LCkvLC9eKD86OikvLC9eKD86dHJ1ZVxiKS8sL14oPzpmYWxzZVxiKS8sL14oPzpudWxsXGIpLywvXig/OiQpLywvXig/Oi4pL10sCiAgICBjb25kaXRpb25zOiB7IklOSVRJQUwiOnsicnVsZXMiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzXSwiaW5jbHVzaXZlIjp0cnVlfX0KICAgIH0pOwogICAgcmV0dXJuIGxleGVyOwogICAgfSkoKTsKICAgIHBhcnNlci5sZXhlciA9IGxleGVyOwogICAgZnVuY3Rpb24gUGFyc2VyICgpIHsKICAgICAgdGhpcy55eSA9IHt9OwogICAgfQogICAgUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyOwogICAgcmV0dXJuIG5ldyBQYXJzZXI7CiAgICB9KSgpOwoKCiAgICBpZiAodHlwZW9mIGNvbW1vbmpzUmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7CiAgICBleHBvcnRzLnBhcnNlciA9IHBhcnNlcjsKICAgIGV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjsKICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXIucGFyc2UuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpOyB9OwogICAgfQogICAgfSk7CgogICAgY29uc3QgZXhwcmVzc2lvbiA9IHsKICAgICAgICBTdHlsZUV4cHJlc3Npb24sCiAgICAgICAgaXNFeHByZXNzaW9uOiBpc0V4cHJlc3Npb24kMSwKICAgICAgICBpc0V4cHJlc3Npb25GaWx0ZXIsCiAgICAgICAgY3JlYXRlRXhwcmVzc2lvbiwKICAgICAgICBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24sCiAgICAgICAgbm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uLAogICAgICAgIFpvb21Db25zdGFudEV4cHJlc3Npb24sCiAgICAgICAgWm9vbURlcGVuZGVudEV4cHJlc3Npb24sCiAgICAgICAgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uCiAgICB9OwoKICAgIHZhciBzdHlsZVNwZWMgPSBjcmVhdGVDb21tb25qc01vZHVsZSQxKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHsKICAgIChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7CiAgICAgIGZhY3RvcnkoZXhwb3J0cykgOwogICAgfShjb21tb25qc0dsb2JhbCQxLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsKICAgICAgdmFyICR2ZXJzaW9uID0gODsKICAgICAgdmFyICRyb290ID0gewogICAgICAJdmVyc2lvbjogewogICAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IFsKICAgICAgCQkJOAogICAgICAJCV0sCiAgICAgIAkJZG9jOiAiU3R5bGUgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIG51bWJlci4gTXVzdCBiZSA4LiIsCiAgICAgIAkJZXhhbXBsZTogOAogICAgICAJfSwKICAgICAgCW5hbWU6IHsKICAgICAgCQl0eXBlOiAic3RyaW5nIiwKICAgICAgCQlkb2M6ICJBIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBzdHlsZS4iLAogICAgICAJCWV4YW1wbGU6ICJCcmlnaHQiCiAgICAgIAl9LAogICAgICAJbWV0YWRhdGE6IHsKICAgICAgCQl0eXBlOiAiKiIsCiAgICAgIAkJZG9jOiAiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIHN0eWxlc2hlZXQsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuIgogICAgICAJfSwKICAgICAgCWNlbnRlcjogewogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIkRlZmF1bHQgbWFwIGNlbnRlciBpbiBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLiAgVGhlIHN0eWxlIGNlbnRlciB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLiIsCiAgICAgIAkJZXhhbXBsZTogWwogICAgICAJCQktNzMuOTc0OSwKICAgICAgCQkJNDAuNzczNgogICAgICAJCV0KICAgICAgCX0sCiAgICAgIAl6b29tOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJZG9jOiAiRGVmYXVsdCB6b29tIGxldmVsLiAgVGhlIHN0eWxlIHpvb20gd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS4iLAogICAgICAJCWV4YW1wbGU6IDEyLjUKICAgICAgCX0sCiAgICAgIAliZWFyaW5nOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCXBlcmlvZDogMzYwLAogICAgICAJCXVuaXRzOiAiZGVncmVlcyIsCiAgICAgIAkJZG9jOiAiRGVmYXVsdCBiZWFyaW5nLCBpbiBkZWdyZWVzLiBUaGUgYmVhcmluZyBpcyB0aGUgY29tcGFzcyBkaXJlY3Rpb24gdGhhdCBpcyBcInVwXCI7IGZvciBleGFtcGxlLCBhIGJlYXJpbmcgb2YgOTDCsCBvcmllbnRzIHRoZSBtYXAgc28gdGhhdCBlYXN0IGlzIHVwLiBUaGlzIHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuIiwKICAgICAgCQlleGFtcGxlOiAyOQogICAgICAJfSwKICAgICAgCXBpdGNoOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCXVuaXRzOiAiZGVncmVlcyIsCiAgICAgIAkJZG9jOiAiRGVmYXVsdCBwaXRjaCwgaW4gZGVncmVlcy4gWmVybyBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBzdXJmYWNlLCBmb3IgYSBsb29rIHN0cmFpZ2h0IGRvd24gYXQgdGhlIG1hcCwgd2hpbGUgYSBncmVhdGVyIHZhbHVlIGxpa2UgNjAgbG9va3MgYWhlYWQgdG93YXJkcyB0aGUgaG9yaXpvbi4gVGhlIHN0eWxlIHBpdGNoIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuIiwKICAgICAgCQlleGFtcGxlOiA1MAogICAgICAJfSwKICAgICAgCWxpZ2h0OiB7CiAgICAgIAkJdHlwZTogImxpZ2h0IiwKICAgICAgCQlkb2M6ICJUaGUgZ2xvYmFsIGxpZ2h0IHNvdXJjZS4iLAogICAgICAJCWV4YW1wbGU6IHsKICAgICAgCQkJYW5jaG9yOiAidmlld3BvcnQiLAogICAgICAJCQljb2xvcjogIndoaXRlIiwKICAgICAgCQkJaW50ZW5zaXR5OiAwLjQKICAgICAgCQl9CiAgICAgIAl9LAogICAgICAJc291cmNlczogewogICAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgICAJCXR5cGU6ICJzb3VyY2VzIiwKICAgICAgCQlkb2M6ICJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucy4iLAogICAgICAJCWV4YW1wbGU6IHsKICAgICAgCQkJIm1hcGJveC1zdHJlZXRzIjogewogICAgICAJCQkJdHlwZTogInZlY3RvciIsCiAgICAgIAkJCQl1cmw6ICJtYXBib3g6Ly9tYXBib3gubWFwYm94LXN0cmVldHMtdjYiCiAgICAgIAkJCX0KICAgICAgCQl9CiAgICAgIAl9LAogICAgICAJc3ByaXRlOiB7CiAgICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiQSBiYXNlIFVSTCBmb3IgcmV0cmlldmluZyB0aGUgc3ByaXRlIGltYWdlIGFuZCBtZXRhZGF0YS4gVGhlIGV4dGVuc2lvbnMgYC5wbmdgLCBgLmpzb25gIGFuZCBzY2FsZSBmYWN0b3IgYEAyeC5wbmdgIHdpbGwgYmUgYXV0b21hdGljYWxseSBhcHBlbmRlZC4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgYGJhY2tncm91bmQtcGF0dGVybmAsIGBmaWxsLXBhdHRlcm5gLCBgbGluZS1wYXR0ZXJuYCwgYGZpbGwtZXh0cnVzaW9uLXBhdHRlcm5gLCBvciBgaWNvbi1pbWFnZWAgcHJvcGVydGllcy4gVGhlIFVSTCBtdXN0IGJlIGFic29sdXRlLCBjb250YWluaW5nIHRoZSBbc2NoZW1lLCBhdXRob3JpdHkgYW5kIHBhdGggY29tcG9uZW50c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJMI1N5bnRheCkuIiwKICAgICAgCQlleGFtcGxlOiAibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4IgogICAgICAJfSwKICAgICAgCWdseXBoczogewogICAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgICAJCWRvYzogIkEgVVJMIHRlbXBsYXRlIGZvciBsb2FkaW5nIHNpZ25lZC1kaXN0YW5jZS1maWVsZCBnbHlwaCBzZXRzIGluIFBCRiBmb3JtYXQuIFRoZSBVUkwgbXVzdCBpbmNsdWRlIGB7Zm9udHN0YWNrfWAgYW5kIGB7cmFuZ2V9YCB0b2tlbnMuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlIGB0ZXh0LWZpZWxkYCBsYXlvdXQgcHJvcGVydHkuIFRoZSBVUkwgbXVzdCBiZSBhYnNvbHV0ZSwgY29udGFpbmluZyB0aGUgW3NjaGVtZSwgYXV0aG9yaXR5IGFuZCBwYXRoIGNvbXBvbmVudHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSTCNTeW50YXgpLiIsCiAgICAgIAkJZXhhbXBsZTogIm1hcGJveDovL2ZvbnRzL21hcGJveC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZiIKICAgICAgCX0sCiAgICAgIAl0cmFuc2l0aW9uOiB7CiAgICAgIAkJdHlwZTogInRyYW5zaXRpb24iLAogICAgICAJCWRvYzogIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLCB0byBiZSB1c2VkIGZvciB0aW1pbmcgdHJhbnNpdGlvbnMgYmV0d2VlbiBvbmUgdmFsdWUgYW5kIHRoZSBuZXh0IHdoZW4gbm8gcHJvcGVydHktc3BlY2lmaWMgdHJhbnNpdGlvbiBpcyBzZXQuIENvbGxpc2lvbi1iYXNlZCBzeW1ib2wgZmFkaW5nIGlzIGNvbnRyb2xsZWQgaW5kZXBlbmRlbnRseSBvZiB0aGUgc3R5bGUncyBgdHJhbnNpdGlvbmAgcHJvcGVydHkuIiwKICAgICAgCQlleGFtcGxlOiB7CiAgICAgIAkJCWR1cmF0aW9uOiAzMDAsCiAgICAgIAkJCWRlbGF5OiAwCiAgICAgIAkJfQogICAgICAJfSwKICAgICAgCWxheWVyczogewogICAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJsYXllciIsCiAgICAgIAkJZG9jOiAiTGF5ZXJzIHdpbGwgYmUgZHJhd24gaW4gdGhlIG9yZGVyIG9mIHRoaXMgYXJyYXkuIiwKICAgICAgCQlleGFtcGxlOiBbCiAgICAgIAkJCXsKICAgICAgCQkJCWlkOiAid2F0ZXIiLAogICAgICAJCQkJc291cmNlOiAibWFwYm94LXN0cmVldHMiLAogICAgICAJCQkJInNvdXJjZS1sYXllciI6ICJ3YXRlciIsCiAgICAgIAkJCQl0eXBlOiAiZmlsbCIsCiAgICAgIAkJCQlwYWludDogewogICAgICAJCQkJCSJmaWxsLWNvbG9yIjogIiMwMGZmZmYiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQldCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBzb3VyY2VzID0gewogICAgICAJIioiOiB7CiAgICAgIAkJdHlwZTogInNvdXJjZSIsCiAgICAgIAkJZG9jOiAiU3BlY2lmaWNhdGlvbiBvZiBhIGRhdGEgc291cmNlLiBGb3IgdmVjdG9yIGFuZCByYXN0ZXIgc291cmNlcywgZWl0aGVyIFRpbGVKU09OIG9yIGEgVVJMIHRvIGEgVGlsZUpTT04gbXVzdCBiZSBwcm92aWRlZC4gRm9yIGltYWdlIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLiBGb3IgR2VvSlNPTiBzb3VyY2VzLCBhIFVSTCBvciBpbmxpbmUgR2VvSlNPTiBtdXN0IGJlIHByb3ZpZGVkLiIKICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIHNvdXJjZSA9IFsKICAgICAgCSJzb3VyY2VfdmVjdG9yIiwKICAgICAgCSJzb3VyY2VfcmFzdGVyIiwKICAgICAgCSJzb3VyY2VfcmFzdGVyX2RlbSIsCiAgICAgIAkic291cmNlX2dlb2pzb24iLAogICAgICAJInNvdXJjZV92aWRlbyIsCiAgICAgIAkic291cmNlX2ltYWdlIgogICAgICBdOwogICAgICB2YXIgc291cmNlX3ZlY3RvciA9IHsKICAgICAgCXR5cGU6IHsKICAgICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCXZlY3RvcjogewogICAgICAJCQkJZG9jOiAiQSB2ZWN0b3IgdGlsZSBzb3VyY2UuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJUaGUgdHlwZSBvZiB0aGUgc291cmNlLiIKICAgICAgCX0sCiAgICAgIAl1cmw6IHsKICAgICAgCQl0eXBlOiAic3RyaW5nIiwKICAgICAgCQlkb2M6ICJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLiIKICAgICAgCX0sCiAgICAgIAl0aWxlczogewogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJzdHJpbmciLAogICAgICAJCWRvYzogIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiIKICAgICAgCX0sCiAgICAgIAlib3VuZHM6IHsKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgICAgCQlsZW5ndGg6IDQsCiAgICAgIAkJImRlZmF1bHQiOiBbCiAgICAgIAkJCS0xODAsCiAgICAgIAkJCS04NS4wNTExMjksCiAgICAgIAkJCTE4MCwKICAgICAgCQkJODUuMDUxMTI5CiAgICAgIAkJXSwKICAgICAgCQlkb2M6ICJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuIgogICAgICAJfSwKICAgICAgCXNjaGVtZTogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJeHl6OiB7CiAgICAgIAkJCQlkb2M6ICJTbGlwcHkgbWFwIHRpbGVuYW1lcyBzY2hlbWUuIgogICAgICAJCQl9LAogICAgICAJCQl0bXM6IHsKICAgICAgCQkJCWRvYzogIk9TR2VvIHNwZWMgc2NoZW1lLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAieHl6IiwKICAgICAgCQlkb2M6ICJJbmZsdWVuY2VzIHRoZSB5IGRpcmVjdGlvbiBvZiB0aGUgdGlsZSBjb29yZGluYXRlcy4gVGhlIGdsb2JhbC1tZXJjYXRvciAoYWthIFNwaGVyaWNhbCBNZXJjYXRvcikgcHJvZmlsZSBpcyBhc3N1bWVkLiIKICAgICAgCX0sCiAgICAgIAltaW56b29tOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCWRvYzogIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIgogICAgICAJfSwKICAgICAgCW1heHpvb206IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDIyLAogICAgICAJCWRvYzogIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuIgogICAgICAJfSwKICAgICAgCWF0dHJpYnV0aW9uOiB7CiAgICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuIgogICAgICAJfSwKICAgICAgCXByb21vdGVJZDogewogICAgICAJCXR5cGU6ICJwcm9tb3RlSWQiLAogICAgICAJCWRvYzogIkEgcHJvcGVydHkgdG8gdXNlIGFzIGEgZmVhdHVyZSBpZCAoZm9yIGZlYXR1cmUgc3RhdGUpLiBFaXRoZXIgYSBwcm9wZXJ0eSBuYW1lLCBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHs8c291cmNlTGF5ZXI+OiA8cHJvcGVydHlOYW1lPn1gLiBJZiBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgZm9yIGEgdmVjdG9yIHRpbGUgc291cmNlLCB0aGUgc2FtZSBwcm9wZXJ0eSBpcyB1c2VkIGFjcm9zcyBhbGwgaXRzIHNvdXJjZSBsYXllcnMuIgogICAgICAJfSwKICAgICAgCXZvbGF0aWxlOiB7CiAgICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAgIAkJZG9jOiAiQSBzZXR0aW5nIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc291cmNlJ3MgdGlsZXMgYXJlIGNhY2hlZCBsb2NhbGx5LiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWFuZHJvaWQ6ICI5LjMuMCIsCiAgICAgIAkJCQlpb3M6ICI1LjEwLjAiCiAgICAgIAkJCX0KICAgICAgCQl9CiAgICAgIAl9LAogICAgICAJIioiOiB7CiAgICAgIAkJdHlwZTogIioiLAogICAgICAJCWRvYzogIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS4iCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBzb3VyY2VfcmFzdGVyID0gewogICAgICAJdHlwZTogewogICAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJcmFzdGVyOiB7CiAgICAgIAkJCQlkb2M6ICJBIHJhc3RlciB0aWxlIHNvdXJjZS4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWRvYzogIlRoZSB0eXBlIG9mIHRoZSBzb3VyY2UuIgogICAgICAJfSwKICAgICAgCXVybDogewogICAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgICAJCWRvYzogIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxUaWxlc2V0IElEPmAuIgogICAgICAJfSwKICAgICAgCXRpbGVzOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQl2YWx1ZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIgogICAgICAJfSwKICAgICAgCWJvdW5kczogewogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgICAJCWxlbmd0aDogNCwKICAgICAgCQkiZGVmYXVsdCI6IFsKICAgICAgCQkJLTE4MCwKICAgICAgCQkJLTg1LjA1MTEyOSwKICAgICAgCQkJMTgwLAogICAgICAJCQk4NS4wNTExMjkKICAgICAgCQldLAogICAgICAJCWRvYzogIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC4iCiAgICAgIAl9LAogICAgICAJbWluem9vbTogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMCwKICAgICAgCQlkb2M6ICJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiIKICAgICAgCX0sCiAgICAgIAltYXh6b29tOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAyMiwKICAgICAgCQlkb2M6ICJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLiIKICAgICAgCX0sCiAgICAgIAl0aWxlU2l6ZTogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogNTEyLAogICAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgICAgCQlkb2M6ICJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy4iCiAgICAgIAl9LAogICAgICAJc2NoZW1lOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQl4eXo6IHsKICAgICAgCQkJCWRvYzogIlNsaXBweSBtYXAgdGlsZW5hbWVzIHNjaGVtZS4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXRtczogewogICAgICAJCQkJZG9jOiAiT1NHZW8gc3BlYyBzY2hlbWUuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJ4eXoiLAogICAgICAJCWRvYzogIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuIgogICAgICAJfSwKICAgICAgCWF0dHJpYnV0aW9uOiB7CiAgICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuIgogICAgICAJfSwKICAgICAgCXZvbGF0aWxlOiB7CiAgICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAgIAkJZG9jOiAiQSBzZXR0aW5nIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc291cmNlJ3MgdGlsZXMgYXJlIGNhY2hlZCBsb2NhbGx5LiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWFuZHJvaWQ6ICI5LjMuMCIsCiAgICAgIAkJCQlpb3M6ICI1LjEwLjAiCiAgICAgIAkJCX0KICAgICAgCQl9CiAgICAgIAl9LAogICAgICAJIioiOiB7CiAgICAgIAkJdHlwZTogIioiLAogICAgICAJCWRvYzogIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS4iCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBzb3VyY2VfcmFzdGVyX2RlbSA9IHsKICAgICAgCXR5cGU6IHsKICAgICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCSJyYXN0ZXItZGVtIjogewogICAgICAJCQkJZG9jOiAiQSBSR0ItZW5jb2RlZCByYXN0ZXIgREVNIHNvdXJjZSIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZG9jOiAiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS4iCiAgICAgIAl9LAogICAgICAJdXJsOiB7CiAgICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPFRpbGVzZXQgSUQ+YC4iCiAgICAgIAl9LAogICAgICAJdGlsZXM6IHsKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCXZhbHVlOiAic3RyaW5nIiwKICAgICAgCQlkb2M6ICJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4iCiAgICAgIAl9LAogICAgICAJYm91bmRzOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAgIAkJbGVuZ3RoOiA0LAogICAgICAJCSJkZWZhdWx0IjogWwogICAgICAJCQktMTgwLAogICAgICAJCQktODUuMDUxMTI5LAogICAgICAJCQkxODAsCiAgICAgIAkJCTg1LjA1MTEyOQogICAgICAJCV0sCiAgICAgIAkJZG9jOiAiQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBvZiB0aGUgc291dGh3ZXN0IGFuZCBub3J0aGVhc3QgY29ybmVycyBvZiB0aGUgc291cmNlJ3MgYm91bmRpbmcgYm94IGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6IGBbc3cubG5nLCBzdy5sYXQsIG5lLmxuZywgbmUubGF0XWAuIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBpbmNsdWRlZCBpbiBhIHNvdXJjZSwgbm8gdGlsZXMgb3V0c2lkZSBvZiB0aGUgZ2l2ZW4gYm91bmRzIGFyZSByZXF1ZXN0ZWQgYnkgTWFwYm94IEdMLiIKICAgICAgCX0sCiAgICAgIAltaW56b29tOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCWRvYzogIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIgogICAgICAJfSwKICAgICAgCW1heHpvb206IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDIyLAogICAgICAJCWRvYzogIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuIgogICAgICAJfSwKICAgICAgCXRpbGVTaXplOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiA1MTIsCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLiIKICAgICAgCX0sCiAgICAgIAlhdHRyaWJ1dGlvbjogewogICAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgICAJCWRvYzogIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLiIKICAgICAgCX0sCiAgICAgIAllbmNvZGluZzogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJdGVycmFyaXVtOiB7CiAgICAgIAkJCQlkb2M6ICJUZXJyYXJpdW0gZm9ybWF0IFBORyB0aWxlcy4gU2VlIGh0dHBzOi8vYXdzLmFtYXpvbi5jb20vZXMvcHVibGljLWRhdGFzZXRzL3RlcnJhaW4vIGZvciBtb3JlIGluZm8uIgogICAgICAJCQl9LAogICAgICAJCQltYXBib3g6IHsKICAgICAgCQkJCWRvYzogIk1hcGJveCBUZXJyYWluIFJHQiB0aWxlcy4gU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vaGVscC9hY2Nlc3MtZWxldmF0aW9uLWRhdGEvI21hcGJveC10ZXJyYWluLXJnYiBmb3IgbW9yZSBpbmZvLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAibWFwYm94IiwKICAgICAgCQlkb2M6ICJUaGUgZW5jb2RpbmcgdXNlZCBieSB0aGlzIHNvdXJjZS4gTWFwYm94IFRlcnJhaW4gUkdCIGlzIHVzZWQgYnkgZGVmYXVsdCIKICAgICAgCX0sCiAgICAgIAl2b2xhdGlsZTogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgICAJCWRvYzogIkEgc2V0dGluZyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNvdXJjZSdzIHRpbGVzIGFyZSBjYWNoZWQgbG9jYWxseS4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlhbmRyb2lkOiAiOS4zLjAiLAogICAgICAJCQkJaW9zOiAiNS4xMC4wIgogICAgICAJCQl9CiAgICAgIAkJfQogICAgICAJfSwKICAgICAgCSIqIjogewogICAgICAJCXR5cGU6ICIqIiwKICAgICAgCQlkb2M6ICJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuIgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgc291cmNlX2dlb2pzb24gPSB7CiAgICAgIAl0eXBlOiB7CiAgICAgIAkJcmVxdWlyZWQ6IHRydWUsCiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQlnZW9qc29uOiB7CiAgICAgIAkJCQlkb2M6ICJBIEdlb0pTT04gZGF0YSBzb3VyY2UuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJUaGUgZGF0YSB0eXBlIG9mIHRoZSBHZW9KU09OIHNvdXJjZS4iCiAgICAgIAl9LAogICAgICAJZGF0YTogewogICAgICAJCXR5cGU6ICIqIiwKICAgICAgCQlkb2M6ICJBIFVSTCB0byBhIEdlb0pTT04gZmlsZSwgb3IgaW5saW5lIEdlb0pTT04uIgogICAgICAJfSwKICAgICAgCW1heHpvb206IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDE4LAogICAgICAJCWRvYzogIk1heGltdW0gem9vbSBsZXZlbCBhdCB3aGljaCB0byBjcmVhdGUgdmVjdG9yIHRpbGVzIChoaWdoZXIgbWVhbnMgZ3JlYXRlciBkZXRhaWwgYXQgaGlnaCB6b29tIGxldmVscykuIgogICAgICAJfSwKICAgICAgCWF0dHJpYnV0aW9uOiB7CiAgICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuIgogICAgICAJfSwKICAgICAgCWJ1ZmZlcjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMTI4LAogICAgICAJCW1heGltdW06IDUxMiwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCWRvYzogIlNpemUgb2YgdGhlIHRpbGUgYnVmZmVyIG9uIGVhY2ggc2lkZS4gQSB2YWx1ZSBvZiAwIHByb2R1Y2VzIG5vIGJ1ZmZlci4gQSB2YWx1ZSBvZiA1MTIgcHJvZHVjZXMgYSBidWZmZXIgYXMgd2lkZSBhcyB0aGUgdGlsZSBpdHNlbGYuIExhcmdlciB2YWx1ZXMgcHJvZHVjZSBmZXdlciByZW5kZXJpbmcgYXJ0aWZhY3RzIG5lYXIgdGlsZSBlZGdlcyBhbmQgc2xvd2VyIHBlcmZvcm1hbmNlLiIKICAgICAgCX0sCiAgICAgIAlmaWx0ZXI6IHsKICAgICAgCQl0eXBlOiAiKiIsCiAgICAgIAkJZG9jOiAiQW4gZXhwcmVzc2lvbiBmb3IgZmlsdGVyaW5nIGZlYXR1cmVzIHByaW9yIHRvIHByb2Nlc3NpbmcgdGhlbSBmb3IgcmVuZGVyaW5nLiIKICAgICAgCX0sCiAgICAgIAl0b2xlcmFuY2U6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAuMzc1LAogICAgICAJCWRvYzogIkRvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyIGdlb21ldHJpZXMgYW5kIGZhc3RlciBwZXJmb3JtYW5jZSkuIgogICAgICAJfSwKICAgICAgCWNsdXN0ZXI6IHsKICAgICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgICAgCQlkb2M6ICJJZiB0aGUgZGF0YSBpcyBhIGNvbGxlY3Rpb24gb2YgcG9pbnQgZmVhdHVyZXMsIHNldHRpbmcgdGhpcyB0byB0cnVlIGNsdXN0ZXJzIHRoZSBwb2ludHMgYnkgcmFkaXVzIGludG8gZ3JvdXBzLiBDbHVzdGVyIGdyb3VwcyBiZWNvbWUgbmV3IGBQb2ludGAgZmVhdHVyZXMgaW4gdGhlIHNvdXJjZSB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllczpcbiAqIGBjbHVzdGVyYCBJcyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGEgY2x1c3RlciBcbiAqIGBjbHVzdGVyX2lkYCBBIHVucWl1ZSBpZCBmb3IgdGhlIGNsdXN0ZXIgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBbY2x1c3RlciBpbnNwZWN0aW9uIG1ldGhvZHNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jZ2VvanNvbnNvdXJjZSNnZXRjbHVzdGVyZXhwYW5zaW9uem9vbSlcbiAqIGBwb2ludF9jb3VudGAgTnVtYmVyIG9mIG9yaWdpbmFsIHBvaW50cyBncm91cGVkIGludG8gdGhpcyBjbHVzdGVyXG4gKiBgcG9pbnRfY291bnRfYWJicmV2aWF0ZWRgIEFuIGFiYnJldmlhdGVkIHBvaW50IGNvdW50IgogICAgICAJfSwKICAgICAgCWNsdXN0ZXJSYWRpdXM6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDUwLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJZG9jOiAiUmFkaXVzIG9mIGVhY2ggY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIEEgdmFsdWUgb2YgNTEyIGluZGljYXRlcyBhIHJhZGl1cyBlcXVhbCB0byB0aGUgd2lkdGggb2YgYSB0aWxlLiIKICAgICAgCX0sCiAgICAgIAljbHVzdGVyTWF4Wm9vbTogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIk1heCB6b29tIG9uIHdoaWNoIHRvIGNsdXN0ZXIgcG9pbnRzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZC4gRGVmYXVsdHMgdG8gb25lIHpvb20gbGVzcyB0aGFuIG1heHpvb20gKHNvIHRoYXQgbGFzdCB6b29tIGZlYXR1cmVzIGFyZSBub3QgY2x1c3RlcmVkKS4gQ2x1c3RlcnMgYXJlIHJlLWV2YWx1YXRlZCBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzIHNvIHNldHRpbmcgY2x1c3Rlck1heFpvb20gdG8gMTQgbWVhbnMgdGhlIGNsdXN0ZXJzIHdpbGwgYmUgZGlzcGxheWVkIHVudGlsIHoxNS4iCiAgICAgIAl9LAogICAgICAJY2x1c3Rlck1pblBvaW50czogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIk1pbmltdW0gbnVtYmVyIG9mIHBvaW50cyBuZWNlc3NhcnkgdG8gZm9ybSBhIGNsdXN0ZXIgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLiBEZWZhdWx0cyB0byBgMmAuIgogICAgICAJfSwKICAgICAgCWNsdXN0ZXJQcm9wZXJ0aWVzOiB7CiAgICAgIAkJdHlwZTogIioiLAogICAgICAJCWRvYzogIkFuIG9iamVjdCBkZWZpbmluZyBjdXN0b20gcHJvcGVydGllcyBvbiB0aGUgZ2VuZXJhdGVkIGNsdXN0ZXJzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZCwgYWdncmVnYXRpbmcgdmFsdWVzIGZyb20gY2x1c3RlcmVkIHBvaW50cy4gSGFzIHRoZSBmb3JtIGB7XCJwcm9wZXJ0eV9uYW1lXCI6IFtvcGVyYXRvciwgbWFwX2V4cHJlc3Npb25dfWAuIGBvcGVyYXRvcmAgaXMgYW55IGV4cHJlc3Npb24gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGF0IGxlYXN0IDIgb3BlcmFuZHMgKGUuZy4gYFwiK1wiYCBvciBgXCJtYXhcImApIOKAlCBpdCBhY2N1bXVsYXRlcyB0aGUgcHJvcGVydHkgdmFsdWUgZnJvbSBjbHVzdGVycy9wb2ludHMgdGhlIGNsdXN0ZXIgY29udGFpbnM7IGBtYXBfZXhwcmVzc2lvbmAgcHJvZHVjZXMgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIHBvaW50LlxuXG5FeGFtcGxlOiBge1wic3VtXCI6IFtcIitcIiwgW1wiZ2V0XCIsIFwic2NhbGVyYW5rXCJdXX1gLlxuXG5Gb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIGluIHBsYWNlIG9mIGBvcGVyYXRvcmAsIHlvdSBjYW4gdXNlIGEgY3VzdG9tIHJlZHVjZSBleHByZXNzaW9uIHRoYXQgcmVmZXJlbmNlcyBhIHNwZWNpYWwgYFtcImFjY3VtdWxhdGVkXCJdYCB2YWx1ZSwgZS5nLjpcbmB7XCJzdW1cIjogW1tcIitcIiwgW1wiYWNjdW11bGF0ZWRcIl0sIFtcImdldFwiLCBcInN1bVwiXV0sIFtcImdldFwiLCBcInNjYWxlcmFua1wiXV19YCIKICAgICAgCX0sCiAgICAgIAlsaW5lTWV0cmljczogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgICAJCWRvYzogIldoZXRoZXIgdG8gY2FsY3VsYXRlIGxpbmUgZGlzdGFuY2UgbWV0cmljcy4gVGhpcyBpcyByZXF1aXJlZCBmb3IgbGluZSBsYXllcnMgdGhhdCBzcGVjaWZ5IGBsaW5lLWdyYWRpZW50YCB2YWx1ZXMuIgogICAgICAJfSwKICAgICAgCWdlbmVyYXRlSWQ6IHsKICAgICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgICAgCQlkb2M6ICJXaGV0aGVyIHRvIGdlbmVyYXRlIGlkcyBmb3IgdGhlIGdlb2pzb24gZmVhdHVyZXMuIFdoZW4gZW5hYmxlZCwgdGhlIGBmZWF0dXJlLmlkYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG8gYXNzaWduZWQgYmFzZWQgb24gaXRzIGluZGV4IGluIHRoZSBgZmVhdHVyZXNgIGFycmF5LCBvdmVyLXdyaXRpbmcgYW55IHByZXZpb3VzIHZhbHVlcy4iCiAgICAgIAl9LAogICAgICAJcHJvbW90ZUlkOiB7CiAgICAgIAkJdHlwZTogInByb21vdGVJZCIsCiAgICAgIAkJZG9jOiAiQSBwcm9wZXJ0eSB0byB1c2UgYXMgYSBmZWF0dXJlIGlkIChmb3IgZmVhdHVyZSBzdGF0ZSkuIEVpdGhlciBhIHByb3BlcnR5IG5hbWUsIG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBgezxzb3VyY2VMYXllcj46IDxwcm9wZXJ0eU5hbWU+fWAuIgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgc291cmNlX3ZpZGVvID0gewogICAgICAJdHlwZTogewogICAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJdmlkZW86IHsKICAgICAgCQkJCWRvYzogIkEgdmlkZW8gZGF0YSBzb3VyY2UuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJUaGUgZGF0YSB0eXBlIG9mIHRoZSB2aWRlbyBzb3VyY2UuIgogICAgICAJfSwKICAgICAgCXVybHM6IHsKICAgICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCXZhbHVlOiAic3RyaW5nIiwKICAgICAgCQlkb2M6ICJVUkxzIHRvIHZpZGVvIGNvbnRlbnQgaW4gb3JkZXIgb2YgcHJlZmVycmVkIGZvcm1hdC4iCiAgICAgIAl9LAogICAgICAJY29vcmRpbmF0ZXM6IHsKICAgICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgICAgCQlkb2M6ICJDb3JuZXJzIG9mIHZpZGVvIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLiIsCiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQlsZW5ndGg6IDQsCiAgICAgIAkJdmFsdWU6IHsKICAgICAgCQkJdHlwZTogImFycmF5IiwKICAgICAgCQkJbGVuZ3RoOiAyLAogICAgICAJCQl2YWx1ZTogIm51bWJlciIsCiAgICAgIAkJCWRvYzogIkEgc2luZ2xlIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpci4iCiAgICAgIAkJfQogICAgICAJfQogICAgICB9OwogICAgICB2YXIgc291cmNlX2ltYWdlID0gewogICAgICAJdHlwZTogewogICAgICAJCXJlcXVpcmVkOiB0cnVlLAogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJaW1hZ2U6IHsKICAgICAgCQkJCWRvYzogIkFuIGltYWdlIGRhdGEgc291cmNlLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZG9jOiAiVGhlIGRhdGEgdHlwZSBvZiB0aGUgaW1hZ2Ugc291cmNlLiIKICAgICAgCX0sCiAgICAgIAl1cmw6IHsKICAgICAgCQlyZXF1aXJlZDogdHJ1ZSwKICAgICAgCQl0eXBlOiAic3RyaW5nIiwKICAgICAgCQlkb2M6ICJVUkwgdGhhdCBwb2ludHMgdG8gYW4gaW1hZ2UuIgogICAgICAJfSwKICAgICAgCWNvb3JkaW5hdGVzOiB7CiAgICAgIAkJcmVxdWlyZWQ6IHRydWUsCiAgICAgIAkJZG9jOiAiQ29ybmVycyBvZiBpbWFnZSBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy4iLAogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJbGVuZ3RoOiA0LAogICAgICAJCXZhbHVlOiB7CiAgICAgIAkJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJCWxlbmd0aDogMiwKICAgICAgCQkJdmFsdWU6ICJudW1iZXIiLAogICAgICAJCQlkb2M6ICJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuIgogICAgICAJCX0KICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIGxheWVyID0gewogICAgICAJaWQ6IHsKICAgICAgCQl0eXBlOiAic3RyaW5nIiwKICAgICAgCQlkb2M6ICJVbmlxdWUgbGF5ZXIgbmFtZS4iLAogICAgICAJCXJlcXVpcmVkOiB0cnVlCiAgICAgIAl9LAogICAgICAJdHlwZTogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJZmlsbDogewogICAgICAJCQkJZG9jOiAiQSBmaWxsZWQgcG9seWdvbiB3aXRoIGFuIG9wdGlvbmFsIHN0cm9rZWQgYm9yZGVyLiIsCiAgICAgIAkJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQkJCX0KICAgICAgCQkJCX0KICAgICAgCQkJfSwKICAgICAgCQkJbGluZTogewogICAgICAJCQkJZG9jOiAiQSBzdHJva2VkIGxpbmUuIiwKICAgICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCQkJfQogICAgICAJCQkJfQogICAgICAJCQl9LAogICAgICAJCQlzeW1ib2w6IHsKICAgICAgCQkJCWRvYzogIkFuIGljb24gb3IgYSB0ZXh0IGxhYmVsLiIsCiAgICAgIAkJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQkJCX0KICAgICAgCQkJCX0KICAgICAgCQkJfSwKICAgICAgCQkJY2lyY2xlOiB7CiAgICAgIAkJCQlkb2M6ICJBIGZpbGxlZCBjaXJjbGUuIiwKICAgICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCQkJfQogICAgICAJCQkJfQogICAgICAJCQl9LAogICAgICAJCQloZWF0bWFwOiB7CiAgICAgIAkJCQlkb2M6ICJBIGhlYXRtYXAuIiwKICAgICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQkJfQogICAgICAJCQkJfQogICAgICAJCQl9LAogICAgICAJCQkiZmlsbC1leHRydXNpb24iOiB7CiAgICAgIAkJCQlkb2M6ICJBbiBleHRydWRlZCAoM0QpIHBvbHlnb24uIiwKICAgICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQkJanM6ICIwLjI3LjAiLAogICAgICAJCQkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgICAJCQkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQkJCW1hY29zOiAiMC41LjAiCiAgICAgIAkJCQkJfQogICAgICAJCQkJfQogICAgICAJCQl9LAogICAgICAJCQlyYXN0ZXI6IHsKICAgICAgCQkJCWRvYzogIlJhc3RlciBtYXAgdGV4dHVyZXMgc3VjaCBhcyBzYXRlbGxpdGUgaW1hZ2VyeS4iLAogICAgICAJCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJCQl9CiAgICAgIAkJCQl9CiAgICAgIAkJCX0sCiAgICAgIAkJCWhpbGxzaGFkZTogewogICAgICAJCQkJZG9jOiAiQ2xpZW50LXNpZGUgaGlsbHNoYWRpbmcgdmlzdWFsaXphdGlvbiBiYXNlZCBvbiBERU0gZGF0YS4gQ3VycmVudGx5LCB0aGUgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBNYXBib3ggVGVycmFpbiBSR0IgYW5kIE1hcHplbiBUZXJyYXJpdW0gdGlsZXMuIiwKICAgICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQkJanM6ICIwLjQzLjAiLAogICAgICAJCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQkJfQogICAgICAJCQkJfQogICAgICAJCQl9LAogICAgICAJCQliYWNrZ3JvdW5kOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgYmFja2dyb3VuZCBjb2xvciBvciBwYXR0ZXJuIG9mIHRoZSBtYXAuIiwKICAgICAgCQkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCQkJfQogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJSZW5kZXJpbmcgdHlwZSBvZiB0aGlzIGxheWVyLiIsCiAgICAgIAkJcmVxdWlyZWQ6IHRydWUKICAgICAgCX0sCiAgICAgIAltZXRhZGF0YTogewogICAgICAJCXR5cGU6ICIqIiwKICAgICAgCQlkb2M6ICJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgbGF5ZXIsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuIgogICAgICAJfSwKICAgICAgCXNvdXJjZTogewogICAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgICAJCWRvYzogIk5hbWUgb2YgYSBzb3VyY2UgZGVzY3JpcHRpb24gdG8gYmUgdXNlZCBmb3IgdGhpcyBsYXllci4gUmVxdWlyZWQgZm9yIGFsbCBsYXllciB0eXBlcyBleGNlcHQgYGJhY2tncm91bmRgLiIKICAgICAgCX0sCiAgICAgIAkic291cmNlLWxheWVyIjogewogICAgICAJCXR5cGU6ICJzdHJpbmciLAogICAgICAJCWRvYzogIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBmb3IgdmVjdG9yIHRpbGUgc291cmNlczsgcHJvaGliaXRlZCBmb3IgYWxsIG90aGVyIHNvdXJjZSB0eXBlcywgaW5jbHVkaW5nIEdlb0pTT04gc291cmNlcy4iCiAgICAgIAl9LAogICAgICAJbWluem9vbTogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJbWF4aW11bTogMjQsCiAgICAgIAkJZG9jOiAiVGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGxheWVyLiBBdCB6b29tIGxldmVscyBsZXNzIHRoYW4gdGhlIG1pbnpvb20sIHRoZSBsYXllciB3aWxsIGJlIGhpZGRlbi4iCiAgICAgIAl9LAogICAgICAJbWF4em9vbTogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJbWF4aW11bTogMjQsCiAgICAgIAkJZG9jOiAiVGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGxheWVyLiBBdCB6b29tIGxldmVscyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gdGhlIG1heHpvb20sIHRoZSBsYXllciB3aWxsIGJlIGhpZGRlbi4iCiAgICAgIAl9LAogICAgICAJZmlsdGVyOiB7CiAgICAgIAkJdHlwZTogImZpbHRlciIsCiAgICAgIAkJZG9jOiAiQSBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuIFpvb20gZXhwcmVzc2lvbnMgaW4gZmlsdGVycyBhcmUgb25seSBldmFsdWF0ZWQgYXQgaW50ZWdlciB6b29tIGxldmVscy4gVGhlIGBmZWF0dXJlLXN0YXRlYCBleHByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZmlsdGVyIGV4cHJlc3Npb25zLiIKICAgICAgCX0sCiAgICAgIAlsYXlvdXQ6IHsKICAgICAgCQl0eXBlOiAibGF5b3V0IiwKICAgICAgCQlkb2M6ICJMYXlvdXQgcHJvcGVydGllcyBmb3IgdGhlIGxheWVyLiIKICAgICAgCX0sCiAgICAgIAlwYWludDogewogICAgICAJCXR5cGU6ICJwYWludCIsCiAgICAgIAkJZG9jOiAiRGVmYXVsdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLiIKICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIGxheW91dCA9IFsKICAgICAgCSJsYXlvdXRfZmlsbCIsCiAgICAgIAkibGF5b3V0X2xpbmUiLAogICAgICAJImxheW91dF9jaXJjbGUiLAogICAgICAJImxheW91dF9oZWF0bWFwIiwKICAgICAgCSJsYXlvdXRfZmlsbC1leHRydXNpb24iLAogICAgICAJImxheW91dF9zeW1ib2wiLAogICAgICAJImxheW91dF9yYXN0ZXIiLAogICAgICAJImxheW91dF9oaWxsc2hhZGUiLAogICAgICAJImxheW91dF9iYWNrZ3JvdW5kIgogICAgICBdOwogICAgICB2YXIgbGF5b3V0X2JhY2tncm91bmQgPSB7CiAgICAgIAl2aXNpYmlsaXR5OiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQl2aXNpYmxlOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgICAJCQl9LAogICAgICAJCQlub25lOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAgIAkJZG9jOiAiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY29uc3RhbnQiCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBsYXlvdXRfZmlsbCA9IHsKICAgICAgCSJmaWxsLXNvcnQta2V5IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjEuMi4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI5LjEuMCIsCiAgICAgIAkJCQlpb3M6ICI1LjguMCIsCiAgICAgIAkJCQltYWNvczogIjAuMTUuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjEuMi4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI5LjEuMCIsCiAgICAgIAkJCQlpb3M6ICI1LjguMCIsCiAgICAgIAkJCQltYWNvczogIjAuMTUuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJdmlzaWJpbGl0eTogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJdmlzaWJsZTogewogICAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIHNob3duLiIKICAgICAgCQkJfSwKICAgICAgCQkJbm9uZTogewogICAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIG5vdCBzaG93bi4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogInZpc2libGUiLAogICAgICAJCWRvYzogIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgbGF5b3V0X2NpcmNsZSA9IHsKICAgICAgCSJjaXJjbGUtc29ydC1rZXkiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJZG9jOiAiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBhcHBlYXIgYWJvdmUgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMS4yLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjkuMi4wIiwKICAgICAgCQkJCWlvczogIjUuOS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNi4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMS4yLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjkuMi4wIiwKICAgICAgCQkJCWlvczogIjUuOS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNi4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAl2aXNpYmlsaXR5OiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQl2aXNpYmxlOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgICAJCQl9LAogICAgICAJCQlub25lOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAgIAkJZG9jOiAiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY29uc3RhbnQiCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBsYXlvdXRfaGVhdG1hcCA9IHsKICAgICAgCXZpc2liaWxpdHk6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCXZpc2libGU6IHsKICAgICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBzaG93bi4iCiAgICAgIAkJCX0sCiAgICAgIAkJCW5vbmU6IHsKICAgICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBub3Qgc2hvd24uIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJ2aXNpYmxlIiwKICAgICAgCQlkb2M6ICJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJjb25zdGFudCIKICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIGxheW91dF9saW5lID0gewogICAgICAJImxpbmUtY2FwIjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJYnV0dDogewogICAgICAJCQkJZG9jOiAiQSBjYXAgd2l0aCBhIHNxdWFyZWQtb2ZmIGVuZCB3aGljaCBpcyBkcmF3biB0byB0aGUgZXhhY3QgZW5kcG9pbnQgb2YgdGhlIGxpbmUuIgogICAgICAJCQl9LAogICAgICAJCQlyb3VuZDogewogICAgICAJCQkJZG9jOiAiQSBjYXAgd2l0aCBhIHJvdW5kZWQgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSByYWRpdXMgb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aCBhbmQgY2VudGVyZWQgb24gdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lLiIKICAgICAgCQkJfSwKICAgICAgCQkJc3F1YXJlOiB7CiAgICAgIAkJCQlkb2M6ICJBIGNhcCB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSBkaXN0YW5jZSBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAiYnV0dCIsCiAgICAgIAkJZG9jOiAiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJsaW5lLWpvaW4iOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQliZXZlbDogewogICAgICAJCQkJZG9jOiAiQSBqb2luIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIGRpc3RhbmNlIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGguIgogICAgICAJCQl9LAogICAgICAJCQlyb3VuZDogewogICAgICAJCQkJZG9jOiAiQSBqb2luIHdpdGggYSByb3VuZGVkIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgcmFkaXVzIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGggYW5kIGNlbnRlcmVkIG9uIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZS4iCiAgICAgIAkJCX0sCiAgICAgIAkJCW1pdGVyOiB7CiAgICAgIAkJCQlkb2M6ICJBIGpvaW4gd2l0aCBhIHNoYXJwLCBhbmdsZWQgY29ybmVyIHdoaWNoIGlzIGRyYXduIHdpdGggdGhlIG91dGVyIHNpZGVzIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIHBhdGggdW50aWwgdGhleSBtZWV0LiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAibWl0ZXIiLAogICAgICAJCWRvYzogIlRoZSBkaXNwbGF5IG9mIGxpbmVzIHdoZW4gam9pbmluZy4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImxpbmUtbWl0ZXItbGltaXQiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAyLAogICAgICAJCWRvYzogIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IG1pdGVyIGpvaW5zIHRvIGJldmVsIGpvaW5zIGZvciBzaGFycCBhbmdsZXMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQl7CiAgICAgIAkJCQkibGluZS1qb2luIjogIm1pdGVyIgogICAgICAJCQl9CiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkibGluZS1yb3VuZC1saW1pdCI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDEuMDUsCiAgICAgIAkJZG9jOiAiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgcm91bmQgam9pbnMgdG8gbWl0ZXIgam9pbnMgZm9yIHNoYWxsb3cgYW5nbGVzLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJewogICAgICAJCQkJImxpbmUtam9pbiI6ICJyb3VuZCIKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImxpbmUtc29ydC1rZXkiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJZG9jOiAiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBhcHBlYXIgYWJvdmUgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMS4yLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgICAgCQkJCWlvczogIjUuOC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMS4yLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgICAgCQkJCWlvczogIjUuOC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAl2aXNpYmlsaXR5OiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQl2aXNpYmxlOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgICAJCQl9LAogICAgICAJCQlub25lOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAgIAkJZG9jOiAiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY29uc3RhbnQiCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBsYXlvdXRfc3ltYm9sID0gewogICAgICAJInN5bWJvbC1wbGFjZW1lbnQiOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQlwb2ludDogewogICAgICAJCQkJZG9jOiAiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGdlb21ldHJ5IGlzIGxvY2F0ZWQuIgogICAgICAJCQl9LAogICAgICAJCQlsaW5lOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGFiZWwgaXMgcGxhY2VkIGFsb25nIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLiIKICAgICAgCQkJfSwKICAgICAgCQkJImxpbmUtY2VudGVyIjogewogICAgICAJCQkJZG9jOiAiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLiBOb3RlIHRoYXQgYSBzaW5nbGUgZmVhdHVyZSBpbiBhIHZlY3RvciB0aWxlIG1heSBjb250YWluIG11bHRpcGxlIGxpbmUgZ2VvbWV0cmllcy4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogInBvaW50IiwKICAgICAgCQlkb2M6ICJMYWJlbCBwbGFjZW1lbnQgcmVsYXRpdmUgdG8gaXRzIGdlb21ldHJ5LiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiYGxpbmUtY2VudGVyYCB2YWx1ZSI6IHsKICAgICAgCQkJCWpzOiAiMC40Ny4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjQuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjMuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMTAuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkic3ltYm9sLXNwYWNpbmciOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAyNTAsCiAgICAgIAkJbWluaW11bTogMSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiRGlzdGFuY2UgYmV0d2VlbiB0d28gc3ltYm9sIGFuY2hvcnMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQl7CiAgICAgIAkJCQkic3ltYm9sLXBsYWNlbWVudCI6ICJsaW5lIgogICAgICAJCQl9CiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkic3ltYm9sLWF2b2lkLWVkZ2VzIjogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgICAJCWRvYzogIklmIHRydWUsIHRoZSBzeW1ib2xzIHdpbGwgbm90IGNyb3NzIHRpbGUgZWRnZXMgdG8gYXZvaWQgbXV0dWFsIGNvbGxpc2lvbnMuIFJlY29tbWVuZGVkIGluIGxheWVycyB0aGF0IGRvbid0IGhhdmUgZW5vdWdoIHBhZGRpbmcgaW4gdGhlIHZlY3RvciB0aWxlIHRvIHByZXZlbnQgY29sbGlzaW9ucywgb3IgaWYgaXQgaXMgYSBwb2ludCBzeW1ib2wgbGF5ZXIgcGxhY2VkIGFmdGVyIGEgbGluZSBzeW1ib2wgbGF5ZXIuIFdoZW4gdXNpbmcgYSBjbGllbnQgdGhhdCBzdXBwb3J0cyBnbG9iYWwgY29sbGlzaW9uIGRldGVjdGlvbiwgbGlrZSBNYXBib3ggR0wgSlMgdmVyc2lvbiAwLjQyLjAgb3IgZ3JlYXRlciwgZW5hYmxpbmcgdGhpcyBwcm9wZXJ0eSBpcyBub3QgbmVlZGVkIHRvIHByZXZlbnQgY2xpcHBlZCBsYWJlbHMgYXQgdGlsZSBib3VuZGFyaWVzLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJzeW1ib2wtc29ydC1rZXkiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJZG9jOiAiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggbG93ZXIgc29ydCBrZXlzIGFyZSBkcmF3biBhbmQgcGxhY2VkIGZpcnN0LiAgV2hlbiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBgZmFsc2VgLCBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkgd2lsbCBoYXZlIHByaW9yaXR5IGR1cmluZyBwbGFjZW1lbnQuIFdoZW4gYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCwgZmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIG92ZXJsYXAgb3ZlciBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjUzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjcuNC4wIiwKICAgICAgCQkJCWlvczogIjQuMTEuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMTQuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNTMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNy40LjAiLAogICAgICAJCQkJaW9zOiAiNC4xMS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkic3ltYm9sLXotb3JkZXIiOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQlhdXRvOiB7CiAgICAgIAkJCQlkb2M6ICJTb3J0cyBzeW1ib2xzIGJ5IGBzeW1ib2wtc29ydC1rZXlgIGlmIHNldC4gT3RoZXJ3aXNlLCBzb3J0cyBzeW1ib2xzIGJ5IHRoZWlyIHktcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGlmIGBpY29uLWFsbG93LW92ZXJsYXBgIG9yIGB0ZXh0LWFsbG93LW92ZXJsYXBgIGlzIHNldCB0byBgdHJ1ZWAgb3IgYGljb24taWdub3JlLXBsYWNlbWVudGAgb3IgYHRleHQtaWdub3JlLXBsYWNlbWVudGAgaXMgYGZhbHNlYC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCSJ2aWV3cG9ydC15IjogewogICAgICAJCQkJZG9jOiAiU29ydHMgc3ltYm9scyBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBpZiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBzZXQgdG8gYHRydWVgIG9yIGBpY29uLWlnbm9yZS1wbGFjZW1lbnRgIG9yIGB0ZXh0LWlnbm9yZS1wbGFjZW1lbnRgIGlzIGBmYWxzZWAuIgogICAgICAJCQl9LAogICAgICAJCQlzb3VyY2U6IHsKICAgICAgCQkJCWRvYzogIlNvcnRzIHN5bWJvbHMgYnkgYHN5bWJvbC1zb3J0LWtleWAgaWYgc2V0LiBPdGhlcndpc2UsIG5vIHNvcnRpbmcgaXMgYXBwbGllZDsgc3ltYm9scyBhcmUgcmVuZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHNvdXJjZSBkYXRhLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAiYXV0byIsCiAgICAgIAkJZG9jOiAiRGV0ZXJtaW5lcyB3aGV0aGVyIG92ZXJsYXBwaW5nIHN5bWJvbHMgaW4gdGhlIHNhbWUgbGF5ZXIgYXJlIHJlbmRlcmVkIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXBwZWFyIGluIHRoZSBkYXRhIHNvdXJjZSBvciBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC4gVG8gY29udHJvbCB0aGUgb3JkZXIgYW5kIHByaW9yaXRpemF0aW9uIG9mIHN5bWJvbHMgb3RoZXJ3aXNlLCB1c2UgYHN5bWJvbC1zb3J0LWtleWAuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjQ5LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjYuNi4wIiwKICAgICAgCQkJCWlvczogIjQuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xMi4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJpY29uLWFsbG93LW92ZXJsYXAiOiB7CiAgICAgIAkJdHlwZTogImJvb2xlYW4iLAogICAgICAJCSJkZWZhdWx0IjogZmFsc2UsCiAgICAgIAkJZG9jOiAiSWYgdHJ1ZSwgdGhlIGljb24gd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1pZ25vcmUtcGxhY2VtZW50IjogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgICAJCWRvYzogIklmIHRydWUsIG90aGVyIHN5bWJvbHMgY2FuIGJlIHZpc2libGUgZXZlbiBpZiB0aGV5IGNvbGxpZGUgd2l0aCB0aGUgaWNvbi4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJpY29uLWltYWdlIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJpY29uLW9wdGlvbmFsIjogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgICAJCWRvYzogIklmIHRydWUsIHRleHQgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyBpY29ucyB3aGVuIHRoZSBpY29uIGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIHRleHQgZG9lcyBub3QuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIsCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJpY29uLXJvdGF0aW9uLWFsaWdubWVudCI6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCW1hcDogewogICAgICAJCQkJZG9jOiAiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIGFsaWducyBpY29ucyBlYXN0LXdlc3QuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgYWxpZ25zIGljb24geC1heGVzIHdpdGggdGhlIGxpbmUuIgogICAgICAJCQl9LAogICAgICAJCQl2aWV3cG9ydDogewogICAgICAJCQkJZG9jOiAiUHJvZHVjZXMgaWNvbnMgd2hvc2UgeC1heGVzIGFyZSBhbGlnbmVkIHdpdGggdGhlIHgtYXhpcyBvZiB0aGUgdmlld3BvcnQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzeW1ib2wtcGxhY2VtZW50YC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCWF1dG86IHsKICAgICAgCQkJCWRvYzogIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYHZpZXdwb3J0YC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYG1hcGAuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJhdXRvIiwKICAgICAgCQlkb2M6ICJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgaWNvbnMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImBhdXRvYCB2YWx1ZSI6IHsKICAgICAgCQkJCWpzOiAiMC4yNS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjQuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJpY29uLXNpemUiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdW5pdHM6ICJmYWN0b3Igb2YgdGhlIG9yaWdpbmFsIGljb24gc2l6ZSIsCiAgICAgIAkJZG9jOiAiU2NhbGVzIHRoZSBvcmlnaW5hbCBzaXplIG9mIHRoZSBpY29uIGJ5IHRoZSBwcm92aWRlZCBmYWN0b3IuIFRoZSBuZXcgcGl4ZWwgc2l6ZSBvZiB0aGUgaW1hZ2Ugd2lsbCBiZSB0aGUgb3JpZ2luYWwgcGl4ZWwgc2l6ZSBtdWx0aXBsaWVkIGJ5IGBpY29uLXNpemVgLiAxIGlzIHRoZSBvcmlnaW5hbCBzaXplOyAzIHRyaXBsZXMgdGhlIHNpemUgb2YgdGhlIGltYWdlLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJImljb24taW1hZ2UiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjM1LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgICAgCQkJCWlvczogIjMuNi4wIiwKICAgICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImljb24tdGV4dC1maXQiOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQlub25lOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgaWNvbiBpcyBkaXNwbGF5ZWQgYXQgaXRzIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIgogICAgICAJCQl9LAogICAgICAJCQl3aWR0aDogewogICAgICAJCQkJZG9jOiAiVGhlIGljb24gaXMgc2NhbGVkIGluIHRoZSB4LWRpbWVuc2lvbiB0byBmaXQgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0LiIKICAgICAgCQkJfSwKICAgICAgCQkJaGVpZ2h0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHktZGltZW5zaW9uIHRvIGZpdCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LiIKICAgICAgCQkJfSwKICAgICAgCQkJYm90aDogewogICAgICAJCQkJZG9jOiAiVGhlIGljb24gaXMgc2NhbGVkIGluIGJvdGggeC0gYW5kIHktZGltZW5zaW9ucy4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogIm5vbmUiLAogICAgICAJCWRvYzogIlNjYWxlcyB0aGUgaWNvbiB0byBmaXQgYXJvdW5kIHRoZSBhc3NvY2lhdGVkIHRleHQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIsCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4yMS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjQuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMi4xIgogICAgICAJCQl9LAogICAgICAJCQkic3RyZXRjaGFibGUgaWNvbnMiOiB7CiAgICAgIAkJCQlqczogIjEuNi4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI5LjIuMCIsCiAgICAgIAkJCQlpb3M6ICI1LjguMCIsCiAgICAgIAkJCQltYWNvczogIjAuMTUuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiaWNvbi10ZXh0LWZpdC1wYWRkaW5nIjogewogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgICAJCWxlbmd0aDogNCwKICAgICAgCQkiZGVmYXVsdCI6IFsKICAgICAgCQkJMCwKICAgICAgCQkJMCwKICAgICAgCQkJMCwKICAgICAgCQkJMAogICAgICAJCV0sCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhZGRlZCB0byBkaW1lbnNpb25zIGRldGVybWluZWQgYnkgYGljb24tdGV4dC1maXRgLCBpbiBjbG9ja3dpc2Ugb3JkZXI6IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdC4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJpY29uLWltYWdlIiwKICAgICAgCQkJInRleHQtZmllbGQiLAogICAgICAJCQl7CiAgICAgIAkJCQkiaWNvbi10ZXh0LWZpdCI6IFsKICAgICAgCQkJCQkiYm90aCIsCiAgICAgIAkJCQkJIndpZHRoIiwKICAgICAgCQkJCQkiaGVpZ2h0IgogICAgICAJCQkJXQogICAgICAJCQl9CiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjIxLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjQuMi4wIiwKICAgICAgCQkJCWlvczogIjMuNC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4yLjEiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1pbWFnZSI6IHsKICAgICAgCQl0eXBlOiAicmVzb2x2ZWRJbWFnZSIsCiAgICAgIAkJZG9jOiAiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGFuIGltYWdlIGJhY2tncm91bmQuIiwKICAgICAgCQl0b2tlbnM6IHRydWUsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4zNS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1yb3RhdGUiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCXBlcmlvZDogMzYwLAogICAgICAJCXVuaXRzOiAiZGVncmVlcyIsCiAgICAgIAkJZG9jOiAiUm90YXRlcyB0aGUgaWNvbiBjbG9ja3dpc2UuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMjEuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1wYWRkaW5nIjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMiwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgICAgCQlkb2M6ICJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSBpY29uIGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJpY29uLWtlZXAtdXByaWdodCI6IHsKICAgICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgICAgCQlkb2M6ICJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIsCiAgICAgIAkJCXsKICAgICAgCQkJCSJpY29uLXJvdGF0aW9uLWFsaWdubWVudCI6ICJtYXAiCiAgICAgIAkJCX0sCiAgICAgIAkJCXsKICAgICAgCQkJCSJzeW1ib2wtcGxhY2VtZW50IjogWwogICAgICAJCQkJCSJsaW5lIiwKICAgICAgCQkJCQkibGluZS1jZW50ZXIiCiAgICAgIAkJCQldCiAgICAgIAkJCX0KICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1vZmZzZXQiOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAgIAkJbGVuZ3RoOiAyLAogICAgICAJCSJkZWZhdWx0IjogWwogICAgICAJCQkwLAogICAgICAJCQkwCiAgICAgIAkJXSwKICAgICAgCQlkb2M6ICJPZmZzZXQgZGlzdGFuY2Ugb2YgaWNvbiBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiBFYWNoIGNvbXBvbmVudCBpcyBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZSBvZiBgaWNvbi1zaXplYCB0byBvYnRhaW4gdGhlIGZpbmFsIG9mZnNldCBpbiBwaXhlbHMuIFdoZW4gY29tYmluZWQgd2l0aCBgaWNvbi1yb3RhdGVgIHRoZSBvZmZzZXQgd2lsbCBiZSBhcyBpZiB0aGUgcm90YXRlZCBkaXJlY3Rpb24gd2FzIHVwLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJImljb24taW1hZ2UiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImljb24tYW5jaG9yIjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJY2VudGVyOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgY2VudGVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQlsZWZ0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGVmdCBzaWRlIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQlyaWdodDogewogICAgICAJCQkJZG9jOiAiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXRvcDogewogICAgICAJCQkJZG9jOiAiVGhlIHRvcCBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJYm90dG9tOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgYm90dG9tIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQkidG9wLWxlZnQiOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQkidG9wLXJpZ2h0IjogewogICAgICAJCQkJZG9jOiAiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCSJib3R0b20tbGVmdCI6IHsKICAgICAgCQkJCWRvYzogIlRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCSJib3R0b20tcmlnaHQiOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAiY2VudGVyIiwKICAgICAgCQlkb2M6ICJQYXJ0IG9mIHRoZSBpY29uIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuNDAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImljb24tcGl0Y2gtYWxpZ25tZW50IjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJbWFwOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgaWNvbiBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgbWFwLiIKICAgICAgCQkJfSwKICAgICAgCQkJdmlld3BvcnQ6IHsKICAgICAgCQkJCWRvYzogIlRoZSBpY29uIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSB2aWV3cG9ydC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCWF1dG86IHsKICAgICAgCQkJCWRvYzogIkF1dG9tYXRpY2FsbHkgbWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGljb24tcm90YXRpb24tYWxpZ25tZW50YC4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogImF1dG8iLAogICAgICAJCWRvYzogIk9yaWVudGF0aW9uIG9mIGljb24gd2hlbiBtYXAgaXMgcGl0Y2hlZC4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJpY29uLWltYWdlIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4zOS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjIuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjcuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LXBpdGNoLWFsaWdubWVudCI6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCW1hcDogewogICAgICAJCQkJZG9jOiAiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXZpZXdwb3J0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuIgogICAgICAJCQl9LAogICAgICAJCQlhdXRvOiB7CiAgICAgIAkJCQlkb2M6ICJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGB0ZXh0LXJvdGF0aW9uLWFsaWdubWVudGAuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJhdXRvIiwKICAgICAgCQlkb2M6ICJPcmllbnRhdGlvbiBvZiB0ZXh0IHdoZW4gbWFwIGlzIHBpdGNoZWQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMjEuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNC4yLjAiLAogICAgICAJCQkJaW9zOiAiMy40LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjIuMSIKICAgICAgCQkJfSwKICAgICAgCQkJImBhdXRvYCB2YWx1ZSI6IHsKICAgICAgCQkJCWpzOiAiMC4yNS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjQuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCI6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCW1hcDogewogICAgICAJCQkJZG9jOiAiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIGFsaWducyB0ZXh0IGVhc3Qtd2VzdC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCBhbGlnbnMgdGV4dCB4LWF4ZXMgd2l0aCB0aGUgbGluZS4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXZpZXdwb3J0OiB7CiAgICAgIAkJCQlkb2M6ICJQcm9kdWNlcyBnbHlwaHMgd2hvc2UgeC1heGVzIGFyZSBhbGlnbmVkIHdpdGggdGhlIHgtYXhpcyBvZiB0aGUgdmlld3BvcnQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzeW1ib2wtcGxhY2VtZW50YC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCWF1dG86IHsKICAgICAgCQkJCWRvYzogIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYHZpZXdwb3J0YC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYG1hcGAuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJhdXRvIiwKICAgICAgCQlkb2M6ICJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgdGhlIGluZGl2aWR1YWwgZ2x5cGhzIGZvcm1pbmcgdGhlIHRleHQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImBhdXRvYCB2YWx1ZSI6IHsKICAgICAgCQkJCWpzOiAiMC4yNS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjQuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LWZpZWxkIjogewogICAgICAJCXR5cGU6ICJmb3JtYXR0ZWQiLAogICAgICAJCSJkZWZhdWx0IjogIiIsCiAgICAgIAkJdG9rZW5zOiB0cnVlLAogICAgICAJCWRvYzogIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBJZiBhIHBsYWluIGBzdHJpbmdgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBgZm9ybWF0dGVkYCB3aXRoIGRlZmF1bHQvaW5oZXJpdGVkIGZvcm1hdHRpbmcgb3B0aW9ucy4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJInRleHQtZm9udCI6IHsKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCXZhbHVlOiAic3RyaW5nIiwKICAgICAgCQkiZGVmYXVsdCI6IFsKICAgICAgCQkJIk9wZW4gU2FucyBSZWd1bGFyIiwKICAgICAgCQkJIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhciIKICAgICAgCQldLAogICAgICAJCWRvYzogIkZvbnQgc3RhY2sgdG8gdXNlIGZvciBkaXNwbGF5aW5nIHRleHQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJInRleHQtc2l6ZSI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDE2LAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIkZvbnQgc2l6ZS4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4zNS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJ0ZXh0LW1heC13aWR0aCI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDEwLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdW5pdHM6ICJlbXMiLAogICAgICAJCWRvYzogIlRoZSBtYXhpbXVtIGxpbmUgd2lkdGggZm9yIHRleHQgd3JhcHBpbmcuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkidGV4dC1saW5lLWhlaWdodCI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDEuMiwKICAgICAgCQl1bml0czogImVtcyIsCiAgICAgIAkJZG9jOiAiVGV4dCBsZWFkaW5nIHZhbHVlIGZvciBtdWx0aS1saW5lIHRleHQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LWxldHRlci1zcGFjaW5nIjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMCwKICAgICAgCQl1bml0czogImVtcyIsCiAgICAgIAkJZG9jOiAiVGV4dCB0cmFja2luZyBhbW91bnQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkidGV4dC1qdXN0aWZ5IjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJYXV0bzogewogICAgICAJCQkJZG9jOiAiVGhlIHRleHQgaXMgYWxpZ25lZCB0b3dhcmRzIHRoZSBhbmNob3IgcG9zaXRpb24uIgogICAgICAJCQl9LAogICAgICAJCQlsZWZ0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBsZWZ0LiIKICAgICAgCQkJfSwKICAgICAgCQkJY2VudGVyOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyBjZW50ZXJlZC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXJpZ2h0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSByaWdodC4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogImNlbnRlciIsCiAgICAgIAkJZG9jOiAiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzkuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgICAgCQkJfSwKICAgICAgCQkJYXV0bzogewogICAgICAJCQkJanM6ICIwLjU0LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjcuNC4wIiwKICAgICAgCQkJCWlvczogIjQuMTAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMTQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJInRleHQtcmFkaWFsLW9mZnNldCI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQl1bml0czogImVtcyIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCWRvYzogIlJhZGlhbCBvZmZzZXQgb2YgdGV4dCwgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3ltYm9sJ3MgYW5jaG9yLiBVc2VmdWwgaW4gY29tYmluYXRpb24gd2l0aCBgdGV4dC12YXJpYWJsZS1hbmNob3JgLCB3aGljaCBkZWZhdWx0cyB0byB1c2luZyB0aGUgdHdvLWRpbWVuc2lvbmFsIGB0ZXh0LW9mZnNldGAgaWYgcHJlc2VudC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuNTQuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNy40LjAiLAogICAgICAJCQkJaW9zOiAiNC4xMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNC4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC41NC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI3LjQuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjEwLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjE0LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgICAJCV0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iLAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0KICAgICAgCX0sCiAgICAgIAkidGV4dC12YXJpYWJsZS1hbmNob3IiOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQl2YWx1ZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQljZW50ZXI6IHsKICAgICAgCQkJCWRvYzogIlRoZSBjZW50ZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCWxlZnQ6IHsKICAgICAgCQkJCWRvYzogIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXJpZ2h0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJdG9wOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdG9wIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQlib3R0b206IHsKICAgICAgCQkJCWRvYzogIlRoZSBib3R0b20gb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCSJ0b3AtbGVmdCI6IHsKICAgICAgCQkJCWRvYzogIlRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCSJ0b3AtcmlnaHQiOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJImJvdHRvbS1sZWZ0IjogewogICAgICAJCQkJZG9jOiAiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJImJvdHRvbS1yaWdodCI6IHsKICAgICAgCQkJCWRvYzogIlRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIsCiAgICAgIAkJCXsKICAgICAgCQkJCSJzeW1ib2wtcGxhY2VtZW50IjogWwogICAgICAJCQkJCSJwb2ludCIKICAgICAgCQkJCV0KICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJZG9jOiAiVG8gaW5jcmVhc2UgdGhlIGNoYW5jZSBvZiBwbGFjaW5nIGhpZ2gtcHJpb3JpdHkgbGFiZWxzIG9uIHRoZSBtYXAsIHlvdSBjYW4gcHJvdmlkZSBhbiBhcnJheSBvZiBgdGV4dC1hbmNob3JgIGxvY2F0aW9uczogdGhlIHJlbmRlcmVyIHdpbGwgYXR0ZW1wdCB0byBwbGFjZSB0aGUgbGFiZWwgYXQgZWFjaCBsb2NhdGlvbiwgaW4gb3JkZXIsIGJlZm9yZSBtb3Zpbmcgb250byB0aGUgbmV4dCBsYWJlbC4gVXNlIGB0ZXh0LWp1c3RpZnk6IGF1dG9gIHRvIGNob29zZSBqdXN0aWZpY2F0aW9uIGJhc2VkIG9uIGFuY2hvciBwb3NpdGlvbi4gVG8gYXBwbHkgYW4gb2Zmc2V0LCB1c2UgdGhlIGB0ZXh0LXJhZGlhbC1vZmZzZXRgIG9yIHRoZSB0d28tZGltZW5zaW9uYWwgYHRleHQtb2Zmc2V0YC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuNTQuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNy40LjAiLAogICAgICAJCQkJaW9zOiAiNC4xMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LWFuY2hvciI6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCWNlbnRlcjogewogICAgICAJCQkJZG9jOiAiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJbGVmdDogewogICAgICAJCQkJZG9jOiAiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJcmlnaHQ6IHsKICAgICAgCQkJCWRvYzogIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQl0b3A6IHsKICAgICAgCQkJCWRvYzogIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0sCiAgICAgIAkJCWJvdHRvbTogewogICAgICAJCQkJZG9jOiAiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJInRvcC1sZWZ0IjogewogICAgICAJCQkJZG9jOiAiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIKICAgICAgCQkJfSwKICAgICAgCQkJInRvcC1yaWdodCI6IHsKICAgICAgCQkJCWRvYzogIlRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQkiYm90dG9tLWxlZnQiOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuIgogICAgICAJCQl9LAogICAgICAJCQkiYm90dG9tLXJpZ2h0IjogewogICAgICAJCQkJZG9jOiAiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogImNlbnRlciIsCiAgICAgIAkJZG9jOiAiUGFydCBvZiB0aGUgdGV4dCBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJInRleHQtZmllbGQiLAogICAgICAJCQl7CiAgICAgIAkJCQkiISI6ICJ0ZXh0LXZhcmlhYmxlLWFuY2hvciIKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4zOS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjIuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjcuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNi4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkidGV4dC1tYXgtYW5nbGUiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiA0NSwKICAgICAgCQl1bml0czogImRlZ3JlZXMiLAogICAgICAJCWRvYzogIk1heGltdW0gYW5nbGUgY2hhbmdlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIiwKICAgICAgCQkJewogICAgICAJCQkJInN5bWJvbC1wbGFjZW1lbnQiOiBbCiAgICAgIAkJCQkJImxpbmUiLAogICAgICAJCQkJCSJsaW5lLWNlbnRlciIKICAgICAgCQkJCV0KICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJInRleHQtd3JpdGluZy1tb2RlIjogewogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJaG9yaXpvbnRhbDogewogICAgICAJCQkJZG9jOiAiSWYgYSB0ZXh0J3MgbGFuZ3VhZ2Ugc3VwcG9ydHMgaG9yaXpvbnRhbCB3cml0aW5nIG1vZGUsIHN5bWJvbHMgd2l0aCBwb2ludCBwbGFjZW1lbnQgd291bGQgYmUgbGFpZCBvdXQgaG9yaXpvbnRhbGx5LiIKICAgICAgCQkJfSwKICAgICAgCQkJdmVydGljYWw6IHsKICAgICAgCQkJCWRvYzogIklmIGEgdGV4dCdzIGxhbmd1YWdlIHN1cHBvcnRzIHZlcnRpY2FsIHdyaXRpbmcgbW9kZSwgc3ltYm9scyB3aXRoIHBvaW50IHBsYWNlbWVudCB3b3VsZCBiZSBsYWlkIG91dCB2ZXJ0aWNhbGx5LiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZG9jOiAiVGhlIHByb3BlcnR5IGFsbG93cyBjb250cm9sIG92ZXIgYSBzeW1ib2wncyBvcmllbnRhdGlvbi4gTm90ZSB0aGF0IHRoZSBwcm9wZXJ0eSB2YWx1ZXMgYWN0IGFzIGEgaGludCwgc28gdGhhdCBhIHN5bWJvbCB3aG9zZSBsYW5ndWFnZSBkb2VzbuKAmXQgc3VwcG9ydCB0aGUgcHJvdmlkZWQgb3JpZW50YXRpb24gd2lsbCBiZSBsYWlkIG91dCBpbiBpdHMgbmF0dXJhbCBvcmllbnRhdGlvbi4gRXhhbXBsZTogRW5nbGlzaCBwb2ludCBzeW1ib2wgd2lsbCBiZSByZW5kZXJlZCBob3Jpem9udGFsbHkgZXZlbiBpZiBhcnJheSB2YWx1ZSBjb250YWlucyBzaW5nbGUgJ3ZlcnRpY2FsJyBlbnVtIHZhbHVlLiBUaGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gYW4gYXJyYXkgZGVmaW5lIHByaW9yaXR5IG9yZGVyIGZvciB0aGUgcGxhY2VtZW50IG9mIGFuIG9yaWVudGF0aW9uIHZhcmlhbnQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIsCiAgICAgIAkJCXsKICAgICAgCQkJCSJzeW1ib2wtcGxhY2VtZW50IjogWwogICAgICAJCQkJCSJwb2ludCIKICAgICAgCQkJCV0KICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMS4zLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjguMy4wIiwKICAgICAgCQkJCWlvczogIjUuMy4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xNS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LXJvdGF0ZSI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAsCiAgICAgIAkJcGVyaW9kOiAzNjAsCiAgICAgIAkJdW5pdHM6ICJkZWdyZWVzIiwKICAgICAgCQlkb2M6ICJSb3RhdGVzIHRoZSB0ZXh0IGNsb2Nrd2lzZS4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4zNS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJ0ZXh0LXBhZGRpbmciOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAyLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIHRleHQgYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJInRleHQta2VlcC11cHJpZ2h0IjogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IHRydWUsCiAgICAgIAkJZG9jOiAiSWYgdHJ1ZSwgdGhlIHRleHQgbWF5IGJlIGZsaXBwZWQgdmVydGljYWxseSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIsCiAgICAgIAkJCXsKICAgICAgCQkJCSJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCI6ICJtYXAiCiAgICAgIAkJCX0sCiAgICAgIAkJCXsKICAgICAgCQkJCSJzeW1ib2wtcGxhY2VtZW50IjogWwogICAgICAJCQkJCSJsaW5lIiwKICAgICAgCQkJCQkibGluZS1jZW50ZXIiCiAgICAgIAkJCQldCiAgICAgIAkJCX0KICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkidGV4dC10cmFuc2Zvcm0iOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQlub25lOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyBub3QgYWx0ZXJlZC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXVwcGVyY2FzZTogewogICAgICAJCQkJZG9jOiAiRm9yY2VzIGFsbCBsZXR0ZXJzIHRvIGJlIGRpc3BsYXllZCBpbiB1cHBlcmNhc2UuIgogICAgICAJCQl9LAogICAgICAJCQlsb3dlcmNhc2U6IHsKICAgICAgCQkJCWRvYzogIkZvcmNlcyBhbGwgbGV0dGVycyB0byBiZSBkaXNwbGF5ZWQgaW4gbG93ZXJjYXNlLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAibm9uZSIsCiAgICAgIAkJZG9jOiAiU3BlY2lmaWVzIGhvdyB0byBjYXBpdGFsaXplIHRleHQsIHNpbWlsYXIgdG8gdGhlIENTUyBgdGV4dC10cmFuc2Zvcm1gIHByb3BlcnR5LiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJInRleHQtZmllbGQiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjMzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJ0ZXh0LW9mZnNldCI6IHsKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCWRvYzogIk9mZnNldCBkaXN0YW5jZSBvZiB0ZXh0IGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIElmIHVzZWQgd2l0aCB0ZXh0LXZhcmlhYmxlLWFuY2hvciwgaW5wdXQgdmFsdWVzIHdpbGwgYmUgdGFrZW4gYXMgYWJzb2x1dGUgdmFsdWVzLiBPZmZzZXRzIGFsb25nIHRoZSB4LSBhbmQgeS1heGlzIHdpbGwgYmUgYXBwbGllZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSBhbmNob3IgcG9zaXRpb24uIiwKICAgICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAgIAkJdW5pdHM6ICJlbXMiLAogICAgICAJCWxlbmd0aDogMiwKICAgICAgCQkiZGVmYXVsdCI6IFsKICAgICAgCQkJMCwKICAgICAgCQkJMAogICAgICAJCV0sCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJInRleHQtZmllbGQiLAogICAgICAJCQl7CiAgICAgIAkJCQkiISI6ICJ0ZXh0LXJhZGlhbC1vZmZzZXQiCiAgICAgIAkJCX0KICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzUuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkidGV4dC1hbGxvdy1vdmVybGFwIjogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IGZhbHNlLAogICAgICAJCWRvYzogIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJInRleHQtZmllbGQiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJInRleHQtaWdub3JlLXBsYWNlbWVudCI6IHsKICAgICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgICAgCQlkb2M6ICJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIHRleHQuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkidGV4dC1vcHRpb25hbCI6IHsKICAgICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAgIAkJImRlZmF1bHQiOiBmYWxzZSwKICAgICAgCQlkb2M6ICJJZiB0cnVlLCBpY29ucyB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIHRleHQgd2hlbiB0aGUgdGV4dCBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSBpY29uIGRvZXMgbm90LiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJInRleHQtZmllbGQiLAogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAl2aXNpYmlsaXR5OiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQl2aXNpYmxlOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgc2hvd24uIgogICAgICAJCQl9LAogICAgICAJCQlub25lOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGF5ZXIgaXMgbm90IHNob3duLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAidmlzaWJsZSIsCiAgICAgIAkJZG9jOiAiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY29uc3RhbnQiCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBsYXlvdXRfcmFzdGVyID0gewogICAgICAJdmlzaWJpbGl0eTogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJdmlzaWJsZTogewogICAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIHNob3duLiIKICAgICAgCQkJfSwKICAgICAgCQkJbm9uZTogewogICAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIG5vdCBzaG93bi4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogInZpc2libGUiLAogICAgICAJCWRvYzogIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgbGF5b3V0X2hpbGxzaGFkZSA9IHsKICAgICAgCXZpc2liaWxpdHk6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCXZpc2libGU6IHsKICAgICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBzaG93bi4iCiAgICAgIAkJCX0sCiAgICAgIAkJCW5vbmU6IHsKICAgICAgCQkJCWRvYzogIlRoZSBsYXllciBpcyBub3Qgc2hvd24uIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJ2aXNpYmxlIiwKICAgICAgCQlkb2M6ICJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC40My4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJjb25zdGFudCIKICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIGZpbHRlciA9IHsKICAgICAgCXR5cGU6ICJhcnJheSIsCiAgICAgIAl2YWx1ZTogIioiLAogICAgICAJZG9jOiAiQSBmaWx0ZXIgc2VsZWN0cyBzcGVjaWZpYyBmZWF0dXJlcyBmcm9tIGEgbGF5ZXIuIgogICAgICB9OwogICAgICB2YXIgZmlsdGVyX29wZXJhdG9yID0gewogICAgICAJdHlwZTogImVudW0iLAogICAgICAJdmFsdWVzOiB7CiAgICAgIAkJIj09IjogewogICAgICAJCQlkb2M6ICJgW1wiPT1cIiwga2V5LCB2YWx1ZV1gIGVxdWFsaXR5OiBgZmVhdHVyZVtrZXldID0gdmFsdWVgIgogICAgICAJCX0sCiAgICAgIAkJIiE9IjogewogICAgICAJCQlkb2M6ICJgW1wiIT1cIiwga2V5LCB2YWx1ZV1gIGluZXF1YWxpdHk6IGBmZWF0dXJlW2tleV0g4omgIHZhbHVlYCIKICAgICAgCQl9LAogICAgICAJCSI+IjogewogICAgICAJCQlkb2M6ICJgW1wiPlwiLCBrZXksIHZhbHVlXWAgZ3JlYXRlciB0aGFuOiBgZmVhdHVyZVtrZXldID4gdmFsdWVgIgogICAgICAJCX0sCiAgICAgIAkJIj49IjogewogICAgICAJCQlkb2M6ICJgW1wiPj1cIiwga2V5LCB2YWx1ZV1gIGdyZWF0ZXIgdGhhbiBvciBlcXVhbDogYGZlYXR1cmVba2V5XSDiiaUgdmFsdWVgIgogICAgICAJCX0sCiAgICAgIAkJIjwiOiB7CiAgICAgIAkJCWRvYzogImBbXCI8XCIsIGtleSwgdmFsdWVdYCBsZXNzIHRoYW46IGBmZWF0dXJlW2tleV0gPCB2YWx1ZWAiCiAgICAgIAkJfSwKICAgICAgCQkiPD0iOiB7CiAgICAgIAkJCWRvYzogImBbXCI8PVwiLCBrZXksIHZhbHVlXWAgbGVzcyB0aGFuIG9yIGVxdWFsOiBgZmVhdHVyZVtrZXldIOKJpCB2YWx1ZWAiCiAgICAgIAkJfSwKICAgICAgCQkiaW4iOiB7CiAgICAgIAkJCWRvYzogImBbXCJpblwiLCBrZXksIHYwLCAuLi4sIHZuXWAgc2V0IGluY2x1c2lvbjogYGZlYXR1cmVba2V5XSDiiIgge3YwLCAuLi4sIHZufWAiCiAgICAgIAkJfSwKICAgICAgCQkiIWluIjogewogICAgICAJCQlkb2M6ICJgW1wiIWluXCIsIGtleSwgdjAsIC4uLiwgdm5dYCBzZXQgZXhjbHVzaW9uOiBgZmVhdHVyZVtrZXldIOKIiSB7djAsIC4uLiwgdm59YCIKICAgICAgCQl9LAogICAgICAJCWFsbDogewogICAgICAJCQlkb2M6ICJgW1wiYWxsXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgQU5EYDogYGYwIOKIpyAuLi4g4oinIGZuYCIKICAgICAgCQl9LAogICAgICAJCWFueTogewogICAgICAJCQlkb2M6ICJgW1wiYW55XCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgT1JgOiBgZjAg4oioIC4uLiDiiKggZm5gIgogICAgICAJCX0sCiAgICAgIAkJbm9uZTogewogICAgICAJCQlkb2M6ICJgW1wibm9uZVwiLCBmMCwgLi4uLCBmbl1gIGxvZ2ljYWwgYE5PUmA6IGDCrGYwIOKIpyAuLi4g4oinIMKsZm5gIgogICAgICAJCX0sCiAgICAgIAkJaGFzOiB7CiAgICAgIAkJCWRvYzogImBbXCJoYXNcIiwga2V5XWAgYGZlYXR1cmVba2V5XWAgZXhpc3RzIgogICAgICAJCX0sCiAgICAgIAkJIiFoYXMiOiB7CiAgICAgIAkJCWRvYzogImBbXCIhaGFzXCIsIGtleV1gIGBmZWF0dXJlW2tleV1gIGRvZXMgbm90IGV4aXN0IgogICAgICAJCX0sCiAgICAgIAkJd2l0aGluOiB7CiAgICAgIAkJCWRvYzogImBbXCJ3aXRoaW5cIiwgb2JqZWN0XWAgZmVhdHVyZSBnZW9tZXRyeSBpcyB3aXRoaW4gb2JqZWN0IGdlb21ldHJ5IgogICAgICAJCX0KICAgICAgCX0sCiAgICAgIAlkb2M6ICJUaGUgZmlsdGVyIG9wZXJhdG9yLiIKICAgICAgfTsKICAgICAgdmFyIGdlb21ldHJ5X3R5cGUgPSB7CiAgICAgIAl0eXBlOiAiZW51bSIsCiAgICAgIAl2YWx1ZXM6IHsKICAgICAgCQlQb2ludDogewogICAgICAJCQlkb2M6ICJGaWx0ZXIgdG8gcG9pbnQgZ2VvbWV0cmllcy4iCiAgICAgIAkJfSwKICAgICAgCQlMaW5lU3RyaW5nOiB7CiAgICAgIAkJCWRvYzogIkZpbHRlciB0byBsaW5lIGdlb21ldHJpZXMuIgogICAgICAJCX0sCiAgICAgIAkJUG9seWdvbjogewogICAgICAJCQlkb2M6ICJGaWx0ZXIgdG8gcG9seWdvbiBnZW9tZXRyaWVzLiIKICAgICAgCQl9CiAgICAgIAl9LAogICAgICAJZG9jOiAiVGhlIGdlb21ldHJ5IHR5cGUgZm9yIHRoZSBmaWx0ZXIgdG8gc2VsZWN0LiIKICAgICAgfTsKICAgICAgdmFyIGZ1bmN0aW9uX3N0b3AgPSB7CiAgICAgIAl0eXBlOiAiYXJyYXkiLAogICAgICAJbWluaW11bTogMCwKICAgICAgCW1heGltdW06IDI0LAogICAgICAJdmFsdWU6IFsKICAgICAgCQkibnVtYmVyIiwKICAgICAgCQkiY29sb3IiCiAgICAgIAldLAogICAgICAJbGVuZ3RoOiAyLAogICAgICAJZG9jOiAiWm9vbSBsZXZlbCBhbmQgdmFsdWUgcGFpci4iCiAgICAgIH07CiAgICAgIHZhciBleHByZXNzaW9uID0gewogICAgICAJdHlwZTogImFycmF5IiwKICAgICAgCXZhbHVlOiAiKiIsCiAgICAgIAltaW5pbXVtOiAxLAogICAgICAJZG9jOiAiQW4gZXhwcmVzc2lvbiBkZWZpbmVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGF0YS1kcml2ZW4gc3R5bGUgcHJvcGVydGllcyBvciBmZWF0dXJlIGZpbHRlcnMuIgogICAgICB9OwogICAgICB2YXIgZXhwcmVzc2lvbl9uYW1lID0gewogICAgICAJZG9jOiAiIiwKICAgICAgCXR5cGU6ICJlbnVtIiwKICAgICAgCXZhbHVlczogewogICAgICAJCSJsZXQiOiB7CiAgICAgIAkJCWRvYzogIkJpbmRzIGV4cHJlc3Npb25zIHRvIG5hbWVkIHZhcmlhYmxlcywgd2hpY2ggY2FuIHRoZW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgcmVzdWx0IGV4cHJlc3Npb24gdXNpbmcgW1widmFyXCIsIFwidmFyaWFibGVfbmFtZVwiXS4iLAogICAgICAJCQlncm91cDogIlZhcmlhYmxlIGJpbmRpbmciLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInZhciI6IHsKICAgICAgCQkJZG9jOiAiUmVmZXJlbmNlcyB2YXJpYWJsZSBib3VuZCB1c2luZyBcImxldFwiLiIsCiAgICAgIAkJCWdyb3VwOiAiVmFyaWFibGUgYmluZGluZyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlsaXRlcmFsOiB7CiAgICAgIAkJCWRvYzogIlByb3ZpZGVzIGEgbGl0ZXJhbCBhcnJheSBvciBvYmplY3QgdmFsdWUuIiwKICAgICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlhcnJheTogewogICAgICAJCQlkb2M6ICJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IGlzIGFuIGFycmF5IChvcHRpb25hbGx5IHdpdGggYSBzcGVjaWZpYyBpdGVtIHR5cGUgYW5kIGxlbmd0aCkuICBJZiwgd2hlbiB0aGUgaW5wdXQgZXhwcmVzc2lvbiBpcyBldmFsdWF0ZWQsIGl0IGlzIG5vdCBvZiB0aGUgYXNzZXJ0ZWQgdHlwZSwgdGhlbiB0aGlzIGFzc2VydGlvbiB3aWxsIGNhdXNlIHRoZSB3aG9sZSBleHByZXNzaW9uIHRvIGJlIGFib3J0ZWQuIiwKICAgICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlhdDogewogICAgICAJCQlkb2M6ICJSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5LiIsCiAgICAgIAkJCWdyb3VwOiAiTG9va3VwIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJpbiI6IHsKICAgICAgCQkJZG9jOiAiRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGl0ZW0gZXhpc3RzIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGV4aXN0cyBpbiBhIHN0cmluZy4iLAogICAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMS42LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI5LjEuMCIsCiAgICAgIAkJCQkJaW9zOiAiNS44LjAiLAogICAgICAJCQkJCW1hY29zOiAiMC4xNS4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiaW5kZXgtb2YiOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIGFuIGl0ZW0gY2FuIGJlIGZvdW5kIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGNhbiBiZSBmb3VuZCBpbiBhIHN0cmluZywgb3IgYC0xYCBpZiB0aGUgaW5wdXQgY2Fubm90IGJlIGZvdW5kLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGluZGV4IGZyb20gd2hlcmUgdG8gYmVnaW4gdGhlIHNlYXJjaC4iLAogICAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMS4xMC4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlzbGljZTogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBmcm9tIGEgc3RyaW5nIGZyb20gYSBzcGVjaWZpZWQgc3RhcnQgaW5kZXgsIG9yIGJldHdlZW4gYSBzdGFydCBpbmRleCBhbmQgYW4gZW5kIGluZGV4IGlmIHNldC4gVGhlIHJldHVybiB2YWx1ZSBpcyBpbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGluZGV4IGJ1dCBub3Qgb2YgdGhlIGVuZCBpbmRleC4iLAogICAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMS4xMC4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiY2FzZSI6IHsKICAgICAgCQkJZG9jOiAiU2VsZWN0cyB0aGUgZmlyc3Qgb3V0cHV0IHdob3NlIGNvcnJlc3BvbmRpbmcgdGVzdCBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWUsIG9yIHRoZSBmYWxsYmFjayB2YWx1ZSBvdGhlcndpc2UuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQltYXRjaDogewogICAgICAJCQlkb2M6ICJTZWxlY3RzIHRoZSBvdXRwdXQgd2hvc2UgbGFiZWwgdmFsdWUgbWF0Y2hlcyB0aGUgaW5wdXQgdmFsdWUsIG9yIHRoZSBmYWxsYmFjayB2YWx1ZSBpZiBubyBtYXRjaCBpcyBmb3VuZC4gVGhlIGlucHV0IGNhbiBiZSBhbnkgZXhwcmVzc2lvbiAoZS5nLiBgW1wiZ2V0XCIsIFwiYnVpbGRpbmdfdHlwZVwiXWApLiBFYWNoIGxhYmVsIG11c3QgYmUgZWl0aGVyOlxuIC0gYSBzaW5nbGUgbGl0ZXJhbCB2YWx1ZTsgb3JcbiAtIGFuIGFycmF5IG9mIGxpdGVyYWwgdmFsdWVzLCB3aG9zZSB2YWx1ZXMgbXVzdCBiZSBhbGwgc3RyaW5ncyBvciBhbGwgbnVtYmVycyAoZS5nLiBgWzEwMCwgMTAxXWAgb3IgYFtcImNcIiwgXCJiXCJdYCkuIFRoZSBpbnB1dCBtYXRjaGVzIGlmIGFueSBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBtYXRjaGVzLCBzaW1pbGFyIHRvIHRoZSBgXCJpblwiYCBvcGVyYXRvci5cbkVhY2ggbGFiZWwgbXVzdCBiZSB1bmlxdWUuIElmIHRoZSBpbnB1dCB0eXBlIGRvZXMgbm90IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBsYWJlbHMsIHRoZSByZXN1bHQgd2lsbCBiZSB0aGUgZmFsbGJhY2sgdmFsdWUuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQljb2FsZXNjZTogewogICAgICAJCQlkb2M6ICJFdmFsdWF0ZXMgZWFjaCBleHByZXNzaW9uIGluIHR1cm4gdW50aWwgdGhlIGZpcnN0IG5vbi1udWxsIHZhbHVlIGlzIG9idGFpbmVkLCBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLiIsCiAgICAgIAkJCWdyb3VwOiAiRGVjaXNpb24iLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJc3RlcDogewogICAgICAJCQlkb2M6ICJQcm9kdWNlcyBkaXNjcmV0ZSwgc3RlcHBlZCByZXN1bHRzIGJ5IGV2YWx1YXRpbmcgYSBwaWVjZXdpc2UtY29uc3RhbnQgZnVuY3Rpb24gZGVmaW5lZCBieSBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXCJzdG9wc1wiKS4gVGhlIGBpbnB1dGAgbWF5IGJlIGFueSBudW1lcmljIGV4cHJlc3Npb24gKGUuZy4sIGBbXCJnZXRcIiwgXCJwb3B1bGF0aW9uXCJdYCkuIFN0b3AgaW5wdXRzIG11c3QgYmUgbnVtZXJpYyBsaXRlcmFscyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuIFJldHVybnMgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgaW5wdXQsIG9yIHRoZSBmaXJzdCBvdXRwdXQgaWYgdGhlIGlucHV0IGlzIGxlc3MgdGhhbiB0aGUgZmlyc3Qgc3RvcC4iLAogICAgICAJCQlncm91cDogIlJhbXBzLCBzY2FsZXMsIGN1cnZlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40Mi4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlpbnRlcnBvbGF0ZTogewogICAgICAJCQlkb2M6ICJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFwic3RvcHNcIikuIFRoZSBgaW5wdXRgIG1heSBiZSBhbnkgbnVtZXJpYyBleHByZXNzaW9uIChlLmcuLCBgW1wiZ2V0XCIsIFwicG9wdWxhdGlvblwiXWApLiBTdG9wIGlucHV0cyBtdXN0IGJlIG51bWVyaWMgbGl0ZXJhbHMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLiBUaGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgbnVtYmVyYCwgYGFycmF5PG51bWJlcj5gLCBvciBgY29sb3JgLlxuXG5JbnRlcnBvbGF0aW9uIHR5cGVzOlxuLSBgW1wibGluZWFyXCJdYDogSW50ZXJwb2xhdGVzIGxpbmVhcmx5IGJldHdlZW4gdGhlIHBhaXIgb2Ygc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBpbnB1dC5cbi0gYFtcImV4cG9uZW50aWFsXCIsIGJhc2VdYDogSW50ZXJwb2xhdGVzIGV4cG9uZW50aWFsbHkgYmV0d2VlbiB0aGUgc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBpbnB1dC4gYGJhc2VgIGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBvdXRwdXQgaW5jcmVhc2VzOiBoaWdoZXIgdmFsdWVzIG1ha2UgdGhlIG91dHB1dCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCB2YWx1ZXMgY2xvc2UgdG8gMSB0aGUgb3V0cHV0IGluY3JlYXNlcyBsaW5lYXJseS5cbi0gYFtcImN1YmljLWJlemllclwiLCB4MSwgeTEsIHgyLCB5Ml1gOiBJbnRlcnBvbGF0ZXMgdXNpbmcgdGhlIGN1YmljIGJlemllciBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBjb250cm9sIHBvaW50cy4iLAogICAgICAJCQlncm91cDogIlJhbXBzLCBzY2FsZXMsIGN1cnZlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40Mi4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiaW50ZXJwb2xhdGUtaGNsIjogewogICAgICAJCQlkb2M6ICJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFwic3RvcHNcIikuIFdvcmtzIGxpa2UgYGludGVycG9sYXRlYCwgYnV0IHRoZSBvdXRwdXQgdHlwZSBtdXN0IGJlIGBjb2xvcmAsIGFuZCB0aGUgaW50ZXJwb2xhdGlvbiBpcyBwZXJmb3JtZWQgaW4gdGhlIEh1ZS1DaHJvbWEtTHVtaW5hbmNlIGNvbG9yIHNwYWNlLiIsCiAgICAgIAkJCWdyb3VwOiAiUmFtcHMsIHNjYWxlcywgY3VydmVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ5LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJpbnRlcnBvbGF0ZS1sYWIiOiB7CiAgICAgIAkJCWRvYzogIlByb2R1Y2VzIGNvbnRpbnVvdXMsIHNtb290aCByZXN1bHRzIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXCJzdG9wc1wiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgQ0lFTEFCIGNvbG9yIHNwYWNlLiIsCiAgICAgIAkJCWdyb3VwOiAiUmFtcHMsIHNjYWxlcywgY3VydmVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ5LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWxuMjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIG1hdGhlbWF0aWNhbCBjb25zdGFudCBsbigyKS4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJcGk6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IHBpLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQllOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIG1hdGhlbWF0aWNhbCBjb25zdGFudCBlLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkidHlwZW9mIjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIGEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIHZhbHVlLiIsCiAgICAgIAkJCWdyb3VwOiAiVHlwZXMiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJc3RyaW5nOiB7CiAgICAgIAkJCWRvYzogIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYSBzdHJpbmcuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIHN0cmluZyBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBzdHJpbmdzLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgICAJCQlncm91cDogIlR5cGVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCW51bWJlcjogewogICAgICAJCQlkb2M6ICJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGEgbnVtYmVyLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYSBudW1iZXIgaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgbnVtYmVycywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuIiwKICAgICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlib29sZWFuOiB7CiAgICAgIAkJCWRvYzogIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYSBib29sZWFuLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYSBib29sZWFuIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIGJvb2xlYW5zLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgICAJCQlncm91cDogIlR5cGVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCW9iamVjdDogewogICAgICAJCQlkb2M6ICJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGFuIG9iamVjdC4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGFuIG9iamVjdCBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBvYmplY3RzLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgICAJCQlncm91cDogIlR5cGVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWNvbGxhdG9yOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgYSBgY29sbGF0b3JgIGZvciB1c2UgaW4gbG9jYWxlLWRlcGVuZGVudCBjb21wYXJpc29uIG9wZXJhdGlvbnMuIFRoZSBgY2FzZS1zZW5zaXRpdmVgIGFuZCBgZGlhY3JpdGljLXNlbnNpdGl2ZWAgb3B0aW9ucyBkZWZhdWx0IHRvIGBmYWxzZWAuIFRoZSBgbG9jYWxlYCBhcmd1bWVudCBzcGVjaWZpZXMgdGhlIElFVEYgbGFuZ3VhZ2UgdGFnIG9mIHRoZSBsb2NhbGUgdG8gdXNlLiBJZiBub25lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBsb2NhbGUgaXMgdXNlZC4gSWYgdGhlIHJlcXVlc3RlZCBsb2NhbGUgaXMgbm90IGF2YWlsYWJsZSwgdGhlIGBjb2xsYXRvcmAgd2lsbCB1c2UgYSBzeXN0ZW0tZGVmaW5lZCBmYWxsYmFjayBsb2NhbGUuIFVzZSBgcmVzb2x2ZWQtbG9jYWxlYCB0byB0ZXN0IHRoZSByZXN1bHRzIG9mIGxvY2FsZSBmYWxsYmFjayBiZWhhdmlvci4iLAogICAgICAJCQlncm91cDogIlR5cGVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4yLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWZvcm1hdDogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIGEgYGZvcm1hdHRlZGAgc3RyaW5nIGZvciBkaXNwbGF5aW5nIG1peGVkLWZvcm1hdCB0ZXh0IGluIHRoZSBgdGV4dC1maWVsZGAgcHJvcGVydHkuIFRoZSBpbnB1dCBtYXkgY29udGFpbiBhIHN0cmluZyBsaXRlcmFsIG9yIGV4cHJlc3Npb24sIGluY2x1ZGluZyBhbiBbYCdpbWFnZSdgXSgjdHlwZXMtaW1hZ2UpIGV4cHJlc3Npb24uIFN0cmluZ3MgbWF5IGJlIGZvbGxvd2VkIGJ5IGEgc3R5bGUgb3ZlcnJpZGUgb2JqZWN0IHRoYXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLSBgXCJ0ZXh0LWZvbnRcImA6IE92ZXJyaWRlcyB0aGUgZm9udCBzdGFjayBzcGVjaWZpZWQgYnkgdGhlIHJvb3QgbGF5b3V0IHByb3BlcnR5LlxuLSBgXCJ0ZXh0LWNvbG9yXCJgOiBPdmVycmlkZXMgdGhlIGNvbG9yIHNwZWNpZmllZCBieSB0aGUgcm9vdCBwYWludCBwcm9wZXJ0eS5cbi0gYFwiZm9udC1zY2FsZVwiYDogQXBwbGllcyBhIHNjYWxpbmcgZmFjdG9yIG9uIGB0ZXh0LXNpemVgIGFzIHNwZWNpZmllZCBieSB0aGUgcm9vdCBsYXlvdXQgcHJvcGVydHkuIiwKICAgICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40OC4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi43LjAiLAogICAgICAJCQkJCWlvczogIjQuNi4wIiwKICAgICAgCQkJCQltYWNvczogIjAuMTIuMCIKICAgICAgCQkJCX0sCiAgICAgIAkJCQkidGV4dC1mb250IjogewogICAgICAJCQkJCWpzOiAiMC40OC4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi43LjAiLAogICAgICAJCQkJCWlvczogIjQuNi4wIiwKICAgICAgCQkJCQltYWNvczogIjAuMTIuMCIKICAgICAgCQkJCX0sCiAgICAgIAkJCQkiZm9udC1zY2FsZSI6IHsKICAgICAgCQkJCQlqczogIjAuNDguMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuNy4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjYuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjEyLjAiCiAgICAgIAkJCQl9LAogICAgICAJCQkJInRleHQtY29sb3IiOiB7CiAgICAgIAkJCQkJanM6ICIxLjMuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjcuMy4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjEwLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC4xNC4wIgogICAgICAJCQkJfSwKICAgICAgCQkJCWltYWdlOiB7CiAgICAgIAkJCQkJanM6ICIxLjYuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjguNi4wIiwKICAgICAgCQkJCQlpb3M6ICI1LjcuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWltYWdlOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgYW4gYGltYWdlYCB0eXBlIGZvciB1c2UgaW4gYGljb24taW1hZ2VgLCBgKi1wYXR0ZXJuYCBlbnRyaWVzIGFuZCBhcyBhIHNlY3Rpb24gaW4gdGhlIGBmb3JtYXRgIGV4cHJlc3Npb24uIElmIHNldCwgdGhlIGBpbWFnZWAgYXJndW1lbnQgd2lsbCBjaGVjayB0aGF0IHRoZSByZXF1ZXN0ZWQgaW1hZ2UgZXhpc3RzIGluIHRoZSBzdHlsZSBhbmQgd2lsbCByZXR1cm4gZWl0aGVyIHRoZSByZXNvbHZlZCBpbWFnZSBuYW1lIG9yIGBudWxsYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBpbWFnZSBpcyBjdXJyZW50bHkgaW4gdGhlIHN0eWxlLiBUaGlzIHZhbGlkYXRpb24gcHJvY2VzcyBpcyBzeW5jaHJvbm91cyBhbmQgcmVxdWlyZXMgdGhlIGltYWdlIHRvIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgc3R5bGUgYmVmb3JlIHJlcXVlc3RpbmcgaXQgaW4gdGhlIGBpbWFnZWAgYXJndW1lbnQuIiwKICAgICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMS40LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI4LjYuMCIsCiAgICAgIAkJCQkJaW9zOiAiNS43LjAiLAogICAgICAJCQkJCW1hY29zOiAiMC4xNS4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkibnVtYmVyLWZvcm1hdCI6IHsKICAgICAgCQkJZG9jOiAiQ29udmVydHMgdGhlIGlucHV0IG51bWJlciBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIHRoZSBwcm92aWRpbmcgZm9ybWF0dGluZyBydWxlcy4gSWYgc2V0LCB0aGUgYGxvY2FsZWAgYXJndW1lbnQgc3BlY2lmaWVzIHRoZSBsb2NhbGUgdG8gdXNlLCBhcyBhIEJDUCA0NyBsYW5ndWFnZSB0YWcuIElmIHNldCwgdGhlIGBjdXJyZW5jeWAgYXJndW1lbnQgc3BlY2lmaWVzIGFuIElTTyA0MjE3IGNvZGUgdG8gdXNlIGZvciBjdXJyZW5jeS1zdHlsZSBmb3JtYXR0aW5nLiBJZiBzZXQsIHRoZSBgbWluLWZyYWN0aW9uLWRpZ2l0c2AgYW5kIGBtYXgtZnJhY3Rpb24tZGlnaXRzYCBhcmd1bWVudHMgc3BlY2lmeSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBudW1iZXIgb2YgZnJhY3Rpb25hbCBkaWdpdHMgdG8gaW5jbHVkZS4iLAogICAgICAJCQlncm91cDogIlR5cGVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjU0LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJ0by1zdHJpbmciOiB7CiAgICAgIAkJCWRvYzogIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIHN0cmluZy4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCwgdGhlIHJlc3VsdCBpcyBgXCJcImAuIElmIHRoZSBpbnB1dCBpcyBhIGJvb2xlYW4sIHRoZSByZXN1bHQgaXMgYFwidHJ1ZVwiYCBvciBgXCJmYWxzZVwiYC4gSWYgdGhlIGlucHV0IGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbXCJOdW1iZXJUb1N0cmluZ1wiIGFsZ29yaXRobV0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmctYXBwbGllZC10by10aGUtbnVtYmVyLXR5cGUpIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIHRoZSBpbnB1dCBpcyBhIGNvbG9yLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgb2YgdGhlIGZvcm0gYFwicmdiYShyLGcsYixhKVwiYCwgd2hlcmUgYHJgLCBgZ2AsIGFuZCBgYmAgYXJlIG51bWVyYWxzIHJhbmdpbmcgZnJvbSAwIHRvIDI1NSwgYW5kIGBhYCByYW5nZXMgZnJvbSAwIHRvIDEuIE90aGVyd2lzZSwgdGhlIGlucHV0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSB0aGUgW2BKU09OLnN0cmluZ2lmeWBdKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5KSBmdW5jdGlvbiBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLiIsCiAgICAgIAkJCWdyb3VwOiAiVHlwZXMiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInRvLW51bWJlciI6IHsKICAgICAgCQkJZG9jOiAiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyLCBpZiBwb3NzaWJsZS4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCBvciBgZmFsc2VgLCB0aGUgcmVzdWx0IGlzIDAuIElmIHRoZSBpbnB1dCBpcyBgdHJ1ZWAsIHRoZSByZXN1bHQgaXMgMS4gSWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbXCJUb051bWJlciBBcHBsaWVkIHRvIHRoZSBTdHJpbmcgVHlwZVwiIGFsZ29yaXRobV0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXItYXBwbGllZC10by10aGUtc3RyaW5nLXR5cGUpIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBjb252ZXJzaW9uIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgY2FuIGJlIGNvbnZlcnRlZCwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuIiwKICAgICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkidG8tYm9vbGVhbiI6IHsKICAgICAgCQkJZG9jOiAiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgYm9vbGVhbi4gVGhlIHJlc3VsdCBpcyBgZmFsc2VgIHdoZW4gdGhlbiBpbnB1dCBpcyBhbiBlbXB0eSBzdHJpbmcsIDAsIGBmYWxzZWAsIGBudWxsYCwgb3IgYE5hTmA7IG90aGVyd2lzZSBpdCBpcyBgdHJ1ZWAuIiwKICAgICAgCQkJZ3JvdXA6ICJUeXBlcyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkidG8tcmdiYSI6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyBhIGZvdXItZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSBpbnB1dCBjb2xvcidzIHJlZCwgZ3JlZW4sIGJsdWUsIGFuZCBhbHBoYSBjb21wb25lbnRzLCBpbiB0aGF0IG9yZGVyLiIsCiAgICAgIAkJCWdyb3VwOiAiQ29sb3IiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInRvLWNvbG9yIjogewogICAgICAJCQlkb2M6ICJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBjb2xvci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBjYW4gYmUgY29udmVydGVkLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgICAJCQlncm91cDogIlR5cGVzIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCXJnYjogewogICAgICAJCQlkb2M6ICJDcmVhdGVzIGEgY29sb3IgdmFsdWUgZnJvbSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IG9mIDEuIElmIGFueSBjb21wb25lbnQgaXMgb3V0IG9mIHJhbmdlLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci4iLAogICAgICAJCQlncm91cDogIkNvbG9yIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCXJnYmE6IHsKICAgICAgCQkJZG9jOiAiQ3JlYXRlcyBhIGNvbG9yIHZhbHVlIGZyb20gcmVkLCBncmVlbiwgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLiBJZiBhbnkgY29tcG9uZW50IGlzIG91dCBvZiByYW5nZSwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuIiwKICAgICAgCQkJZ3JvdXA6ICJDb2xvciIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlnZXQ6IHsKICAgICAgCQkJZG9jOiAiUmV0cmlldmVzIGEgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBmZWF0dXJlJ3MgcHJvcGVydGllcywgb3IgZnJvbSBhbm90aGVyIG9iamVjdCBpZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZC4gUmV0dXJucyBudWxsIGlmIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgbWlzc2luZy4iLAogICAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQloYXM6IHsKICAgICAgCQkJZG9jOiAiVGVzdHMgZm9yIHRoZSBwcmVzZW5jZSBvZiBhbiBwcm9wZXJ0eSB2YWx1ZSBpbiB0aGUgY3VycmVudCBmZWF0dXJlJ3MgcHJvcGVydGllcywgb3IgZnJvbSBhbm90aGVyIG9iamVjdCBpZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZC4iLAogICAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlsZW5ndGg6IHsKICAgICAgCQkJZG9jOiAiR2V0cyB0aGUgbGVuZ3RoIG9mIGFuIGFycmF5IG9yIHN0cmluZy4iLAogICAgICAJCQlncm91cDogIkxvb2t1cCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlwcm9wZXJ0aWVzOiB7CiAgICAgIAkJCWRvYzogIkdldHMgdGhlIGZlYXR1cmUgcHJvcGVydGllcyBvYmplY3QuICBOb3RlIHRoYXQgaW4gc29tZSBjYXNlcywgaXQgbWF5IGJlIG1vcmUgZWZmaWNpZW50IHRvIHVzZSBbXCJnZXRcIiwgXCJwcm9wZXJ0eV9uYW1lXCJdIGRpcmVjdGx5LiIsCiAgICAgIAkJCWdyb3VwOiAiRmVhdHVyZSBkYXRhIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJmZWF0dXJlLXN0YXRlIjogewogICAgICAJCQlkb2M6ICJSZXRyaWV2ZXMgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZlYXR1cmUncyBzdGF0ZS4gUmV0dXJucyBudWxsIGlmIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgb24gdGhlIGZlYXR1cmUncyBzdGF0ZS4gQSBmZWF0dXJlJ3Mgc3RhdGUgaXMgbm90IHBhcnQgb2YgdGhlIEdlb0pTT04gb3IgdmVjdG9yIHRpbGUgZGF0YSwgYW5kIG11c3QgYmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgb24gZWFjaCBmZWF0dXJlLiBGZWF0dXJlcyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBgaWRgIGF0dHJpYnV0ZSwgd2hpY2ggbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGNhc3QgdG8gYW4gaW50ZWdlci4gTm90ZSB0aGF0IFtcImZlYXR1cmUtc3RhdGVcIl0gY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHBhaW50IHByb3BlcnRpZXMgdGhhdCBzdXBwb3J0IGRhdGEtZHJpdmVuIHN0eWxpbmcuIiwKICAgICAgCQkJZ3JvdXA6ICJGZWF0dXJlIGRhdGEiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDYuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImdlb21ldHJ5LXR5cGUiOiB7CiAgICAgIAkJCWRvYzogIkdldHMgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSB0eXBlOiBgUG9pbnRgLCBgTXVsdGlQb2ludGAsIGBMaW5lU3RyaW5nYCwgYE11bHRpTGluZVN0cmluZ2AsIGBQb2x5Z29uYCwgYE11bHRpUG9seWdvbmAuIiwKICAgICAgCQkJZ3JvdXA6ICJGZWF0dXJlIGRhdGEiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJaWQ6IHsKICAgICAgCQkJZG9jOiAiR2V0cyB0aGUgZmVhdHVyZSdzIGlkLCBpZiBpdCBoYXMgb25lLiIsCiAgICAgIAkJCWdyb3VwOiAiRmVhdHVyZSBkYXRhIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCXpvb206IHsKICAgICAgCQkJZG9jOiAiR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsLiAgTm90ZSB0aGF0IGluIHN0eWxlIGxheW91dCBhbmQgcGFpbnQgcHJvcGVydGllcywgW1wiem9vbVwiXSBtYXkgb25seSBhcHBlYXIgYXMgdGhlIGlucHV0IHRvIGEgdG9wLWxldmVsIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9uLiIsCiAgICAgIAkJCWdyb3VwOiAiWm9vbSIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiaGVhdG1hcC1kZW5zaXR5IjogewogICAgICAJCQlkb2M6ICJHZXRzIHRoZSBrZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uIG9mIGEgcGl4ZWwgaW4gYSBoZWF0bWFwIGxheWVyLCB3aGljaCBpcyBhIHJlbGF0aXZlIG1lYXN1cmUgb2YgaG93IG1hbnkgZGF0YSBwb2ludHMgYXJlIGNyb3dkZWQgYXJvdW5kIGEgcGFydGljdWxhciBwaXhlbC4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGhlYXRtYXAtY29sb3JgIHByb3BlcnR5LiIsCiAgICAgIAkJCWdyb3VwOiAiSGVhdG1hcCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkibGluZS1wcm9ncmVzcyI6IHsKICAgICAgCQkJZG9jOiAiR2V0cyB0aGUgcHJvZ3Jlc3MgYWxvbmcgYSBncmFkaWVudCBsaW5lLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgbGluZS1ncmFkaWVudGAgcHJvcGVydHkuIiwKICAgICAgCQkJZ3JvdXA6ICJGZWF0dXJlIGRhdGEiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDUuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuNS4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjYuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjEyLjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWFjY3VtdWxhdGVkOiB7CiAgICAgIAkJCWRvYzogIkdldHMgdGhlIHZhbHVlIG9mIGEgY2x1c3RlciBwcm9wZXJ0eSBhY2N1bXVsYXRlZCBzbyBmYXIuIENhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBjbHVzdGVyUHJvcGVydGllc2Agb3B0aW9uIG9mIGEgY2x1c3RlcmVkIEdlb0pTT04gc291cmNlLiIsCiAgICAgIAkJCWdyb3VwOiAiRmVhdHVyZSBkYXRhIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjUzLjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSIrIjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGlucHV0cy4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJIioiOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhlIGlucHV0cy4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJIi0iOiB7CiAgICAgIAkJCWRvYzogIkZvciB0d28gaW5wdXRzLCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgdGhlIHNlY29uZCBpbnB1dCBmcm9tIHRoZSBmaXJzdC4gRm9yIGEgc2luZ2xlIGlucHV0LCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgaXQgZnJvbSAwLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiLyI6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgcmVzdWx0IG9mIGZsb2F0aW5nIHBvaW50IGRpdmlzaW9uIG9mIHRoZSBmaXJzdCBpbnB1dCBieSB0aGUgc2Vjb25kLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiJSI6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgcmVtYWluZGVyIGFmdGVyIGludGVnZXIgZGl2aXNpb24gb2YgdGhlIGZpcnN0IGlucHV0IGJ5IHRoZSBzZWNvbmQuIiwKICAgICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJeIjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSByZXN1bHQgb2YgcmFpc2luZyB0aGUgZmlyc3QgaW5wdXQgdG8gdGhlIHBvd2VyIHNwZWNpZmllZCBieSB0aGUgc2Vjb25kLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlzcXJ0OiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBpbnB1dC4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDIuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJbG9nMTA6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgYmFzZS10ZW4gbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJbG46IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgdGhlIGlucHV0LiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlsb2cyOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGJhc2UtdHdvIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuIiwKICAgICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCXNpbjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBzaW5lIG9mIHRoZSBpbnB1dC4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJY29zOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGNvc2luZSBvZiB0aGUgaW5wdXQuIiwKICAgICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCXRhbjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSB0YW5nZW50IG9mIHRoZSBpbnB1dC4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJYXNpbjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBhcmNzaW5lIG9mIHRoZSBpbnB1dC4iLAogICAgICAJCQlncm91cDogIk1hdGgiLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJYWNvczogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBhcmNjb3NpbmUgb2YgdGhlIGlucHV0LiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlhdGFuOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGFyY3RhbmdlbnQgb2YgdGhlIGlucHV0LiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQltaW46IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgaW5wdXRzLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQltYXg6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgaW5wdXRzLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlyb3VuZDogewogICAgICAJCQlkb2M6ICJSb3VuZHMgdGhlIGlucHV0IHRvIHRoZSBuZWFyZXN0IGludGVnZXIuIEhhbGZ3YXkgdmFsdWVzIGFyZSByb3VuZGVkIGF3YXkgZnJvbSB6ZXJvLiBGb3IgZXhhbXBsZSwgYFtcInJvdW5kXCIsIC0xLjVdYCBldmFsdWF0ZXMgdG8gLTIuIiwKICAgICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWFiczogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgaW5wdXQuIiwKICAgICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWNlaWw6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgc21hbGxlc3QgaW50ZWdlciB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQuIiwKICAgICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWZsb29yOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGxhcmdlc3QgaW50ZWdlciB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQuIiwKICAgICAgCQkJZ3JvdXA6ICJNYXRoIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWRpc3RhbmNlOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGluIG1ldGVycyBiZXR3ZWVuIHRoZSBldmFsdWF0ZWQgZmVhdHVyZSBhbmQgdGhlIGlucHV0IGdlb21ldHJ5LiBUaGUgaW5wdXQgdmFsdWUgY2FuIGJlIGEgdmFsaWQgR2VvSlNPTiBvZiB0eXBlIGBQb2ludGAsIGBNdWx0aVBvaW50YCwgYExpbmVTdHJpbmdgLCBgTXVsdGlMaW5lU3RyaW5nYCwgYFBvbHlnb25gLCBgTXVsdGlQb2x5Z29uYCwgYEZlYXR1cmVgLCBvciBgRmVhdHVyZUNvbGxlY3Rpb25gLiBEaXN0YW5jZSB2YWx1ZXMgcmV0dXJuZWQgbWF5IHZhcnkgaW4gcHJlY2lzaW9uIGR1ZSB0byBsb3NzIGluIHByZWNpc2lvbiBmcm9tIGVuY29kaW5nIGdlb21ldHJpZXMsIHBhcnRpY3VsYXJseSBiZWxvdyB6b29tIGxldmVsIDEzLiIsCiAgICAgIAkJCWdyb3VwOiAiTWF0aCIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWFuZHJvaWQ6ICI5LjIuMCIsCiAgICAgIAkJCQkJaW9zOiAiNS45LjAiLAogICAgICAJCQkJCW1hY29zOiAiMC4xNi4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiPT0iOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfSwKICAgICAgCQkJCWNvbGxhdG9yOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4yLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSIhPSI6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgbm90IGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfSwKICAgICAgCQkJCWNvbGxhdG9yOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4yLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSI+IjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfSwKICAgICAgCQkJCWNvbGxhdG9yOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4yLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSI8IjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfSwKICAgICAgCQkJCWNvbGxhdG9yOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4yLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSI+PSI6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLiIsCiAgICAgIAkJCWdyb3VwOiAiRGVjaXNpb24iLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0sCiAgICAgIAkJCQljb2xsYXRvcjogewogICAgICAJCQkJCWpzOiAiMC40NS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgICAJCQkJCWlvczogIjQuMi4wIiwKICAgICAgCQkJCQltYWNvczogIjAuOS4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiPD0iOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBpbnB1dCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBhcmd1bWVudHMgYXJlIHJlcXVpcmVkIHRvIGJlIGVpdGhlciBib3RoIHN0cmluZ3Mgb3IgYm90aCBudW1iZXJzOyBpZiBkdXJpbmcgZXZhbHVhdGlvbiB0aGV5IGFyZSBub3QsIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBwcm9kdWNlcyBhbiBlcnJvci4gQ2FzZXMgd2hlcmUgdGhpcyBjb25zdHJhaW50IGlzIGtub3duIG5vdCB0byBob2xkIGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW4gdmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy4iLAogICAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9LAogICAgICAJCQkJY29sbGF0b3I6IHsKICAgICAgCQkJCQlqczogIjAuNDUuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuNS4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjIuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjkuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJYWxsOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgYHRydWVgIGlmIGFsbCB0aGUgaW5wdXRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgaW5wdXRzIGFyZSBldmFsdWF0ZWQgaW4gb3JkZXIsIGFuZCBldmFsdWF0aW9uIGlzIHNob3J0LWNpcmN1aXRpbmc6IG9uY2UgYW4gaW5wdXQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYGZhbHNlYCwgdGhlIHJlc3VsdCBpcyBgZmFsc2VgIGFuZCBubyBmdXJ0aGVyIGlucHV0IGV4cHJlc3Npb25zIGFyZSBldmFsdWF0ZWQuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlhbnk6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyBgdHJ1ZWAgaWYgYW55IG9mIHRoZSBpbnB1dHMgYXJlIGB0cnVlYCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBpbnB1dHMgYXJlIGV2YWx1YXRlZCBpbiBvcmRlciwgYW5kIGV2YWx1YXRpb24gaXMgc2hvcnQtY2lyY3VpdGluZzogb25jZSBhbiBpbnB1dCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBgdHJ1ZWAsIHRoZSByZXN1bHQgaXMgYHRydWVgIGFuZCBubyBmdXJ0aGVyIGlucHV0IGV4cHJlc3Npb25zIGFyZSBldmFsdWF0ZWQuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiISI6IHsKICAgICAgCQkJZG9jOiAiTG9naWNhbCBuZWdhdGlvbi4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IGlzIGBmYWxzZWAsIGFuZCBgZmFsc2VgIGlmIHRoZSBpbnB1dCBpcyBgdHJ1ZWAuIiwKICAgICAgCQkJZ3JvdXA6ICJEZWNpc2lvbiIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQl3aXRoaW46IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV2YWx1YXRlZCBmZWF0dXJlIGlzIGZ1bGx5IGNvbnRhaW5lZCBpbnNpZGUgYSBib3VuZGFyeSBvZiB0aGUgaW5wdXQgZ2VvbWV0cnksIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgaW5wdXQgdmFsdWUgY2FuIGJlIGEgdmFsaWQgR2VvSlNPTiBvZiB0eXBlIGBQb2x5Z29uYCwgYE11bHRpUG9seWdvbmAsIGBGZWF0dXJlYCwgb3IgYEZlYXR1cmVDb2xsZWN0aW9uYC4gU3VwcG9ydGVkIGZlYXR1cmVzIGZvciBldmFsdWF0aW9uOlxuLSBgUG9pbnRgOiBSZXR1cm5zIGBmYWxzZWAgaWYgYSBwb2ludCBpcyBvbiB0aGUgYm91bmRhcnkgb3IgZmFsbHMgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4tIGBMaW5lU3RyaW5nYDogUmV0dXJucyBgZmFsc2VgIGlmIGFueSBwYXJ0IG9mIGEgbGluZSBmYWxscyBvdXRzaWRlIHRoZSBib3VuZGFyeSwgdGhlIGxpbmUgaW50ZXJzZWN0cyB0aGUgYm91bmRhcnksIG9yIGEgbGluZSdzIGVuZHBvaW50IGlzIG9uIHRoZSBib3VuZGFyeS4iLAogICAgICAJCQlncm91cDogIkRlY2lzaW9uIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIxLjkuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjkuMS4wIiwKICAgICAgCQkJCQlpb3M6ICI1LjguMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjE1LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJpcy1zdXBwb3J0ZWQtc2NyaXB0IjogewogICAgICAJCQlkb2M6ICJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIHJlbmRlciBsZWdpYmx5LiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGlucHV0IHN0cmluZyBjb250YWlucyBzZWN0aW9ucyB0aGF0IGNhbm5vdCBiZSByZW5kZXJlZCB3aXRob3V0IHBvdGVudGlhbCBsb3NzIG9mIG1lYW5pbmcgKGUuZy4gSW5kaWMgc2NyaXB0cyB0aGF0IHJlcXVpcmUgY29tcGxleCB0ZXh0IHNoYXBpbmcsIG9yIHJpZ2h0LXRvLWxlZnQgc2NyaXB0cyBpZiB0aGUgdGhlIGBtYXBib3gtZ2wtcnRsLXRleHRgIHBsdWdpbiBpcyBub3QgaW4gdXNlIGluIE1hcGJveCBHTCBKUykuIiwKICAgICAgCQkJZ3JvdXA6ICJTdHJpbmciLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDUuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuNi4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQl1cGNhc2U6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgaW5wdXQgc3RyaW5nIGNvbnZlcnRlZCB0byB1cHBlcmNhc2UuIEZvbGxvd3MgdGhlIFVuaWNvZGUgRGVmYXVsdCBDYXNlIENvbnZlcnNpb24gYWxnb3JpdGhtIGFuZCB0aGUgbG9jYWxlLWluc2Vuc2l0aXZlIGNhc2UgbWFwcGluZ3MgaW4gdGhlIFVuaWNvZGUgQ2hhcmFjdGVyIERhdGFiYXNlLiIsCiAgICAgIAkJCWdyb3VwOiAiU3RyaW5nIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWRvd25jYXNlOiB7CiAgICAgIAkJCWRvYzogIlJldHVybnMgdGhlIGlucHV0IHN0cmluZyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLiBGb2xsb3dzIHRoZSBVbmljb2RlIERlZmF1bHQgQ2FzZSBDb252ZXJzaW9uIGFsZ29yaXRobSBhbmQgdGhlIGxvY2FsZS1pbnNlbnNpdGl2ZSBjYXNlIG1hcHBpbmdzIGluIHRoZSBVbmljb2RlIENoYXJhY3RlciBEYXRhYmFzZS4iLAogICAgICAJCQlncm91cDogIlN0cmluZyIsCiAgICAgIAkJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQljb25jYXQ6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyBhIGBzdHJpbmdgIGNvbnNpc3Rpbmcgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGlucHV0cy4gRWFjaCBpbnB1dCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgaWYgYnkgYHRvLXN0cmluZ2AuIiwKICAgICAgCQkJZ3JvdXA6ICJTdHJpbmciLAogICAgICAJCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJCX0KICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJInJlc29sdmVkLWxvY2FsZSI6IHsKICAgICAgCQkJZG9jOiAiUmV0dXJucyB0aGUgSUVURiBsYW5ndWFnZSB0YWcgb2YgdGhlIGxvY2FsZSBiZWluZyB1c2VkIGJ5IHRoZSBwcm92aWRlZCBgY29sbGF0b3JgLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbG9jYWxlLCBvciB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0ZWQgbG9jYWxlIHdhcyBzdWNjZXNzZnVsbHkgbG9hZGVkLiIsCiAgICAgIAkJCWdyb3VwOiAiU3RyaW5nIiwKICAgICAgCQkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAgIAkJCQkJaW9zOiAiNC4yLjAiLAogICAgICAJCQkJCW1hY29zOiAiMC45LjAiCiAgICAgIAkJCQl9CiAgICAgIAkJCX0KICAgICAgCQl9CiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBsaWdodCA9IHsKICAgICAgCWFuY2hvcjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQkiZGVmYXVsdCI6ICJ2aWV3cG9ydCIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCW1hcDogewogICAgICAJCQkJZG9jOiAiVGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgaXMgYWxpZ25lZCB0byB0aGUgcm90YXRpb24gb2YgdGhlIG1hcC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXZpZXdwb3J0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgdmlld3BvcnQuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IiwKICAgICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJXaGV0aGVyIGV4dHJ1ZGVkIGdlb21ldHJpZXMgYXJlIGxpdCByZWxhdGl2ZSB0byB0aGUgbWFwIG9yIHZpZXdwb3J0LiIsCiAgICAgIAkJZXhhbXBsZTogIm1hcCIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9CiAgICAgIAkJfQogICAgICAJfSwKICAgICAgCXBvc2l0aW9uOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQkiZGVmYXVsdCI6IFsKICAgICAgCQkJMS4xNSwKICAgICAgCQkJMjEwLAogICAgICAJCQkzMAogICAgICAJCV0sCiAgICAgIAkJbGVuZ3RoOiAzLAogICAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJZG9jOiAiUG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSByZWxhdGl2ZSB0byBsaXQgKGV4dHJ1ZGVkKSBnZW9tZXRyaWVzLCBpbiBbciByYWRpYWwgY29vcmRpbmF0ZSwgYSBhemltdXRoYWwgYW5nbGUsIHAgcG9sYXIgYW5nbGVdIHdoZXJlIHIgaW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGJhc2Ugb2YgYW4gb2JqZWN0IHRvIGl0cyBsaWdodCwgYSBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCByZWxhdGl2ZSB0byAwwrAgKDDCsCB3aGVuIGBsaWdodC5hbmNob3JgIGlzIHNldCB0byBgdmlld3BvcnRgIGNvcnJlc3BvbmRzIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0LCBvciAwwrAgd2hlbiBgbGlnaHQuYW5jaG9yYCBpcyBzZXQgdG8gYG1hcGAgY29ycmVzcG9uZHMgdG8gZHVlIG5vcnRoLCBhbmQgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZSksIGFuZCBwIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBsaWdodCAoZnJvbSAwwrAsIGRpcmVjdGx5IGFib3ZlLCB0byAxODDCsCwgZGlyZWN0bHkgYmVsb3cpLiIsCiAgICAgIAkJZXhhbXBsZTogWwogICAgICAJCQkxLjUsCiAgICAgIAkJCTkwLAogICAgICAJCQk4MAogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9CiAgICAgIAkJfQogICAgICAJfSwKICAgICAgCWNvbG9yOiB7CiAgICAgIAkJdHlwZTogImNvbG9yIiwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IiwKICAgICAgCQkiZGVmYXVsdCI6ICIjZmZmZmZmIiwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJZG9jOiAiQ29sb3IgdGludCBmb3IgbGlnaHRpbmcgZXh0cnVkZWQgZ2VvbWV0cmllcy4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgICAgCQkJfQogICAgICAJCX0KICAgICAgCX0sCiAgICAgIAlpbnRlbnNpdHk6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IiwKICAgICAgCQkiZGVmYXVsdCI6IDAuNSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCWRvYzogIkludGVuc2l0eSBvZiBsaWdodGluZyAob24gYSBzY2FsZSBmcm9tIDAgdG8gMSkuIEhpZ2hlciBudW1iZXJzIHdpbGwgcHJlc2VudCBhcyBtb3JlIGV4dHJlbWUgY29udHJhc3QuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgICAgCQkJCWlvczogIjMuNi4wIiwKICAgICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAgIAkJCX0KICAgICAgCQl9CiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBwYWludCA9IFsKICAgICAgCSJwYWludF9maWxsIiwKICAgICAgCSJwYWludF9saW5lIiwKICAgICAgCSJwYWludF9jaXJjbGUiLAogICAgICAJInBhaW50X2hlYXRtYXAiLAogICAgICAJInBhaW50X2ZpbGwtZXh0cnVzaW9uIiwKICAgICAgCSJwYWludF9zeW1ib2wiLAogICAgICAJInBhaW50X3Jhc3RlciIsCiAgICAgIAkicGFpbnRfaGlsbHNoYWRlIiwKICAgICAgCSJwYWludF9iYWNrZ3JvdW5kIgogICAgICBdOwogICAgICB2YXIgcGFpbnRfZmlsbCA9IHsKICAgICAgCSJmaWxsLWFudGlhbGlhcyI6IHsKICAgICAgCQl0eXBlOiAiYm9vbGVhbiIsCiAgICAgIAkJImRlZmF1bHQiOiB0cnVlLAogICAgICAJCWRvYzogIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiZmlsbC1vcGFjaXR5IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGxheWVyLiBJbiBjb250cmFzdCB0byB0aGUgYGZpbGwtY29sb3JgLCB0aGlzIHZhbHVlIHdpbGwgYWxzbyBhZmZlY3QgdGhlIDFweCBzdHJva2UgYXJvdW5kIHRoZSBmaWxsLCBpZiB0aGUgc3Ryb2tlIGlzIHVzZWQuIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMjEuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiZmlsbC1jb2xvciI6IHsKICAgICAgCQl0eXBlOiAiY29sb3IiLAogICAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgICAJCWRvYzogIlRoZSBjb2xvciBvZiB0aGUgZmlsbGVkIHBhcnQgb2YgdGhpcyBsYXllci4gVGhpcyBjb2xvciBjYW4gYmUgc3BlY2lmaWVkIGFzIGByZ2JhYCB3aXRoIGFuIGFscGhhIGNvbXBvbmVudCBhbmQgdGhlIGNvbG9yJ3Mgb3BhY2l0eSB3aWxsIG5vdCBhZmZlY3QgdGhlIG9wYWNpdHkgb2YgdGhlIDFweCBzdHJva2UsIGlmIGl0IGlzIHVzZWQuIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCXsKICAgICAgCQkJCSIhIjogImZpbGwtcGF0dGVybiIKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4xOS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJmaWxsLW91dGxpbmUtY29sb3IiOiB7CiAgICAgIAkJdHlwZTogImNvbG9yIiwKICAgICAgCQlkb2M6ICJUaGUgb3V0bGluZSBjb2xvciBvZiB0aGUgZmlsbC4gTWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGZpbGwtY29sb3JgIGlmIHVuc3BlY2lmaWVkLiIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQl7CiAgICAgIAkJCQkiISI6ICJmaWxsLXBhdHRlcm4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXsKICAgICAgCQkJCSJmaWxsLWFudGlhbGlhcyI6IHRydWUKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4xOS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJmaWxsLXRyYW5zbGF0ZSI6IHsKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgICAgCQlsZW5ndGg6IDIsCiAgICAgIAkJImRlZmF1bHQiOiBbCiAgICAgIAkJCTAsCiAgICAgIAkJCTAKICAgICAgCQldLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiZmlsbC10cmFuc2xhdGUtYW5jaG9yIjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJbWFwOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuIgogICAgICAJCQl9LAogICAgICAJCQl2aWV3cG9ydDogewogICAgICAJCQkJZG9jOiAiVGhlIGZpbGwgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC10cmFuc2xhdGVgLiIsCiAgICAgIAkJImRlZmF1bHQiOiAibWFwIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiZmlsbC10cmFuc2xhdGUiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImZpbGwtcGF0dGVybiI6IHsKICAgICAgCQl0eXBlOiAicmVzb2x2ZWRJbWFnZSIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlkb2M6ICJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgZmlsbHMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC40OS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMTEuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW4iCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciBwYWludF9saW5lID0gewogICAgICAJImxpbmUtb3BhY2l0eSI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQlkb2M6ICJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLiIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJbWF4aW11bTogMSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMjkuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkibGluZS1jb2xvciI6IHsKICAgICAgCQl0eXBlOiAiY29sb3IiLAogICAgICAJCWRvYzogIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uIiwKICAgICAgCQkiZGVmYXVsdCI6ICIjMDAwMDAwIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCXsKICAgICAgCQkJCSIhIjogImxpbmUtcGF0dGVybiIKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4yMy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJsaW5lLXRyYW5zbGF0ZSI6IHsKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgICAgCQlsZW5ndGg6IDIsCiAgICAgIAkJImRlZmF1bHQiOiBbCiAgICAgIAkJCTAsCiAgICAgIAkJCTAKICAgICAgCQldLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkibGluZS10cmFuc2xhdGUtYW5jaG9yIjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJbWFwOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgbGluZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuIgogICAgICAJCQl9LAogICAgICAJCQl2aWV3cG9ydDogewogICAgICAJCQkJZG9jOiAiVGhlIGxpbmUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgbGluZS10cmFuc2xhdGVgLiIsCiAgICAgIAkJImRlZmF1bHQiOiAibWFwIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkibGluZS10cmFuc2xhdGUiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImxpbmUtd2lkdGgiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiU3Ryb2tlIHRoaWNrbmVzcy4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzkuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4yLjAiLAogICAgICAJCQkJaW9zOiAiMy43LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjYuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkibGluZS1nYXAtd2lkdGgiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJZG9jOiAiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIsCiAgICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImxpbmUtb2Zmc2V0IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMCwKICAgICAgCQlkb2M6ICJUaGUgbGluZSdzIG9mZnNldC4gRm9yIGxpbmVhciBmZWF0dXJlcywgYSBwb3NpdGl2ZSB2YWx1ZSBvZmZzZXRzIHRoZSBsaW5lIHRvIHRoZSByaWdodCwgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZSwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgdG8gdGhlIGxlZnQuIEZvciBwb2x5Z29uIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gaW5zZXQsIGFuZCBhIG5lZ2F0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gb3V0c2V0LiIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMi4xIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIzLjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjEuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJsaW5lLWJsdXIiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiQmx1ciBhcHBsaWVkIHRvIHRoZSBsaW5lLCBpbiBwaXhlbHMuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIsCiAgICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImxpbmUtZGFzaGFycmF5IjogewogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIlNwZWNpZmllcyB0aGUgbGVuZ3RocyBvZiB0aGUgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzIHRoYXQgZm9ybSB0aGUgZGFzaCBwYXR0ZXJuLiBUaGUgbGVuZ3RocyBhcmUgbGF0ZXIgc2NhbGVkIGJ5IHRoZSBsaW5lIHdpZHRoLiBUbyBjb252ZXJ0IGEgZGFzaCBsZW5ndGggdG8gcGl4ZWxzLCBtdWx0aXBseSB0aGUgbGVuZ3RoIGJ5IHRoZSBjdXJyZW50IGxpbmUgd2lkdGguIE5vdGUgdGhhdCBHZW9KU09OIHNvdXJjZXMgd2l0aCBgbGluZU1ldHJpY3M6IHRydWVgIHNwZWNpZmllZCB3b24ndCByZW5kZXIgZGFzaGVkIGxpbmVzIHRvIHRoZSBleHBlY3RlZCBzY2FsZS4gQWxzbyBub3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLiIsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXVuaXRzOiAibGluZSB3aWR0aHMiLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCXsKICAgICAgCQkJCSIhIjogImxpbmUtcGF0dGVybiIKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiY3Jvc3MtZmFkZWQiCiAgICAgIAl9LAogICAgICAJImxpbmUtcGF0dGVybiI6IHsKICAgICAgCQl0eXBlOiAicmVzb2x2ZWRJbWFnZSIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlkb2M6ICJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgbGluZXMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDkuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjExLjAiLAogICAgICAJCQkJaW9zOiAiNC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJsaW5lLWdyYWRpZW50IjogewogICAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAgIAkJZG9jOiAiRGVmaW5lcyBhIGdyYWRpZW50IHdpdGggd2hpY2ggdG8gY29sb3IgYSBsaW5lIGZlYXR1cmUuIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBHZW9KU09OIHNvdXJjZXMgdGhhdCBzcGVjaWZ5IGBcImxpbmVNZXRyaWNzXCI6IHRydWVgLiIsCiAgICAgIAkJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJewogICAgICAJCQkJIiEiOiAibGluZS1kYXNoYXJyYXkiCiAgICAgIAkJCX0sCiAgICAgIAkJCXsKICAgICAgCQkJCSIhIjogImxpbmUtcGF0dGVybiIKICAgICAgCQkJfSwKICAgICAgCQkJewogICAgICAJCQkJc291cmNlOiAiZ2VvanNvbiIsCiAgICAgIAkJCQloYXM6IHsKICAgICAgCQkJCQlsaW5lTWV0cmljczogdHJ1ZQogICAgICAJCQkJfQogICAgICAJCQl9CiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjQ1LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjYuNS4wIiwKICAgICAgCQkJCWlvczogIjQuNC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJsaW5lLXByb2dyZXNzIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJjb2xvci1yYW1wIgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgcGFpbnRfY2lyY2xlID0gewogICAgICAJImNpcmNsZS1yYWRpdXMiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiA1LAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiQ2lyY2xlIHJhZGl1cy4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMTguMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiY2lyY2xlLWNvbG9yIjogewogICAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAgIAkJImRlZmF1bHQiOiAiIzAwMDAwMCIsCiAgICAgIAkJZG9jOiAiVGhlIGZpbGwgY29sb3Igb2YgdGhlIGNpcmNsZS4iLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4xOC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJjaXJjbGUtYmx1ciI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAsCiAgICAgIAkJZG9jOiAiQW1vdW50IHRvIGJsdXIgdGhlIGNpcmNsZS4gMSBibHVycyB0aGUgY2lyY2xlIHN1Y2ggdGhhdCBvbmx5IHRoZSBjZW50ZXJwb2ludCBpcyBmdWxsIG9wYWNpdHkuIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMjAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiY2lyY2xlLW9wYWNpdHkiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGNpcmNsZSB3aWxsIGJlIGRyYXduLiIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJbWF4aW11bTogMSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMjAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiY2lyY2xlLXRyYW5zbGF0ZSI6IHsKICAgICAgCQl0eXBlOiAiYXJyYXkiLAogICAgICAJCXZhbHVlOiAibnVtYmVyIiwKICAgICAgCQlsZW5ndGg6IDIsCiAgICAgIAkJImRlZmF1bHQiOiBbCiAgICAgIAkJCTAsCiAgICAgIAkJCTAKICAgICAgCQldLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3IiOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQltYXA6IHsKICAgICAgCQkJCWRvYzogIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLiIKICAgICAgCQkJfSwKICAgICAgCQkJdmlld3BvcnQ6IHsKICAgICAgCQkJCWRvYzogIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgY2lyY2xlLXRyYW5zbGF0ZWAuIiwKICAgICAgCQkiZGVmYXVsdCI6ICJtYXAiLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJjaXJjbGUtdHJhbnNsYXRlIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJjaXJjbGUtcGl0Y2gtc2NhbGUiOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQltYXA6IHsKICAgICAgCQkJCWRvYzogIkNpcmNsZXMgYXJlIHNjYWxlZCBhY2NvcmRpbmcgdG8gdGhlaXIgYXBwYXJlbnQgZGlzdGFuY2UgdG8gdGhlIGNhbWVyYS4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXZpZXdwb3J0OiB7CiAgICAgIAkJCQlkb2M6ICJDaXJjbGVzIGFyZSBub3Qgc2NhbGVkLiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJImRlZmF1bHQiOiAibWFwIiwKICAgICAgCQlkb2M6ICJDb250cm9scyB0aGUgc2NhbGluZyBiZWhhdmlvciBvZiB0aGUgY2lyY2xlIHdoZW4gdGhlIG1hcCBpcyBwaXRjaGVkLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4yMS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI0LjIuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjQuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMi4xIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50IjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJbWFwOiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgY2lyY2xlIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuIgogICAgICAJCQl9LAogICAgICAJCQl2aWV3cG9ydDogewogICAgICAJCQkJZG9jOiAiVGhlIGNpcmNsZSBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJ2aWV3cG9ydCIsCiAgICAgIAkJZG9jOiAiT3JpZW50YXRpb24gb2YgY2lyY2xlIHdoZW4gbWFwIGlzIHBpdGNoZWQuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjM5LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMi4wIiwKICAgICAgCQkJCWlvczogIjMuNy4wIiwKICAgICAgCQkJCW1hY29zOiAiMC42LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImNpcmNsZS1zdHJva2Utd2lkdGgiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiVGhlIHdpZHRoIG9mIHRoZSBjaXJjbGUncyBzdHJva2UuIFN0cm9rZXMgYXJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBgY2lyY2xlLXJhZGl1c2AuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjI5LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIsCiAgICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImNpcmNsZS1zdHJva2UtY29sb3IiOiB7CiAgICAgIAkJdHlwZTogImNvbG9yIiwKICAgICAgCQkiZGVmYXVsdCI6ICIjMDAwMDAwIiwKICAgICAgCQlkb2M6ICJUaGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBjaXJjbGUuIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMjkuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMjkuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiY2lyY2xlLXN0cm9rZS1vcGFjaXR5IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIlRoZSBvcGFjaXR5IG9mIHRoZSBjaXJjbGUncyBzdHJva2UuIiwKICAgICAgCQkiZGVmYXVsdCI6IDEsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQltYXhpbXVtOiAxLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4yOS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgcGFpbnRfaGVhdG1hcCA9IHsKICAgICAgCSJoZWF0bWFwLXJhZGl1cyI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDMwLAogICAgICAJCW1pbmltdW06IDEsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiUmFkaXVzIG9mIGluZmx1ZW5jZSBvZiBvbmUgaGVhdG1hcCBwb2ludCBpbiBwaXhlbHMuIEluY3JlYXNpbmcgdGhlIHZhbHVlIG1ha2VzIHRoZSBoZWF0bWFwIHNtb290aGVyLCBidXQgbGVzcyBkZXRhaWxlZC4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuNDEuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiaGVhdG1hcC13ZWlnaHQiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAgIAkJZG9jOiAiQSBtZWFzdXJlIG9mIGhvdyBtdWNoIGFuIGluZGl2aWR1YWwgcG9pbnQgY29udHJpYnV0ZXMgdG8gdGhlIGhlYXRtYXAuIEEgdmFsdWUgb2YgMTAgd291bGQgYmUgZXF1aXZhbGVudCB0byBoYXZpbmcgMTAgcG9pbnRzIG9mIHdlaWdodCAxIGluIHRoZSBzYW1lIHNwb3QuIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBjbHVzdGVyaW5nLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJoZWF0bWFwLWludGVuc2l0eSI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDEsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCWRvYzogIlNpbWlsYXIgdG8gYGhlYXRtYXAtd2VpZ2h0YCBidXQgY29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgaGVhdG1hcCBnbG9iYWxseS4gUHJpbWFyaWx5IHVzZWQgZm9yIGFkanVzdGluZyB0aGUgaGVhdG1hcCBiYXNlZCBvbiB6b29tIGxldmVsLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImhlYXRtYXAtY29sb3IiOiB7CiAgICAgIAkJdHlwZTogImNvbG9yIiwKICAgICAgCQkiZGVmYXVsdCI6IFsKICAgICAgCQkJImludGVycG9sYXRlIiwKICAgICAgCQkJWwogICAgICAJCQkJImxpbmVhciIKICAgICAgCQkJXSwKICAgICAgCQkJWwogICAgICAJCQkJImhlYXRtYXAtZGVuc2l0eSIKICAgICAgCQkJXSwKICAgICAgCQkJMCwKICAgICAgCQkJInJnYmEoMCwgMCwgMjU1LCAwKSIsCiAgICAgIAkJCTAuMSwKICAgICAgCQkJInJveWFsYmx1ZSIsCiAgICAgIAkJCTAuMywKICAgICAgCQkJImN5YW4iLAogICAgICAJCQkwLjUsCiAgICAgIAkJCSJsaW1lIiwKICAgICAgCQkJMC43LAogICAgICAJCQkieWVsbG93IiwKICAgICAgCQkJMSwKICAgICAgCQkJInJlZCIKICAgICAgCQldLAogICAgICAJCWRvYzogIkRlZmluZXMgdGhlIGNvbG9yIG9mIGVhY2ggcGl4ZWwgYmFzZWQgb24gaXRzIGRlbnNpdHkgdmFsdWUgaW4gYSBoZWF0bWFwLiAgU2hvdWxkIGJlIGFuIGV4cHJlc3Npb24gdGhhdCB1c2VzIGBbXCJoZWF0bWFwLWRlbnNpdHlcIl1gIGFzIGlucHV0LiIsCiAgICAgIAkJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC40MS4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI2LjAuMCIsCiAgICAgIAkJCQlpb3M6ICI0LjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNy4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJoZWF0bWFwLWRlbnNpdHkiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbG9yLXJhbXAiCiAgICAgIAl9LAogICAgICAJImhlYXRtYXAtb3BhY2l0eSI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQlkb2M6ICJUaGUgZ2xvYmFsIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGhlYXRtYXAgbGF5ZXIgd2lsbCBiZSBkcmF3bi4iLAogICAgICAJCSJkZWZhdWx0IjogMSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjQxLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIHBhaW50X3N5bWJvbCA9IHsKICAgICAgCSJpY29uLW9wYWNpdHkiOiB7CiAgICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGljb24gd2lsbCBiZSBkcmF3bi4iLAogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1jb2xvciI6IHsKICAgICAgCQl0eXBlOiAiY29sb3IiLAogICAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJZG9jOiAiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1oYWxvLWNvbG9yIjogewogICAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAgIAkJImRlZmF1bHQiOiAicmdiYSgwLCAwLCAwLCAwKSIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlkb2M6ICJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBTREYgaWNvbnMuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkiaWNvbi1pbWFnZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiaWNvbi1oYWxvLXdpZHRoIjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMCwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJdW5pdHM6ICJwaXhlbHMiLAogICAgICAJCWRvYzogIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGljb24gb3V0bGluZS4iLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJpY29uLWltYWdlIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4zMy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJpY29uLWhhbG8tYmx1ciI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgICAgCQlkb2M6ICJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJImljb24taW1hZ2UiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjMzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIsCiAgICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImljb24tdHJhbnNsYXRlIjogewogICAgICAJCXR5cGU6ICJhcnJheSIsCiAgICAgIAkJdmFsdWU6ICJudW1iZXIiLAogICAgICAJCWxlbmd0aDogMiwKICAgICAgCQkiZGVmYXVsdCI6IFsKICAgICAgCQkJMCwKICAgICAgCQkJMAogICAgICAJCV0sCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiRGlzdGFuY2UgdGhhdCB0aGUgaWNvbidzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJImljb24taW1hZ2UiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiaWNvbi10cmFuc2xhdGUtYW5jaG9yIjogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJbWFwOiB7CiAgICAgIAkJCQlkb2M6ICJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLiIKICAgICAgCQkJfSwKICAgICAgCQkJdmlld3BvcnQ6IHsKICAgICAgCQkJCWRvYzogIkljb25zIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWRvYzogIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBpY29uLXRyYW5zbGF0ZWAuIiwKICAgICAgCQkiZGVmYXVsdCI6ICJtYXAiLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJpY29uLWltYWdlIiwKICAgICAgCQkJImljb24tdHJhbnNsYXRlIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LW9wYWNpdHkiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi4iLAogICAgICAJCSJkZWZhdWx0IjogMSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkidGV4dC1jb2xvciI6IHsKICAgICAgCQl0eXBlOiAiY29sb3IiLAogICAgICAJCWRvYzogIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uIiwKICAgICAgCQkiZGVmYXVsdCI6ICIjMDAwMDAwIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCW92ZXJyaWRhYmxlOiB0cnVlLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4zMy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjAuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjUuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNC4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJ0ZXh0LWhhbG8tY29sb3IiOiB7CiAgICAgIAkJdHlwZTogImNvbG9yIiwKICAgICAgCQkiZGVmYXVsdCI6ICJyZ2JhKDAsIDAsIDAsIDApIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCWRvYzogIlRoZSBjb2xvciBvZiB0aGUgdGV4dCdzIGhhbG8sIHdoaWNoIGhlbHBzIGl0IHN0YW5kIG91dCBmcm9tIGJhY2tncm91bmRzLiIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJInRleHQtZmllbGQiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjMzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMC4wIiwKICAgICAgCQkJCWlvczogIjMuNS4wIiwKICAgICAgCQkJCW1hY29zOiAiMC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIsCiAgICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJInRleHQtaGFsby13aWR0aCI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgICAgCQlkb2M6ICJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBmb250IG91dGxpbmUuIE1heCB0ZXh0IGhhbG8gd2lkdGggaXMgMS80IG9mIHRoZSBmb250LXNpemUuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkidGV4dC1oYWxvLWJsdXIiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogInBpeGVscyIsCiAgICAgIAkJZG9jOiAiVGhlIGhhbG8ncyBmYWRlb3V0IGRpc3RhbmNlIHRvd2FyZHMgdGhlIG91dHNpZGUuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMzMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4wLjAiLAogICAgICAJCQkJaW9zOiAiMy41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjQuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkidGV4dC10cmFuc2xhdGUiOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAgIAkJbGVuZ3RoOiAyLAogICAgICAJCSJkZWZhdWx0IjogWwogICAgICAJCQkwLAogICAgICAJCQkwCiAgICAgIAkJXSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgICAgCQlkb2M6ICJEaXN0YW5jZSB0aGF0IHRoZSB0ZXh0J3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIiwKICAgICAgCQlyZXF1aXJlczogWwogICAgICAJCQkidGV4dC1maWVsZCIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3IiOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQltYXA6IHsKICAgICAgCQkJCWRvYzogIlRoZSB0ZXh0IGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXZpZXdwb3J0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWRvYzogIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGB0ZXh0LXRyYW5zbGF0ZWAuIiwKICAgICAgCQkiZGVmYXVsdCI6ICJtYXAiLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJ0ZXh0LWZpZWxkIiwKICAgICAgCQkJInRleHQtdHJhbnNsYXRlIgogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgcGFpbnRfcmFzdGVyID0gewogICAgICAJInJhc3Rlci1vcGFjaXR5IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpbWFnZSB3aWxsIGJlIGRyYXduLiIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJbWF4aW11bTogMSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJyYXN0ZXItaHVlLXJvdGF0ZSI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAsCiAgICAgIAkJcGVyaW9kOiAzNjAsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQl1bml0czogImRlZ3JlZXMiLAogICAgICAJCWRvYzogIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLiIsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJInJhc3Rlci1icmlnaHRuZXNzLW1pbiI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQlkb2M6ICJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy4iLAogICAgICAJCSJkZWZhdWx0IjogMCwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkicmFzdGVyLWJyaWdodG5lc3MtbWF4IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIFRoZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBicmlnaHRuZXNzLiIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJbWF4aW11bTogMSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMTAuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiMi4wLjEiLAogICAgICAJCQkJaW9zOiAiMi4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjEuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJyYXN0ZXItc2F0dXJhdGlvbiI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQlkb2M6ICJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIHNhdHVyYXRpb24gb2YgdGhlIGltYWdlLiIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCW1pbmltdW06IC0xLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkicmFzdGVyLWNvbnRyYXN0IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCWRvYzogIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLiIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCW1pbmltdW06IC0xLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkicmFzdGVyLXJlc2FtcGxpbmciOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCWRvYzogIlRoZSByZXNhbXBsaW5nL2ludGVycG9sYXRpb24gbWV0aG9kIHRvIHVzZSBmb3Igb3ZlcnNjYWxpbmcsIGFsc28ga25vd24gYXMgdGV4dHVyZSBtYWduaWZpY2F0aW9uIGZpbHRlciIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCWxpbmVhcjogewogICAgICAJCQkJZG9jOiAiKEJpKWxpbmVhciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciBjbG9zZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbHMgY3JlYXRpbmcgYSBzbW9vdGggYnV0IGJsdXJyeSBsb29rIHdoZW4gb3ZlcnNjYWxlZCIKICAgICAgCQkJfSwKICAgICAgCQkJbmVhcmVzdDogewogICAgICAJCQkJZG9jOiAiTmVhcmVzdCBuZWlnaGJvciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgbmVhcmVzdCBvcmlnaW5hbCBzb3VyY2UgcGl4ZWwgY3JlYXRpbmcgYSBzaGFycCBidXQgcGl4ZWxhdGVkIGxvb2sgd2hlbiBvdmVyc2NhbGVkIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQkiZGVmYXVsdCI6ICJsaW5lYXIiLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuNDcuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi4zLjAiLAogICAgICAJCQkJaW9zOiAiNC4yLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjkuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkicmFzdGVyLWZhZGUtZHVyYXRpb24iOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAzMDAsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQl0cmFuc2l0aW9uOiBmYWxzZSwKICAgICAgCQl1bml0czogIm1pbGxpc2Vjb25kcyIsCiAgICAgIAkJZG9jOiAiRmFkZSBkdXJhdGlvbiB3aGVuIGEgbmV3IHRpbGUgaXMgYWRkZWQuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIHBhaW50X2hpbGxzaGFkZSA9IHsKICAgICAgCSJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvbiI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDMzNSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDM1OSwKICAgICAgCQlkb2M6ICJUaGUgZGlyZWN0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgaGlsbHNoYWRpbmcgd2l0aCAwIGFzIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGB2aWV3cG9ydGAgYW5kIGR1ZSBub3J0aCBpZiBgaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1hbmNob3JgIGlzIHNldCB0byBgbWFwYC4iLAogICAgICAJCXRyYW5zaXRpb246IGZhbHNlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvciI6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCW1hcDogewogICAgICAJCQkJZG9jOiAiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG5vcnRoIGRpcmVjdGlvbi4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXZpZXdwb3J0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgaGlsbHNoYWRlIGlsbHVtaW5hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogInZpZXdwb3J0IiwKICAgICAgCQlkb2M6ICJEaXJlY3Rpb24gb2YgbGlnaHQgc291cmNlIHdoZW4gbWFwIGlzIHJvdGF0ZWQuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImhpbGxzaGFkZS1leGFnZ2VyYXRpb24iOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJZG9jOiAiSW50ZW5zaXR5IG9mIHRoZSBoaWxsc2hhZGUiLAogICAgICAJCSJkZWZhdWx0IjogMC41LAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJbWF4aW11bTogMSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuNDMuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi4wLjAiLAogICAgICAJCQkJaW9zOiAiNC4wLjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjcuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfSwKICAgICAgCSJoaWxsc2hhZGUtc2hhZG93LWNvbG9yIjogewogICAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAgIAkJImRlZmF1bHQiOiAiIzAwMDAwMCIsCiAgICAgIAkJZG9jOiAiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlLiIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvciI6IHsKICAgICAgCQl0eXBlOiAiY29sb3IiLAogICAgICAJCSJkZWZhdWx0IjogIiNGRkZGRkYiLAogICAgICAJCWRvYzogIlRoZSBzaGFkaW5nIGNvbG9yIG9mIGFyZWFzIHRoYXQgZmFjZXMgdG93YXJkcyB0aGUgbGlnaHQgc291cmNlLiIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiaGlsbHNoYWRlLWFjY2VudC1jb2xvciI6IHsKICAgICAgCQl0eXBlOiAiY29sb3IiLAogICAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgICAJCWRvYzogIlRoZSBzaGFkaW5nIGNvbG9yIHVzZWQgdG8gYWNjZW50dWF0ZSBydWdnZWQgdGVycmFpbiBsaWtlIHNoYXJwIGNsaWZmcyBhbmQgZ29yZ2VzLiIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjQzLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjYuMC4wIiwKICAgICAgCQkJCWlvczogIjQuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC43LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0KICAgICAgfTsKICAgICAgdmFyIHBhaW50X2JhY2tncm91bmQgPSB7CiAgICAgIAkiYmFja2dyb3VuZC1jb2xvciI6IHsKICAgICAgCQl0eXBlOiAiY29sb3IiLAogICAgICAJCSJkZWZhdWx0IjogIiMwMDAwMDAiLAogICAgICAJCWRvYzogIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCXsKICAgICAgCQkJCSIhIjogImJhY2tncm91bmQtcGF0dGVybiIKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImJhY2tncm91bmQtcGF0dGVybiI6IHsKICAgICAgCQl0eXBlOiAicmVzb2x2ZWRJbWFnZSIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlkb2M6ICJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjEwLjAiLAogICAgICAJCQkJYW5kcm9pZDogIjIuMC4xIiwKICAgICAgCQkJCWlvczogIjIuMC4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xLjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJjcm9zcy1mYWRlZCIKICAgICAgCX0sCiAgICAgIAkiYmFja2dyb3VuZC1vcGFjaXR5IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi4iLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4xMC4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICIyLjAuMSIsCiAgICAgIAkJCQlpb3M6ICIyLjAuMCIsCiAgICAgIAkJCQltYWNvczogIjAuMS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9CiAgICAgIH07CiAgICAgIHZhciB0cmFuc2l0aW9uID0gewogICAgICAJZHVyYXRpb246IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDMwMCwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCXVuaXRzOiAibWlsbGlzZWNvbmRzIiwKICAgICAgCQlkb2M6ICJUaW1lIGFsbG90dGVkIGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZS4iCiAgICAgIAl9LAogICAgICAJZGVsYXk6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQl1bml0czogIm1pbGxpc2Vjb25kcyIsCiAgICAgIAkJZG9jOiAiTGVuZ3RoIG9mIHRpbWUgYmVmb3JlIGEgdHJhbnNpdGlvbiBiZWdpbnMuIgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgcHJvbW90ZUlkID0gewogICAgICAJIioiOiB7CiAgICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiQSBuYW1lIG9mIGEgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgSUQgZm9yIGZlYXR1cmUgc3RhdGUuIgogICAgICAJfQogICAgICB9OwogICAgICB2YXIgdjggPSB7CiAgICAgIAkkdmVyc2lvbjogJHZlcnNpb24sCiAgICAgIAkkcm9vdDogJHJvb3QsCiAgICAgIAlzb3VyY2VzOiBzb3VyY2VzLAogICAgICAJc291cmNlOiBzb3VyY2UsCiAgICAgIAlzb3VyY2VfdmVjdG9yOiBzb3VyY2VfdmVjdG9yLAogICAgICAJc291cmNlX3Jhc3Rlcjogc291cmNlX3Jhc3RlciwKICAgICAgCXNvdXJjZV9yYXN0ZXJfZGVtOiBzb3VyY2VfcmFzdGVyX2RlbSwKICAgICAgCXNvdXJjZV9nZW9qc29uOiBzb3VyY2VfZ2VvanNvbiwKICAgICAgCXNvdXJjZV92aWRlbzogc291cmNlX3ZpZGVvLAogICAgICAJc291cmNlX2ltYWdlOiBzb3VyY2VfaW1hZ2UsCiAgICAgIAlsYXllcjogbGF5ZXIsCiAgICAgIAlsYXlvdXQ6IGxheW91dCwKICAgICAgCWxheW91dF9iYWNrZ3JvdW5kOiBsYXlvdXRfYmFja2dyb3VuZCwKICAgICAgCWxheW91dF9maWxsOiBsYXlvdXRfZmlsbCwKICAgICAgCWxheW91dF9jaXJjbGU6IGxheW91dF9jaXJjbGUsCiAgICAgIAlsYXlvdXRfaGVhdG1hcDogbGF5b3V0X2hlYXRtYXAsCiAgICAgIAkibGF5b3V0X2ZpbGwtZXh0cnVzaW9uIjogewogICAgICAJdmlzaWJpbGl0eTogewogICAgICAJCXR5cGU6ICJlbnVtIiwKICAgICAgCQl2YWx1ZXM6IHsKICAgICAgCQkJdmlzaWJsZTogewogICAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIHNob3duLiIKICAgICAgCQkJfSwKICAgICAgCQkJbm9uZTogewogICAgICAJCQkJZG9jOiAiVGhlIGxheWVyIGlzIG5vdCBzaG93bi4iCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJkZWZhdWx0IjogInZpc2libGUiLAogICAgICAJCWRvYzogIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgICAgCQkJCWlvczogIjMuNi4wIiwKICAgICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNvbnN0YW50IgogICAgICAJfQogICAgICB9LAogICAgICAJbGF5b3V0X2xpbmU6IGxheW91dF9saW5lLAogICAgICAJbGF5b3V0X3N5bWJvbDogbGF5b3V0X3N5bWJvbCwKICAgICAgCWxheW91dF9yYXN0ZXI6IGxheW91dF9yYXN0ZXIsCiAgICAgIAlsYXlvdXRfaGlsbHNoYWRlOiBsYXlvdXRfaGlsbHNoYWRlLAogICAgICAJZmlsdGVyOiBmaWx0ZXIsCiAgICAgIAlmaWx0ZXJfb3BlcmF0b3I6IGZpbHRlcl9vcGVyYXRvciwKICAgICAgCWdlb21ldHJ5X3R5cGU6IGdlb21ldHJ5X3R5cGUsCiAgICAgIAkiZnVuY3Rpb24iOiB7CiAgICAgIAlleHByZXNzaW9uOiB7CiAgICAgIAkJdHlwZTogImV4cHJlc3Npb24iLAogICAgICAJCWRvYzogIkFuIGV4cHJlc3Npb24uIgogICAgICAJfSwKICAgICAgCXN0b3BzOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQlkb2M6ICJBbiBhcnJheSBvZiBzdG9wcy4iLAogICAgICAJCXZhbHVlOiAiZnVuY3Rpb25fc3RvcCIKICAgICAgCX0sCiAgICAgIAliYXNlOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAxLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJZG9jOiAiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuIgogICAgICAJfSwKICAgICAgCXByb3BlcnR5OiB7CiAgICAgIAkJdHlwZTogInN0cmluZyIsCiAgICAgIAkJZG9jOiAiVGhlIG5hbWUgb2YgYSBmZWF0dXJlIHByb3BlcnR5IHRvIHVzZSBhcyB0aGUgZnVuY3Rpb24gaW5wdXQuIiwKICAgICAgCQkiZGVmYXVsdCI6ICIkem9vbSIKICAgICAgCX0sCiAgICAgIAl0eXBlOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQlpZGVudGl0eTogewogICAgICAJCQkJZG9jOiAiUmV0dXJuIHRoZSBpbnB1dCB2YWx1ZSBhcyB0aGUgb3V0cHV0IHZhbHVlLiIKICAgICAgCQkJfSwKICAgICAgCQkJZXhwb25lbnRpYWw6IHsKICAgICAgCQkJCWRvYzogIkdlbmVyYXRlIGFuIG91dHB1dCBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBmdW5jdGlvbiBpbnB1dC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCWludGVydmFsOiB7CiAgICAgIAkJCQlkb2M6ICJSZXR1cm4gdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgZnVuY3Rpb24gaW5wdXQuIgogICAgICAJCQl9LAogICAgICAJCQljYXRlZ29yaWNhbDogewogICAgICAJCQkJZG9jOiAiUmV0dXJuIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AgZXF1YWwgdG8gdGhlIGZ1bmN0aW9uIGlucHV0LiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZG9jOiAiVGhlIGludGVycG9sYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGluIGZ1bmN0aW9uIGV2YWx1YXRpb24uIiwKICAgICAgCQkiZGVmYXVsdCI6ICJleHBvbmVudGlhbCIKICAgICAgCX0sCiAgICAgIAljb2xvclNwYWNlOiB7CiAgICAgIAkJdHlwZTogImVudW0iLAogICAgICAJCXZhbHVlczogewogICAgICAJCQlyZ2I6IHsKICAgICAgCQkJCWRvYzogIlVzZSB0aGUgUkdCIGNvbG9yIHNwYWNlIHRvIGludGVycG9sYXRlIGNvbG9yIHZhbHVlcyIKICAgICAgCQkJfSwKICAgICAgCQkJbGFiOiB7CiAgICAgIAkJCQlkb2M6ICJVc2UgdGhlIExBQiBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMuIgogICAgICAJCQl9LAogICAgICAJCQloY2w6IHsKICAgICAgCQkJCWRvYzogIlVzZSB0aGUgSENMIGNvbG9yIHNwYWNlIHRvIGludGVycG9sYXRlIGNvbG9yIHZhbHVlcywgaW50ZXJwb2xhdGluZyB0aGUgSHVlLCBDaHJvbWEsIGFuZCBMdW1pbmFuY2UgY2hhbm5lbHMgaW5kaXZpZHVhbGx5LiIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZG9jOiAiVGhlIGNvbG9yIHNwYWNlIGluIHdoaWNoIGNvbG9ycyBpbnRlcnBvbGF0ZWQuIEludGVycG9sYXRpbmcgY29sb3JzIGluIHBlcmNlcHR1YWwgY29sb3Igc3BhY2VzIGxpa2UgTEFCIGFuZCBIQ0wgdGVuZCB0byBwcm9kdWNlIGNvbG9yIHJhbXBzIHRoYXQgbG9vayBtb3JlIGNvbnNpc3RlbnQgYW5kIHByb2R1Y2UgY29sb3JzIHRoYXQgY2FuIGJlIGRpZmZlcmVudGlhdGVkIG1vcmUgZWFzaWx5IHRoYW4gdGhvc2UgaW50ZXJwb2xhdGVkIGluIFJHQiBzcGFjZS4iLAogICAgICAJCSJkZWZhdWx0IjogInJnYiIKICAgICAgCX0sCiAgICAgIAkiZGVmYXVsdCI6IHsKICAgICAgCQl0eXBlOiAiKiIsCiAgICAgIAkJcmVxdWlyZWQ6IGZhbHNlLAogICAgICAJCWRvYzogIkEgdmFsdWUgdG8gc2VydmUgYXMgYSBmYWxsYmFjayBmdW5jdGlvbiByZXN1bHQgd2hlbiBhIHZhbHVlIGlzbid0IG90aGVyd2lzZSBhdmFpbGFibGUuIEl0IGlzIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBjaXJjdW1zdGFuY2VzOlxuKiBJbiBjYXRlZ29yaWNhbCBmdW5jdGlvbnMsIHdoZW4gdGhlIGZlYXR1cmUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBzdG9wIGRvbWFpbiB2YWx1ZXMuXG4qIEluIHByb3BlcnR5IGFuZCB6b29tLWFuZC1wcm9wZXJ0eSBmdW5jdGlvbnMsIHdoZW4gYSBmZWF0dXJlIGRvZXMgbm90IGNvbnRhaW4gYSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiogSW4gaWRlbnRpdHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIHN0eWxlIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaWYgdGhlIGZ1bmN0aW9uIGlzIGJlaW5nIHVzZWQgZm9yIGEgYGNpcmNsZS1jb2xvcmAgcHJvcGVydHkgYnV0IHRoZSBmZWF0dXJlIHByb3BlcnR5IHZhbHVlIGlzIG5vdCBhIHN0cmluZyBvciBub3QgYSB2YWxpZCBjb2xvcikuXG4qIEluIGludGVydmFsIG9yIGV4cG9uZW50aWFsIHByb3BlcnR5IGFuZCB6b29tLWFuZC1wcm9wZXJ0eSBmdW5jdGlvbnMsIHdoZW4gdGhlIGZlYXR1cmUgdmFsdWUgaXMgbm90IG51bWVyaWMuXG5JZiBubyBkZWZhdWx0IGlzIHByb3ZpZGVkLCB0aGUgc3R5bGUgcHJvcGVydHkncyBkZWZhdWx0IGlzIHVzZWQgaW4gdGhlc2UgY2lyY3Vtc3RhbmNlcy4iCiAgICAgIAl9CiAgICAgIH0sCiAgICAgIAlmdW5jdGlvbl9zdG9wOiBmdW5jdGlvbl9zdG9wLAogICAgICAJZXhwcmVzc2lvbjogZXhwcmVzc2lvbiwKICAgICAgCWV4cHJlc3Npb25fbmFtZTogZXhwcmVzc2lvbl9uYW1lLAogICAgICAJbGlnaHQ6IGxpZ2h0LAogICAgICAJcGFpbnQ6IHBhaW50LAogICAgICAJcGFpbnRfZmlsbDogcGFpbnRfZmlsbCwKICAgICAgCSJwYWludF9maWxsLWV4dHJ1c2lvbiI6IHsKICAgICAgCSJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5IjogewogICAgICAJCXR5cGU6ICJudW1iZXIiLAogICAgICAJCSJkZWZhdWx0IjogMSwKICAgICAgCQltaW5pbXVtOiAwLAogICAgICAJCW1heGltdW06IDEsCiAgICAgIAkJZG9jOiAiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGV4dHJ1c2lvbiBsYXllci4gVGhpcyBpcyByZW5kZXJlZCBvbiBhIHBlci1sYXllciwgbm90IHBlci1mZWF0dXJlLCBiYXNpcywgYW5kIGRhdGEtZHJpdmVuIHN0eWxpbmcgaXMgbm90IGF2YWlsYWJsZS4iLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtY29uc3RhbnQiCiAgICAgIAl9LAogICAgICAJImZpbGwtZXh0cnVzaW9uLWNvbG9yIjogewogICAgICAJCXR5cGU6ICJjb2xvciIsCiAgICAgIAkJImRlZmF1bHQiOiAiIzAwMDAwMCIsCiAgICAgIAkJZG9jOiAiVGhlIGJhc2UgY29sb3Igb2YgdGhlIGV4dHJ1ZGVkIGZpbGwuIFRoZSBleHRydXNpb24ncyBzdXJmYWNlcyB3aWxsIGJlIHNoYWRlZCBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGlzIGNvbG9yIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHJvb3QgYGxpZ2h0YCBzZXR0aW5ncy4gSWYgdGhpcyBjb2xvciBpcyBzcGVjaWZpZWQgYXMgYHJnYmFgIHdpdGggYW4gYWxwaGEgY29tcG9uZW50LCB0aGUgYWxwaGEgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZDsgdXNlIGBmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5YCB0byBzZXQgbGF5ZXIgb3BhY2l0eS4iLAogICAgICAJCXRyYW5zaXRpb246IHRydWUsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJewogICAgICAJCQkJIiEiOiAiZmlsbC1leHRydXNpb24tcGF0dGVybiIKICAgICAgCQkJfQogICAgICAJCV0sCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9LAogICAgICAJCQkiZGF0YS1kcml2ZW4gc3R5bGluZyI6IHsKICAgICAgCQkJCWpzOiAiMC4yNy4wIiwKICAgICAgCQkJCWFuZHJvaWQ6ICI1LjEuMCIsCiAgICAgIAkJCQlpb3M6ICIzLjYuMCIsCiAgICAgIAkJCQltYWNvczogIjAuNS4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogdHJ1ZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiLAogICAgICAJCQkJImZlYXR1cmUtc3RhdGUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUiOiB7CiAgICAgIAkJdHlwZTogImFycmF5IiwKICAgICAgCQl2YWx1ZTogIm51bWJlciIsCiAgICAgIAkJbGVuZ3RoOiAyLAogICAgICAJCSJkZWZhdWx0IjogWwogICAgICAJCQkwLAogICAgICAJCQkwCiAgICAgIAkJXSwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXVuaXRzOiAicGl4ZWxzIiwKICAgICAgCQlkb2M6ICJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCAob24gdGhlIGZsYXQgcGxhbmUpLCByZXNwZWN0aXZlbHkuIiwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgICAgCQkJCWlvczogIjMuNi4wIiwKICAgICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvciI6IHsKICAgICAgCQl0eXBlOiAiZW51bSIsCiAgICAgIAkJdmFsdWVzOiB7CiAgICAgIAkJCW1hcDogewogICAgICAJCQkJZG9jOiAiVGhlIGZpbGwgZXh0cnVzaW9uIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC4iCiAgICAgIAkJCX0sCiAgICAgIAkJCXZpZXdwb3J0OiB7CiAgICAgIAkJCQlkb2M6ICJUaGUgZmlsbCBleHRydXNpb24gaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlkb2M6ICJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC1leHRydXNpb24tdHJhbnNsYXRlYC4iLAogICAgICAJCSJkZWZhdWx0IjogIm1hcCIsCiAgICAgIAkJcmVxdWlyZXM6IFsKICAgICAgCQkJImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZSIKICAgICAgCQldLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IGZhbHNlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1jb25zdGFudCIKICAgICAgCX0sCiAgICAgIAkiZmlsbC1leHRydXNpb24tcGF0dGVybiI6IHsKICAgICAgCQl0eXBlOiAicmVzb2x2ZWRJbWFnZSIsCiAgICAgIAkJdHJhbnNpdGlvbjogdHJ1ZSwKICAgICAgCQlkb2M6ICJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2VzIG9uIGV4dHJ1ZGVkIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy4iLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuNDkuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNi41LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjExLjAiLAogICAgICAJCQkJaW9zOiAiNC40LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiBmYWxzZSwKICAgICAgCQkJcGFyYW1ldGVyczogWwogICAgICAJCQkJInpvb20iLAogICAgICAJCQkJImZlYXR1cmUiCiAgICAgIAkJCV0KICAgICAgCQl9LAogICAgICAJCSJwcm9wZXJ0eS10eXBlIjogImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuIgogICAgICAJfSwKICAgICAgCSJmaWxsLWV4dHJ1c2lvbi1oZWlnaHQiOiB7CiAgICAgIAkJdHlwZTogIm51bWJlciIsCiAgICAgIAkJImRlZmF1bHQiOiAwLAogICAgICAJCW1pbmltdW06IDAsCiAgICAgIAkJdW5pdHM6ICJtZXRlcnMiLAogICAgICAJCWRvYzogIlRoZSBoZWlnaHQgd2l0aCB3aGljaCB0byBleHRydWRlIHRoaXMgbGF5ZXIuIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCSJzZGstc3VwcG9ydCI6IHsKICAgICAgCQkJImJhc2ljIGZ1bmN0aW9uYWxpdHkiOiB7CiAgICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgICAgCQkJfSwKICAgICAgCQkJImRhdGEtZHJpdmVuIHN0eWxpbmciOiB7CiAgICAgIAkJCQlqczogIjAuMjcuMCIsCiAgICAgIAkJCQlhbmRyb2lkOiAiNS4xLjAiLAogICAgICAJCQkJaW9zOiAiMy42LjAiLAogICAgICAJCQkJbWFjb3M6ICIwLjUuMCIKICAgICAgCQkJfQogICAgICAJCX0sCiAgICAgIAkJZXhwcmVzc2lvbjogewogICAgICAJCQlpbnRlcnBvbGF0ZWQ6IHRydWUsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIiwKICAgICAgCQkJCSJmZWF0dXJlIiwKICAgICAgCQkJCSJmZWF0dXJlLXN0YXRlIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWRyaXZlbiIKICAgICAgCX0sCiAgICAgIAkiZmlsbC1leHRydXNpb24tYmFzZSI6IHsKICAgICAgCQl0eXBlOiAibnVtYmVyIiwKICAgICAgCQkiZGVmYXVsdCI6IDAsCiAgICAgIAkJbWluaW11bTogMCwKICAgICAgCQl1bml0czogIm1ldGVycyIsCiAgICAgIAkJZG9jOiAiVGhlIGhlaWdodCB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhlIGJhc2Ugb2YgdGhpcyBsYXllci4gTXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYGZpbGwtZXh0cnVzaW9uLWhlaWdodGAuIiwKICAgICAgCQl0cmFuc2l0aW9uOiB0cnVlLAogICAgICAJCXJlcXVpcmVzOiBbCiAgICAgIAkJCSJmaWxsLWV4dHJ1c2lvbi1oZWlnaHQiCiAgICAgIAkJXSwKICAgICAgCQkic2RrLXN1cHBvcnQiOiB7CiAgICAgIAkJCSJiYXNpYyBmdW5jdGlvbmFsaXR5IjogewogICAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgICAgCQkJCWlvczogIjMuNi4wIiwKICAgICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAgIAkJCX0sCiAgICAgIAkJCSJkYXRhLWRyaXZlbiBzdHlsaW5nIjogewogICAgICAJCQkJanM6ICIwLjI3LjAiLAogICAgICAJCQkJYW5kcm9pZDogIjUuMS4wIiwKICAgICAgCQkJCWlvczogIjMuNi4wIiwKICAgICAgCQkJCW1hY29zOiAiMC41LjAiCiAgICAgIAkJCX0KICAgICAgCQl9LAogICAgICAJCWV4cHJlc3Npb246IHsKICAgICAgCQkJaW50ZXJwb2xhdGVkOiB0cnVlLAogICAgICAJCQlwYXJhbWV0ZXJzOiBbCiAgICAgIAkJCQkiem9vbSIsCiAgICAgIAkJCQkiZmVhdHVyZSIsCiAgICAgIAkJCQkiZmVhdHVyZS1zdGF0ZSIKICAgICAgCQkJXQogICAgICAJCX0sCiAgICAgIAkJInByb3BlcnR5LXR5cGUiOiAiZGF0YS1kcml2ZW4iCiAgICAgIAl9LAogICAgICAJImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50IjogewogICAgICAJCXR5cGU6ICJib29sZWFuIiwKICAgICAgCQkiZGVmYXVsdCI6IHRydWUsCiAgICAgIAkJZG9jOiAiV2hldGhlciB0byBhcHBseSBhIHZlcnRpY2FsIGdyYWRpZW50IHRvIHRoZSBzaWRlcyBvZiBhIGZpbGwtZXh0cnVzaW9uIGxheWVyLiBJZiB0cnVlLCBzaWRlcyB3aWxsIGJlIHNoYWRlZCBzbGlnaHRseSBkYXJrZXIgZmFydGhlciBkb3duLiIsCiAgICAgIAkJdHJhbnNpdGlvbjogZmFsc2UsCiAgICAgIAkJInNkay1zdXBwb3J0IjogewogICAgICAJCQkiYmFzaWMgZnVuY3Rpb25hbGl0eSI6IHsKICAgICAgCQkJCWpzOiAiMC41MC4wIiwKICAgICAgCQkJCWlvczogIjQuNy4wIiwKICAgICAgCQkJCW1hY29zOiAiMC4xMy4wIgogICAgICAJCQl9CiAgICAgIAkJfSwKICAgICAgCQlleHByZXNzaW9uOiB7CiAgICAgIAkJCWludGVycG9sYXRlZDogZmFsc2UsCiAgICAgIAkJCXBhcmFtZXRlcnM6IFsKICAgICAgCQkJCSJ6b29tIgogICAgICAJCQldCiAgICAgIAkJfSwKICAgICAgCQkicHJvcGVydHktdHlwZSI6ICJkYXRhLWNvbnN0YW50IgogICAgICAJfQogICAgICB9LAogICAgICAJcGFpbnRfbGluZTogcGFpbnRfbGluZSwKICAgICAgCXBhaW50X2NpcmNsZTogcGFpbnRfY2lyY2xlLAogICAgICAJcGFpbnRfaGVhdG1hcDogcGFpbnRfaGVhdG1hcCwKICAgICAgCXBhaW50X3N5bWJvbDogcGFpbnRfc3ltYm9sLAogICAgICAJcGFpbnRfcmFzdGVyOiBwYWludF9yYXN0ZXIsCiAgICAgIAlwYWludF9oaWxsc2hhZGU6IHBhaW50X2hpbGxzaGFkZSwKICAgICAgCXBhaW50X2JhY2tncm91bmQ6IHBhaW50X2JhY2tncm91bmQsCiAgICAgIAl0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLAogICAgICAJInByb3BlcnR5LXR5cGUiOiB7CiAgICAgIAkiZGF0YS1kcml2ZW4iOiB7CiAgICAgIAkJdHlwZTogInByb3BlcnR5LXR5cGUiLAogICAgICAJCWRvYzogIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBhbmQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi4iCiAgICAgIAl9LAogICAgICAJImNyb3NzLWZhZGVkIjogewogICAgICAJCXR5cGU6ICJwcm9wZXJ0eS10eXBlIiwKICAgICAgCQlkb2M6ICJQcm9wZXJ0eSBpcyBub24taW50ZXJwb2xhYmxlOyByYXRoZXIsIGl0cyB2YWx1ZXMgd2lsbCBiZSBjcm9zcy1mYWRlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gaW50ZWdlciB6b29tcy4iCiAgICAgIAl9LAogICAgICAJImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuIjogewogICAgICAJCXR5cGU6ICJwcm9wZXJ0eS10eXBlIiwKICAgICAgCQlkb2M6ICJQcm9wZXJ0eSBpcyBub24taW50ZXJwb2xhYmxlOyByYXRoZXIsIGl0cyB2YWx1ZXMgd2lsbCBiZSBjcm9zcy1mYWRlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gaW50ZWdlciB6b29tcy4gSXQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi4iCiAgICAgIAl9LAogICAgICAJImNvbG9yLXJhbXAiOiB7CiAgICAgIAkJdHlwZTogInByb3BlcnR5LXR5cGUiLAogICAgICAJCWRvYzogIlByb3BlcnR5IHNob3VsZCBiZSBzcGVjaWZpZWQgdXNpbmcgYSBjb2xvciByYW1wIGZyb20gd2hpY2ggdGhlIG91dHB1dCBjb2xvciBjYW4gYmUgc2FtcGxlZCBiYXNlZCBvbiBhIHByb3BlcnR5IGNhbGN1bGF0aW9uLiIKICAgICAgCX0sCiAgICAgIAkiZGF0YS1jb25zdGFudCI6IHsKICAgICAgCQl0eXBlOiAicHJvcGVydHktdHlwZSIsCiAgICAgIAkJZG9jOiAiUHJvcGVydHkgaXMgaW50ZXJwb2xhYmxlIGJ1dCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLiIKICAgICAgCX0sCiAgICAgIAljb25zdGFudDogewogICAgICAJCXR5cGU6ICJwcm9wZXJ0eS10eXBlIiwKICAgICAgCQlkb2M6ICJQcm9wZXJ0eSBpcyBjb25zdGFudCBhY3Jvc3MgYWxsIHpvb20gbGV2ZWxzIGFuZCBwcm9wZXJ0eSB2YWx1ZXMuIgogICAgICAJfQogICAgICB9LAogICAgICAJcHJvbW90ZUlkOiBwcm9tb3RlSWQKICAgICAgfTsKCiAgICAgIC8vIE5vdGU6IFRoaXMgcmVnZXggbWF0Y2hlcyBldmVuIGludmFsaWQgSlNPTiBzdHJpbmdzLCBidXQgc2luY2Ugd2XigJlyZQogICAgICAvLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzCiAgICAgIC8vIGFyZSBwcmVzZW50ICh1bmxlc3MgdGhlIHVzZXIgc3VwcGxpZWQgYSB3ZWlyZCBgb3B0aW9ucy5pbmRlbnRgIGJ1dCBpbgogICAgICAvLyB0aGF0IGNhc2Ugd2UgZG9u4oCZdCBjYXJlIHNpbmNlIHRoZSBvdXRwdXQgd291bGQgYmUgaW52YWxpZCBhbnl3YXkpLgogICAgICB2YXIgc3RyaW5nT3JDaGFyID0gLygiKD86W15cXCJdfFxcLikqIil8WzosXS9nOwoKICAgICAgdmFyIGpzb25TdHJpbmdpZnlQcmV0dHlDb21wYWN0ID0gZnVuY3Rpb24gc3RyaW5naWZ5KHBhc3NlZE9iaiwgb3B0aW9ucykgewogICAgICAgIHZhciBpbmRlbnQsIG1heExlbmd0aCwgcmVwbGFjZXI7CgogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KAogICAgICAgICAgWzFdLAogICAgICAgICAgdW5kZWZpbmVkLAogICAgICAgICAgb3B0aW9ucy5pbmRlbnQgPT09IHVuZGVmaW5lZCA/IDIgOiBvcHRpb25zLmluZGVudAogICAgICAgICkuc2xpY2UoMiwgLTMpOwogICAgICAgIG1heExlbmd0aCA9CiAgICAgICAgICBpbmRlbnQgPT09ICIiCiAgICAgICAgICAgID8gSW5maW5pdHkKICAgICAgICAgICAgOiBvcHRpb25zLm1heExlbmd0aCA9PT0gdW5kZWZpbmVkCiAgICAgICAgICAgID8gODAKICAgICAgICAgICAgOiBvcHRpb25zLm1heExlbmd0aDsKICAgICAgICByZXBsYWNlciA9IG9wdGlvbnMucmVwbGFjZXI7CgogICAgICAgIHJldHVybiAoZnVuY3Rpb24gX3N0cmluZ2lmeShvYmosIGN1cnJlbnRJbmRlbnQsIHJlc2VydmVkKSB7CiAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmUKICAgICAgICAgIHZhciBlbmQsIGluZGV4LCBpdGVtcywga2V5LCBrZXlQYXJ0LCBrZXlzLCBsZW5ndGgsIG5leHRJbmRlbnQsIHByZXR0aWZpZWQsIHN0YXJ0LCBzdHJpbmcsIHZhbHVlOwoKICAgICAgICAgIGlmIChvYmogJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpOwogICAgICAgICAgfQoKICAgICAgICAgIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIpOwoKICAgICAgICAgIGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICByZXR1cm4gc3RyaW5nOwogICAgICAgICAgfQoKICAgICAgICAgIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWQ7CgogICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPD0gbGVuZ3RoKSB7CiAgICAgICAgICAgIHByZXR0aWZpZWQgPSBzdHJpbmcucmVwbGFjZShzdHJpbmdPckNoYXIsIGZ1bmN0aW9uKG1hdGNoLCBzdHJpbmdMaXRlcmFsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0xpdGVyYWwgfHwgbWF0Y2ggKyAiICI7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBpZiAocHJldHRpZmllZC5sZW5ndGggPD0gbGVuZ3RoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHByZXR0aWZpZWQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAocmVwbGFjZXIgIT0gbnVsbCkgewogICAgICAgICAgICBvYmogPSBKU09OLnBhcnNlKHN0cmluZyk7CiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAib2JqZWN0IiAmJiBvYmogIT09IG51bGwpIHsKICAgICAgICAgICAgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnQ7CiAgICAgICAgICAgIGl0ZW1zID0gW107CiAgICAgICAgICAgIGluZGV4ID0gMDsKCiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHsKICAgICAgICAgICAgICBzdGFydCA9ICJbIjsKICAgICAgICAgICAgICBlbmQgPSAiXSI7CiAgICAgICAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDsKICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHsKICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goCiAgICAgICAgICAgICAgICAgIF9zdHJpbmdpZnkob2JqW2luZGV4XSwgbmV4dEluZGVudCwgaW5kZXggPT09IGxlbmd0aCAtIDEgPyAwIDogMSkgfHwKICAgICAgICAgICAgICAgICAgICAibnVsbCIKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHN0YXJ0ID0gInsiOwogICAgICAgICAgICAgIGVuZCA9ICJ9IjsKICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMob2JqKTsKICAgICAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDsKICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHsKICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaW5kZXhdOwogICAgICAgICAgICAgICAga2V5UGFydCA9IEpTT04uc3RyaW5naWZ5KGtleSkgKyAiOiAiOwogICAgICAgICAgICAgICAgdmFsdWUgPSBfc3RyaW5naWZ5KAogICAgICAgICAgICAgICAgICBvYmpba2V5XSwKICAgICAgICAgICAgICAgICAgbmV4dEluZGVudCwKICAgICAgICAgICAgICAgICAga2V5UGFydC5sZW5ndGggKyAoaW5kZXggPT09IGxlbmd0aCAtIDEgPyAwIDogMSkKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGtleVBhcnQgKyB2YWx1ZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgIHJldHVybiBbc3RhcnQsIGluZGVudCArIGl0ZW1zLmpvaW4oIixcbiIgKyBuZXh0SW5kZW50KSwgZW5kXS5qb2luKAogICAgICAgICAgICAgICAgIlxuIiArIGN1cnJlbnRJbmRlbnQKICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHN0cmluZzsKICAgICAgICB9KShwYXNzZWRPYmosICIiLCAwKTsKICAgICAgfTsKCiAgICAgIGZ1bmN0aW9uIHNvcnRLZXlzQnkob2JqLCByZWZlcmVuY2UpIHsKICAgICAgICAgIHZhciByZXN1bHQgPSB7fTsKICAgICAgICAgIGZvciAodmFyIGtleSBpbiByZWZlcmVuY2UpIHsKICAgICAgICAgICAgICBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGtleSQxIGluIG9iaikgewogICAgICAgICAgICAgIGlmIChyZXN1bHRba2V5JDFdID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleSQxXSA9IG9ialtrZXkkMV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBmb3JtYXQoc3R5bGUsIHNwYWNlKSB7CiAgICAgICAgICBpZiAoc3BhY2UgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBzcGFjZSA9IDI7CiAgICAgICAgICBzdHlsZSA9IHNvcnRLZXlzQnkoc3R5bGUsIHY4LiRyb290KTsKICAgICAgICAgIGlmIChzdHlsZS5sYXllcnMpIHsKICAgICAgICAgICAgICBzdHlsZS5sYXllcnMgPSBzdHlsZS5sYXllcnMubWFwKGZ1bmN0aW9uIChsYXllcikgewogICAgICAgICAgICAgICAgICByZXR1cm4gc29ydEtleXNCeShsYXllciwgdjgubGF5ZXIpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnlQcmV0dHlDb21wYWN0KHN0eWxlLCB7IGluZGVudDogc3BhY2UgfSk7CiAgICAgIH0KCiAgICAgIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBjb21tb25qc0dsb2JhbCQxICE9PSAndW5kZWZpbmVkJyA/IGNvbW1vbmpzR2xvYmFsJDEgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307CgogICAgICBmdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKCkgewogICAgICAJdGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSByb2xsdXAtcGx1Z2luLWNvbW1vbmpzJyk7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHsKICAgICAgCXJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0czsKICAgICAgfQoKICAgICAgdmFyIHB1bnljb2RlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykgewogICAgICAoZnVuY3Rpb24ocm9vdCkgewoKICAgICAgCS8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi8KICAgICAgCXZhciBmcmVlRXhwb3J0cyA9ICBleHBvcnRzICYmCiAgICAgIAkJIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICAgICAgCXZhciBmcmVlTW9kdWxlID0gIG1vZHVsZSAmJgogICAgICAJCSFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwogICAgICAJdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWw7CiAgICAgIAlpZiAoCiAgICAgIAkJZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwKICAgICAgCQlmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fAogICAgICAJCWZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbAogICAgICAJKSB7CiAgICAgIAkJcm9vdCA9IGZyZWVHbG9iYWw7CiAgICAgIAl9CgogICAgICAJLyoqCiAgICAgIAkgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuCiAgICAgIAkgKiBAbmFtZSBwdW55Y29kZQogICAgICAJICogQHR5cGUgT2JqZWN0CiAgICAgIAkgKi8KICAgICAgCXZhciBwdW55Y29kZSwKCiAgICAgIAkvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovCiAgICAgIAltYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xCgogICAgICAJLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqLwogICAgICAJYmFzZSA9IDM2LAogICAgICAJdE1pbiA9IDEsCiAgICAgIAl0TWF4ID0gMjYsCiAgICAgIAlza2V3ID0gMzgsCiAgICAgIAlkYW1wID0gNzAwLAogICAgICAJaW5pdGlhbEJpYXMgPSA3MiwKICAgICAgCWluaXRpYWxOID0gMTI4LCAvLyAweDgwCiAgICAgIAlkZWxpbWl0ZXIgPSAnLScsIC8vICdceDJEJwoKICAgICAgCS8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovCiAgICAgIAlyZWdleFB1bnljb2RlID0gL154bi0tLywKICAgICAgCXJlZ2V4Tm9uQVNDSUkgPSAvW15ceDIwLVx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnMKICAgICAgCXJlZ2V4U2VwYXJhdG9ycyA9IC9bXHgyRVx1MzAwMlx1RkYwRVx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9ycwoKICAgICAgCS8qKiBFcnJvciBtZXNzYWdlcyAqLwogICAgICAJZXJyb3JzID0gewogICAgICAJCSdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsCiAgICAgIAkJJ25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJywKICAgICAgCQknaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0JwogICAgICAJfSwKCiAgICAgIAkvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovCiAgICAgIAliYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sCiAgICAgIAlmbG9vciA9IE1hdGguZmxvb3IsCiAgICAgIAlzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLAoKICAgICAgCS8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi8KICAgICAgCWtleTsKCiAgICAgIAkvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8KCiAgICAgIAkvKioKICAgICAgCSAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLgogICAgICAJICogQHByaXZhdGUKICAgICAgCSAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLgogICAgICAJICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLgogICAgICAJICovCiAgICAgIAlmdW5jdGlvbiBlcnJvcih0eXBlKSB7CiAgICAgIAkJdGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pOwogICAgICAJfQoKICAgICAgCS8qKgogICAgICAJICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uCiAgICAgIAkgKiBAcHJpdmF0ZQogICAgICAJICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci4KICAgICAgCSAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheQogICAgICAJICogaXRlbS4KICAgICAgCSAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi4KICAgICAgCSAqLwogICAgICAJZnVuY3Rpb24gbWFwKGFycmF5LCBmbikgewogICAgICAJCXZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICAgIAkJdmFyIHJlc3VsdCA9IFtdOwogICAgICAJCXdoaWxlIChsZW5ndGgtLSkgewogICAgICAJCQlyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pOwogICAgICAJCX0KICAgICAgCQlyZXR1cm4gcmVzdWx0OwogICAgICAJfQoKICAgICAgCS8qKgogICAgICAJICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsCiAgICAgIAkgKiBhZGRyZXNzZXMuCiAgICAgIAkgKiBAcHJpdmF0ZQogICAgICAJICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy4KICAgICAgCSAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeQogICAgICAJICogY2hhcmFjdGVyLgogICAgICAJICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sKICAgICAgCSAqIGZ1bmN0aW9uLgogICAgICAJICovCiAgICAgIAlmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikgewogICAgICAJCXZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpOwogICAgICAJCXZhciByZXN1bHQgPSAnJzsKICAgICAgCQlpZiAocGFydHMubGVuZ3RoID4gMSkgewogICAgICAJCQkvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlCiAgICAgIAkJCS8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuCiAgICAgIAkJCXJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnOwogICAgICAJCQlzdHJpbmcgPSBwYXJ0c1sxXTsKICAgICAgCQl9CiAgICAgIAkJLy8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LgogICAgICAJCXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1x4MkUnKTsKICAgICAgCQl2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7CiAgICAgIAkJdmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpOwogICAgICAJCXJldHVybiByZXN1bHQgKyBlbmNvZGVkOwogICAgICAJfQoKICAgICAgCS8qKgogICAgICAJICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZQogICAgICAJICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LAogICAgICAJICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2gKICAgICAgCSAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LAogICAgICAJICogbWF0Y2hpbmcgVVRGLTE2LgogICAgICAJICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgCiAgICAgIAkgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz4KICAgICAgCSAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyCiAgICAgIAkgKiBAbmFtZSBkZWNvZGUKICAgICAgCSAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuCiAgICAgIAkgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuCiAgICAgIAkgKi8KICAgICAgCWZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7CiAgICAgIAkJdmFyIG91dHB1dCA9IFtdLAogICAgICAJCSAgICBjb3VudGVyID0gMCwKICAgICAgCQkgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCwKICAgICAgCQkgICAgdmFsdWUsCiAgICAgIAkJICAgIGV4dHJhOwogICAgICAJCXdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7CiAgICAgIAkJCXZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTsKICAgICAgCQkJaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkgewogICAgICAJCQkJLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyCiAgICAgIAkJCQlleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7CiAgICAgIAkJCQlpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZQogICAgICAJCQkJCW91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7CiAgICAgIAkJCQl9IGVsc2UgewogICAgICAJCQkJCS8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0CiAgICAgIAkJCQkJLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyCiAgICAgIAkJCQkJb3V0cHV0LnB1c2godmFsdWUpOwogICAgICAJCQkJCWNvdW50ZXItLTsKICAgICAgCQkJCX0KICAgICAgCQkJfSBlbHNlIHsKICAgICAgCQkJCW91dHB1dC5wdXNoKHZhbHVlKTsKICAgICAgCQkJfQogICAgICAJCX0KICAgICAgCQlyZXR1cm4gb3V0cHV0OwogICAgICAJfQoKICAgICAgCS8qKgogICAgICAJICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLgogICAgICAJICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgCiAgICAgIAkgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMgogICAgICAJICogQG5hbWUgZW5jb2RlCiAgICAgIAkgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLgogICAgICAJICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLgogICAgICAJICovCiAgICAgIAlmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7CiAgICAgIAkJcmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHsKICAgICAgCQkJdmFyIG91dHB1dCA9ICcnOwogICAgICAJCQlpZiAodmFsdWUgPiAweEZGRkYpIHsKICAgICAgCQkJCXZhbHVlIC09IDB4MTAwMDA7CiAgICAgIAkJCQlvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTsKICAgICAgCQkJCXZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjsKICAgICAgCQkJfQogICAgICAJCQlvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTsKICAgICAgCQkJcmV0dXJuIG91dHB1dDsKICAgICAgCQl9KS5qb2luKCcnKTsKICAgICAgCX0KCiAgICAgIAkvKioKICAgICAgCSAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci4KICAgICAgCSAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYAogICAgICAJICogQHByaXZhdGUKICAgICAgCSAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS4KICAgICAgCSAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpbgogICAgICAJICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZgogICAgICAJICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuCiAgICAgIAkgKi8KICAgICAgCWZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHsKICAgICAgCQlpZiAoY29kZVBvaW50IC0gNDggPCAxMCkgewogICAgICAJCQlyZXR1cm4gY29kZVBvaW50IC0gMjI7CiAgICAgIAkJfQogICAgICAJCWlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7CiAgICAgIAkJCXJldHVybiBjb2RlUG9pbnQgLSA2NTsKICAgICAgCQl9CiAgICAgIAkJaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHsKICAgICAgCQkJcmV0dXJuIGNvZGVQb2ludCAtIDk3OwogICAgICAJCX0KICAgICAgCQlyZXR1cm4gYmFzZTsKICAgICAgCX0KCiAgICAgIAkvKioKICAgICAgCSAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC4KICAgICAgCSAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYAogICAgICAJICogQHByaXZhdGUKICAgICAgCSAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuCiAgICAgIAkgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvcgogICAgICAJICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2UKICAgICAgCSAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpcwogICAgICAJICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQKICAgICAgCSAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uCiAgICAgIAkgKi8KICAgICAgCWZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykgewogICAgICAJCS8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aCiAgICAgIAkJLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45CiAgICAgIAkJcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTsKICAgICAgCX0KCiAgICAgIAkvKioKICAgICAgCSAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuCiAgICAgIAkgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40CiAgICAgIAkgKiBAcHJpdmF0ZQogICAgICAJICovCiAgICAgIAlmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHsKICAgICAgCQl2YXIgayA9IDA7CiAgICAgIAkJZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTsKICAgICAgCQlkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7CiAgICAgIAkJZm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHsKICAgICAgCQkJZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pOwogICAgICAJCX0KICAgICAgCQlyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTsKICAgICAgCX0KCiAgICAgIAkvKioKICAgICAgCSAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlCiAgICAgIAkgKiBzeW1ib2xzLgogICAgICAJICogQG1lbWJlck9mIHB1bnljb2RlCiAgICAgIAkgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuCiAgICAgIAkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuCiAgICAgIAkgKi8KICAgICAgCWZ1bmN0aW9uIGRlY29kZShpbnB1dCkgewogICAgICAJCS8vIERvbid0IHVzZSBVQ1MtMgogICAgICAJCXZhciBvdXRwdXQgPSBbXSwKICAgICAgCQkgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsCiAgICAgIAkJICAgIG91dCwKICAgICAgCQkgICAgaSA9IDAsCiAgICAgIAkJICAgIG4gPSBpbml0aWFsTiwKICAgICAgCQkgICAgYmlhcyA9IGluaXRpYWxCaWFzLAogICAgICAJCSAgICBiYXNpYywKICAgICAgCQkgICAgaiwKICAgICAgCQkgICAgaW5kZXgsCiAgICAgIAkJICAgIG9sZGksCiAgICAgIAkJICAgIHcsCiAgICAgIAkJICAgIGssCiAgICAgIAkJICAgIGRpZ2l0LAogICAgICAJCSAgICB0LAogICAgICAJCSAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi8KICAgICAgCQkgICAgYmFzZU1pbnVzVDsKCiAgICAgIAkJLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlCiAgICAgIAkJLy8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHkKICAgICAgCQkvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC4KCiAgICAgIAkJYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpOwogICAgICAJCWlmIChiYXNpYyA8IDApIHsKICAgICAgCQkJYmFzaWMgPSAwOwogICAgICAJCX0KCiAgICAgIAkJZm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHsKICAgICAgCQkJLy8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50CiAgICAgIAkJCWlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHsKICAgICAgCQkJCWVycm9yKCdub3QtYmFzaWMnKTsKICAgICAgCQkJfQogICAgICAJCQlvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTsKICAgICAgCQl9CgogICAgICAJCS8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGUKICAgICAgCQkvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLgoKICAgICAgCQlmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykgewoKICAgICAgCQkJLy8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLgogICAgICAJCQkvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsCiAgICAgIAkJCS8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyCiAgICAgIAkJCS8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nCiAgICAgIAkJCS8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuCiAgICAgIAkJCWZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHsKCiAgICAgIAkJCQlpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHsKICAgICAgCQkJCQllcnJvcignaW52YWxpZC1pbnB1dCcpOwogICAgICAJCQkJfQoKICAgICAgCQkJCWRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpOwoKICAgICAgCQkJCWlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHsKICAgICAgCQkJCQllcnJvcignb3ZlcmZsb3cnKTsKICAgICAgCQkJCX0KCiAgICAgIAkJCQlpICs9IGRpZ2l0ICogdzsKICAgICAgCQkJCXQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpOwoKICAgICAgCQkJCWlmIChkaWdpdCA8IHQpIHsKICAgICAgCQkJCQlicmVhazsKICAgICAgCQkJCX0KCiAgICAgIAkJCQliYXNlTWludXNUID0gYmFzZSAtIHQ7CiAgICAgIAkJCQlpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7CiAgICAgIAkJCQkJZXJyb3IoJ292ZXJmbG93Jyk7CiAgICAgIAkJCQl9CgogICAgICAJCQkJdyAqPSBiYXNlTWludXNUOwoKICAgICAgCQkJfQoKICAgICAgCQkJb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7CiAgICAgIAkJCWJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApOwoKICAgICAgCQkJLy8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCwKICAgICAgCQkJLy8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzoKICAgICAgCQkJaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikgewogICAgICAJCQkJZXJyb3IoJ292ZXJmbG93Jyk7CiAgICAgIAkJCX0KCiAgICAgIAkJCW4gKz0gZmxvb3IoaSAvIG91dCk7CiAgICAgIAkJCWkgJT0gb3V0OwoKICAgICAgCQkJLy8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dAogICAgICAJCQlvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7CgogICAgICAJCX0KCiAgICAgIAkJcmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTsKICAgICAgCX0KCiAgICAgIAkvKioKICAgICAgCSAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhCiAgICAgIAkgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLgogICAgICAJICogQG1lbWJlck9mIHB1bnljb2RlCiAgICAgIAkgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuCiAgICAgIAkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuCiAgICAgIAkgKi8KICAgICAgCWZ1bmN0aW9uIGVuY29kZShpbnB1dCkgewogICAgICAJCXZhciBuLAogICAgICAJCSAgICBkZWx0YSwKICAgICAgCQkgICAgaGFuZGxlZENQQ291bnQsCiAgICAgIAkJICAgIGJhc2ljTGVuZ3RoLAogICAgICAJCSAgICBiaWFzLAogICAgICAJCSAgICBqLAogICAgICAJCSAgICBtLAogICAgICAJCSAgICBxLAogICAgICAJCSAgICBrLAogICAgICAJCSAgICB0LAogICAgICAJCSAgICBjdXJyZW50VmFsdWUsCiAgICAgIAkJICAgIG91dHB1dCA9IFtdLAogICAgICAJCSAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqLwogICAgICAJCSAgICBpbnB1dExlbmd0aCwKICAgICAgCQkgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovCiAgICAgIAkJICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSwKICAgICAgCQkgICAgYmFzZU1pbnVzVCwKICAgICAgCQkgICAgcU1pbnVzVDsKCiAgICAgIAkJLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZQogICAgICAJCWlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7CgogICAgICAJCS8vIENhY2hlIHRoZSBsZW5ndGgKICAgICAgCQlpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDsKCiAgICAgIAkJLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUKICAgICAgCQluID0gaW5pdGlhbE47CiAgICAgIAkJZGVsdGEgPSAwOwogICAgICAJCWJpYXMgPSBpbml0aWFsQmlhczsKCiAgICAgIAkJLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cwogICAgICAJCWZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CiAgICAgIAkJCWN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdOwogICAgICAJCQlpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkgewogICAgICAJCQkJb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpOwogICAgICAJCQl9CiAgICAgIAkJfQoKICAgICAgCQloYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDsKCiAgICAgIAkJLy8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7CiAgICAgIAkJLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLgoKICAgICAgCQkvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXIKICAgICAgCQlpZiAoYmFzaWNMZW5ndGgpIHsKICAgICAgCQkJb3V0cHV0LnB1c2goZGVsaW1pdGVyKTsKICAgICAgCQl9CgogICAgICAJCS8vIE1haW4gZW5jb2RpbmcgbG9vcDoKICAgICAgCQl3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkgewoKICAgICAgCQkJLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dAogICAgICAJCQkvLyBsYXJnZXIgb25lOgogICAgICAJCQlmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikgewogICAgICAJCQkJY3VycmVudFZhbHVlID0gaW5wdXRbal07CiAgICAgIAkJCQlpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkgewogICAgICAJCQkJCW0gPSBjdXJyZW50VmFsdWU7CiAgICAgIAkJCQl9CiAgICAgIAkJCX0KCiAgICAgIAkJCS8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPiwKICAgICAgCQkJLy8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cKICAgICAgCQkJaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxOwogICAgICAJCQlpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkgewogICAgICAJCQkJZXJyb3IoJ292ZXJmbG93Jyk7CiAgICAgIAkJCX0KCiAgICAgIAkJCWRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7CiAgICAgIAkJCW4gPSBtOwoKICAgICAgCQkJZm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHsKICAgICAgCQkJCWN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdOwoKICAgICAgCQkJCWlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHsKICAgICAgCQkJCQllcnJvcignb3ZlcmZsb3cnKTsKICAgICAgCQkJCX0KCiAgICAgIAkJCQlpZiAoY3VycmVudFZhbHVlID09IG4pIHsKICAgICAgCQkJCQkvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlcgogICAgICAJCQkJCWZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHsKICAgICAgCQkJCQkJdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7CiAgICAgIAkJCQkJCWlmIChxIDwgdCkgewogICAgICAJCQkJCQkJYnJlYWs7CiAgICAgIAkJCQkJCX0KICAgICAgCQkJCQkJcU1pbnVzVCA9IHEgLSB0OwogICAgICAJCQkJCQliYXNlTWludXNUID0gYmFzZSAtIHQ7CiAgICAgIAkJCQkJCW91dHB1dC5wdXNoKAogICAgICAJCQkJCQkJc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKQogICAgICAJCQkJCQkpOwogICAgICAJCQkJCQlxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpOwogICAgICAJCQkJCX0KCiAgICAgIAkJCQkJb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpOwogICAgICAJCQkJCWJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7CiAgICAgIAkJCQkJZGVsdGEgPSAwOwogICAgICAJCQkJCSsraGFuZGxlZENQQ291bnQ7CiAgICAgIAkJCQl9CiAgICAgIAkJCX0KCiAgICAgIAkJCSsrZGVsdGE7CiAgICAgIAkJCSsrbjsKCiAgICAgIAkJfQogICAgICAJCXJldHVybiBvdXRwdXQuam9pbignJyk7CiAgICAgIAl9CgogICAgICAJLyoqCiAgICAgIAkgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzCiAgICAgIAkgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuCiAgICAgIAkgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW4KICAgICAgCSAqIGNvbnZlcnRlZCB0byBVbmljb2RlLgogICAgICAJICogQG1lbWJlck9mIHB1bnljb2RlCiAgICAgIAkgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvCiAgICAgIAkgKiBjb252ZXJ0IHRvIFVuaWNvZGUuCiAgICAgIAkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGUKICAgICAgCSAqIHN0cmluZy4KICAgICAgCSAqLwogICAgICAJZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7CiAgICAgIAkJcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7CiAgICAgIAkJCXJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKQogICAgICAJCQkJPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpCiAgICAgIAkJCQk6IHN0cmluZzsKICAgICAgCQl9KTsKICAgICAgCX0KCiAgICAgIAkvKioKICAgICAgCSAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0bwogICAgICAJICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsCiAgICAgIAkgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW4KICAgICAgCSAqIEFTQ0lJLgogICAgICAJICogQG1lbWJlck9mIHB1bnljb2RlCiAgICAgIAkgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYQogICAgICAJICogVW5pY29kZSBzdHJpbmcuCiAgICAgIAkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yCiAgICAgIAkgKiBlbWFpbCBhZGRyZXNzLgogICAgICAJICovCiAgICAgIAlmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7CiAgICAgIAkJcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7CiAgICAgIAkJCXJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKQogICAgICAJCQkJPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKQogICAgICAJCQkJOiBzdHJpbmc7CiAgICAgIAkJfSk7CiAgICAgIAl9CgogICAgICAJLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovCgogICAgICAJLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqLwogICAgICAJcHVueWNvZGUgPSB7CiAgICAgIAkJLyoqCiAgICAgIAkJICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLgogICAgICAJCSAqIEBtZW1iZXJPZiBwdW55Y29kZQogICAgICAJCSAqIEB0eXBlIFN0cmluZwogICAgICAJCSAqLwogICAgICAJCSd2ZXJzaW9uJzogJzEuMy4yJywKICAgICAgCQkvKioKICAgICAgCQkgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlcgogICAgICAJCSAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suCiAgICAgIAkJICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+CiAgICAgIAkJICogQG1lbWJlck9mIHB1bnljb2RlCiAgICAgIAkJICogQHR5cGUgT2JqZWN0CiAgICAgIAkJICovCiAgICAgIAkJJ3VjczInOiB7CiAgICAgIAkJCSdkZWNvZGUnOiB1Y3MyZGVjb2RlLAogICAgICAJCQknZW5jb2RlJzogdWNzMmVuY29kZQogICAgICAJCX0sCiAgICAgIAkJJ2RlY29kZSc6IGRlY29kZSwKICAgICAgCQknZW5jb2RlJzogZW5jb2RlLAogICAgICAJCSd0b0FTQ0lJJzogdG9BU0NJSSwKICAgICAgCQkndG9Vbmljb2RlJzogdG9Vbmljb2RlCiAgICAgIAl9OwoKICAgICAgCS8qKiBFeHBvc2UgYHB1bnljb2RlYCAqLwogICAgICAJLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zCiAgICAgIAkvLyBsaWtlIHRoZSBmb2xsb3dpbmc6CiAgICAgIAlpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkgewogICAgICAJCWlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wKwogICAgICAJCQlmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTsKICAgICAgCQl9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLQogICAgICAJCQlmb3IgKGtleSBpbiBwdW55Y29kZSkgewogICAgICAJCQkJcHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pOwogICAgICAJCQl9CiAgICAgIAkJfQogICAgICAJfSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlcgogICAgICAJCXJvb3QucHVueWNvZGUgPSBwdW55Y29kZTsKICAgICAgCX0KCiAgICAgIH0oY29tbW9uanNHbG9iYWwpKTsKICAgICAgfSk7CgogICAgICB2YXIgdXRpbCA9IHsKICAgICAgICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7CiAgICAgICAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnOwogICAgICAgIH0sCiAgICAgICAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykgewogICAgICAgICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7CiAgICAgICAgfSwKICAgICAgICBpc051bGw6IGZ1bmN0aW9uKGFyZykgewogICAgICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbDsKICAgICAgICB9LAogICAgICAgIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHsKICAgICAgICAgIHJldHVybiBhcmcgPT0gbnVsbDsKICAgICAgICB9CiAgICAgIH07CgogICAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KCiAgICAgIC8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmcKICAgICAgLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuCiAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3CiAgICAgIGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkgewogICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsKICAgICAgfQoKICAgICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7CiAgICAgICAgc2VwID0gc2VwIHx8ICcmJzsKICAgICAgICBlcSA9IGVxIHx8ICc9JzsKICAgICAgICB2YXIgb2JqID0ge307CgogICAgICAgIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CgogICAgICAgIHZhciByZWdleHAgPSAvXCsvZzsKICAgICAgICBxcyA9IHFzLnNwbGl0KHNlcCk7CgogICAgICAgIHZhciBtYXhLZXlzID0gMTAwMDsKICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykgewogICAgICAgICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5czsKICAgICAgICB9CgogICAgICAgIHZhciBsZW4gPSBxcy5sZW5ndGg7CiAgICAgICAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50CiAgICAgICAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHsKICAgICAgICAgIGxlbiA9IG1heEtleXM7CiAgICAgICAgfQoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksCiAgICAgICAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSwKICAgICAgICAgICAgICBrc3RyLCB2c3RyLCBrLCB2OwoKICAgICAgICAgIGlmIChpZHggPj0gMCkgewogICAgICAgICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTsKICAgICAgICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAga3N0ciA9IHg7CiAgICAgICAgICAgIHZzdHIgPSAnJzsKICAgICAgICAgIH0KCiAgICAgICAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpOwogICAgICAgICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTsKCiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHsKICAgICAgICAgICAgb2JqW2tdID0gdjsKICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7CiAgICAgICAgICAgIG9ialtrXS5wdXNoKHYpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gb2JqOwogICAgICB9OwoKICAgICAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCgogICAgICB2YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikgewogICAgICAgIHN3aXRjaCAodHlwZW9mIHYpIHsKICAgICAgICAgIGNhc2UgJ3N0cmluZyc6CiAgICAgICAgICAgIHJldHVybiB2OwoKICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOgogICAgICAgICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7CgogICAgICAgICAgY2FzZSAnbnVtYmVyJzoKICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnOwoKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiAnJzsKICAgICAgICB9CiAgICAgIH07CgogICAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7CiAgICAgICAgc2VwID0gc2VwIHx8ICcmJzsKICAgICAgICBlcSA9IGVxIHx8ICc9JzsKICAgICAgICBpZiAob2JqID09PSBudWxsKSB7CiAgICAgICAgICBvYmogPSB1bmRlZmluZWQ7CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7CiAgICAgICAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7CiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHsKICAgICAgICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7CiAgICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTsKICAgICAgICAgICAgICB9KS5qb2luKHNlcCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSkuam9pbihzZXApOwoKICAgICAgICB9CgogICAgICAgIGlmICghbmFtZSkgeyByZXR1cm4gJyc7IH0KICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArCiAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7CiAgICAgIH07CgogICAgICB2YXIgcXVlcnlzdHJpbmcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7CgogICAgICBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSBkZWNvZGU7CiAgICAgIGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBlbmNvZGU7CiAgICAgIH0pOwogICAgICBxdWVyeXN0cmluZy5kZWNvZGU7CiAgICAgIHF1ZXJ5c3RyaW5nLnBhcnNlOwogICAgICBxdWVyeXN0cmluZy5lbmNvZGU7CiAgICAgIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeTsKCiAgICAgIHZhciBwYXJzZSA9IHVybFBhcnNlOwogICAgICB2YXIgcmVzb2x2ZSA9IHVybFJlc29sdmU7CiAgICAgIHZhciByZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDsKICAgICAgdmFyIGZvcm1hdCQxID0gdXJsRm9ybWF0OwoKICAgICAgdmFyIFVybF8xID0gVXJsOwoKICAgICAgZnVuY3Rpb24gVXJsKCkgewogICAgICAgIHRoaXMucHJvdG9jb2wgPSBudWxsOwogICAgICAgIHRoaXMuc2xhc2hlcyA9IG51bGw7CiAgICAgICAgdGhpcy5hdXRoID0gbnVsbDsKICAgICAgICB0aGlzLmhvc3QgPSBudWxsOwogICAgICAgIHRoaXMucG9ydCA9IG51bGw7CiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IG51bGw7CiAgICAgICAgdGhpcy5oYXNoID0gbnVsbDsKICAgICAgICB0aGlzLnNlYXJjaCA9IG51bGw7CiAgICAgICAgdGhpcy5xdWVyeSA9IG51bGw7CiAgICAgICAgdGhpcy5wYXRobmFtZSA9IG51bGw7CiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDsKICAgICAgICB0aGlzLmhyZWYgPSBudWxsOwogICAgICB9CgogICAgICAvLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTYKCiAgICAgIC8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlCiAgICAgIC8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLgogICAgICB2YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSwKICAgICAgICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLywKCiAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMCiAgICAgICAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFwvXC8/KD8hXC8pW15cP1xzXSopKFw/W15cc10qKT8kLywKCiAgICAgICAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLgogICAgICAgICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS4KICAgICAgICAgIGRlbGltcyA9IFsnPCcsICc+JywgJyInLCAnYCcsICcgJywgJ1xyJywgJ1xuJywgJ1x0J10sCgogICAgICAgICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy4KICAgICAgICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksCgogICAgICAgICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLgogICAgICAgICAgYXV0b0VzY2FwZSA9IFsnXCcnXS5jb25jYXQodW53aXNlKSwKICAgICAgICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuCiAgICAgICAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlCiAgICAgICAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGgKICAgICAgICAgIC8vIHRoZW0uCiAgICAgICAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSwKICAgICAgICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSwKICAgICAgICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LAogICAgICAgICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLywKICAgICAgICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLAogICAgICAgICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93ICJ1bnNhZmUiIGFuZCAidW53aXNlIiBjaGFycy4KICAgICAgICAgIHVuc2FmZVByb3RvY29sID0gewogICAgICAgICAgICAnamF2YXNjcmlwdCc6IHRydWUsCiAgICAgICAgICAgICdqYXZhc2NyaXB0Oic6IHRydWUKICAgICAgICAgIH0sCiAgICAgICAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuCiAgICAgICAgICBob3N0bGVzc1Byb3RvY29sID0gewogICAgICAgICAgICAnamF2YXNjcmlwdCc6IHRydWUsCiAgICAgICAgICAgICdqYXZhc2NyaXB0Oic6IHRydWUKICAgICAgICAgIH0sCiAgICAgICAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC4KICAgICAgICAgIHNsYXNoZWRQcm90b2NvbCA9IHsKICAgICAgICAgICAgJ2h0dHAnOiB0cnVlLAogICAgICAgICAgICAnaHR0cHMnOiB0cnVlLAogICAgICAgICAgICAnZnRwJzogdHJ1ZSwKICAgICAgICAgICAgJ2dvcGhlcic6IHRydWUsCiAgICAgICAgICAgICdmaWxlJzogdHJ1ZSwKICAgICAgICAgICAgJ2h0dHA6JzogdHJ1ZSwKICAgICAgICAgICAgJ2h0dHBzOic6IHRydWUsCiAgICAgICAgICAgICdmdHA6JzogdHJ1ZSwKICAgICAgICAgICAgJ2dvcGhlcjonOiB0cnVlLAogICAgICAgICAgICAnZmlsZTonOiB0cnVlCiAgICAgICAgICB9OwoKICAgICAgZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkgewogICAgICAgIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9CgogICAgICAgIHZhciB1ID0gbmV3IFVybDsKICAgICAgICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpOwogICAgICAgIHJldHVybiB1OwogICAgICB9CgogICAgICBVcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkgewogICAgICAgIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90ICIgKyB0eXBlb2YgdXJsKTsKICAgICAgICB9CgogICAgICAgIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLgogICAgICAgIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlcwogICAgICAgIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2CiAgICAgICAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLAogICAgICAgICAgICBzcGxpdHRlciA9CiAgICAgICAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLAogICAgICAgICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLAogICAgICAgICAgICBzbGFzaFJlZ2V4ID0gL1xcL2c7CiAgICAgICAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTsKICAgICAgICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7CgogICAgICAgIHZhciByZXN0ID0gdXJsOwoKICAgICAgICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLgogICAgICAgIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlICIgIGh0dHA6Ly9mb28uY29tICBcbiIKICAgICAgICByZXN0ID0gcmVzdC50cmltKCk7CgogICAgICAgIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cAogICAgICAgICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpOwogICAgICAgICAgaWYgKHNpbXBsZVBhdGgpIHsKICAgICAgICAgICAgdGhpcy5wYXRoID0gcmVzdDsKICAgICAgICAgICAgdGhpcy5ocmVmID0gcmVzdDsKICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07CiAgICAgICAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7CiAgICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdOwogICAgICAgICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7CiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykgewogICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gJyc7CiAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHt9OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7CiAgICAgICAgaWYgKHByb3RvKSB7CiAgICAgICAgICBwcm90byA9IHByb3RvWzBdOwogICAgICAgICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87CiAgICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTsKICAgICAgICB9CgogICAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0CiAgICAgICAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybAogICAgICAgIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3MKICAgICAgICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy4KICAgICAgICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlwvXC9bXkBcL10rQFteQFwvXSsvKSkgewogICAgICAgICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJzsKICAgICAgICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7CiAgICAgICAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTsKICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiYKICAgICAgICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHsKCiAgICAgICAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuCiAgICAgICAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LgogICAgICAgICAgLy8KICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWQKICAgICAgICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyCiAgICAgICAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLgogICAgICAgICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLgogICAgICAgICAgLy8KICAgICAgICAgIC8vIGV4OgogICAgICAgICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmMKICAgICAgICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGMKCiAgICAgICAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuCiAgICAgICAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LgoKICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnMKICAgICAgICAgIHZhciBob3N0RW5kID0gLTE7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7CiAgICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkKICAgICAgICAgICAgICB7IGhvc3RFbmQgPSBoZWM7IH0KICAgICAgICAgIH0KCiAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGUKICAgICAgICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLgogICAgICAgICAgdmFyIGF1dGgsIGF0U2lnbjsKICAgICAgICAgIGlmIChob3N0RW5kID09PSAtMSkgewogICAgICAgICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLgogICAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uCiAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkCiAgICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC4KICAgICAgICAgIC8vIFB1bGwgdGhhdCBvZmYuCiAgICAgICAgICBpZiAoYXRTaWduICE9PSAtMSkgewogICAgICAgICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pOwogICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTsKICAgICAgICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXIKICAgICAgICAgIGhvc3RFbmQgPSAtMTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTsKICAgICAgICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKQogICAgICAgICAgICAgIHsgaG9zdEVuZCA9IGhlYzsgfQogICAgICAgICAgfQogICAgICAgICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LgogICAgICAgICAgaWYgKGhvc3RFbmQgPT09IC0xKQogICAgICAgICAgICB7IGhvc3RFbmQgPSByZXN0Lmxlbmd0aDsgfQoKICAgICAgICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7CiAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTsKCiAgICAgICAgICAvLyBwdWxsIG91dCBwb3J0LgogICAgICAgICAgdGhpcy5wYXJzZUhvc3QoKTsKCiAgICAgICAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLAogICAgICAgICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC4KICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnOwoKICAgICAgICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdCiAgICAgICAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy4KICAgICAgICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiYKICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJzsKCiAgICAgICAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS4KICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7CiAgICAgICAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cLi8pOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTsKICAgICAgICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH0KICAgICAgICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHsKICAgICAgICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7CiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHsKICAgICAgICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXIKICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90CiAgICAgICAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZwogICAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seQogICAgICAgICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7CiAgICAgICAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpOwogICAgICAgICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7CiAgICAgICAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTsKICAgICAgICAgICAgICAgICAgaWYgKGJpdCkgewogICAgICAgICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pOwogICAgICAgICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikgewogICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gJyc7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLgogICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7CiAgICAgICAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiAiZG9tYWluIi4KICAgICAgICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdAogICAgICAgICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmCiAgICAgICAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuCiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpOwogICAgICAgICAgfQoKICAgICAgICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7CiAgICAgICAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7CiAgICAgICAgICB0aGlzLmhvc3QgPSBoICsgcDsKICAgICAgICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7CgogICAgICAgICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZQogICAgICAgICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2gKICAgICAgICAgIGlmIChpcHY2SG9zdG5hbWUpIHsKICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7CiAgICAgICAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHsKICAgICAgICAgICAgICByZXN0ID0gJy8nICsgcmVzdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuCiAgICAgICAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLgogICAgICAgIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHsKCiAgICAgICAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgImF1dG9Fc2NhcGUiIGNoYXJzIGdldAogICAgICAgICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5CiAgICAgICAgICAvLyBuZWVkIHRvIGJlLgogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldOwogICAgICAgICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpCiAgICAgICAgICAgICAgeyBjb250aW51ZTsgfQogICAgICAgICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTsKICAgICAgICAgICAgaWYgKGVzYyA9PT0gYWUpIHsKICAgICAgICAgICAgICBlc2MgPSBlc2NhcGUoYWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7CiAgICAgICAgICB9CiAgICAgICAgfQoKCiAgICAgICAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC4KICAgICAgICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpOwogICAgICAgIGlmIChoYXNoICE9PSAtMSkgewogICAgICAgICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLgogICAgICAgICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7CiAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTsKICAgICAgICB9CiAgICAgICAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7CiAgICAgICAgaWYgKHFtICE9PSAtMSkgewogICAgICAgICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7CiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTsKICAgICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7CiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTsKICAgICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHsKICAgICAgICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkCiAgICAgICAgICB0aGlzLnNlYXJjaCA9ICcnOwogICAgICAgICAgdGhpcy5xdWVyeSA9IHt9OwogICAgICAgIH0KICAgICAgICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfQogICAgICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiYKICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkgewogICAgICAgICAgdGhpcy5wYXRobmFtZSA9ICcvJzsKICAgICAgICB9CgogICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3QKICAgICAgICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkgewogICAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnOwogICAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJzsKICAgICAgICAgIHRoaXMucGF0aCA9IHAgKyBzOwogICAgICAgIH0KCiAgICAgICAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuCiAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKCiAgICAgIC8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmcKICAgICAgZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikgewogICAgICAgIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuCiAgICAgICAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC4KICAgICAgICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzCiAgICAgICAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy4KICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSB7IG9iaiA9IHVybFBhcnNlKG9iaik7IH0KICAgICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSB7IHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7IH0KICAgICAgICByZXR1cm4gb2JqLmZvcm1hdCgpOwogICAgICB9CgogICAgICBVcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnOwogICAgICAgIGlmIChhdXRoKSB7CiAgICAgICAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpOwogICAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7CiAgICAgICAgICBhdXRoICs9ICdAJzsKICAgICAgICB9CgogICAgICAgIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsCiAgICAgICAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJywKICAgICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJywKICAgICAgICAgICAgaG9zdCA9IGZhbHNlLAogICAgICAgICAgICBxdWVyeSA9ICcnOwoKICAgICAgICBpZiAodGhpcy5ob3N0KSB7CiAgICAgICAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDsKICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHsKICAgICAgICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/CiAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA6CiAgICAgICAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7CiAgICAgICAgICBpZiAodGhpcy5wb3J0KSB7CiAgICAgICAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0OwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMucXVlcnkgJiYKICAgICAgICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJgogICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHsKICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpOwogICAgICAgIH0KCiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJzsKCiAgICAgICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgeyBwcm90b2NvbCArPSAnOic7IH0KCiAgICAgICAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuCiAgICAgICAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC4KICAgICAgICBpZiAodGhpcy5zbGFzaGVzIHx8CiAgICAgICAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHsKICAgICAgICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpOwogICAgICAgICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7IHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7IH0KICAgICAgICB9IGVsc2UgaWYgKCFob3N0KSB7CiAgICAgICAgICBob3N0ID0gJyc7CiAgICAgICAgfQoKICAgICAgICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7IGhhc2ggPSAnIycgKyBoYXNoOyB9CiAgICAgICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHsgc2VhcmNoID0gJz8nICsgc2VhcmNoOyB9CgogICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkgewogICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7CiAgICAgICAgfSk7CiAgICAgICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7CgogICAgICAgIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7CiAgICAgIH07CgogICAgICBmdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHsKICAgICAgICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7CiAgICAgIH0KCiAgICAgIFVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7CiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTsKICAgICAgfTsKCiAgICAgIGZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkgewogICAgICAgIGlmICghc291cmNlKSB7IHJldHVybiByZWxhdGl2ZTsgfQogICAgICAgIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTsKICAgICAgfQoKICAgICAgVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHsKICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHsKICAgICAgICAgIHZhciByZWwgPSBuZXcgVXJsKCk7CiAgICAgICAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTsKICAgICAgICAgIHJlbGF0aXZlID0gcmVsOwogICAgICAgIH0KCiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTsKICAgICAgICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTsKICAgICAgICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7CiAgICAgICAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTsKICAgICAgICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07CiAgICAgICAgfQoKICAgICAgICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC4KICAgICAgICAvLyBldmVuIGhyZWY9IiIgd2lsbCByZW1vdmUgaXQuCiAgICAgICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoOwoKICAgICAgICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuCiAgICAgICAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7CiAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQoKICAgICAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC4KICAgICAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHsKICAgICAgICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmUKICAgICAgICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTsKICAgICAgICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHsKICAgICAgICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107CiAgICAgICAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKQogICAgICAgICAgICAgIHsgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07IH0KICAgICAgICAgIH0KCiAgICAgICAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbQogICAgICAgICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmCiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHsKICAgICAgICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7CiAgICAgICAgICB9CgogICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KCiAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHsKICAgICAgICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmcKICAgICAgICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5ncwogICAgICAgICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsCiAgICAgICAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aAogICAgICAgICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLgogICAgICAgICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCwKICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLgogICAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLgogICAgICAgICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7CiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpOwogICAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHsKICAgICAgICAgICAgICB2YXIgayA9IGtleXNbdl07CiAgICAgICAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9CgogICAgICAgICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7CiAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7CiAgICAgICAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpOwogICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSl7IH0KICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSB7IHJlbGF0aXZlLmhvc3QgPSAnJzsgfQogICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSB7IHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7IH0KICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSB7IHJlbFBhdGgudW5zaGlmdCgnJyk7IH0KICAgICAgICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgeyByZWxQYXRoLnVuc2hpZnQoJycpOyB9CiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoOwogICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7CiAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7CiAgICAgICAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7CiAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0OwogICAgICAgICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0OwogICAgICAgICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3QKICAgICAgICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkgewogICAgICAgICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJzsKICAgICAgICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnOwogICAgICAgICAgICByZXN1bHQucGF0aCA9IHAgKyBzOwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzOwogICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KCiAgICAgICAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLAogICAgICAgICAgICBpc1JlbEFicyA9ICgKICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHwKICAgICAgICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nCiAgICAgICAgICAgICksCiAgICAgICAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHwKICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSwKICAgICAgICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsCiAgICAgICAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sCiAgICAgICAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLAogICAgICAgICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdOwoKICAgICAgICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlCiAgICAgICAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZQogICAgICAgIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS4KICAgICAgICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LgogICAgICAgIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLgogICAgICAgIGlmIChwc3ljaG90aWMpIHsKICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnOwogICAgICAgICAgcmVzdWx0LnBvcnQgPSBudWxsOwogICAgICAgICAgaWYgKHJlc3VsdC5ob3N0KSB7CiAgICAgICAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgeyBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7IH0KICAgICAgICAgICAgZWxzZSB7IHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7IH0KICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5ob3N0ID0gJyc7CiAgICAgICAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHsKICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsOwogICAgICAgICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDsKICAgICAgICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHsKICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHsgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7IH0KICAgICAgICAgICAgICBlbHNlIHsgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpOyB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGlzUmVsQWJzKSB7CiAgICAgICAgICAvLyBpdCdzIGFic29sdXRlLgogICAgICAgICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgPwogICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7CiAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTsKICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7CiAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTsKICAgICAgICAgIHNyY1BhdGggPSByZWxQYXRoOwogICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuCiAgICAgICAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkgewogICAgICAgICAgLy8gaXQncyByZWxhdGl2ZQogICAgICAgICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuCiAgICAgICAgICBpZiAoIXNyY1BhdGgpIHsgc3JjUGF0aCA9IFtdOyB9CiAgICAgICAgICBzcmNQYXRoLnBvcCgpOwogICAgICAgICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpOwogICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDsKICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5OwogICAgICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkgewogICAgICAgICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLgogICAgICAgICAgLy8gbGlrZSBocmVmPSc/Zm9vJy4KICAgICAgICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFucwogICAgICAgICAgaWYgKHBzeWNob3RpYykgewogICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTsKICAgICAgICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdAogICAgICAgICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2UKICAgICAgICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJykKICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8KICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7CiAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7CiAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7CiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7CiAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTsKICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3QKICAgICAgICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHsKICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICsKICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQoKICAgICAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7CiAgICAgICAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuCiAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLgogICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDsKICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3QKICAgICAgICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7CiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpOwogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CgogICAgICAgIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLgogICAgICAgIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LAogICAgICAgIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guCiAgICAgICAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTsKICAgICAgICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9ICgKICAgICAgICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJgogICAgICAgICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTsKCiAgICAgICAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpcgogICAgICAgIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwCiAgICAgICAgdmFyIHVwID0gMDsKICAgICAgICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICBsYXN0ID0gc3JjUGF0aFtpXTsKICAgICAgICAgIGlmIChsYXN0ID09PSAnLicpIHsKICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7CiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHsKICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7CiAgICAgICAgICAgIHVwKys7CiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7CiAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpOwogICAgICAgICAgICB1cC0tOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4ucwogICAgICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykgewogICAgICAgICAgZm9yICg7IHVwLS07IHVwKSB7CiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmCiAgICAgICAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkgewogICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcnKTsKICAgICAgICB9CgogICAgICAgIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7CiAgICAgICAgICBzcmNQYXRoLnB1c2goJycpOwogICAgICAgIH0KCiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fAogICAgICAgICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTsKCiAgICAgICAgLy8gcHV0IHRoZSBob3N0IGJhY2sKICAgICAgICBpZiAocHN5Y2hvdGljKSB7CiAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7CiAgICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0CiAgICAgICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2UKICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpCiAgICAgICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPwogICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7CiAgICAgICAgICBpZiAoYXV0aEluSG9zdCkgewogICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTsKICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpOwoKICAgICAgICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkgewogICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcnKTsKICAgICAgICB9CgogICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHsKICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7CiAgICAgICAgICByZXN1bHQucGF0aCA9IG51bGw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpOwogICAgICAgIH0KCiAgICAgICAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cAogICAgICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHsKICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArCiAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTsKICAgICAgICB9CiAgICAgICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoOwogICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlczsKICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9OwoKICAgICAgVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDsKICAgICAgICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7CiAgICAgICAgaWYgKHBvcnQpIHsKICAgICAgICAgIHBvcnQgPSBwb3J0WzBdOwogICAgICAgICAgaWYgKHBvcnQgIT09ICc6JykgewogICAgICAgICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTsKICAgICAgICAgIH0KICAgICAgICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7IH0KICAgICAgfTsKCiAgICAgIHZhciB1cmwgPSB7CiAgICAgIAlwYXJzZTogcGFyc2UsCiAgICAgIAlyZXNvbHZlOiByZXNvbHZlLAogICAgICAJcmVzb2x2ZU9iamVjdDogcmVzb2x2ZU9iamVjdCwKICAgICAgCWZvcm1hdDogZm9ybWF0JDEsCiAgICAgIAlVcmw6IFVybF8xCiAgICAgIH07CgogICAgICBmdW5jdGlvbiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eU5hbWUpIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjgubGF5b3V0Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHY4W3Y4LmxheW91dFtpXV0pIHsKICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcGVydHlOYW1lKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjhbdjgubGF5b3V0W2ldXVtrZXldOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdjgucGFpbnQubGVuZ3RoOyBpJDErKykgewogICAgICAgICAgICAgIGZvciAodmFyIGtleSQxIGluIHY4W3Y4LnBhaW50W2kkMV1dKSB7CiAgICAgICAgICAgICAgICAgIGlmIChrZXkkMSA9PT0gcHJvcGVydHlOYW1lKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjhbdjgucGFpbnRbaSQxXV1ba2V5JDFdOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZWFjaFNvdXJjZShzdHlsZSwgY2FsbGJhY2spIHsKICAgICAgICAgIGZvciAodmFyIGsgaW4gc3R5bGUuc291cmNlcykgewogICAgICAgICAgICAgIGNhbGxiYWNrKHN0eWxlLnNvdXJjZXNba10pOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVhY2hMYXllcihzdHlsZSwgY2FsbGJhY2spIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3R5bGUubGF5ZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciBsYXllciA9IGxpc3RbaV07CiAgICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXIpOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVhY2hQcm9wZXJ0eShzdHlsZSwgb3B0aW9ucywgY2FsbGJhY2spIHsKICAgICAgICAgIGZ1bmN0aW9uIGlubmVyKGxheWVyLCBwcm9wZXJ0eVR5cGUpIHsKICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IGxheWVyW3Byb3BlcnR5VHlwZV07CiAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHsKICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5pZCwKICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5CiAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcGVydGllc1trZXldLAogICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShrZXkpLAogICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoeCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHsKICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYWludCkgewogICAgICAgICAgICAgICAgICBpbm5lcihsYXllciwgJ3BhaW50Jyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChvcHRpb25zLmxheW91dCkgewogICAgICAgICAgICAgICAgICBpbm5lcihsYXllciwgJ2xheW91dCcpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICB9CgogICAgICBmdW5jdGlvbiBlYWNoTGF5b3V0KGxheWVyLCBjYWxsYmFjaykgewogICAgICAgICAgZm9yICh2YXIgayBpbiBsYXllcikgewogICAgICAgICAgICAgIGlmIChrLmluZGV4T2YoJ2xheW91dCcpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyW2tdLCBrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZWFjaFBhaW50KGxheWVyLCBjYWxsYmFjaykgewogICAgICAgICAgZm9yICh2YXIgayBpbiBsYXllcikgewogICAgICAgICAgICAgIGlmIChrLmluZGV4T2YoJ3BhaW50JykgPT09IDApIHsKICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHZhbHVlKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVDb25zdGFudChzdHlsZSwgc3R5bGUuY29uc3RhbnRzW3ZhbHVlXSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZS5zdG9wcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVuYW1lUHJvcGVydHkob2JqLCBmcm9tLCB0bykgewogICAgICAgICAgb2JqW3RvXSA9IG9ialtmcm9tXTsKICAgICAgICAgIGRlbGV0ZSBvYmpbZnJvbV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbWlncmF0ZVRvVjggKHN0eWxlKSB7CiAgICAgICAgICBzdHlsZS52ZXJzaW9uID0gODsKICAgICAgICAgIGVhY2hTb3VyY2Uoc3R5bGUsIGZ1bmN0aW9uIChzb3VyY2UpIHsKICAgICAgICAgICAgICBpZiAoc291cmNlLnR5cGUgPT09ICd2aWRlbycgJiYgc291cmNlLnVybCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHNvdXJjZSwgJ3VybCcsICd1cmxzJyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzb3VyY2UudHlwZSA9PT0gJ3ZpZGVvJykgewogICAgICAgICAgICAgICAgICBzb3VyY2UuY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY29vcmQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb29yZC5yZXZlcnNlKCk7CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHsKICAgICAgICAgICAgICBlYWNoTGF5b3V0KGxheWVyLCBmdW5jdGlvbiAobGF5b3V0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRbJ3N5bWJvbC1taW4tZGlzdGFuY2UnXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShsYXlvdXQsICdzeW1ib2wtbWluLWRpc3RhbmNlJywgJ3N5bWJvbC1zcGFjaW5nJyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBlYWNoUGFpbnQobGF5ZXIsIGZ1bmN0aW9uIChwYWludCkgewogICAgICAgICAgICAgICAgICBpZiAocGFpbnRbJ2JhY2tncm91bmQtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2JhY2tncm91bmQtaW1hZ2UnLCAnYmFja2dyb3VuZC1wYXR0ZXJuJyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHBhaW50WydsaW5lLWltYWdlJ10gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdsaW5lLWltYWdlJywgJ2xpbmUtcGF0dGVybicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChwYWludFsnZmlsbC1pbWFnZSddICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnZmlsbC1pbWFnZScsICdmaWxsLXBhdHRlcm4nKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgICBlYWNoUHJvcGVydHkoc3R5bGUsIHsKICAgICAgICAgICAgICBwYWludDogdHJ1ZSwKICAgICAgICAgICAgICBsYXlvdXQ6IHRydWUKICAgICAgICAgIH0sIGZ1bmN0aW9uIChwcm9wZXJ0eSkgewogICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc29sdmVDb25zdGFudChzdHlsZSwgcHJvcGVydHkudmFsdWUpOwogICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkgewogICAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdG9wWzFdID0gcmVzb2x2ZUNvbnN0YW50KHN0eWxlLCBzdG9wWzFdKTsKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHByb3BlcnR5LnNldCh2YWx1ZSk7CiAgICAgICAgICB9KTsKICAgICAgICAgIGRlbGV0ZSBzdHlsZS5jb25zdGFudHM7CiAgICAgICAgICBlYWNoTGF5ZXIoc3R5bGUsIGZ1bmN0aW9uIChsYXllcikgewogICAgICAgICAgICAgIGVhY2hMYXlvdXQobGF5ZXIsIGZ1bmN0aW9uIChsYXlvdXQpIHsKICAgICAgICAgICAgICAgICAgZGVsZXRlIGxheW91dFsndGV4dC1tYXgtc2l6ZSddOwogICAgICAgICAgICAgICAgICBkZWxldGUgbGF5b3V0WydpY29uLW1heC1zaXplJ107CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgZWFjaFBhaW50KGxheWVyLCBmdW5jdGlvbiAocGFpbnQpIHsKICAgICAgICAgICAgICAgICAgaWYgKHBhaW50Wyd0ZXh0LXNpemUnXSkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXllci5sYXlvdXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5sYXlvdXQgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmxheW91dFsndGV4dC1zaXplJ10gPSBwYWludFsndGV4dC1zaXplJ107CiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFpbnRbJ3RleHQtc2l6ZSddOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChwYWludFsnaWNvbi1zaXplJ10pIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICghbGF5ZXIubGF5b3V0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0ID0ge307CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBsYXllci5sYXlvdXRbJ2ljb24tc2l6ZSddID0gcGFpbnRbJ2ljb24tc2l6ZSddOwogICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhaW50WydpY29uLXNpemUnXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgICBmdW5jdGlvbiBtaWdyYXRlRm9udHN0YWNrVVJMKGlucHV0KSB7CiAgICAgICAgICAgICAgdmFyIGlucHV0UGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTsKICAgICAgICAgICAgICB2YXIgaW5wdXRQYXRobmFtZVBhcnRzID0gaW5wdXRQYXJzZWQucGF0aG5hbWUuc3BsaXQoJy8nKTsKICAgICAgICAgICAgICBpZiAoaW5wdXRQYXJzZWQucHJvdG9jb2wgIT09ICdtYXBib3g6JykgewogICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFBhcnNlZC5ob3N0bmFtZSA9PT0gJ2ZvbnRzdGFjaycpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICdtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmYnOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250cycpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICdtYXBib3g6Ly9mb250cy8nICsgaW5wdXRQYXRobmFtZVBhcnRzWzJdICsgJy97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZic7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0eWxlLmdseXBocykgewogICAgICAgICAgICAgIHN0eWxlLmdseXBocyA9IG1pZ3JhdGVGb250c3RhY2tVUkwoc3R5bGUuZ2x5cGhzKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIG1pZ3JhdGVGb250U3RhY2soZm9udCkgewogICAgICAgICAgICAgIGZ1bmN0aW9uIHNwbGl0QW5kVHJpbShzdHJpbmcpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocykgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudHJpbSgpOwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9udCkpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvbnQ7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0QW5kVHJpbShmb250KTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb250ID09PSAnb2JqZWN0JykgewogICAgICAgICAgICAgICAgICBmb250LnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKHN0b3ApIHsKICAgICAgICAgICAgICAgICAgICAgIHN0b3BbMV0gPSBzcGxpdEFuZFRyaW0oc3RvcFsxXSk7CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICByZXR1cm4gZm9udDsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZm9udCB2YWx1ZScpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7CiAgICAgICAgICAgICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkgewogICAgICAgICAgICAgICAgICBpZiAobGF5b3V0Wyd0ZXh0LWZvbnQnXSkgewogICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Wyd0ZXh0LWZvbnQnXSA9IG1pZ3JhdGVGb250U3RhY2sobGF5b3V0Wyd0ZXh0LWZvbnQnXSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KTsKICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIGZpcnN0U3ltYm9sTGF5ZXIgPSAwOwogICAgICAgICAgZm9yICh2YXIgaSA9IHN0eWxlLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgICAgIHZhciBsYXllciA9IHN0eWxlLmxheWVyc1tpXTsKICAgICAgICAgICAgICBpZiAobGF5ZXIudHlwZSAhPT0gJ3N5bWJvbCcpIHsKICAgICAgICAgICAgICAgICAgZmlyc3RTeW1ib2xMYXllciA9IGkgKyAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgc3ltYm9sTGF5ZXJzID0gc3R5bGUubGF5ZXJzLnNwbGljZShmaXJzdFN5bWJvbExheWVyKTsKICAgICAgICAgIHN5bWJvbExheWVycy5yZXZlcnNlKCk7CiAgICAgICAgICBzdHlsZS5sYXllcnMgPSBzdHlsZS5sYXllcnMuY29uY2F0KHN5bWJvbExheWVycyk7CiAgICAgICAgICByZXR1cm4gc3R5bGU7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGV4dGVuZCAob3V0cHV0KSB7CiAgICAgICAgICB2YXIgaW5wdXRzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOwogICAgICAgICAgd2hpbGUgKGxlbi0tID4gMCkKICAgICAgICAgICAgICBpbnB1dHNbbGVuXSA9IGFyZ3VtZW50c1tsZW4gKyAxXTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gaW5wdXRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciBpbnB1dCA9IGxpc3RbaV07CiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBpbnB1dCkgewogICAgICAgICAgICAgICAgICBvdXRwdXRba10gPSBpbnB1dFtrXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgICB9CgogICAgICB2YXIgUGFyc2luZ0Vycm9yID0gZnVuY3Rpb24gKEVycm9yKSB7CiAgICAgICAgICBmdW5jdGlvbiBQYXJzaW5nRXJyb3Ioa2V5LCBtZXNzYWdlKSB7CiAgICAgICAgICAgICAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTsKICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5OwogICAgICAgICAgfQogICAgICAgICAgaWYgKEVycm9yKQogICAgICAgICAgICAgIFBhcnNpbmdFcnJvci5fX3Byb3RvX18gPSBFcnJvcjsKICAgICAgICAgIFBhcnNpbmdFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yICYmIEVycm9yLnByb3RvdHlwZSk7CiAgICAgICAgICBQYXJzaW5nRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyc2luZ0Vycm9yOwogICAgICAgICAgcmV0dXJuIFBhcnNpbmdFcnJvcjsKICAgICAgfShFcnJvcik7CgogICAgICB2YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShwYXJlbnQsIGJpbmRpbmdzKSB7CiAgICAgICAgICBpZiAoYmluZGluZ3MgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBiaW5kaW5ncyA9IFtdOwogICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7CiAgICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGJpbmRpbmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciByZWYgPSBsaXN0W2ldOwogICAgICAgICAgICAgIHZhciBuYW1lID0gcmVmWzBdOwogICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdOwogICAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbbmFtZV0gPSBleHByZXNzaW9uOwogICAgICAgICAgfQogICAgICB9OwogICAgICBTY29wZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGJpbmRpbmdzKSB7CiAgICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMsIGJpbmRpbmdzKTsKICAgICAgfTsKICAgICAgU2NvcGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7CiAgICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1tuYW1lXSkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW25hbWVdOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChuYW1lKTsKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBub3QgZm91bmQgaW4gc2NvcGUuJyk7CiAgICAgIH07CiAgICAgIFNjb3BlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMobmFtZSkgewogICAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbbmFtZV0pIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmhhcyhuYW1lKSA6IGZhbHNlOwogICAgICB9OwoKICAgICAgdmFyIE51bGxUeXBlID0geyBraW5kOiAnbnVsbCcgfTsKICAgICAgdmFyIE51bWJlclR5cGUgPSB7IGtpbmQ6ICdudW1iZXInIH07CiAgICAgIHZhciBTdHJpbmdUeXBlID0geyBraW5kOiAnc3RyaW5nJyB9OwogICAgICB2YXIgQm9vbGVhblR5cGUgPSB7IGtpbmQ6ICdib29sZWFuJyB9OwogICAgICB2YXIgQ29sb3JUeXBlID0geyBraW5kOiAnY29sb3InIH07CiAgICAgIHZhciBPYmplY3RUeXBlID0geyBraW5kOiAnb2JqZWN0JyB9OwogICAgICB2YXIgVmFsdWVUeXBlID0geyBraW5kOiAndmFsdWUnIH07CiAgICAgIHZhciBFcnJvclR5cGUgPSB7IGtpbmQ6ICdlcnJvcicgfTsKICAgICAgdmFyIENvbGxhdG9yVHlwZSA9IHsga2luZDogJ2NvbGxhdG9yJyB9OwogICAgICB2YXIgRm9ybWF0dGVkVHlwZSA9IHsga2luZDogJ2Zvcm1hdHRlZCcgfTsKICAgICAgdmFyIFJlc29sdmVkSW1hZ2VUeXBlID0geyBraW5kOiAncmVzb2x2ZWRJbWFnZScgfTsKICAgICAgZnVuY3Rpb24gYXJyYXkoaXRlbVR5cGUsIE4pIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAga2luZDogJ2FycmF5JywKICAgICAgICAgICAgICBpdGVtVHlwZTogaXRlbVR5cGUsCiAgICAgICAgICAgICAgTjogTgogICAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiB0b1N0cmluZyh0eXBlKSB7CiAgICAgICAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7CiAgICAgICAgICAgICAgdmFyIGl0ZW1UeXBlID0gdG9TdHJpbmcodHlwZS5pdGVtVHlwZSk7CiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlLk4gPT09ICdudW1iZXInID8gJ2FycmF5PCcgKyBpdGVtVHlwZSArICcsICcgKyB0eXBlLk4gKyAnPicgOiB0eXBlLml0ZW1UeXBlLmtpbmQgPT09ICd2YWx1ZScgPyAnYXJyYXknIDogJ2FycmF5PCcgKyBpdGVtVHlwZSArICc+JzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIHR5cGUua2luZDsKICAgICAgICAgIH0KICAgICAgfQogICAgICB2YXIgdmFsdWVNZW1iZXJUeXBlcyA9IFsKICAgICAgICAgIE51bGxUeXBlLAogICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgIENvbG9yVHlwZSwKICAgICAgICAgIEZvcm1hdHRlZFR5cGUsCiAgICAgICAgICBPYmplY3RUeXBlLAogICAgICAgICAgYXJyYXkoVmFsdWVUeXBlKSwKICAgICAgICAgIFJlc29sdmVkSW1hZ2VUeXBlCiAgICAgIF07CiAgICAgIGZ1bmN0aW9uIGNoZWNrU3VidHlwZShleHBlY3RlZCwgdCkgewogICAgICAgICAgaWYgKHQua2luZCA9PT0gJ2Vycm9yJykgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAnYXJyYXknKSB7CiAgICAgICAgICAgICAgaWYgKHQua2luZCA9PT0gJ2FycmF5JyAmJiAodC5OID09PSAwICYmIHQuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCAhY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLml0ZW1UeXBlLCB0Lml0ZW1UeXBlKSkgJiYgKHR5cGVvZiBleHBlY3RlZC5OICE9PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5OID09PSB0Lk4pKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQua2luZCA9PT0gdC5raW5kKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHZhbHVlTWVtYmVyVHlwZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgICAgICAgIHZhciBtZW1iZXJUeXBlID0gbGlzdFtpXTsKICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1N1YnR5cGUobWVtYmVyVHlwZSwgdCkpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCAnICsgdG9TdHJpbmcoZXhwZWN0ZWQpICsgJyBidXQgZm91bmQgJyArIHRvU3RyaW5nKHQpICsgJyBpbnN0ZWFkLic7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNWYWxpZFR5cGUocHJvdmlkZWQsIGFsbG93ZWRUeXBlcykgewogICAgICAgICAgcmV0dXJuIGFsbG93ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHQua2luZCA9PT0gcHJvdmlkZWQua2luZDsKICAgICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzVmFsaWROYXRpdmVUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHsKICAgICAgICAgIHJldHVybiBhbGxvd2VkVHlwZXMuc29tZShmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIGlmICh0ID09PSAnbnVsbCcpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkID09PSBudWxsOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ2FycmF5JykgewogICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwcm92aWRlZCk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09PSAnb2JqZWN0JykgewogICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZWQgJiYgIUFycmF5LmlzQXJyYXkocHJvdmlkZWQpICYmIHR5cGVvZiBwcm92aWRlZCA9PT0gJ29iamVjdCc7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPT09IHR5cGVvZiBwcm92aWRlZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgfQoKICAgICAgdmFyIGNzc2NvbG9ycGFyc2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykgewogICAgICAvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuCiAgICAgIC8vCiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzCiAgICAgIC8vCiAgICAgIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkKICAgICAgLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgIlNvZnR3YXJlIiksIHRvCiAgICAgIC8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlCiAgICAgIC8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vcgogICAgICAvLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcwogICAgICAvLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOgogICAgICAvLwogICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgogICAgICAvLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KICAgICAgLy8KICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IKICAgICAgLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksCiAgICAgIC8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRQogICAgICAvLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSCiAgICAgIC8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HCiAgICAgIC8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MKICAgICAgLy8gSU4gVEhFIFNPRlRXQVJFLgoKICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8KICAgICAgdmFyIGtDU1NDb2xvclRhYmxlID0gewogICAgICAgICJ0cmFuc3BhcmVudCI6IFswLDAsMCwwXSwgImFsaWNlYmx1ZSI6IFsyNDAsMjQ4LDI1NSwxXSwKICAgICAgICAiYW50aXF1ZXdoaXRlIjogWzI1MCwyMzUsMjE1LDFdLCAiYXF1YSI6IFswLDI1NSwyNTUsMV0sCiAgICAgICAgImFxdWFtYXJpbmUiOiBbMTI3LDI1NSwyMTIsMV0sICJhenVyZSI6IFsyNDAsMjU1LDI1NSwxXSwKICAgICAgICAiYmVpZ2UiOiBbMjQ1LDI0NSwyMjAsMV0sICJiaXNxdWUiOiBbMjU1LDIyOCwxOTYsMV0sCiAgICAgICAgImJsYWNrIjogWzAsMCwwLDFdLCAiYmxhbmNoZWRhbG1vbmQiOiBbMjU1LDIzNSwyMDUsMV0sCiAgICAgICAgImJsdWUiOiBbMCwwLDI1NSwxXSwgImJsdWV2aW9sZXQiOiBbMTM4LDQzLDIyNiwxXSwKICAgICAgICAiYnJvd24iOiBbMTY1LDQyLDQyLDFdLCAiYnVybHl3b29kIjogWzIyMiwxODQsMTM1LDFdLAogICAgICAgICJjYWRldGJsdWUiOiBbOTUsMTU4LDE2MCwxXSwgImNoYXJ0cmV1c2UiOiBbMTI3LDI1NSwwLDFdLAogICAgICAgICJjaG9jb2xhdGUiOiBbMjEwLDEwNSwzMCwxXSwgImNvcmFsIjogWzI1NSwxMjcsODAsMV0sCiAgICAgICAgImNvcm5mbG93ZXJibHVlIjogWzEwMCwxNDksMjM3LDFdLCAiY29ybnNpbGsiOiBbMjU1LDI0OCwyMjAsMV0sCiAgICAgICAgImNyaW1zb24iOiBbMjIwLDIwLDYwLDFdLCAiY3lhbiI6IFswLDI1NSwyNTUsMV0sCiAgICAgICAgImRhcmtibHVlIjogWzAsMCwxMzksMV0sICJkYXJrY3lhbiI6IFswLDEzOSwxMzksMV0sCiAgICAgICAgImRhcmtnb2xkZW5yb2QiOiBbMTg0LDEzNCwxMSwxXSwgImRhcmtncmF5IjogWzE2OSwxNjksMTY5LDFdLAogICAgICAgICJkYXJrZ3JlZW4iOiBbMCwxMDAsMCwxXSwgImRhcmtncmV5IjogWzE2OSwxNjksMTY5LDFdLAogICAgICAgICJkYXJra2hha2kiOiBbMTg5LDE4MywxMDcsMV0sICJkYXJrbWFnZW50YSI6IFsxMzksMCwxMzksMV0sCiAgICAgICAgImRhcmtvbGl2ZWdyZWVuIjogWzg1LDEwNyw0NywxXSwgImRhcmtvcmFuZ2UiOiBbMjU1LDE0MCwwLDFdLAogICAgICAgICJkYXJrb3JjaGlkIjogWzE1Myw1MCwyMDQsMV0sICJkYXJrcmVkIjogWzEzOSwwLDAsMV0sCiAgICAgICAgImRhcmtzYWxtb24iOiBbMjMzLDE1MCwxMjIsMV0sICJkYXJrc2VhZ3JlZW4iOiBbMTQzLDE4OCwxNDMsMV0sCiAgICAgICAgImRhcmtzbGF0ZWJsdWUiOiBbNzIsNjEsMTM5LDFdLCAiZGFya3NsYXRlZ3JheSI6IFs0Nyw3OSw3OSwxXSwKICAgICAgICAiZGFya3NsYXRlZ3JleSI6IFs0Nyw3OSw3OSwxXSwgImRhcmt0dXJxdW9pc2UiOiBbMCwyMDYsMjA5LDFdLAogICAgICAgICJkYXJrdmlvbGV0IjogWzE0OCwwLDIxMSwxXSwgImRlZXBwaW5rIjogWzI1NSwyMCwxNDcsMV0sCiAgICAgICAgImRlZXBza3libHVlIjogWzAsMTkxLDI1NSwxXSwgImRpbWdyYXkiOiBbMTA1LDEwNSwxMDUsMV0sCiAgICAgICAgImRpbWdyZXkiOiBbMTA1LDEwNSwxMDUsMV0sICJkb2RnZXJibHVlIjogWzMwLDE0NCwyNTUsMV0sCiAgICAgICAgImZpcmVicmljayI6IFsxNzgsMzQsMzQsMV0sICJmbG9yYWx3aGl0ZSI6IFsyNTUsMjUwLDI0MCwxXSwKICAgICAgICAiZm9yZXN0Z3JlZW4iOiBbMzQsMTM5LDM0LDFdLCAiZnVjaHNpYSI6IFsyNTUsMCwyNTUsMV0sCiAgICAgICAgImdhaW5zYm9ybyI6IFsyMjAsMjIwLDIyMCwxXSwgImdob3N0d2hpdGUiOiBbMjQ4LDI0OCwyNTUsMV0sCiAgICAgICAgImdvbGQiOiBbMjU1LDIxNSwwLDFdLCAiZ29sZGVucm9kIjogWzIxOCwxNjUsMzIsMV0sCiAgICAgICAgImdyYXkiOiBbMTI4LDEyOCwxMjgsMV0sICJncmVlbiI6IFswLDEyOCwwLDFdLAogICAgICAgICJncmVlbnllbGxvdyI6IFsxNzMsMjU1LDQ3LDFdLCAiZ3JleSI6IFsxMjgsMTI4LDEyOCwxXSwKICAgICAgICAiaG9uZXlkZXciOiBbMjQwLDI1NSwyNDAsMV0sICJob3RwaW5rIjogWzI1NSwxMDUsMTgwLDFdLAogICAgICAgICJpbmRpYW5yZWQiOiBbMjA1LDkyLDkyLDFdLCAiaW5kaWdvIjogWzc1LDAsMTMwLDFdLAogICAgICAgICJpdm9yeSI6IFsyNTUsMjU1LDI0MCwxXSwgImtoYWtpIjogWzI0MCwyMzAsMTQwLDFdLAogICAgICAgICJsYXZlbmRlciI6IFsyMzAsMjMwLDI1MCwxXSwgImxhdmVuZGVyYmx1c2giOiBbMjU1LDI0MCwyNDUsMV0sCiAgICAgICAgImxhd25ncmVlbiI6IFsxMjQsMjUyLDAsMV0sICJsZW1vbmNoaWZmb24iOiBbMjU1LDI1MCwyMDUsMV0sCiAgICAgICAgImxpZ2h0Ymx1ZSI6IFsxNzMsMjE2LDIzMCwxXSwgImxpZ2h0Y29yYWwiOiBbMjQwLDEyOCwxMjgsMV0sCiAgICAgICAgImxpZ2h0Y3lhbiI6IFsyMjQsMjU1LDI1NSwxXSwgImxpZ2h0Z29sZGVucm9keWVsbG93IjogWzI1MCwyNTAsMjEwLDFdLAogICAgICAgICJsaWdodGdyYXkiOiBbMjExLDIxMSwyMTEsMV0sICJsaWdodGdyZWVuIjogWzE0NCwyMzgsMTQ0LDFdLAogICAgICAgICJsaWdodGdyZXkiOiBbMjExLDIxMSwyMTEsMV0sICJsaWdodHBpbmsiOiBbMjU1LDE4MiwxOTMsMV0sCiAgICAgICAgImxpZ2h0c2FsbW9uIjogWzI1NSwxNjAsMTIyLDFdLCAibGlnaHRzZWFncmVlbiI6IFszMiwxNzgsMTcwLDFdLAogICAgICAgICJsaWdodHNreWJsdWUiOiBbMTM1LDIwNiwyNTAsMV0sICJsaWdodHNsYXRlZ3JheSI6IFsxMTksMTM2LDE1MywxXSwKICAgICAgICAibGlnaHRzbGF0ZWdyZXkiOiBbMTE5LDEzNiwxNTMsMV0sICJsaWdodHN0ZWVsYmx1ZSI6IFsxNzYsMTk2LDIyMiwxXSwKICAgICAgICAibGlnaHR5ZWxsb3ciOiBbMjU1LDI1NSwyMjQsMV0sICJsaW1lIjogWzAsMjU1LDAsMV0sCiAgICAgICAgImxpbWVncmVlbiI6IFs1MCwyMDUsNTAsMV0sICJsaW5lbiI6IFsyNTAsMjQwLDIzMCwxXSwKICAgICAgICAibWFnZW50YSI6IFsyNTUsMCwyNTUsMV0sICJtYXJvb24iOiBbMTI4LDAsMCwxXSwKICAgICAgICAibWVkaXVtYXF1YW1hcmluZSI6IFsxMDIsMjA1LDE3MCwxXSwgIm1lZGl1bWJsdWUiOiBbMCwwLDIwNSwxXSwKICAgICAgICAibWVkaXVtb3JjaGlkIjogWzE4Niw4NSwyMTEsMV0sICJtZWRpdW1wdXJwbGUiOiBbMTQ3LDExMiwyMTksMV0sCiAgICAgICAgIm1lZGl1bXNlYWdyZWVuIjogWzYwLDE3OSwxMTMsMV0sICJtZWRpdW1zbGF0ZWJsdWUiOiBbMTIzLDEwNCwyMzgsMV0sCiAgICAgICAgIm1lZGl1bXNwcmluZ2dyZWVuIjogWzAsMjUwLDE1NCwxXSwgIm1lZGl1bXR1cnF1b2lzZSI6IFs3MiwyMDksMjA0LDFdLAogICAgICAgICJtZWRpdW12aW9sZXRyZWQiOiBbMTk5LDIxLDEzMywxXSwgIm1pZG5pZ2h0Ymx1ZSI6IFsyNSwyNSwxMTIsMV0sCiAgICAgICAgIm1pbnRjcmVhbSI6IFsyNDUsMjU1LDI1MCwxXSwgIm1pc3R5cm9zZSI6IFsyNTUsMjI4LDIyNSwxXSwKICAgICAgICAibW9jY2FzaW4iOiBbMjU1LDIyOCwxODEsMV0sICJuYXZham93aGl0ZSI6IFsyNTUsMjIyLDE3MywxXSwKICAgICAgICAibmF2eSI6IFswLDAsMTI4LDFdLCAib2xkbGFjZSI6IFsyNTMsMjQ1LDIzMCwxXSwKICAgICAgICAib2xpdmUiOiBbMTI4LDEyOCwwLDFdLCAib2xpdmVkcmFiIjogWzEwNywxNDIsMzUsMV0sCiAgICAgICAgIm9yYW5nZSI6IFsyNTUsMTY1LDAsMV0sICJvcmFuZ2VyZWQiOiBbMjU1LDY5LDAsMV0sCiAgICAgICAgIm9yY2hpZCI6IFsyMTgsMTEyLDIxNCwxXSwgInBhbGVnb2xkZW5yb2QiOiBbMjM4LDIzMiwxNzAsMV0sCiAgICAgICAgInBhbGVncmVlbiI6IFsxNTIsMjUxLDE1MiwxXSwgInBhbGV0dXJxdW9pc2UiOiBbMTc1LDIzOCwyMzgsMV0sCiAgICAgICAgInBhbGV2aW9sZXRyZWQiOiBbMjE5LDExMiwxNDcsMV0sICJwYXBheWF3aGlwIjogWzI1NSwyMzksMjEzLDFdLAogICAgICAgICJwZWFjaHB1ZmYiOiBbMjU1LDIxOCwxODUsMV0sICJwZXJ1IjogWzIwNSwxMzMsNjMsMV0sCiAgICAgICAgInBpbmsiOiBbMjU1LDE5MiwyMDMsMV0sICJwbHVtIjogWzIyMSwxNjAsMjIxLDFdLAogICAgICAgICJwb3dkZXJibHVlIjogWzE3NiwyMjQsMjMwLDFdLCAicHVycGxlIjogWzEyOCwwLDEyOCwxXSwKICAgICAgICAicmViZWNjYXB1cnBsZSI6IFsxMDIsNTEsMTUzLDFdLAogICAgICAgICJyZWQiOiBbMjU1LDAsMCwxXSwgInJvc3licm93biI6IFsxODgsMTQzLDE0MywxXSwKICAgICAgICAicm95YWxibHVlIjogWzY1LDEwNSwyMjUsMV0sICJzYWRkbGVicm93biI6IFsxMzksNjksMTksMV0sCiAgICAgICAgInNhbG1vbiI6IFsyNTAsMTI4LDExNCwxXSwgInNhbmR5YnJvd24iOiBbMjQ0LDE2NCw5NiwxXSwKICAgICAgICAic2VhZ3JlZW4iOiBbNDYsMTM5LDg3LDFdLCAic2Vhc2hlbGwiOiBbMjU1LDI0NSwyMzgsMV0sCiAgICAgICAgInNpZW5uYSI6IFsxNjAsODIsNDUsMV0sICJzaWx2ZXIiOiBbMTkyLDE5MiwxOTIsMV0sCiAgICAgICAgInNreWJsdWUiOiBbMTM1LDIwNiwyMzUsMV0sICJzbGF0ZWJsdWUiOiBbMTA2LDkwLDIwNSwxXSwKICAgICAgICAic2xhdGVncmF5IjogWzExMiwxMjgsMTQ0LDFdLCAic2xhdGVncmV5IjogWzExMiwxMjgsMTQ0LDFdLAogICAgICAgICJzbm93IjogWzI1NSwyNTAsMjUwLDFdLCAic3ByaW5nZ3JlZW4iOiBbMCwyNTUsMTI3LDFdLAogICAgICAgICJzdGVlbGJsdWUiOiBbNzAsMTMwLDE4MCwxXSwgInRhbiI6IFsyMTAsMTgwLDE0MCwxXSwKICAgICAgICAidGVhbCI6IFswLDEyOCwxMjgsMV0sICJ0aGlzdGxlIjogWzIxNiwxOTEsMjE2LDFdLAogICAgICAgICJ0b21hdG8iOiBbMjU1LDk5LDcxLDFdLCAidHVycXVvaXNlIjogWzY0LDIyNCwyMDgsMV0sCiAgICAgICAgInZpb2xldCI6IFsyMzgsMTMwLDIzOCwxXSwgIndoZWF0IjogWzI0NSwyMjIsMTc5LDFdLAogICAgICAgICJ3aGl0ZSI6IFsyNTUsMjU1LDI1NSwxXSwgIndoaXRlc21va2UiOiBbMjQ1LDI0NSwyNDUsMV0sCiAgICAgICAgInllbGxvdyI6IFsyNTUsMjU1LDAsMV0sICJ5ZWxsb3dncmVlbiI6IFsxNTQsMjA1LDUwLDFdfTsKCiAgICAgIGZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuCiAgICAgICAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS4KICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLgogICAgICAgIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmOwogICAgICB9CgogICAgICBmdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuCiAgICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJykKICAgICAgICAgIHsgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7IH0KICAgICAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuCiAgICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJykKICAgICAgICAgIHsgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApOyB9CiAgICAgICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpOwogICAgICB9CgogICAgICBmdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHsKICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAxOyB9CiAgICAgICAgZWxzZSBpZiAoaCA+IDEpIHsgaCAtPSAxOyB9CgogICAgICAgIGlmIChoICogNiA8IDEpIHsgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7IH0KICAgICAgICBpZiAoaCAqIDIgPCAxKSB7IHJldHVybiBtMjsgfQogICAgICAgIGlmIChoICogMyA8IDIpIHsgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjsgfQogICAgICAgIHJldHVybiBtMTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gcGFyc2VDU1NDb2xvcihjc3Nfc3RyKSB7CiAgICAgICAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuCiAgICAgICAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTsKCiAgICAgICAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLgogICAgICAgIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHsgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgfSAgLy8gZHVwLgoKICAgICAgICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC4KICAgICAgICBpZiAoc3RyWzBdID09PSAnIycpIHsKICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7CiAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLgogICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgeyByZXR1cm4gbnVsbDsgfSAgLy8gQ292ZXJzIE5hTi4KICAgICAgICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSwKICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSwKICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksCiAgICAgICAgICAgICAgICAgICAgMV07CiAgICAgICAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHsKICAgICAgICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuCiAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7IHJldHVybiBudWxsOyB9ICAvLyBDb3ZlcnMgTmFOLgogICAgICAgICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNiwKICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsCiAgICAgICAgICAgICAgICAgICAgaXYgJiAweGZmLAogICAgICAgICAgICAgICAgICAgIDFdOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpOwogICAgICAgIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7CiAgICAgICAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTsKICAgICAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTsKICAgICAgICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLgogICAgICAgICAgc3dpdGNoIChmbmFtZSkgewogICAgICAgICAgICBjYXNlICdyZ2JhJzoKICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgeyByZXR1cm4gbnVsbDsgfQogICAgICAgICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7CiAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLgogICAgICAgICAgICBjYXNlICdyZ2InOgogICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7IHJldHVybiBudWxsOyB9CiAgICAgICAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksCiAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksCiAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksCiAgICAgICAgICAgICAgICAgICAgICBhbHBoYV07CiAgICAgICAgICAgIGNhc2UgJ2hzbGEnOgogICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7IHJldHVybiBudWxsOyB9CiAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTsKICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guCiAgICAgICAgICAgIGNhc2UgJ2hzbCc6CiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHsgcmV0dXJuIG51bGw7IH0KICAgICAgICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMQogICAgICAgICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZQogICAgICAgICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS4KICAgICAgICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pOwogICAgICAgICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7CiAgICAgICAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7CiAgICAgICAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjsKICAgICAgICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSwKICAgICAgICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkgKiAyNTUpLAogICAgICAgICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLAogICAgICAgICAgICAgICAgICAgICAgYWxwaGFdOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIHRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3I7IH0gY2F0Y2goZSkgeyB9CiAgICAgIH0pOwogICAgICB2YXIgY3NzY29sb3JwYXJzZXJfMSA9IGNzc2NvbG9ycGFyc2VyLnBhcnNlQ1NTQ29sb3I7CgogICAgICB2YXIgQ29sb3IgPSBmdW5jdGlvbiBDb2xvcihyLCBnLCBiLCBhKSB7CiAgICAgICAgICBpZiAoYSA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIGEgPSAxOwogICAgICAgICAgdGhpcy5yID0gcjsKICAgICAgICAgIHRoaXMuZyA9IGc7CiAgICAgICAgICB0aGlzLmIgPSBiOwogICAgICAgICAgdGhpcy5hID0gYTsKICAgICAgfTsKICAgICAgQ29sb3IucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShpbnB1dCkgewogICAgICAgICAgaWYgKCFpbnB1dCkgewogICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikgewogICAgICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciByZ2JhID0gY3NzY29sb3JwYXJzZXJfMShpbnB1dCk7CiAgICAgICAgICBpZiAoIXJnYmEpIHsKICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JhWzBdIC8gMjU1ICogcmdiYVszXSwgcmdiYVsxXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbMl0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzNdKTsKICAgICAgfTsKICAgICAgQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgICB2YXIgcmVmID0gdGhpcy50b0FycmF5KCk7CiAgICAgICAgICB2YXIgciA9IHJlZlswXTsKICAgICAgICAgIHZhciBnID0gcmVmWzFdOwogICAgICAgICAgdmFyIGIgPSByZWZbMl07CiAgICAgICAgICB2YXIgYSA9IHJlZlszXTsKICAgICAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChyKSArICcsJyArIE1hdGgucm91bmQoZykgKyAnLCcgKyBNYXRoLnJvdW5kKGIpICsgJywnICsgYSArICcpJzsKICAgICAgfTsKICAgICAgQ29sb3IucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCkgewogICAgICAgICAgdmFyIHJlZiA9IHRoaXM7CiAgICAgICAgICB2YXIgciA9IHJlZi5yOwogICAgICAgICAgdmFyIGcgPSByZWYuZzsKICAgICAgICAgIHZhciBiID0gcmVmLmI7CiAgICAgICAgICB2YXIgYSA9IHJlZi5hOwogICAgICAgICAgcmV0dXJuIGEgPT09IDAgPyBbCiAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICAwLAogICAgICAgICAgICAgIDAsCiAgICAgICAgICAgICAgMAogICAgICAgICAgXSA6IFsKICAgICAgICAgICAgICByICogMjU1IC8gYSwKICAgICAgICAgICAgICBnICogMjU1IC8gYSwKICAgICAgICAgICAgICBiICogMjU1IC8gYSwKICAgICAgICAgICAgICBhCiAgICAgICAgICBdOwogICAgICB9OwogICAgICBDb2xvci5ibGFjayA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTsKICAgICAgQ29sb3Iud2hpdGUgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7CiAgICAgIENvbG9yLnRyYW5zcGFyZW50ID0gbmV3IENvbG9yKDAsIDAsIDAsIDApOwogICAgICBDb2xvci5yZWQgPSBuZXcgQ29sb3IoMSwgMCwgMCwgMSk7CgogICAgICB2YXIgQ29sbGF0b3IgPSBmdW5jdGlvbiBDb2xsYXRvcihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkgewogICAgICAgICAgaWYgKGNhc2VTZW5zaXRpdmUpIHsKICAgICAgICAgICAgICB0aGlzLnNlbnNpdGl2aXR5ID0gZGlhY3JpdGljU2Vuc2l0aXZlID8gJ3ZhcmlhbnQnIDogJ2Nhc2UnOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLnNlbnNpdGl2aXR5ID0gZGlhY3JpdGljU2Vuc2l0aXZlID8gJ2FjY2VudCcgOiAnYmFzZSc7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTsKICAgICAgICAgIHRoaXMuY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10sIHsKICAgICAgICAgICAgICBzZW5zaXRpdml0eTogdGhpcy5zZW5zaXRpdml0eSwKICAgICAgICAgICAgICB1c2FnZTogJ3NlYXJjaCcKICAgICAgICAgIH0pOwogICAgICB9OwogICAgICBDb2xsYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUobGhzLCByaHMpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yLmNvbXBhcmUobGhzLCByaHMpOwogICAgICB9OwogICAgICBDb2xsYXRvci5wcm90b3R5cGUucmVzb2x2ZWRMb2NhbGUgPSBmdW5jdGlvbiByZXNvbHZlZExvY2FsZSgpIHsKICAgICAgICAgIHJldHVybiBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10pLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTsKICAgICAgfTsKCiAgICAgIHZhciBGb3JtYXR0ZWRTZWN0aW9uID0gZnVuY3Rpb24gRm9ybWF0dGVkU2VjdGlvbih0ZXh0LCBpbWFnZSwgc2NhbGUsIGZvbnRTdGFjaywgdGV4dENvbG9yKSB7CiAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0OwogICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlOwogICAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlOwogICAgICAgICAgdGhpcy5mb250U3RhY2sgPSBmb250U3RhY2s7CiAgICAgICAgICB0aGlzLnRleHRDb2xvciA9IHRleHRDb2xvcjsKICAgICAgfTsKICAgICAgdmFyIEZvcm1hdHRlZCA9IGZ1bmN0aW9uIEZvcm1hdHRlZChzZWN0aW9ucykgewogICAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zOwogICAgICB9OwogICAgICBGb3JtYXR0ZWQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcodW5mb3JtYXR0ZWQpIHsKICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKFtuZXcgRm9ybWF0dGVkU2VjdGlvbih1bmZvcm1hdHRlZCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCldKTsKICAgICAgfTsKICAgICAgRm9ybWF0dGVkLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHsKICAgICAgICAgIGlmICh0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICF0aGlzLnNlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHNlY3Rpb24pIHsKICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbi50ZXh0Lmxlbmd0aCAhPT0gMCB8fCBzZWN0aW9uLmltYWdlICYmIHNlY3Rpb24uaW1hZ2UubmFtZS5sZW5ndGggIT09IDA7CiAgICAgICAgICB9KTsKICAgICAgfTsKICAgICAgRm9ybWF0dGVkLmZhY3RvcnkgPSBmdW5jdGlvbiBmYWN0b3J5KHRleHQpIHsKICAgICAgICAgIGlmICh0ZXh0IGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0ZXh0KTsKICAgICAgICAgIH0KICAgICAgfTsKICAgICAgRm9ybWF0dGVkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuICcnOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMuc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzZWN0aW9uKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb24udGV4dDsKICAgICAgICAgIH0pLmpvaW4oJycpOwogICAgICB9OwogICAgICBGb3JtYXR0ZWQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gWydmb3JtYXQnXTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5zZWN0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgc2VjdGlvbiA9IGxpc3RbaV07CiAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uaW1hZ2UpIHsKICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKFsKICAgICAgICAgICAgICAgICAgICAgICdpbWFnZScsCiAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmltYWdlLm5hbWUKICAgICAgICAgICAgICAgICAgXSk7CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi50ZXh0KTsKICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9OwogICAgICAgICAgICAgIGlmIChzZWN0aW9uLmZvbnRTdGFjaykgewogICAgICAgICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWZvbnQnXSA9IFsKICAgICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJywKICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb24uZm9udFN0YWNrLnNwbGl0KCcsJykKICAgICAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uc2NhbGUpIHsKICAgICAgICAgICAgICAgICAgb3B0aW9uc1snZm9udC1zY2FsZSddID0gc2VjdGlvbi5zY2FsZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHNlY3Rpb24udGV4dENvbG9yKSB7CiAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3RleHQtY29sb3InXSA9IFsncmdiYSddLmNvbmNhdChzZWN0aW9uLnRleHRDb2xvci50b0FycmF5KCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2gob3B0aW9ucyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDsKICAgICAgfTsKCiAgICAgIHZhciBSZXNvbHZlZEltYWdlID0gZnVuY3Rpb24gUmVzb2x2ZWRJbWFnZShvcHRpb25zKSB7CiAgICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7CiAgICAgICAgICB0aGlzLmF2YWlsYWJsZSA9IG9wdGlvbnMuYXZhaWxhYmxlOwogICAgICB9OwogICAgICBSZXNvbHZlZEltYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTsKICAgICAgfTsKICAgICAgUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhuYW1lKSB7CiAgICAgICAgICBpZiAoIW5hbWUpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRJbWFnZSh7CiAgICAgICAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICAgICAgICBhdmFpbGFibGU6IGZhbHNlCiAgICAgICAgICB9KTsKICAgICAgfTsKICAgICAgUmVzb2x2ZWRJbWFnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAnaW1hZ2UnLAogICAgICAgICAgICAgIHRoaXMubmFtZQogICAgICAgICAgXTsKICAgICAgfTsKCiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUkdCQShyLCBnLCBiLCBhKSB7CiAgICAgICAgICBpZiAoISh0eXBlb2YgciA9PT0gJ251bWJlcicgJiYgciA+PSAwICYmIHIgPD0gMjU1ICYmIHR5cGVvZiBnID09PSAnbnVtYmVyJyAmJiBnID49IDAgJiYgZyA8PSAyNTUgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInICYmIGIgPj0gMCAmJiBiIDw9IDI1NSkpIHsKICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBbCiAgICAgICAgICAgICAgICAgIHIsCiAgICAgICAgICAgICAgICAgIGcsCiAgICAgICAgICAgICAgICAgIGIsCiAgICAgICAgICAgICAgICAgIGEKICAgICAgICAgICAgICBdIDogWwogICAgICAgICAgICAgICAgICByLAogICAgICAgICAgICAgICAgICBnLAogICAgICAgICAgICAgICAgICBiCiAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgcmdiYSB2YWx1ZSBbJyArIHZhbHVlLmpvaW4oJywgJykgKyAnXTogXCdyXCcsIFwnZ1wnLCBhbmQgXCdiXCcgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCEodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiBhID49IDAgJiYgYSA8PSAxKSkgewogICAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCByZ2JhIHZhbHVlIFsnICsgWwogICAgICAgICAgICAgICAgICByLAogICAgICAgICAgICAgICAgICBnLAogICAgICAgICAgICAgICAgICBiLAogICAgICAgICAgICAgICAgICBhCiAgICAgICAgICAgICAgXS5qb2luKCcsICcpICsgJ106IFwnYVwnIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLic7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc1ZhbHVlKG1peGVkKSB7CiAgICAgICAgICBpZiAobWl4ZWQgPT09IG51bGwpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnc3RyaW5nJykgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdib29sZWFuJykgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sb3IpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBDb2xsYXRvcikgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIEZvcm1hdHRlZCkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIFJlc29sdmVkSW1hZ2UpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXhlZCkpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG1peGVkOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV07CiAgICAgICAgICAgICAgICAgIGlmICghaXNWYWx1ZShpdGVtKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG1peGVkKSB7CiAgICAgICAgICAgICAgICAgIGlmICghaXNWYWx1ZShtaXhlZFtrZXldKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHlwZU9mKHZhbHVlKSB7CiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHsKICAgICAgICAgICAgICByZXR1cm4gTnVsbFR5cGU7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nVHlwZTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHsKICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhblR5cGU7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyVHlwZTsKICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb2xvcikgewogICAgICAgICAgICAgIHJldHVybiBDb2xvclR5cGU7CiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sbGF0b3IpIHsKICAgICAgICAgICAgICByZXR1cm4gQ29sbGF0b3JUeXBlOwogICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZvcm1hdHRlZCkgewogICAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZWRUeXBlOwogICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlc29sdmVkSW1hZ2UpIHsKICAgICAgICAgICAgICByZXR1cm4gUmVzb2x2ZWRJbWFnZVR5cGU7CiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7CiAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsKICAgICAgICAgICAgICB2YXIgaXRlbVR5cGU7CiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB2YWx1ZTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBsaXN0W2ldOwogICAgICAgICAgICAgICAgICB2YXIgdCA9IHR5cGVPZihpdGVtKTsKICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtVHlwZSkgewogICAgICAgICAgICAgICAgICAgICAgaXRlbVR5cGUgPSB0OwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1UeXBlID09PSB0KSB7CiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5KGl0ZW1UeXBlIHx8IFZhbHVlVHlwZSwgbGVuZ3RoKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdFR5cGU7CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdG9TdHJpbmckMSh2YWx1ZSkgewogICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHsKICAgICAgICAgICAgICByZXR1cm4gJyc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJykgewogICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpOwogICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yIHx8IHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkgewogICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpOwogICAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgTGl0ZXJhbCA9IGZ1bmN0aW9uIExpdGVyYWwodHlwZSwgdmFsdWUpIHsKICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7CiAgICAgIH07CiAgICAgIExpdGVyYWwucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignXCdsaXRlcmFsXCcgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghaXNWYWx1ZShhcmdzWzFdKSkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdpbnZhbGlkIHZhbHVlJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmdzWzFdOwogICAgICAgICAgdmFyIHR5cGUgPSB0eXBlT2YodmFsdWUpOwogICAgICAgICAgdmFyIGV4cGVjdGVkID0gY29udGV4dC5leHBlY3RlZFR5cGU7CiAgICAgICAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknICYmIHR5cGUuTiA9PT0gMCAmJiBleHBlY3RlZCAmJiBleHBlY3RlZC5raW5kID09PSAnYXJyYXknICYmICh0eXBlb2YgZXhwZWN0ZWQuTiAhPT0gJ251bWJlcicgfHwgZXhwZWN0ZWQuTiA9PT0gMCkpIHsKICAgICAgICAgICAgICB0eXBlID0gZXhwZWN0ZWQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWwodHlwZSwgdmFsdWUpOwogICAgICB9OwogICAgICBMaXRlcmFsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7CiAgICAgIH07CiAgICAgIExpdGVyYWwucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZCgpIHsKICAgICAgfTsKICAgICAgTGl0ZXJhbC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgTGl0ZXJhbC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAnYXJyYXknIHx8IHRoaXMudHlwZS5raW5kID09PSAnb2JqZWN0JykgewogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICdsaXRlcmFsJywKICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZQogICAgICAgICAgICAgIF07CiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBDb2xvcikgewogICAgICAgICAgICAgIHJldHVybiBbJ3JnYmEnXS5jb25jYXQodGhpcy52YWx1ZS50b0FycmF5KCkpOwogICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2VyaWFsaXplKCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlOwogICAgICAgICAgfQogICAgICB9OwoKICAgICAgdmFyIFJ1bnRpbWVFcnJvciA9IGZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihtZXNzYWdlKSB7CiAgICAgICAgICB0aGlzLm5hbWUgPSAnRXhwcmVzc2lvbkV2YWx1YXRpb25FcnJvcic7CiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICB9OwogICAgICBSdW50aW1lRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7CiAgICAgIH07CgogICAgICB2YXIgdHlwZXMgPSB7CiAgICAgICAgICBzdHJpbmc6IFN0cmluZ1R5cGUsCiAgICAgICAgICBudW1iZXI6IE51bWJlclR5cGUsCiAgICAgICAgICBib29sZWFuOiBCb29sZWFuVHlwZSwKICAgICAgICAgIG9iamVjdDogT2JqZWN0VHlwZQogICAgICB9OwogICAgICB2YXIgQXNzZXJ0aW9uID0gZnVuY3Rpb24gQXNzZXJ0aW9uKHR5cGUsIGFyZ3MpIHsKICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzOwogICAgICB9OwogICAgICBBc3NlcnRpb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpID0gMTsKICAgICAgICAgIHZhciB0eXBlOwogICAgICAgICAgdmFyIG5hbWUgPSBhcmdzWzBdOwogICAgICAgICAgaWYgKG5hbWUgPT09ICdhcnJheScpIHsKICAgICAgICAgICAgICB2YXIgaXRlbVR5cGU7CiAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMikgewogICAgICAgICAgICAgICAgICB2YXIgdHlwZSQxID0gYXJnc1sxXTsKICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlJDEgIT09ICdzdHJpbmcnIHx8ICEodHlwZSQxIGluIHR5cGVzKSB8fCB0eXBlJDEgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVGhlIGl0ZW0gdHlwZSBhcmd1bWVudCBvZiAiYXJyYXkiIG11c3QgYmUgb25lIG9mIHN0cmluZywgbnVtYmVyLCBib29sZWFuJywgMSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaXRlbVR5cGUgPSB0eXBlc1t0eXBlJDFdOwogICAgICAgICAgICAgICAgICBpKys7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgaXRlbVR5cGUgPSBWYWx1ZVR5cGU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBOOwogICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIHsKICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbMl0gIT09IG51bGwgJiYgKHR5cGVvZiBhcmdzWzJdICE9PSAnbnVtYmVyJyB8fCBhcmdzWzJdIDwgMCB8fCBhcmdzWzJdICE9PSBNYXRoLmZsb29yKGFyZ3NbMl0pKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBsZW5ndGggYXJndW1lbnQgdG8gImFycmF5IiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsaXRlcmFsJywgMik7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgTiA9IGFyZ3NbMl07CiAgICAgICAgICAgICAgICAgIGkrKzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBOKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdHlwZSA9IHR5cGVzW25hbWVdOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHBhcnNlZCA9IFtdOwogICAgICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBWYWx1ZVR5cGUpOwogICAgICAgICAgICAgIGlmICghaW5wdXQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHBhcnNlZC5wdXNoKGlucHV0KTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHR5cGUsIHBhcnNlZCk7CiAgICAgIH07CiAgICAgIEFzc2VydGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcmdzW2ldLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgdmFyIGVycm9yID0gY2hlY2tTdWJ0eXBlKHRoaXMudHlwZSwgdHlwZU9mKHZhbHVlKSk7CiAgICAgICAgICAgICAgaWYgKCFlcnJvcikgewogICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlICcgKyB0b1N0cmluZyh0aGlzLnR5cGUpICsgJywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YodmFsdWUpKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfTsKICAgICAgQXNzZXJ0aW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTsKICAgICAgfTsKICAgICAgQXNzZXJ0aW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykgewogICAgICAgICAgICAgIHJldHVybiBhcmcub3V0cHV0RGVmaW5lZCgpOwogICAgICAgICAgfSk7CiAgICAgIH07CiAgICAgIEFzc2VydGlvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7CiAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFt0eXBlLmtpbmRdOwogICAgICAgICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5JykgewogICAgICAgICAgICAgIHZhciBpdGVtVHlwZSA9IHR5cGUuaXRlbVR5cGU7CiAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlLmtpbmQgPT09ICdzdHJpbmcnIHx8IGl0ZW1UeXBlLmtpbmQgPT09ICdudW1iZXInIHx8IGl0ZW1UeXBlLmtpbmQgPT09ICdib29sZWFuJykgewogICAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goaXRlbVR5cGUua2luZCk7CiAgICAgICAgICAgICAgICAgIHZhciBOID0gdHlwZS5OOwogICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIE4gPT09ICdudW1iZXInIHx8IHRoaXMuYXJncy5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goTik7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZC5jb25jYXQodGhpcy5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGFyZy5zZXJpYWxpemUoKTsKICAgICAgICAgIH0pKTsKICAgICAgfTsKCiAgICAgIHZhciBGb3JtYXRFeHByZXNzaW9uID0gZnVuY3Rpb24gRm9ybWF0RXhwcmVzc2lvbihzZWN0aW9ucykgewogICAgICAgICAgdGhpcy50eXBlID0gRm9ybWF0dGVkVHlwZTsKICAgICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9uczsKICAgICAgfTsKICAgICAgRm9ybWF0RXhwcmVzc2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGZpcnN0QXJnID0gYXJnc1sxXTsKICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmaXJzdEFyZykgJiYgdHlwZW9mIGZpcnN0QXJnID09PSAnb2JqZWN0JykgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBzZWN0aW9ucyA9IFtdOwogICAgICAgICAgdmFyIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7CiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBhcmdzLmxlbmd0aCAtIDE7ICsraSkgewogICAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2ldOwogICAgICAgICAgICAgIGlmIChuZXh0VG9rZW5NYXlCZU9iamVjdCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7CiAgICAgICAgICAgICAgICAgIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IG51bGw7CiAgICAgICAgICAgICAgICAgIGlmIChhcmdbJ2ZvbnQtc2NhbGUnXSkgewogICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBjb250ZXh0LnBhcnNlKGFyZ1snZm9udC1zY2FsZSddLCAxLCBOdW1iZXJUeXBlKTsKICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NhbGUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIgZm9udCA9IG51bGw7CiAgICAgICAgICAgICAgICAgIGlmIChhcmdbJ3RleHQtZm9udCddKSB7CiAgICAgICAgICAgICAgICAgICAgICBmb250ID0gY29udGV4dC5wYXJzZShhcmdbJ3RleHQtZm9udCddLCAxLCBhcnJheShTdHJpbmdUeXBlKSk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvbnQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIgdGV4dENvbG9yID0gbnVsbDsKICAgICAgICAgICAgICAgICAgaWYgKGFyZ1sndGV4dC1jb2xvciddKSB7CiAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3IgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1jb2xvciddLCAxLCBDb2xvclR5cGUpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0Q29sb3IpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIgbGFzdEV4cHJlc3Npb24gPSBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXTsKICAgICAgICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24uc2NhbGUgPSBzY2FsZTsKICAgICAgICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24uZm9udCA9IGZvbnQ7CiAgICAgICAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLnRleHRDb2xvciA9IHRleHRDb2xvcjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgMSwgVmFsdWVUeXBlKTsKICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIga2luZCA9IGNvbnRlbnQudHlwZS5raW5kOwogICAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3N0cmluZycgJiYga2luZCAhPT0gJ3ZhbHVlJyAmJiBraW5kICE9PSAnbnVsbCcgJiYga2luZCAhPT0gJ3Jlc29sdmVkSW1hZ2UnKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRm9ybWF0dGVkIHRleHQgdHlwZSBtdXN0IGJlIFwnc3RyaW5nXCcsIFwndmFsdWVcJywgXCdpbWFnZVwnIG9yIFwnbnVsbFwnLicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LAogICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IG51bGwsCiAgICAgICAgICAgICAgICAgICAgICBmb250OiBudWxsLAogICAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiBudWxsCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhwcmVzc2lvbihzZWN0aW9ucyk7CiAgICAgIH07CiAgICAgIEZvcm1hdEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICB2YXIgZXZhbHVhdGVTZWN0aW9uID0gZnVuY3Rpb24gKHNlY3Rpb24pIHsKICAgICAgICAgICAgICB2YXIgZXZhbHVhdGVkQ29udGVudCA9IHNlY3Rpb24uY29udGVudC5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgIGlmICh0eXBlT2YoZXZhbHVhdGVkQ29udGVudCkgPT09IFJlc29sdmVkSW1hZ2VUeXBlKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkU2VjdGlvbignJywgZXZhbHVhdGVkQ29udGVudCwgbnVsbCwgbnVsbCwgbnVsbCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkU2VjdGlvbih0b1N0cmluZyQxKGV2YWx1YXRlZENvbnRlbnQpLCBudWxsLCBzZWN0aW9uLnNjYWxlID8gc2VjdGlvbi5zY2FsZS5ldmFsdWF0ZShjdHgpIDogbnVsbCwgc2VjdGlvbi5mb250ID8gc2VjdGlvbi5mb250LmV2YWx1YXRlKGN0eCkuam9pbignLCcpIDogbnVsbCwgc2VjdGlvbi50ZXh0Q29sb3IgPyBzZWN0aW9uLnRleHRDb2xvci5ldmFsdWF0ZShjdHgpIDogbnVsbCk7CiAgICAgICAgICB9OwogICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWQodGhpcy5zZWN0aW9ucy5tYXAoZXZhbHVhdGVTZWN0aW9uKSk7CiAgICAgIH07CiAgICAgIEZvcm1hdEV4cHJlc3Npb24ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLnNlY3Rpb25zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciBzZWN0aW9uID0gbGlzdFtpXTsKICAgICAgICAgICAgICBmbihzZWN0aW9uLmNvbnRlbnQpOwogICAgICAgICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7CiAgICAgICAgICAgICAgICAgIGZuKHNlY3Rpb24uc2NhbGUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoc2VjdGlvbi5mb250KSB7CiAgICAgICAgICAgICAgICAgIGZuKHNlY3Rpb24uZm9udCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikgewogICAgICAgICAgICAgICAgICBmbihzZWN0aW9uLnRleHRDb2xvcik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9OwogICAgICBGb3JtYXRFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfTsKICAgICAgRm9ybWF0RXhwcmVzc2lvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddOwogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLnNlY3Rpb25zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciBzZWN0aW9uID0gbGlzdFtpXTsKICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi5jb250ZW50LnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9OwogICAgICAgICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7CiAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGUuc2VyaWFsaXplKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzZWN0aW9uLmZvbnQpIHsKICAgICAgICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBzZWN0aW9uLmZvbnQuc2VyaWFsaXplKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikgewogICAgICAgICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBzZWN0aW9uLnRleHRDb2xvci5zZXJpYWxpemUoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKG9wdGlvbnMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7CiAgICAgIH07CgogICAgICB2YXIgSW1hZ2VFeHByZXNzaW9uID0gZnVuY3Rpb24gSW1hZ2VFeHByZXNzaW9uKGlucHV0KSB7CiAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvbHZlZEltYWdlVHlwZTsKICAgICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDsKICAgICAgfTsKICAgICAgSW1hZ2VFeHByZXNzaW9uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIHR3byBhcmd1bWVudHMuJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbmFtZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgU3RyaW5nVHlwZSk7CiAgICAgICAgICBpZiAoIW5hbWUpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignTm8gaW1hZ2UgbmFtZSBwcm92aWRlZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VFeHByZXNzaW9uKG5hbWUpOwogICAgICB9OwogICAgICBJbWFnZUV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICB2YXIgZXZhbHVhdGVkSW1hZ2VOYW1lID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgdmFyIHZhbHVlID0gUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nKGV2YWx1YXRlZEltYWdlTmFtZSk7CiAgICAgICAgICBpZiAodmFsdWUgJiYgY3R4LmF2YWlsYWJsZUltYWdlcykgewogICAgICAgICAgICAgIHZhbHVlLmF2YWlsYWJsZSA9IGN0eC5hdmFpbGFibGVJbWFnZXMuaW5kZXhPZihldmFsdWF0ZWRJbWFnZU5hbWUpID4gLTE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgIH07CiAgICAgIEltYWdlRXhwcmVzc2lvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgfTsKICAgICAgSW1hZ2VFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfTsKICAgICAgSW1hZ2VFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7CiAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICdpbWFnZScsCiAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKQogICAgICAgICAgXTsKICAgICAgfTsKCiAgICAgIHZhciB0eXBlcyQxID0gewogICAgICAgICAgJ3RvLWJvb2xlYW4nOiBCb29sZWFuVHlwZSwKICAgICAgICAgICd0by1jb2xvcic6IENvbG9yVHlwZSwKICAgICAgICAgICd0by1udW1iZXInOiBOdW1iZXJUeXBlLAogICAgICAgICAgJ3RvLXN0cmluZyc6IFN0cmluZ1R5cGUKICAgICAgfTsKICAgICAgdmFyIENvZXJjaW9uID0gZnVuY3Rpb24gQ29lcmNpb24odHlwZSwgYXJncykgewogICAgICAgICAgdGhpcy50eXBlID0gdHlwZTsKICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7CiAgICAgIH07CiAgICAgIENvZXJjaW9uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbmFtZSA9IGFyZ3NbMF07CiAgICAgICAgICBpZiAoKG5hbWUgPT09ICd0by1ib29sZWFuJyB8fCBuYW1lID09PSAndG8tc3RyaW5nJykgJiYgYXJncy5sZW5ndGggIT09IDIpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgb25lIGFyZ3VtZW50LicpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHR5cGUgPSB0eXBlcyQxW25hbWVdOwogICAgICAgICAgdmFyIHBhcnNlZCA9IFtdOwogICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBWYWx1ZVR5cGUpOwogICAgICAgICAgICAgIGlmICghaW5wdXQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHBhcnNlZC5wdXNoKGlucHV0KTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgcGFyc2VkKTsKICAgICAgfTsKICAgICAgQ29lcmNpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdib29sZWFuJykgewogICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdjb2xvcicpIHsKICAgICAgICAgICAgICB2YXIgaW5wdXQ7CiAgICAgICAgICAgICAgdmFyIGVycm9yOwogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5hcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTsKICAgICAgICAgICAgICAgICAgaW5wdXQgPSBhcmcuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsOwogICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0OwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gY3R4LnBhcnNlQ29sb3IoaW5wdXQpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYzsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8IDMgfHwgaW5wdXQubGVuZ3RoID4gNCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ0ludmFsaWQgcmJnYSB2YWx1ZSAnICsgSlNPTi5zdHJpbmdpZnkoaW5wdXQpICsgJzogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy4nOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHZhbGlkYXRlUkdCQShpbnB1dFswXSwgaW5wdXRbMV0sIGlucHV0WzJdLCBpbnB1dFszXSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dFswXSAvIDI1NSwgaW5wdXRbMV0gLyAyNTUsIGlucHV0WzJdIC8gMjU1LCBpbnB1dFszXSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihlcnJvciB8fCAnQ291bGQgbm90IHBhcnNlIGNvbG9yIGZyb20gdmFsdWUgXCcnICsgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IFN0cmluZyhKU09OLnN0cmluZ2lmeShpbnB1dCkpKSArICdcJycpOwogICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBudWxsOwogICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHRoaXMuYXJnczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIGFyZyQxID0gbGlzdCQxW2kkMV07CiAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnJDEuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHZhbHVlKTsKICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkpIHsKICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiBudW07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnIHRvIG51bWJlci4nKTsKICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdmb3JtYXR0ZWQnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlZC5mcm9tU3RyaW5nKHRvU3RyaW5nJDEodGhpcy5hcmdzWzBdLmV2YWx1YXRlKGN0eCkpKTsKICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykgewogICAgICAgICAgICAgIHJldHVybiBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcodG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gdG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSk7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIENvZXJjaW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTsKICAgICAgfTsKICAgICAgQ29lcmNpb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGFyZy5vdXRwdXREZWZpbmVkKCk7CiAgICAgICAgICB9KTsKICAgICAgfTsKICAgICAgQ29lcmNpb24ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2Zvcm1hdHRlZCcpIHsKICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEV4cHJlc3Npb24oW3sKICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuYXJnc1swXSwKICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBudWxsLAogICAgICAgICAgICAgICAgICAgICAgZm9udDogbnVsbCwKICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbAogICAgICAgICAgICAgICAgICB9XSkuc2VyaWFsaXplKCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykgewogICAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VFeHByZXNzaW9uKHRoaXMuYXJnc1swXSkuc2VyaWFsaXplKCk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFsndG8tJyArIHRoaXMudHlwZS5raW5kXTsKICAgICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkgewogICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICB9OwoKICAgICAgdmFyIGdlb21ldHJ5VHlwZXMgPSBbCiAgICAgICAgICAnVW5rbm93bicsCiAgICAgICAgICAnUG9pbnQnLAogICAgICAgICAgJ0xpbmVTdHJpbmcnLAogICAgICAgICAgJ1BvbHlnb24nCiAgICAgIF07CiAgICAgIHZhciBFdmFsdWF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIEV2YWx1YXRpb25Db250ZXh0KCkgewogICAgICAgICAgdGhpcy5nbG9iYWxzID0gbnVsbDsKICAgICAgICAgIHRoaXMuZmVhdHVyZSA9IG51bGw7CiAgICAgICAgICB0aGlzLmZlYXR1cmVTdGF0ZSA9IG51bGw7CiAgICAgICAgICB0aGlzLmZvcm1hdHRlZFNlY3Rpb24gPSBudWxsOwogICAgICAgICAgdGhpcy5fcGFyc2VDb2xvckNhY2hlID0ge307CiAgICAgICAgICB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IG51bGw7CiAgICAgICAgICB0aGlzLmNhbm9uaWNhbCA9IG51bGw7CiAgICAgIH07CiAgICAgIEV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uIGlkKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiAnaWQnIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5pZCA6IG51bGw7CiAgICAgIH07CiAgICAgIEV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5nZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZW9tZXRyeVR5cGUoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlID8gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID09PSAnbnVtYmVyJyA/IGdlb21ldHJ5VHlwZXNbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsOwogICAgICB9OwogICAgICBFdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2VvbWV0cnkgPSBmdW5jdGlvbiBnZW9tZXRyeSgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgJ2dlb21ldHJ5JyBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgOiBudWxsOwogICAgICB9OwogICAgICBFdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUuY2Fub25pY2FsSUQgPSBmdW5jdGlvbiBjYW5vbmljYWxJRCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbDsKICAgICAgfTsKICAgICAgRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTsKICAgICAgfTsKICAgICAgRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLnBhcnNlQ29sb3IgPSBmdW5jdGlvbiBwYXJzZUNvbG9yKGlucHV0KSB7CiAgICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XTsKICAgICAgICAgIGlmICghY2FjaGVkKSB7CiAgICAgICAgICAgICAgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XSA9IENvbG9yLnBhcnNlKGlucHV0KTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBjYWNoZWQ7CiAgICAgIH07CgogICAgICB2YXIgQ29tcG91bmRFeHByZXNzaW9uID0gZnVuY3Rpb24gQ29tcG91bmRFeHByZXNzaW9uKG5hbWUsIHR5cGUsIGV2YWx1YXRlLCBhcmdzKSB7CiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOwogICAgICAgICAgdGhpcy50eXBlID0gdHlwZTsKICAgICAgICAgIHRoaXMuX2V2YWx1YXRlID0gZXZhbHVhdGU7CiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzOwogICAgICB9OwogICAgICBDb21wb3VuZEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGUoY3R4LCB0aGlzLmFyZ3MpOwogICAgICB9OwogICAgICBDb21wb3VuZEV4cHJlc3Npb24ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pOwogICAgICB9OwogICAgICBDb21wb3VuZEV4cHJlc3Npb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgICBDb21wb3VuZEV4cHJlc3Npb24ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgIHJldHVybiBbdGhpcy5uYW1lXS5jb25jYXQodGhpcy5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGFyZy5zZXJpYWxpemUoKTsKICAgICAgICAgIH0pKTsKICAgICAgfTsKICAgICAgQ29tcG91bmRFeHByZXNzaW9uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgdmFyIHJlZiQxOwogICAgICAgICAgdmFyIG9wID0gYXJnc1swXTsKICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zW29wXTsKICAgICAgICAgIGlmICghZGVmaW5pdGlvbikgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdVbmtub3duIGV4cHJlc3Npb24gIicgKyBvcCArICciLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFsibGl0ZXJhbCIsIFsuLi5dXS4nLCAwKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSA/IGRlZmluaXRpb25bMF0gOiBkZWZpbml0aW9uLnR5cGU7CiAgICAgICAgICB2YXIgYXZhaWxhYmxlT3ZlcmxvYWRzID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSA/IFtbCiAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25bMV0sCiAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25bMl0KICAgICAgICAgICAgICBdXSA6IGRlZmluaXRpb24ub3ZlcmxvYWRzOwogICAgICAgICAgdmFyIG92ZXJsb2FkcyA9IGF2YWlsYWJsZU92ZXJsb2Fkcy5maWx0ZXIoZnVuY3Rpb24gKHJlZikgewogICAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSByZWZbMF07CiAgICAgICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkgfHwgc2lnbmF0dXJlLmxlbmd0aCA9PT0gYXJncy5sZW5ndGggLSAxOwogICAgICAgICAgfSk7CiAgICAgICAgICB2YXIgc2lnbmF0dXJlQ29udGV4dCA9IG51bGw7CiAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwLCBsaXN0ID0gb3ZlcmxvYWRzOyBpJDMgPCBsaXN0Lmxlbmd0aDsgaSQzICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgcmVmID0gbGlzdFtpJDNdOwogICAgICAgICAgICAgIHZhciBwYXJhbXMgPSByZWZbMF07CiAgICAgICAgICAgICAgdmFyIGV2YWx1YXRlID0gcmVmWzFdOwogICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQgPSBuZXcgUGFyc2luZ0NvbnRleHQoY29udGV4dC5yZWdpc3RyeSwgY29udGV4dC5wYXRoLCBudWxsLCBjb250ZXh0LnNjb3BlKTsKICAgICAgICAgICAgICB2YXIgcGFyc2VkQXJncyA9IFtdOwogICAgICAgICAgICAgIHZhciBhcmdQYXJzZUZhaWxlZCA9IGZhbHNlOwogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTsKICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtc1tpIC0gMV0gOiBwYXJhbXMudHlwZTsKICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHNpZ25hdHVyZUNvbnRleHQucGFyc2UoYXJnLCAxICsgcGFyc2VkQXJncy5sZW5ndGgsIGV4cGVjdGVkVHlwZSk7CiAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7CiAgICAgICAgICAgICAgICAgICAgICBhcmdQYXJzZUZhaWxlZCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGFyZ1BhcnNlRmFpbGVkKSB7CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7CiAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSBwYXJzZWRBcmdzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5lcnJvcignRXhwZWN0ZWQgJyArIHBhcmFtcy5sZW5ndGggKyAnIGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyBwYXJzZWRBcmdzLmxlbmd0aCArICcgaW5zdGVhZC4nKTsKICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBhcnNlZEFyZ3MubGVuZ3RoOyBpJDErKykgewogICAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSBBcnJheS5pc0FycmF5KHBhcmFtcykgPyBwYXJhbXNbaSQxXSA6IHBhcmFtcy50eXBlOwogICAgICAgICAgICAgICAgICB2YXIgYXJnJDEgPSBwYXJzZWRBcmdzW2kkMV07CiAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuY29uY2F0KGkkMSArIDEpLmNoZWNrU3VidHlwZShleHBlY3RlZCwgYXJnJDEudHlwZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzaWduYXR1cmVDb250ZXh0LmVycm9ycy5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZEV4cHJlc3Npb24ob3AsIHR5cGUsIGV2YWx1YXRlLCBwYXJzZWRBcmdzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAob3ZlcmxvYWRzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICAgIChyZWYkMSA9IGNvbnRleHQuZXJyb3JzKS5wdXNoLmFwcGx5KHJlZiQxLCBzaWduYXR1cmVDb250ZXh0LmVycm9ycyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciBleHBlY3RlZCQxID0gb3ZlcmxvYWRzLmxlbmd0aCA/IG92ZXJsb2FkcyA6IGF2YWlsYWJsZU92ZXJsb2FkczsKICAgICAgICAgICAgICB2YXIgc2lnbmF0dXJlcyA9IGV4cGVjdGVkJDEubWFwKGZ1bmN0aW9uIChyZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVNpZ25hdHVyZShwYXJhbXMpOwogICAgICAgICAgICAgIH0pLmpvaW4oJyB8ICcpOwogICAgICAgICAgICAgIHZhciBhY3R1YWxUeXBlcyA9IFtdOwogICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGFyZ3MubGVuZ3RoOyBpJDIrKykgewogICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkJDEgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSQyXSwgMSArIGFjdHVhbFR5cGVzLmxlbmd0aCk7CiAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkJDEpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGFjdHVhbFR5cGVzLnB1c2godG9TdHJpbmcocGFyc2VkJDEudHlwZSkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhcmd1bWVudHMgb2YgdHlwZSAnICsgc2lnbmF0dXJlcyArICcsIGJ1dCBmb3VuZCAoJyArIGFjdHVhbFR5cGVzLmpvaW4oJywgJykgKyAnKSBpbnN0ZWFkLicpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH07CiAgICAgIENvbXBvdW5kRXhwcmVzc2lvbi5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKHJlZ2lzdHJ5LCBkZWZpbml0aW9ucykgewogICAgICAgICAgQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7CiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmluaXRpb25zKSB7CiAgICAgICAgICAgICAgcmVnaXN0cnlbbmFtZV0gPSBDb21wb3VuZEV4cHJlc3Npb247CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVNpZ25hdHVyZShzaWduYXR1cmUpIHsKICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkpIHsKICAgICAgICAgICAgICByZXR1cm4gJygnICsgc2lnbmF0dXJlLm1hcCh0b1N0cmluZykuam9pbignLCAnKSArICcpJzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuICcoJyArIHRvU3RyaW5nKHNpZ25hdHVyZS50eXBlKSArICcuLi4pJzsKICAgICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIENvbGxhdG9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIENvbGxhdG9yRXhwcmVzc2lvbihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkgewogICAgICAgICAgdGhpcy50eXBlID0gQ29sbGF0b3JUeXBlOwogICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7CiAgICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlOwogICAgICAgICAgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUgPSBkaWFjcml0aWNTZW5zaXRpdmU7CiAgICAgIH07CiAgICAgIENvbGxhdG9yRXhwcmVzc2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBvbmUgYXJndW1lbnQuJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMV07CiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ29sbGF0b3Igb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBjYXNlU2Vuc2l0aXZlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10sIDEsIEJvb2xlYW5UeXBlKTsKICAgICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGRpYWNyaXRpY1NlbnNpdGl2ZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snZGlhY3JpdGljLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpOwogICAgICAgICAgaWYgKCFkaWFjcml0aWNTZW5zaXRpdmUpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBsb2NhbGUgPSBudWxsOwogICAgICAgICAgaWYgKG9wdGlvbnNbJ2xvY2FsZSddKSB7CiAgICAgICAgICAgICAgbG9jYWxlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydsb2NhbGUnXSwgMSwgU3RyaW5nVHlwZSk7CiAgICAgICAgICAgICAgaWYgKCFsb2NhbGUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5ldyBDb2xsYXRvckV4cHJlc3Npb24oY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpOwogICAgICB9OwogICAgICBDb2xsYXRvckV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICByZXR1cm4gbmV3IENvbGxhdG9yKHRoaXMuY2FzZVNlbnNpdGl2ZS5ldmFsdWF0ZShjdHgpLCB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5ldmFsdWF0ZShjdHgpLCB0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlLmV2YWx1YXRlKGN0eCkgOiBudWxsKTsKICAgICAgfTsKICAgICAgQ29sbGF0b3JFeHByZXNzaW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgIGZuKHRoaXMuY2FzZVNlbnNpdGl2ZSk7CiAgICAgICAgICBmbih0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSk7CiAgICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHsKICAgICAgICAgICAgICBmbih0aGlzLmxvY2FsZSk7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIENvbGxhdG9yRXhwcmVzc2lvbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07CiAgICAgIENvbGxhdG9yRXhwcmVzc2lvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTsKICAgICAgICAgIG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10gPSB0aGlzLmNhc2VTZW5zaXRpdmUuc2VyaWFsaXplKCk7CiAgICAgICAgICBvcHRpb25zWydkaWFjcml0aWMtc2Vuc2l0aXZlJ10gPSB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5zZXJpYWxpemUoKTsKICAgICAgICAgIGlmICh0aGlzLmxvY2FsZSkgewogICAgICAgICAgICAgIG9wdGlvbnNbJ2xvY2FsZSddID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICdjb2xsYXRvcicsCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgXTsKICAgICAgfTsKCiAgICAgIHZhciBFWFRFTlQgPSA4MTkyOwogICAgICBmdW5jdGlvbiB1cGRhdGVCQm94KGJib3gsIGNvb3JkKSB7CiAgICAgICAgICBiYm94WzBdID0gTWF0aC5taW4oYmJveFswXSwgY29vcmRbMF0pOwogICAgICAgICAgYmJveFsxXSA9IE1hdGgubWluKGJib3hbMV0sIGNvb3JkWzFdKTsKICAgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heChiYm94WzJdLCBjb29yZFswXSk7CiAgICAgICAgICBiYm94WzNdID0gTWF0aC5tYXgoYmJveFszXSwgY29vcmRbMV0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG1lcmNhdG9yWGZyb21MbmcobG5nKSB7CiAgICAgICAgICByZXR1cm4gKDE4MCArIGxuZykgLyAzNjA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbWVyY2F0b3JZZnJvbUxhdChsYXQpIHsKICAgICAgICAgIHJldHVybiAoMTgwIC0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpKSAvIDM2MDsKICAgICAgfQogICAgICBmdW5jdGlvbiBib3hXaXRoaW5Cb3goYmJveDEsIGJib3gyKSB7CiAgICAgICAgICBpZiAoYmJveDFbMF0gPD0gYmJveDJbMF0pIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmJveDFbMl0gPj0gYmJveDJbMl0pIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmJveDFbMV0gPD0gYmJveDJbMV0pIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmJveDFbM10gPj0gYmJveDJbM10pIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRUaWxlQ29vcmRpbmF0ZXMocCwgY2Fub25pY2FsKSB7CiAgICAgICAgICB2YXIgeCA9IG1lcmNhdG9yWGZyb21MbmcocFswXSk7CiAgICAgICAgICB2YXIgeSA9IG1lcmNhdG9yWWZyb21MYXQocFsxXSk7CiAgICAgICAgICB2YXIgdGlsZXNBdFpvb20gPSBNYXRoLnBvdygyLCBjYW5vbmljYWwueik7CiAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgIE1hdGgucm91bmQoeCAqIHRpbGVzQXRab29tICogRVhURU5UKSwKICAgICAgICAgICAgICBNYXRoLnJvdW5kKHkgKiB0aWxlc0F0Wm9vbSAqIEVYVEVOVCkKICAgICAgICAgIF07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb25Cb3VuZGFyeShwLCBwMSwgcDIpIHsKICAgICAgICAgIHZhciB4MSA9IHBbMF0gLSBwMVswXTsKICAgICAgICAgIHZhciB5MSA9IHBbMV0gLSBwMVsxXTsKICAgICAgICAgIHZhciB4MiA9IHBbMF0gLSBwMlswXTsKICAgICAgICAgIHZhciB5MiA9IHBbMV0gLSBwMlsxXTsKICAgICAgICAgIHJldHVybiB4MSAqIHkyIC0geDIgKiB5MSA9PT0gMCAmJiB4MSAqIHgyIDw9IDAgJiYgeTEgKiB5MiA8PSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJheUludGVyc2VjdChwLCBwMSwgcDIpIHsKICAgICAgICAgIHJldHVybiBwMVsxXSA+IHBbMV0gIT09IHAyWzFdID4gcFsxXSAmJiBwWzBdIDwgKHAyWzBdIC0gcDFbMF0pICogKHBbMV0gLSBwMVsxXSkgLyAocDJbMV0gLSBwMVsxXSkgKyBwMVswXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHJpbmdzKSB7CiAgICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2U7CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldOwogICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gcmluZy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7CiAgICAgICAgICAgICAgICAgIGlmIChvbkJvdW5kYXJ5KHBvaW50LCByaW5nW2pdLCByaW5nW2ogKyAxXSkpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAocmF5SW50ZXJzZWN0KHBvaW50LCByaW5nW2pdLCByaW5nW2ogKyAxXSkpIHsKICAgICAgICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gaW5zaWRlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvaW50V2l0aGluUG9seWdvbnMocG9pbnQsIHBvbHlnb25zKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgaWYgKHBvaW50V2l0aGluUG9seWdvbihwb2ludCwgcG9seWdvbnNbaV0pKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwZXJwKHYxLCB2MikgewogICAgICAgICAgcmV0dXJuIHYxWzBdICogdjJbMV0gLSB2MVsxXSAqIHYyWzBdOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHR3b1NpZGVkKHAxLCBwMiwgcTEsIHEyKSB7CiAgICAgICAgICB2YXIgeDEgPSBwMVswXSAtIHExWzBdOwogICAgICAgICAgdmFyIHkxID0gcDFbMV0gLSBxMVsxXTsKICAgICAgICAgIHZhciB4MiA9IHAyWzBdIC0gcTFbMF07CiAgICAgICAgICB2YXIgeTIgPSBwMlsxXSAtIHExWzFdOwogICAgICAgICAgdmFyIHgzID0gcTJbMF0gLSBxMVswXTsKICAgICAgICAgIHZhciB5MyA9IHEyWzFdIC0gcTFbMV07CiAgICAgICAgICB2YXIgZGV0MSA9IHgxICogeTMgLSB4MyAqIHkxOwogICAgICAgICAgdmFyIGRldDIgPSB4MiAqIHkzIC0geDMgKiB5MjsKICAgICAgICAgIGlmIChkZXQxID4gMCAmJiBkZXQyIDwgMCB8fCBkZXQxIDwgMCAmJiBkZXQyID4gMCkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RMaW5lKGEsIGIsIGMsIGQpIHsKICAgICAgICAgIHZhciB2ZWN0b3JQID0gWwogICAgICAgICAgICAgIGJbMF0gLSBhWzBdLAogICAgICAgICAgICAgIGJbMV0gLSBhWzFdCiAgICAgICAgICBdOwogICAgICAgICAgdmFyIHZlY3RvclEgPSBbCiAgICAgICAgICAgICAgZFswXSAtIGNbMF0sCiAgICAgICAgICAgICAgZFsxXSAtIGNbMV0KICAgICAgICAgIF07CiAgICAgICAgICBpZiAocGVycCh2ZWN0b3JRLCB2ZWN0b3JQKSA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0d29TaWRlZChhLCBiLCBjLCBkKSAmJiB0d29TaWRlZChjLCBkLCBhLCBiKSkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RQb2x5Z29uKHAxLCBwMiwgcG9seWdvbikgewogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwb2x5Z29uOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciByaW5nID0gbGlzdFtpXTsKICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoIC0gMTsgKytqKSB7CiAgICAgICAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0TGluZShwMSwgcDIsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGluZVN0cmluZ1dpdGhpblBvbHlnb24obGluZSwgcG9seWdvbikgewogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24obGluZVtpXSwgcG9seWdvbikpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmUubGVuZ3RoIC0gMTsgKytpJDEpIHsKICAgICAgICAgICAgICBpZiAobGluZUludGVyc2VjdFBvbHlnb24obGluZVtpJDFdLCBsaW5lW2kkMSArIDFdLCBwb2x5Z29uKSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGluZVN0cmluZ1dpdGhpblBvbHlnb25zKGxpbmUsIHBvbHlnb25zKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgaWYgKGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb25zW2ldKSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0VGlsZVBvbHlnb24oY29vcmRpbmF0ZXMsIGJib3gsIGNhbm9uaWNhbCkgewogICAgICAgICAgdmFyIHBvbHlnb24gPSBbXTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICB2YXIgcmluZyA9IFtdOwogICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkID0gZ2V0VGlsZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzW2ldW2pdLCBjYW5vbmljYWwpOwogICAgICAgICAgICAgICAgICB1cGRhdGVCQm94KGJib3gsIGNvb3JkKTsKICAgICAgICAgICAgICAgICAgcmluZy5wdXNoKGNvb3JkKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHBvbHlnb247CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0VGlsZVBvbHlnb25zKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHsKICAgICAgICAgIHZhciBwb2x5Z29ucyA9IFtdOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIGJib3gsIGNhbm9uaWNhbCk7CiAgICAgICAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwb2x5Z29uczsKICAgICAgfQogICAgICBmdW5jdGlvbiB1cGRhdGVQb2ludChwLCBiYm94LCBwb2x5QkJveCwgd29ybGRTaXplKSB7CiAgICAgICAgICBpZiAocFswXSA8IHBvbHlCQm94WzBdIHx8IHBbMF0gPiBwb2x5QkJveFsyXSkgewogICAgICAgICAgICAgIHZhciBoYWxmV29ybGRTaXplID0gd29ybGRTaXplICogMC41OwogICAgICAgICAgICAgIHZhciBzaGlmdCA9IHBbMF0gLSBwb2x5QkJveFswXSA+IGhhbGZXb3JsZFNpemUgPyAtd29ybGRTaXplIDogcG9seUJCb3hbMF0gLSBwWzBdID4gaGFsZldvcmxkU2l6ZSA/IHdvcmxkU2l6ZSA6IDA7CiAgICAgICAgICAgICAgaWYgKHNoaWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzJdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFsyXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcFswXSArPSBzaGlmdDsKICAgICAgICAgIH0KICAgICAgICAgIHVwZGF0ZUJCb3goYmJveCwgcCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVzZXRCQm94KGJib3gpIHsKICAgICAgICAgIGJib3hbMF0gPSBiYm94WzFdID0gSW5maW5pdHk7CiAgICAgICAgICBiYm94WzJdID0gYmJveFszXSA9IC1JbmZpbml0eTsKICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRUaWxlUG9pbnRzKGdlb21ldHJ5LCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpIHsKICAgICAgICAgIHZhciB3b3JsZFNpemUgPSBNYXRoLnBvdygyLCBjYW5vbmljYWwueikgKiBFWFRFTlQ7CiAgICAgICAgICB2YXIgc2hpZnRzID0gWwogICAgICAgICAgICAgIGNhbm9uaWNhbC54ICogRVhURU5ULAogICAgICAgICAgICAgIGNhbm9uaWNhbC55ICogRVhURU5UCiAgICAgICAgICBdOwogICAgICAgICAgdmFyIHRpbGVQb2ludHMgPSBbXTsKICAgICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGdlb21ldHJ5OyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkgewogICAgICAgICAgICAgIHZhciBwb2ludHMgPSBsaXN0JDFbaSQxXTsKICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBvaW50czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gbGlzdFtpXTsKICAgICAgICAgICAgICAgICAgdmFyIHAgPSBbCiAgICAgICAgICAgICAgICAgICAgICBwb2ludC54ICsgc2hpZnRzWzBdLAogICAgICAgICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXQogICAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgICAgICB1cGRhdGVQb2ludChwLCBwb2ludEJCb3gsIHBvbHlCQm94LCB3b3JsZFNpemUpOwogICAgICAgICAgICAgICAgICB0aWxlUG9pbnRzLnB1c2gocCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRpbGVQb2ludHM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0VGlsZUxpbmVzKGdlb21ldHJ5LCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCkgewogICAgICAgICAgdmFyIHdvcmxkU2l6ZSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KSAqIEVYVEVOVDsKICAgICAgICAgIHZhciBzaGlmdHMgPSBbCiAgICAgICAgICAgICAgY2Fub25pY2FsLnggKiBFWFRFTlQsCiAgICAgICAgICAgICAgY2Fub25pY2FsLnkgKiBFWFRFTlQKICAgICAgICAgIF07CiAgICAgICAgICB2YXIgdGlsZUxpbmVzID0gW107CiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBnZW9tZXRyeTsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpc3QkMVtpJDFdOwogICAgICAgICAgICAgIHZhciB0aWxlTGluZSA9IFtdOwogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbGluZTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gbGlzdFtpXTsKICAgICAgICAgICAgICAgICAgdmFyIHAgPSBbCiAgICAgICAgICAgICAgICAgICAgICBwb2ludC54ICsgc2hpZnRzWzBdLAogICAgICAgICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXQogICAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgICAgICB1cGRhdGVCQm94KGxpbmVCQm94LCBwKTsKICAgICAgICAgICAgICAgICAgdGlsZUxpbmUucHVzaChwKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGlsZUxpbmVzLnB1c2godGlsZUxpbmUpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGxpbmVCQm94WzJdIC0gbGluZUJCb3hbMF0gPD0gd29ybGRTaXplIC8gMikgewogICAgICAgICAgICAgIHJlc2V0QkJveChsaW5lQkJveCk7CiAgICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMCwgbGlzdCQzID0gdGlsZUxpbmVzOyBpJDMgPCBsaXN0JDMubGVuZ3RoOyBpJDMgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgbGluZSQxID0gbGlzdCQzW2kkM107CiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QkMiA9IGxpbmUkMTsgaSQyIDwgbGlzdCQyLmxlbmd0aDsgaSQyICs9IDEpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBwJDEgPSBsaXN0JDJbaSQyXTsKICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVBvaW50KHAkMSwgbGluZUJCb3gsIHBvbHlCQm94LCB3b3JsZFNpemUpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRpbGVMaW5lczsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb2ludHNXaXRoaW5Qb2x5Z29ucyhjdHgsIHBvbHlnb25HZW9tZXRyeSkgewogICAgICAgICAgdmFyIHBvaW50QkJveCA9IFsKICAgICAgICAgICAgICBJbmZpbml0eSwKICAgICAgICAgICAgICBJbmZpbml0eSwKICAgICAgICAgICAgICAtSW5maW5pdHksCiAgICAgICAgICAgICAgLUluZmluaXR5CiAgICAgICAgICBdOwogICAgICAgICAgdmFyIHBvbHlCQm94ID0gWwogICAgICAgICAgICAgIEluZmluaXR5LAogICAgICAgICAgICAgIEluZmluaXR5LAogICAgICAgICAgICAgIC1JbmZpbml0eSwKICAgICAgICAgICAgICAtSW5maW5pdHkKICAgICAgICAgIF07CiAgICAgICAgICB2YXIgY2Fub25pY2FsID0gY3R4LmNhbm9uaWNhbElEKCk7CiAgICAgICAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykgewogICAgICAgICAgICAgIHZhciB0aWxlUG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7CiAgICAgICAgICAgICAgdmFyIHRpbGVQb2ludHMgPSBnZXRUaWxlUG9pbnRzKGN0eC5nZW9tZXRyeSgpLCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICAgIGlmICghYm94V2l0aGluQm94KHBvaW50QkJveCwgcG9seUJCb3gpKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aWxlUG9pbnRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBsaXN0W2ldOwogICAgICAgICAgICAgICAgICBpZiAoIXBvaW50V2l0aGluUG9seWdvbihwb2ludCwgdGlsZVBvbHlnb24pKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7CiAgICAgICAgICAgICAgdmFyIHRpbGVQb2x5Z29ucyA9IGdldFRpbGVQb2x5Z29ucyhwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICAgIHZhciB0aWxlUG9pbnRzJDEgPSBnZXRUaWxlUG9pbnRzKGN0eC5nZW9tZXRyeSgpLCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICAgIGlmICghYm94V2l0aGluQm94KHBvaW50QkJveCwgcG9seUJCb3gpKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gdGlsZVBvaW50cyQxOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgcG9pbnQkMSA9IGxpc3QkMVtpJDFdOwogICAgICAgICAgICAgICAgICBpZiAoIXBvaW50V2l0aGluUG9seWdvbnMocG9pbnQkMSwgdGlsZVBvbHlnb25zKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGluZXNXaXRoaW5Qb2x5Z29ucyhjdHgsIHBvbHlnb25HZW9tZXRyeSkgewogICAgICAgICAgdmFyIGxpbmVCQm94ID0gWwogICAgICAgICAgICAgIEluZmluaXR5LAogICAgICAgICAgICAgIEluZmluaXR5LAogICAgICAgICAgICAgIC1JbmZpbml0eSwKICAgICAgICAgICAgICAtSW5maW5pdHkKICAgICAgICAgIF07CiAgICAgICAgICB2YXIgcG9seUJCb3ggPSBbCiAgICAgICAgICAgICAgSW5maW5pdHksCiAgICAgICAgICAgICAgSW5maW5pdHksCiAgICAgICAgICAgICAgLUluZmluaXR5LAogICAgICAgICAgICAgIC1JbmZpbml0eQogICAgICAgICAgXTsKICAgICAgICAgIHZhciBjYW5vbmljYWwgPSBjdHguY2Fub25pY2FsSUQoKTsKICAgICAgICAgIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7CiAgICAgICAgICAgICAgdmFyIHRpbGVQb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24ocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTsKICAgICAgICAgICAgICB2YXIgdGlsZUxpbmVzID0gZ2V0VGlsZUxpbmVzKGN0eC5nZW9tZXRyeSgpLCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7CiAgICAgICAgICAgICAgaWYgKCFib3hXaXRoaW5Cb3gobGluZUJCb3gsIHBvbHlCQm94KSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGlsZUxpbmVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpc3RbaV07CiAgICAgICAgICAgICAgICAgIGlmICghbGluZVN0cmluZ1dpdGhpblBvbHlnb24obGluZSwgdGlsZVBvbHlnb24pKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7CiAgICAgICAgICAgICAgdmFyIHRpbGVQb2x5Z29ucyA9IGdldFRpbGVQb2x5Z29ucyhwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICAgIHZhciB0aWxlTGluZXMkMSA9IGdldFRpbGVMaW5lcyhjdHguZ2VvbWV0cnkoKSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpOwogICAgICAgICAgICAgIGlmICghYm94V2l0aGluQm94KGxpbmVCQm94LCBwb2x5QkJveCkpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSB0aWxlTGluZXMkMTsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIGxpbmUkMSA9IGxpc3QkMVtpJDFdOwogICAgICAgICAgICAgICAgICBpZiAoIWxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29ucyhsaW5lJDEsIHRpbGVQb2x5Z29ucykpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIHZhciBXaXRoaW4gPSBmdW5jdGlvbiBXaXRoaW4oZ2VvanNvbiwgZ2VvbWV0cmllcykgewogICAgICAgICAgdGhpcy50eXBlID0gQm9vbGVhblR5cGU7CiAgICAgICAgICB0aGlzLmdlb2pzb24gPSBnZW9qc29uOwogICAgICAgICAgdGhpcy5nZW9tZXRyaWVzID0gZ2VvbWV0cmllczsKICAgICAgfTsKICAgICAgV2l0aGluLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1wnd2l0aGluXCcgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpc1ZhbHVlKGFyZ3NbMV0pKSB7CiAgICAgICAgICAgICAgdmFyIGdlb2pzb24gPSBhcmdzWzFdOwogICAgICAgICAgICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHsKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGdlb2pzb24uZmVhdHVyZXNbaV0uZ2VvbWV0cnkudHlwZTsKICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnUG9seWdvbicgfHwgdHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpdGhpbihnZW9qc29uLCBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5KTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHsKICAgICAgICAgICAgICAgICAgdmFyIHR5cGUkMSA9IGdlb2pzb24uZ2VvbWV0cnkudHlwZTsKICAgICAgICAgICAgICAgICAgaWYgKHR5cGUkMSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUkMSA9PT0gJ011bHRpUG9seWdvbicpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24uZ2VvbWV0cnkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9qc29uLnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9qc29uLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24pOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdcJ3dpdGhpblwnIGV4cHJlc3Npb24gcmVxdWlyZXMgdmFsaWQgZ2VvanNvbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2x5Z29uIGdlb21ldHJ5IHR5cGUuJyk7CiAgICAgIH07CiAgICAgIFdpdGhpbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIGlmIChjdHguZ2VvbWV0cnkoKSAhPSBudWxsICYmIGN0eC5jYW5vbmljYWxJRCgpICE9IG51bGwpIHsKICAgICAgICAgICAgICBpZiAoY3R4Lmdlb21ldHJ5VHlwZSgpID09PSAnUG9pbnQnKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdHguZ2VvbWV0cnlUeXBlKCkgPT09ICdMaW5lU3RyaW5nJykgewogICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgICBXaXRoaW4ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZCgpIHsKICAgICAgfTsKICAgICAgV2l0aGluLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBXaXRoaW4ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgJ3dpdGhpbicsCiAgICAgICAgICAgICAgdGhpcy5nZW9qc29uCiAgICAgICAgICBdOwogICAgICB9OwoKICAgICAgZnVuY3Rpb24gaXNGZWF0dXJlQ29uc3RhbnQoZSkgewogICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24pIHsKICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSAnZ2V0JyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ2ZlYXR1cmUtc3RhdGUnKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ2hhcycgJiYgZS5hcmdzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdwcm9wZXJ0aWVzJyB8fCBlLm5hbWUgPT09ICdnZW9tZXRyeS10eXBlJyB8fCBlLm5hbWUgPT09ICdpZCcpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoL15maWx0ZXItLy50ZXN0KGUubmFtZSkpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgV2l0aGluKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7CiAgICAgICAgICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7CiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNGZWF0dXJlQ29uc3RhbnQoYXJnKSkgewogICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNTdGF0ZUNvbnN0YW50KGUpIHsKICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uKSB7CiAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ2ZlYXR1cmUtc3RhdGUnKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTsKICAgICAgICAgIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChhcmcpIHsKICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmICFpc1N0YXRlQ29uc3RhbnQoYXJnKSkgewogICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGUsIHByb3BlcnRpZXMpIHsKICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIHByb3BlcnRpZXMuaW5kZXhPZihlLm5hbWUpID49IDApIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTsKICAgICAgICAgIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChhcmcpIHsKICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmICFpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoYXJnLCBwcm9wZXJ0aWVzKSkgewogICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KCiAgICAgIHZhciBWYXIgPSBmdW5jdGlvbiBWYXIobmFtZSwgYm91bmRFeHByZXNzaW9uKSB7CiAgICAgICAgICB0aGlzLnR5cGUgPSBib3VuZEV4cHJlc3Npb24udHlwZTsKICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgICAgICB0aGlzLmJvdW5kRXhwcmVzc2lvbiA9IGJvdW5kRXhwcmVzc2lvbjsKICAgICAgfTsKICAgICAgVmFyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyIHx8IHR5cGVvZiBhcmdzWzFdICE9PSAnc3RyaW5nJykgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdcJ3ZhclwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbmFtZSA9IGFyZ3NbMV07CiAgICAgICAgICBpZiAoIWNvbnRleHQuc2NvcGUuaGFzKG5hbWUpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1Vua25vd24gdmFyaWFibGUgIicgKyBuYW1lICsgJyIuIE1ha2Ugc3VyZSAiJyArIG5hbWUgKyAnIiBoYXMgYmVlbiBib3VuZCBpbiBhbiBlbmNsb3NpbmcgImxldCIgZXhwcmVzc2lvbiBiZWZvcmUgdXNpbmcgaXQuJywgMSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbmV3IFZhcihuYW1lLCBjb250ZXh0LnNjb3BlLmdldChuYW1lKSk7CiAgICAgIH07CiAgICAgIFZhci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kRXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpOwogICAgICB9OwogICAgICBWYXIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZCgpIHsKICAgICAgfTsKICAgICAgVmFyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfTsKICAgICAgVmFyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7CiAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICd2YXInLAogICAgICAgICAgICAgIHRoaXMubmFtZQogICAgICAgICAgXTsKICAgICAgfTsKCiAgICAgIHZhciBQYXJzaW5nQ29udGV4dCA9IGZ1bmN0aW9uIFBhcnNpbmdDb250ZXh0KHJlZ2lzdHJ5LCBwYXRoLCBleHBlY3RlZFR5cGUsIHNjb3BlLCBlcnJvcnMpIHsKICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApCiAgICAgICAgICAgICAgcGF0aCA9IFtdOwogICAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApCiAgICAgICAgICAgICAgc2NvcGUgPSBuZXcgU2NvcGUoKTsKICAgICAgICAgIGlmIChlcnJvcnMgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBlcnJvcnMgPSBbXTsKICAgICAgICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTsKICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7CiAgICAgICAgICB0aGlzLmtleSA9IHBhdGgubWFwKGZ1bmN0aW9uIChwYXJ0KSB7CiAgICAgICAgICAgICAgcmV0dXJuICdbJyArIHBhcnQgKyAnXSc7CiAgICAgICAgICB9KS5qb2luKCcnKTsKICAgICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTsKICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzOwogICAgICAgICAgdGhpcy5leHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7CiAgICAgIH07CiAgICAgIFBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGV4cHIsIGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzLCBvcHRpb25zKSB7CiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgICAgIGlmIChpbmRleCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmNhdChpbmRleCwgZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncykuX3BhcnNlKGV4cHIsIG9wdGlvbnMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlKGV4cHIsIG9wdGlvbnMpOwogICAgICB9OwogICAgICBQYXJzaW5nQ29udGV4dC5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gX3BhcnNlKGV4cHIsIG9wdGlvbnMpIHsKICAgICAgICAgIGlmIChleHByID09PSBudWxsIHx8IHR5cGVvZiBleHByID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXhwciA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBleHByID09PSAnbnVtYmVyJykgewogICAgICAgICAgICAgIGV4cHIgPSBbCiAgICAgICAgICAgICAgICAgICdsaXRlcmFsJywKICAgICAgICAgICAgICAgICAgZXhwcgogICAgICAgICAgICAgIF07CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBhbm5vdGF0ZShwYXJzZWQsIHR5cGUsIHR5cGVBbm5vdGF0aW9uKSB7CiAgICAgICAgICAgICAgaWYgKHR5cGVBbm5vdGF0aW9uID09PSAnYXNzZXJ0JykgewogICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0eXBlLCBbcGFyc2VkXSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2NvZXJjZScpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2VyY2lvbih0eXBlLCBbcGFyc2VkXSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHByKSkgewogICAgICAgICAgICAgIGlmIChleHByLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbImxpdGVyYWwiLCBbXV0uJyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBvcCA9IGV4cHJbMF07CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcCAhPT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignRXhwcmVzc2lvbiBuYW1lIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdHlwZW9mIG9wICsgJyBpbnN0ZWFkLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFsibGl0ZXJhbCIsIFsuLi5dXS4nLCAwKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBFeHByID0gdGhpcy5yZWdpc3RyeVtvcF07CiAgICAgICAgICAgICAgaWYgKEV4cHIpIHsKICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEV4cHIucGFyc2UoZXhwciwgdGhpcyk7CiAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAodGhpcy5leHBlY3RlZFR5cGUpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IHRoaXMuZXhwZWN0ZWRUeXBlOwogICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHBhcnNlZC50eXBlOwogICAgICAgICAgICAgICAgICAgICAgaWYgKChleHBlY3RlZC5raW5kID09PSAnc3RyaW5nJyB8fCBleHBlY3RlZC5raW5kID09PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5raW5kID09PSAnYm9vbGVhbicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2FycmF5JykgJiYgYWN0dWFsLmtpbmQgPT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdhc3NlcnQnKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGV4cGVjdGVkLmtpbmQgPT09ICdjb2xvcicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2Zvcm1hdHRlZCcgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSAmJiAoYWN0dWFsLmtpbmQgPT09ICd2YWx1ZScgfHwgYWN0dWFsLmtpbmQgPT09ICdzdHJpbmcnKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGFubm90YXRlKHBhcnNlZCwgZXhwZWN0ZWQsIG9wdGlvbnMudHlwZUFubm90YXRpb24gfHwgJ2NvZXJjZScpOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrU3VidHlwZShleHBlY3RlZCwgYWN0dWFsKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICghKHBhcnNlZCBpbnN0YW5jZW9mIExpdGVyYWwpICYmIHBhcnNlZC50eXBlLmtpbmQgIT09ICdyZXNvbHZlZEltYWdlJyAmJiBpc0NvbnN0YW50KHBhcnNlZCkpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBlYyA9IG5ldyBFdmFsdWF0aW9uQ29udGV4dCgpOwogICAgICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBuZXcgTGl0ZXJhbChwYXJzZWQudHlwZSwgcGFyc2VkLmV2YWx1YXRlKGVjKSk7CiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlLm1lc3NhZ2UpOwogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbmtub3duIGV4cHJlc3Npb24gIicgKyBvcCArICciLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFsibGl0ZXJhbCIsIFsuLi5dXS4nLCAwKTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1wndW5kZWZpbmVkXCcgdmFsdWUgaW52YWxpZC4gVXNlIG51bGwgaW5zdGVhZC4nKTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0JhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgWyJsaXRlcmFsIiwgey4uLn1dIGluc3RlYWQuJyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSwgYnV0IGZvdW5kICcgKyB0eXBlb2YgZXhwciArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgfTsKICAgICAgUGFyc2luZ0NvbnRleHQucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChpbmRleCwgZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncykgewogICAgICAgICAgdmFyIHBhdGggPSB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gdGhpcy5wYXRoLmNvbmNhdChpbmRleCkgOiB0aGlzLnBhdGg7CiAgICAgICAgICB2YXIgc2NvcGUgPSBiaW5kaW5ncyA/IHRoaXMuc2NvcGUuY29uY2F0KGJpbmRpbmdzKSA6IHRoaXMuc2NvcGU7CiAgICAgICAgICByZXR1cm4gbmV3IFBhcnNpbmdDb250ZXh0KHRoaXMucmVnaXN0cnksIHBhdGgsIGV4cGVjdGVkVHlwZSB8fCBudWxsLCBzY29wZSwgdGhpcy5lcnJvcnMpOwogICAgICB9OwogICAgICBQYXJzaW5nQ29udGV4dC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnJvciQxKSB7CiAgICAgICAgICB2YXIga2V5cyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsKICAgICAgICAgIHdoaWxlIChsZW4tLSA+IDApCiAgICAgICAgICAgICAga2V5c1tsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdOwogICAgICAgICAgdmFyIGtleSA9ICcnICsgdGhpcy5rZXkgKyBrZXlzLm1hcChmdW5jdGlvbiAoaykgewogICAgICAgICAgICAgIHJldHVybiAnWycgKyBrICsgJ10nOwogICAgICAgICAgfSkuam9pbignJyk7CiAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzaW5nRXJyb3Ioa2V5LCBlcnJvciQxKSk7CiAgICAgIH07CiAgICAgIFBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5jaGVja1N1YnR5cGUgPSBmdW5jdGlvbiBjaGVja1N1YnR5cGUkMShleHBlY3RlZCwgdCkgewogICAgICAgICAgdmFyIGVycm9yID0gY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCB0KTsKICAgICAgICAgIGlmIChlcnJvcikgewogICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGVycm9yOwogICAgICB9OwogICAgICBmdW5jdGlvbiBpc0NvbnN0YW50KGV4cHJlc3Npb24pIHsKICAgICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgVmFyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGlzQ29uc3RhbnQoZXhwcmVzc2lvbi5ib3VuZEV4cHJlc3Npb24pOwogICAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIGV4cHJlc3Npb24ubmFtZSA9PT0gJ2Vycm9yJykgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvbGxhdG9yRXhwcmVzc2lvbikgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFdpdGhpbikgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpc1R5cGVBbm5vdGF0aW9uID0gZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvZXJjaW9uIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBBc3NlcnRpb247CiAgICAgICAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IHRydWU7CiAgICAgICAgICBleHByZXNzaW9uLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHsKICAgICAgICAgICAgICBpZiAoaXNUeXBlQW5ub3RhdGlvbikgewogICAgICAgICAgICAgICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBpc0NvbnN0YW50KGNoaWxkKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBjaGlsZCBpbnN0YW5jZW9mIExpdGVyYWw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBpZiAoIWNoaWxkcmVuQ29uc3RhbnQpIHsKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gaXNGZWF0dXJlQ29uc3RhbnQoZXhwcmVzc2lvbikgJiYgaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGV4cHJlc3Npb24sIFsKICAgICAgICAgICAgICAnem9vbScsCiAgICAgICAgICAgICAgJ2hlYXRtYXAtZGVuc2l0eScsCiAgICAgICAgICAgICAgJ2xpbmUtcHJvZ3Jlc3MnLAogICAgICAgICAgICAgICdhY2N1bXVsYXRlZCcsCiAgICAgICAgICAgICAgJ2lzLXN1cHBvcnRlZC1zY3JpcHQnCiAgICAgICAgICBdKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhzdG9wcywgaW5wdXQpIHsKICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBzdG9wcy5sZW5ndGggLSAxOwogICAgICAgICAgdmFyIGxvd2VySW5kZXggPSAwOwogICAgICAgICAgdmFyIHVwcGVySW5kZXggPSBsYXN0SW5kZXg7CiAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gMDsKICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUsIG5leHRWYWx1ZTsKICAgICAgICAgIHdoaWxlIChsb3dlckluZGV4IDw9IHVwcGVySW5kZXgpIHsKICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBNYXRoLmZsb29yKChsb3dlckluZGV4ICsgdXBwZXJJbmRleCkgLyAyKTsKICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXhdOwogICAgICAgICAgICAgIG5leHRWYWx1ZSA9IHN0b3BzW2N1cnJlbnRJbmRleCArIDFdOwogICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPD0gaW5wdXQpIHsKICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gbGFzdEluZGV4IHx8IGlucHV0IDwgbmV4dFZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEluZGV4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjdXJyZW50SW5kZXggKyAxOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gaW5wdXQpIHsKICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignSW5wdXQgaXMgbm90IGEgbnVtYmVyLicpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAwOwogICAgICB9CgogICAgICB2YXIgU3RlcCA9IGZ1bmN0aW9uIFN0ZXAodHlwZSwgaW5wdXQsIHN0b3BzKSB7CiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0OwogICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTsKICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtdOwogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTsKICAgICAgICAgICAgICB2YXIgbGFiZWwgPSByZWZbMF07CiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSByZWZbMV07CiAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7CiAgICAgICAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIFN0ZXAucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggLSAxIDwgNCkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJy4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoYXJncy5sZW5ndGggLSAxKSAlIDIgIT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLicpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTsKICAgICAgICAgIGlmICghaW5wdXQpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBzdG9wcyA9IFtdOwogICAgICAgICAgdmFyIG91dHB1dFR5cGUgPSBudWxsOwogICAgICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHsKICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBpID09PSAxID8gLUluZmluaXR5IDogYXJnc1tpXTsKICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcmdzW2kgKyAxXTsKICAgICAgICAgICAgICB2YXIgbGFiZWxLZXkgPSBpOwogICAgICAgICAgICAgIHZhciB2YWx1ZUtleSA9IGkgKyAxOwogICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yICJzdGVwIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCBsYWJlbEtleSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzdG9wcy5sZW5ndGggJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMF0gPj0gbGFiZWwpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgInN0ZXAiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGxhYmVsS2V5KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGNvbnRleHQucGFyc2UodmFsdWUsIHZhbHVlS2V5LCBvdXRwdXRUeXBlKTsKICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7CiAgICAgICAgICAgICAgc3RvcHMucHVzaChbCiAgICAgICAgICAgICAgICAgIGxhYmVsLAogICAgICAgICAgICAgICAgICBwYXJzZWQKICAgICAgICAgICAgICBdKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgU3RlcChvdXRwdXRUeXBlLCBpbnB1dCwgc3RvcHMpOwogICAgICB9OwogICAgICBTdGVwLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzOwogICAgICAgICAgdmFyIG91dHB1dHMgPSB0aGlzLm91dHB1dHM7CiAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICBpZiAodmFsdWUgPD0gbGFiZWxzWzBdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBzdG9wQ291bnQgPSBsYWJlbHMubGVuZ3RoOwogICAgICAgICAgaWYgKHZhbHVlID49IGxhYmVsc1tzdG9wQ291bnQgLSAxXSkgewogICAgICAgICAgICAgIHJldHVybiBvdXRwdXRzW3N0b3BDb3VudCAtIDFdLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKGxhYmVscywgdmFsdWUpOwogICAgICAgICAgcmV0dXJuIG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7CiAgICAgIH07CiAgICAgIFN0ZXAucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgZm4odGhpcy5pbnB1dCk7CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMub3V0cHV0czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGxpc3RbaV07CiAgICAgICAgICAgICAgZm4oZXhwcmVzc2lvbik7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIFN0ZXAucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAob3V0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7CiAgICAgICAgICB9KTsKICAgICAgfTsKICAgICAgU3RlcC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbCiAgICAgICAgICAgICAgJ3N0ZXAnLAogICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKCkKICAgICAgICAgIF07CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7CiAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLmxhYmVsc1tpXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbaV0uc2VyaWFsaXplKCkpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7CiAgICAgIH07CgogICAgICAvKgogICAgICAgKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLgogICAgICAgKgogICAgICAgKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQKICAgICAgICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zCiAgICAgICAqIGFyZSBtZXQ6CiAgICAgICAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0CiAgICAgICAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci4KICAgICAgICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQKICAgICAgICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZQogICAgICAgKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLgogICAgICAgKgogICAgICAgKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEFQUExFIElOQy4gYGBBUyBJUycnIEFORCBBTlkKICAgICAgICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUKICAgICAgICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSCiAgICAgICAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBBUFBMRSBJTkMuIE9SCiAgICAgICAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLAogICAgICAgKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sCiAgICAgICAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUgogICAgICAgKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZCiAgICAgICAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVAogICAgICAgKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UKICAgICAgICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4KICAgICAgICoKICAgICAgICogUG9ydGVkIGZyb20gV2Via2l0CiAgICAgICAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmgKICAgICAgICovCgogICAgICB2YXIgdW5pdGJlemllciA9IFVuaXRCZXppZXI7CgogICAgICBmdW5jdGlvbiBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSkgewogICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS4KICAgICAgICAgIHRoaXMuY3ggPSAzLjAgKiBwMXg7CiAgICAgICAgICB0aGlzLmJ4ID0gMy4wICogKHAyeCAtIHAxeCkgLSB0aGlzLmN4OwogICAgICAgICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4OwoKICAgICAgICAgIHRoaXMuY3kgPSAzLjAgKiBwMXk7CiAgICAgICAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5OwogICAgICAgICAgdGhpcy5heSA9IDEuMCAtIHRoaXMuY3kgLSB0aGlzLmJ5OwoKICAgICAgICAgIHRoaXMucDF4ID0gcDF4OwogICAgICAgICAgdGhpcy5wMXkgPSBwMnk7CiAgICAgICAgICB0aGlzLnAyeCA9IHAyeDsKICAgICAgICAgIHRoaXMucDJ5ID0gcDJ5OwogICAgICB9CgogICAgICBVbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7CiAgICAgICAgICAvLyBgYXggdF4zICsgYnggdF4yICsgY3ggdCcgZXhwYW5kZWQgdXNpbmcgSG9ybmVyJ3MgcnVsZS4KICAgICAgICAgIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0OwogICAgICB9OwoKICAgICAgVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVZID0gZnVuY3Rpb24odCkgewogICAgICAgICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7CiAgICAgIH07CgogICAgICBVbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkgewogICAgICAgICAgcmV0dXJuICgzLjAgKiB0aGlzLmF4ICogdCArIDIuMCAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7CiAgICAgIH07CgogICAgICBVbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHsKICAgICAgICAgIGlmICh0eXBlb2YgZXBzaWxvbiA9PT0gJ3VuZGVmaW5lZCcpIHsgZXBzaWxvbiA9IDFlLTY7IH0KCiAgICAgICAgICB2YXIgdDAsIHQxLCB0MiwgeDIsIGk7CgogICAgICAgICAgLy8gRmlyc3QgdHJ5IGEgZmV3IGl0ZXJhdGlvbnMgb2YgTmV3dG9uJ3MgbWV0aG9kIC0tIG5vcm1hbGx5IHZlcnkgZmFzdC4KICAgICAgICAgIGZvciAodDIgPSB4LCBpID0gMDsgaSA8IDg7IGkrKykgewoKICAgICAgICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKSAtIHg7CiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IGVwc2lsb24pIHsgcmV0dXJuIHQyOyB9CgogICAgICAgICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7CiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGQyKSA8IDFlLTYpIHsgYnJlYWs7IH0KCiAgICAgICAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7CiAgICAgICAgICB9CgogICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS4KICAgICAgICAgIHQwID0gMC4wOwogICAgICAgICAgdDEgPSAxLjA7CiAgICAgICAgICB0MiA9IHg7CgogICAgICAgICAgaWYgKHQyIDwgdDApIHsgcmV0dXJuIHQwOyB9CiAgICAgICAgICBpZiAodDIgPiB0MSkgeyByZXR1cm4gdDE7IH0KCiAgICAgICAgICB3aGlsZSAodDAgPCB0MSkgewoKICAgICAgICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKTsKICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHsgcmV0dXJuIHQyOyB9CgogICAgICAgICAgICAgIGlmICh4ID4geDIpIHsKICAgICAgICAgICAgICAgICAgdDAgPSB0MjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB0MSA9IHQyOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdDIgPSAodDEgLSB0MCkgKiAwLjUgKyB0MDsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyBGYWlsdXJlLgogICAgICAgICAgcmV0dXJuIHQyOwogICAgICB9OwoKICAgICAgVW5pdEJlemllci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7CiAgICAgIH07CgogICAgICBmdW5jdGlvbiBudW1iZXIoYSwgYiwgdCkgewogICAgICAgICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29sb3IoZnJvbSwgdG8sIHQpIHsKICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobnVtYmVyKGZyb20uciwgdG8uciwgdCksIG51bWJlcihmcm9tLmcsIHRvLmcsIHQpLCBudW1iZXIoZnJvbS5iLCB0by5iLCB0KSwgbnVtYmVyKGZyb20uYSwgdG8uYSwgdCkpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFycmF5JDEoZnJvbSwgdG8sIHQpIHsKICAgICAgICAgIHJldHVybiBmcm9tLm1hcChmdW5jdGlvbiAoZCwgaSkgewogICAgICAgICAgICAgIHJldHVybiBudW1iZXIoZCwgdG9baV0sIHQpOwogICAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHsKICAgICAgICBfX3Byb3RvX186IG51bGwsCiAgICAgICAgbnVtYmVyOiBudW1iZXIsCiAgICAgICAgY29sb3I6IGNvbG9yLAogICAgICAgIGFycmF5OiBhcnJheSQxCiAgICAgIH0pOwoKICAgICAgdmFyIFhuID0gMC45NTA0NywgWW4gPSAxLCBabiA9IDEuMDg4ODMsIHQwID0gNCAvIDI5LCB0MSA9IDYgLyAyOSwgdDIgPSAzICogdDEgKiB0MSwgdDMgPSB0MSAqIHQxICogdDEsIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwLCByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTsKICAgICAgZnVuY3Rpb24geHl6MmxhYih0KSB7CiAgICAgICAgICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGFiMnh5eih0KSB7CiAgICAgICAgICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB4eXoycmdiKHgpIHsKICAgICAgICAgIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJnYjJ4eXooeCkgewogICAgICAgICAgeCAvPSAyNTU7CiAgICAgICAgICByZXR1cm4geCA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZ2JUb0xhYihyZ2JDb2xvcikgewogICAgICAgICAgdmFyIGIgPSByZ2IyeHl6KHJnYkNvbG9yLnIpLCBhID0gcmdiMnh5eihyZ2JDb2xvci5nKSwgbCA9IHJnYjJ4eXoocmdiQ29sb3IuYiksIHggPSB4eXoybGFiKCgwLjQxMjQ1NjQgKiBiICsgMC4zNTc1NzYxICogYSArIDAuMTgwNDM3NSAqIGwpIC8gWG4pLCB5ID0geHl6MmxhYigoMC4yMTI2NzI5ICogYiArIDAuNzE1MTUyMiAqIGEgKyAwLjA3MjE3NSAqIGwpIC8gWW4pLCB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogYiArIDAuMTE5MTkyICogYSArIDAuOTUwMzA0MSAqIGwpIC8gWm4pOwogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBsOiAxMTYgKiB5IC0gMTYsCiAgICAgICAgICAgICAgYTogNTAwICogKHggLSB5KSwKICAgICAgICAgICAgICBiOiAyMDAgKiAoeSAtIHopLAogICAgICAgICAgICAgIGFscGhhOiByZ2JDb2xvci5hCiAgICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxhYlRvUmdiKGxhYkNvbG9yKSB7CiAgICAgICAgICB2YXIgeSA9IChsYWJDb2xvci5sICsgMTYpIC8gMTE2LCB4ID0gaXNOYU4obGFiQ29sb3IuYSkgPyB5IDogeSArIGxhYkNvbG9yLmEgLyA1MDAsIHogPSBpc05hTihsYWJDb2xvci5iKSA/IHkgOiB5IC0gbGFiQ29sb3IuYiAvIDIwMDsKICAgICAgICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7CiAgICAgICAgICB4ID0gWG4gKiBsYWIyeHl6KHgpOwogICAgICAgICAgeiA9IFpuICogbGFiMnh5eih6KTsKICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoeHl6MnJnYigzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIDAuNDk4NTMxNCAqIHopLCB4eXoycmdiKC0wLjk2OTI2NiAqIHggKyAxLjg3NjAxMDggKiB5ICsgMC4wNDE1NTYgKiB6KSwgeHl6MnJnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopLCBsYWJDb2xvci5hbHBoYSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVMYWIoZnJvbSwgdG8sIHQpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgbDogbnVtYmVyKGZyb20ubCwgdG8ubCwgdCksCiAgICAgICAgICAgICAgYTogbnVtYmVyKGZyb20uYSwgdG8uYSwgdCksCiAgICAgICAgICAgICAgYjogbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksCiAgICAgICAgICAgICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdCkKICAgICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmdiVG9IY2wocmdiQ29sb3IpIHsKICAgICAgICAgIHZhciByZWYgPSByZ2JUb0xhYihyZ2JDb2xvcik7CiAgICAgICAgICB2YXIgbCA9IHJlZi5sOwogICAgICAgICAgdmFyIGEgPSByZWYuYTsKICAgICAgICAgIHZhciBiID0gcmVmLmI7CiAgICAgICAgICB2YXIgaCA9IE1hdGguYXRhbjIoYiwgYSkgKiByYWQyZGVnOwogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBoOiBoIDwgMCA/IGggKyAzNjAgOiBoLAogICAgICAgICAgICAgIGM6IE1hdGguc3FydChhICogYSArIGIgKiBiKSwKICAgICAgICAgICAgICBsOiBsLAogICAgICAgICAgICAgIGFscGhhOiByZ2JDb2xvci5hCiAgICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGhjbFRvUmdiKGhjbENvbG9yKSB7CiAgICAgICAgICB2YXIgaCA9IGhjbENvbG9yLmggKiBkZWcycmFkLCBjID0gaGNsQ29sb3IuYywgbCA9IGhjbENvbG9yLmw7CiAgICAgICAgICByZXR1cm4gbGFiVG9SZ2IoewogICAgICAgICAgICAgIGw6IGwsCiAgICAgICAgICAgICAgYTogTWF0aC5jb3MoaCkgKiBjLAogICAgICAgICAgICAgIGI6IE1hdGguc2luKGgpICogYywKICAgICAgICAgICAgICBhbHBoYTogaGNsQ29sb3IuYWxwaGEKICAgICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlSHVlKGEsIGIsIHQpIHsKICAgICAgICAgIHZhciBkID0gYiAtIGE7CiAgICAgICAgICByZXR1cm4gYSArIHQgKiAoZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIY2woZnJvbSwgdG8sIHQpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgaDogaW50ZXJwb2xhdGVIdWUoZnJvbS5oLCB0by5oLCB0KSwKICAgICAgICAgICAgICBjOiBudW1iZXIoZnJvbS5jLCB0by5jLCB0KSwKICAgICAgICAgICAgICBsOiBudW1iZXIoZnJvbS5sLCB0by5sLCB0KSwKICAgICAgICAgICAgICBhbHBoYTogbnVtYmVyKGZyb20uYWxwaGEsIHRvLmFscGhhLCB0KQogICAgICAgICAgfTsKICAgICAgfQogICAgICB2YXIgbGFiID0gewogICAgICAgICAgZm9yd2FyZDogcmdiVG9MYWIsCiAgICAgICAgICByZXZlcnNlOiBsYWJUb1JnYiwKICAgICAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZUxhYgogICAgICB9OwogICAgICB2YXIgaGNsID0gewogICAgICAgICAgZm9yd2FyZDogcmdiVG9IY2wsCiAgICAgICAgICByZXZlcnNlOiBoY2xUb1JnYiwKICAgICAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZUhjbAogICAgICB9OwoKICAgICAgdmFyIGNvbG9yU3BhY2VzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoewogICAgICAgIF9fcHJvdG9fXzogbnVsbCwKICAgICAgICBsYWI6IGxhYiwKICAgICAgICBoY2w6IGhjbAogICAgICB9KTsKCiAgICAgIHZhciBJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIEludGVycG9sYXRlKHR5cGUsIG9wZXJhdG9yLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgc3RvcHMpIHsKICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7CiAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uOwogICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0OwogICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTsKICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtdOwogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTsKICAgICAgICAgICAgICB2YXIgbGFiZWwgPSByZWZbMF07CiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSByZWZbMV07CiAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7CiAgICAgICAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGludGVycG9sYXRpb24sIGlucHV0LCBsb3dlciwgdXBwZXIpIHsKICAgICAgICAgIHZhciB0ID0gMDsKICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHsKICAgICAgICAgICAgICB0ID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBpbnRlcnBvbGF0aW9uLmJhc2UsIGxvd2VyLCB1cHBlcik7CiAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2xpbmVhcicpIHsKICAgICAgICAgICAgICB0ID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCAxLCBsb3dlciwgdXBwZXIpOwogICAgICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdjdWJpYy1iZXppZXInKSB7CiAgICAgICAgICAgICAgdmFyIGMgPSBpbnRlcnBvbGF0aW9uLmNvbnRyb2xQb2ludHM7CiAgICAgICAgICAgICAgdmFyIHViID0gbmV3IHVuaXRiZXppZXIoY1swXSwgY1sxXSwgY1syXSwgY1szXSk7CiAgICAgICAgICAgICAgdCA9IHViLnNvbHZlKGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgMSwgbG93ZXIsIHVwcGVyKSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdDsKICAgICAgfTsKICAgICAgSW50ZXJwb2xhdGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBhcmdzWzBdOwogICAgICAgICAgdmFyIGludGVycG9sYXRpb24gPSBhcmdzWzFdOwogICAgICAgICAgdmFyIGlucHV0ID0gYXJnc1syXTsKICAgICAgICAgIHZhciByZXN0ID0gYXJncy5zbGljZSgzKTsKICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnRlcnBvbGF0aW9uKSB8fCBpbnRlcnBvbGF0aW9uLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBpbnRlcnBvbGF0aW9uIHR5cGUgZXhwcmVzc2lvbi4nLCAxKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uWzBdID09PSAnbGluZWFyJykgewogICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSB7IG5hbWU6ICdsaW5lYXInIH07CiAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdleHBvbmVudGlhbCcpIHsKICAgICAgICAgICAgICB2YXIgYmFzZSA9IGludGVycG9sYXRpb25bMV07CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlICE9PSAnbnVtYmVyJykgewogICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS4nLCAxLCAxKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHsKICAgICAgICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJywKICAgICAgICAgICAgICAgICAgYmFzZTogYmFzZQogICAgICAgICAgICAgIH07CiAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdjdWJpYy1iZXppZXInKSB7CiAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBpbnRlcnBvbGF0aW9uLnNsaWNlKDEpOwogICAgICAgICAgICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCAhPT0gNCB8fCBjb250cm9sUG9pbnRzLnNvbWUoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdCAhPT0gJ251bWJlcicgfHwgdCA8IDAgfHwgdCA+IDE7CiAgICAgICAgICAgICAgICAgIH0pKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdDdWJpYyBiZXppZXIgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBmb3VyIG51bWVyaWMgYXJndW1lbnRzIHdpdGggdmFsdWVzIGJldHdlZW4gMCBhbmQgMS4nLCAxKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHsKICAgICAgICAgICAgICAgICAgbmFtZTogJ2N1YmljLWJlemllcicsCiAgICAgICAgICAgICAgICAgIGNvbnRyb2xQb2ludHM6IGNvbnRyb2xQb2ludHMKICAgICAgICAgICAgICB9OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVW5rbm93biBpbnRlcnBvbGF0aW9uIHR5cGUgJyArIFN0cmluZyhpbnRlcnBvbGF0aW9uWzBdKSwgMSwgMCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggLSAxIDwgNCkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJy4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoYXJncy5sZW5ndGggLSAxKSAlIDIgIT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLicpOwogICAgICAgICAgfQogICAgICAgICAgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGlucHV0LCAyLCBOdW1iZXJUeXBlKTsKICAgICAgICAgIGlmICghaW5wdXQpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBzdG9wcyA9IFtdOwogICAgICAgICAgdmFyIG91dHB1dFR5cGUgPSBudWxsOwogICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtaGNsJyB8fCBvcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWxhYicpIHsKICAgICAgICAgICAgICBvdXRwdXRUeXBlID0gQ29sb3JUeXBlOwogICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7CiAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSArPSAyKSB7CiAgICAgICAgICAgICAgdmFyIGxhYmVsID0gcmVzdFtpXTsKICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN0W2kgKyAxXTsKICAgICAgICAgICAgICB2YXIgbGFiZWxLZXkgPSBpICsgMzsKICAgICAgICAgICAgICB2YXIgdmFsdWVLZXkgPSBpICsgNDsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJykgewogICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciAiaW50ZXJwb2xhdGUiIGV4cHJlc3Npb25zIG11c3QgYmUgZGVmaW5lZCB1c2luZyBsaXRlcmFsIG51bWVyaWMgdmFsdWVzIChub3QgY29tcHV0ZWQgZXhwcmVzc2lvbnMpIGZvciB0aGUgaW5wdXQgdmFsdWVzLicsIGxhYmVsS2V5KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+PSBsYWJlbCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciAiaW50ZXJwb2xhdGUiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGxhYmVsS2V5KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGNvbnRleHQucGFyc2UodmFsdWUsIHZhbHVlS2V5LCBvdXRwdXRUeXBlKTsKICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7CiAgICAgICAgICAgICAgc3RvcHMucHVzaChbCiAgICAgICAgICAgICAgICAgIGxhYmVsLAogICAgICAgICAgICAgICAgICBwYXJzZWQKICAgICAgICAgICAgICBdKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvdXRwdXRUeXBlLmtpbmQgIT09ICdudW1iZXInICYmIG91dHB1dFR5cGUua2luZCAhPT0gJ2NvbG9yJyAmJiAhKG91dHB1dFR5cGUua2luZCA9PT0gJ2FycmF5JyAmJiBvdXRwdXRUeXBlLml0ZW1UeXBlLmtpbmQgPT09ICdudW1iZXInICYmIHR5cGVvZiBvdXRwdXRUeXBlLk4gPT09ICdudW1iZXInKSkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdUeXBlICcgKyB0b1N0cmluZyhvdXRwdXRUeXBlKSArICcgaXMgbm90IGludGVycG9sYXRhYmxlLicpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0ZShvdXRwdXRUeXBlLCBvcGVyYXRvciwgaW50ZXJwb2xhdGlvbiwgaW5wdXQsIHN0b3BzKTsKICAgICAgfTsKICAgICAgSW50ZXJwb2xhdGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5sYWJlbHM7CiAgICAgICAgICB2YXIgb3V0cHV0cyA9IHRoaXMub3V0cHV0czsKICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIGlmICh2YWx1ZSA8PSBsYWJlbHNbMF0pIHsKICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHN0b3BDb3VudCA9IGxhYmVscy5sZW5ndGg7CiAgICAgICAgICBpZiAodmFsdWUgPj0gbGFiZWxzW3N0b3BDb3VudCAtIDFdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbc3RvcENvdW50IC0gMV0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8obGFiZWxzLCB2YWx1ZSk7CiAgICAgICAgICB2YXIgbG93ZXIgPSBsYWJlbHNbaW5kZXhdOwogICAgICAgICAgdmFyIHVwcGVyID0gbGFiZWxzW2luZGV4ICsgMV07CiAgICAgICAgICB2YXIgdCA9IEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uLCB2YWx1ZSwgbG93ZXIsIHVwcGVyKTsKICAgICAgICAgIHZhciBvdXRwdXRMb3dlciA9IG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICB2YXIgb3V0cHV0VXBwZXIgPSBvdXRwdXRzW2luZGV4ICsgMV0uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlW3RoaXMudHlwZS5raW5kLnRvTG93ZXJDYXNlKCldKG91dHB1dExvd2VyLCBvdXRwdXRVcHBlciwgdCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZS1oY2wnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGhjbC5yZXZlcnNlKGhjbC5pbnRlcnBvbGF0ZShoY2wuZm9yd2FyZChvdXRwdXRMb3dlciksIGhjbC5mb3J3YXJkKG91dHB1dFVwcGVyKSwgdCkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gbGFiLnJldmVyc2UobGFiLmludGVycG9sYXRlKGxhYi5mb3J3YXJkKG91dHB1dExvd2VyKSwgbGFiLmZvcndhcmQob3V0cHV0VXBwZXIpLCB0KSk7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIEludGVycG9sYXRlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgIGZuKHRoaXMuaW5wdXQpOwogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLm91dHB1dHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBsaXN0W2ldOwogICAgICAgICAgICAgIGZuKGV4cHJlc3Npb24pOwogICAgICAgICAgfQogICAgICB9OwogICAgICBJbnRlcnBvbGF0ZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXQpIHsKICAgICAgICAgICAgICByZXR1cm4gb3V0Lm91dHB1dERlZmluZWQoKTsKICAgICAgICAgIH0pOwogICAgICB9OwogICAgICBJbnRlcnBvbGF0ZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgdmFyIGludGVycG9sYXRpb247CiAgICAgICAgICBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7CiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFsnbGluZWFyJ107CiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnZXhwb25lbnRpYWwnKSB7CiAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlID09PSAxKSB7CiAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbJ2xpbmVhciddOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbCiAgICAgICAgICAgICAgICAgICAgICAnZXhwb25lbnRpYWwnLAogICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uLmJhc2UKICAgICAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbJ2N1YmljLWJlemllciddLmNvbmNhdCh0aGlzLmludGVycG9sYXRpb24uY29udHJvbFBvaW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFsKICAgICAgICAgICAgICB0aGlzLm9wZXJhdG9yLAogICAgICAgICAgICAgIGludGVycG9sYXRpb24sCiAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKQogICAgICAgICAgXTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5sYWJlbHNbaV0sIHRoaXMub3V0cHV0c1tpXS5zZXJpYWxpemUoKSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7CiAgICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlOwogICAgICAgICAgdmFyIHByb2dyZXNzID0gaW5wdXQgLSBsb3dlclZhbHVlOwogICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgIH0gZWxzZSBpZiAoYmFzZSA9PT0gMSkgewogICAgICAgICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiAoTWF0aC5wb3coYmFzZSwgcHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgZGlmZmVyZW5jZSkgLSAxKTsKICAgICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIENvYWxlc2NlID0gZnVuY3Rpb24gQ29hbGVzY2UodHlwZSwgYXJncykgewogICAgICAgICAgdGhpcy50eXBlID0gdHlwZTsKICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7CiAgICAgIH07CiAgICAgIENvYWxlc2NlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgb3V0cHV0VHlwZSA9IG51bGw7CiAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7CiAgICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlICYmIGV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7CiAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGV4cGVjdGVkVHlwZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBwYXJzZWRBcmdzID0gW107CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGFyZ3Muc2xpY2UoMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07CiAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGNvbnRleHQucGFyc2UoYXJnLCAxICsgcGFyc2VkQXJncy5sZW5ndGgsIG91dHB1dFR5cGUsIHVuZGVmaW5lZCwgeyB0eXBlQW5ub3RhdGlvbjogJ29taXQnIH0pOwogICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCBwYXJzZWQudHlwZTsKICAgICAgICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBuZWVkc0Fubm90YXRpb24gPSBleHBlY3RlZFR5cGUgJiYgcGFyc2VkQXJncy5zb21lKGZ1bmN0aW9uIChhcmcpIHsKICAgICAgICAgICAgICByZXR1cm4gY2hlY2tTdWJ0eXBlKGV4cGVjdGVkVHlwZSwgYXJnLnR5cGUpOwogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gbmVlZHNBbm5vdGF0aW9uID8gbmV3IENvYWxlc2NlKFZhbHVlVHlwZSwgcGFyc2VkQXJncykgOiBuZXcgQ29hbGVzY2Uob3V0cHV0VHlwZSwgcGFyc2VkQXJncyk7CiAgICAgIH07CiAgICAgIENvYWxlc2NlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7CiAgICAgICAgICB2YXIgYXJnQ291bnQgPSAwOwogICAgICAgICAgdmFyIHJlcXVlc3RlZEltYWdlTmFtZTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5hcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldOwogICAgICAgICAgICAgIGFyZ0NvdW50Kys7CiAgICAgICAgICAgICAgcmVzdWx0ID0gYXJnLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlICYmICFyZXN1bHQuYXZhaWxhYmxlKSB7CiAgICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdGVkSW1hZ2VOYW1lKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRJbWFnZU5hbWUgPSByZXN1bHQubmFtZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsOwogICAgICAgICAgICAgICAgICBpZiAoYXJnQ291bnQgPT09IHRoaXMuYXJncy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcXVlc3RlZEltYWdlTmFtZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH07CiAgICAgIENvYWxlc2NlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTsKICAgICAgfTsKICAgICAgQ29hbGVzY2UucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGFyZy5vdXRwdXREZWZpbmVkKCk7CiAgICAgICAgICB9KTsKICAgICAgfTsKICAgICAgQ29hbGVzY2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gWydjb2FsZXNjZSddOwogICAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7CiAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTsKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7CiAgICAgIH07CgogICAgICB2YXIgTGV0ID0gZnVuY3Rpb24gTGV0KGJpbmRpbmdzLCByZXN1bHQpIHsKICAgICAgICAgIHRoaXMudHlwZSA9IHJlc3VsdC50eXBlOwogICAgICAgICAgdGhpcy5iaW5kaW5ncyA9IFtdLmNvbmNhdChiaW5kaW5ncyk7CiAgICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDsKICAgICAgfTsKICAgICAgTGV0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LmV2YWx1YXRlKGN0eCk7CiAgICAgIH07CiAgICAgIExldC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMuYmluZGluZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBsaXN0W2ldOwogICAgICAgICAgICAgIGZuKGJpbmRpbmdbMV0pOwogICAgICAgICAgfQogICAgICAgICAgZm4odGhpcy5yZXN1bHQpOwogICAgICB9OwogICAgICBMZXQucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCA0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGJpbmRpbmdzID0gW107CiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7CiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBhcmdzW2ldOwogICAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIHN0cmluZywgYnV0IGZvdW5kICcgKyB0eXBlb2YgbmFtZSArICcgaW5zdGVhZC4nLCBpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKC9bXmEtekEtWjAtOV9dLy50ZXN0KG5hbWUpKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdWYXJpYWJsZSBuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciBcJ19cJy4nLCBpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29udGV4dC5wYXJzZShhcmdzW2kgKyAxXSwgaSArIDEpOwogICAgICAgICAgICAgIGlmICghdmFsdWUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goWwogICAgICAgICAgICAgICAgICBuYW1lLAogICAgICAgICAgICAgICAgICB2YWx1ZQogICAgICAgICAgICAgIF0pOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIGNvbnRleHQuZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncyk7CiAgICAgICAgICBpZiAoIXJlc3VsdCkgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5ldyBMZXQoYmluZGluZ3MsIHJlc3VsdCk7CiAgICAgIH07CiAgICAgIExldC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3V0cHV0RGVmaW5lZCgpOwogICAgICB9OwogICAgICBMZXQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gWydsZXQnXTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5iaW5kaW5nczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTsKICAgICAgICAgICAgICB2YXIgbmFtZSA9IHJlZlswXTsKICAgICAgICAgICAgICB2YXIgZXhwciA9IHJlZlsxXTsKICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2gobmFtZSwgZXhwci5zZXJpYWxpemUoKSk7CiAgICAgICAgICB9CiAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5yZXN1bHQuc2VyaWFsaXplKCkpOwogICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7CiAgICAgIH07CgogICAgICB2YXIgQXQgPSBmdW5jdGlvbiBBdCh0eXBlLCBpbmRleCwgaW5wdXQpIHsKICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7CiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7CiAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7CiAgICAgIH07CiAgICAgIEF0LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTsKICAgICAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgYXJyYXkoY29udGV4dC5leHBlY3RlZFR5cGUgfHwgVmFsdWVUeXBlKSk7CiAgICAgICAgICBpZiAoIWluZGV4IHx8ICFpbnB1dCkgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHQgPSBpbnB1dC50eXBlOwogICAgICAgICAgcmV0dXJuIG5ldyBBdCh0Lml0ZW1UeXBlLCBpbmRleCwgaW5wdXQpOwogICAgICB9OwogICAgICBBdC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXguZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIGlmIChpbmRleCA8IDApIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiAnICsgaW5kZXggKyAnIDwgMC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpbmRleCA+PSBhcnJheS5sZW5ndGgpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiAnICsgaW5kZXggKyAnID4gJyArIChhcnJheS5sZW5ndGggLSAxKSArICcuJyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5kZXggIT09IE1hdGguZmxvb3IoaW5kZXgpKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignQXJyYXkgaW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZm91bmQgJyArIGluZGV4ICsgJyBpbnN0ZWFkLicpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTsKICAgICAgfTsKICAgICAgQXQucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgZm4odGhpcy5pbmRleCk7CiAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgfTsKICAgICAgQXQucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgICBBdC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAnYXQnLAogICAgICAgICAgICAgIHRoaXMuaW5kZXguc2VyaWFsaXplKCksCiAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKQogICAgICAgICAgXTsKICAgICAgfTsKCiAgICAgIHZhciBJbiA9IGZ1bmN0aW9uIEluKG5lZWRsZSwgaGF5c3RhY2spIHsKICAgICAgICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlOwogICAgICAgICAgdGhpcy5uZWVkbGUgPSBuZWVkbGU7CiAgICAgICAgICB0aGlzLmhheXN0YWNrID0gaGF5c3RhY2s7CiAgICAgIH07CiAgICAgIEluLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIG5lZWRsZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTsKICAgICAgICAgIHZhciBoYXlzdGFjayA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgVmFsdWVUeXBlKTsKICAgICAgICAgIGlmICghbmVlZGxlIHx8ICFoYXlzdGFjaykgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShuZWVkbGUudHlwZSwgWwogICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgICAgTnVsbFR5cGUsCiAgICAgICAgICAgICAgICAgIFZhbHVlVHlwZQogICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICcgKyB0b1N0cmluZyhuZWVkbGUudHlwZSkgKyAnIGluc3RlYWQnKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgSW4obmVlZGxlLCBoYXlzdGFjayk7CiAgICAgIH07CiAgICAgIEluLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkgewogICAgICAgICAgdmFyIG5lZWRsZSA9IHRoaXMubmVlZGxlLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICB2YXIgaGF5c3RhY2sgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICBpZiAoIWhheXN0YWNrKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFsKICAgICAgICAgICAgICAgICAgJ2Jvb2xlYW4nLAogICAgICAgICAgICAgICAgICAnc3RyaW5nJywKICAgICAgICAgICAgICAgICAgJ251bWJlcicsCiAgICAgICAgICAgICAgICAgICdudWxsJwogICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihuZWVkbGUpKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghaXNWYWxpZE5hdGl2ZVR5cGUoaGF5c3RhY2ssIFsKICAgICAgICAgICAgICAgICAgJ3N0cmluZycsCiAgICAgICAgICAgICAgICAgICdhcnJheScKICAgICAgICAgICAgICBdKSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YoaGF5c3RhY2spKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPj0gMDsKICAgICAgfTsKICAgICAgSW4ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgZm4odGhpcy5uZWVkbGUpOwogICAgICAgICAgZm4odGhpcy5oYXlzdGFjayk7CiAgICAgIH07CiAgICAgIEluLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBJbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAnaW4nLAogICAgICAgICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCkKICAgICAgICAgIF07CiAgICAgIH07CgogICAgICB2YXIgSW5kZXhPZiA9IGZ1bmN0aW9uIEluZGV4T2YobmVlZGxlLCBoYXlzdGFjaywgZnJvbUluZGV4KSB7CiAgICAgICAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlOwogICAgICAgICAgdGhpcy5uZWVkbGUgPSBuZWVkbGU7CiAgICAgICAgICB0aGlzLmhheXN0YWNrID0gaGF5c3RhY2s7CiAgICAgICAgICB0aGlzLmZyb21JbmRleCA9IGZyb21JbmRleDsKICAgICAgfTsKICAgICAgSW5kZXhPZi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHsKICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAyIHx8IGFyZ3MubGVuZ3RoID49IDUpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBuZWVkbGUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7CiAgICAgICAgICB2YXIgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7CiAgICAgICAgICBpZiAoIW5lZWRsZSB8fCAhaGF5c3RhY2spIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUobmVlZGxlLnR5cGUsIFsKICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgICAgIE51bGxUeXBlLAogICAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgICBdKSkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcobmVlZGxlLnR5cGUpICsgJyBpbnN0ZWFkJyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICB2YXIgZnJvbUluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBOdW1iZXJUeXBlKTsKICAgICAgICAgICAgICBpZiAoIWZyb21JbmRleCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiBuZXcgSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrKTsKICAgICAgICAgIH0KICAgICAgfTsKICAgICAgSW5kZXhPZi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIHZhciBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgdmFyIGhheXN0YWNrID0gdGhpcy5oYXlzdGFjay5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFsKICAgICAgICAgICAgICAgICAgJ2Jvb2xlYW4nLAogICAgICAgICAgICAgICAgICAnc3RyaW5nJywKICAgICAgICAgICAgICAgICAgJ251bWJlcicsCiAgICAgICAgICAgICAgICAgICdudWxsJwogICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihuZWVkbGUpKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghaXNWYWxpZE5hdGl2ZVR5cGUoaGF5c3RhY2ssIFsKICAgICAgICAgICAgICAgICAgJ3N0cmluZycsCiAgICAgICAgICAgICAgICAgICdhcnJheScKICAgICAgICAgICAgICBdKSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YoaGF5c3RhY2spKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLmZyb21JbmRleCkgewogICAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleC5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgZnJvbUluZGV4KTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSk7CiAgICAgIH07CiAgICAgIEluZGV4T2YucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgZm4odGhpcy5uZWVkbGUpOwogICAgICAgICAgZm4odGhpcy5oYXlzdGFjayk7CiAgICAgICAgICBpZiAodGhpcy5mcm9tSW5kZXgpIHsKICAgICAgICAgICAgICBmbih0aGlzLmZyb21JbmRleCk7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIEluZGV4T2YucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgICBJbmRleE9mLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7CiAgICAgICAgICBpZiAodGhpcy5mcm9tSW5kZXggIT0gbnVsbCAmJiB0aGlzLmZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuZnJvbUluZGV4LnNlcmlhbGl6ZSgpOwogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICdpbmRleC1vZicsCiAgICAgICAgICAgICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgICAgICB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgICAgICBmcm9tSW5kZXgKICAgICAgICAgICAgICBdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAnaW5kZXgtb2YnLAogICAgICAgICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCkKICAgICAgICAgIF07CiAgICAgIH07CgogICAgICB2YXIgTWF0Y2ggPSBmdW5jdGlvbiBNYXRjaChpbnB1dFR5cGUsIG91dHB1dFR5cGUsIGlucHV0LCBjYXNlcywgb3V0cHV0cywgb3RoZXJ3aXNlKSB7CiAgICAgICAgICB0aGlzLmlucHV0VHlwZSA9IGlucHV0VHlwZTsKICAgICAgICAgIHRoaXMudHlwZSA9IG91dHB1dFR5cGU7CiAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7CiAgICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzOwogICAgICAgICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7CiAgICAgIH07CiAgICAgIE1hdGNoLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNSkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJy4nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAlIDIgIT09IDEpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLicpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGlucHV0VHlwZTsKICAgICAgICAgIHZhciBvdXRwdXRUeXBlOwogICAgICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgY2FzZXMgPSB7fTsKICAgICAgICAgIHZhciBvdXRwdXRzID0gW107CiAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7CiAgICAgICAgICAgICAgdmFyIGxhYmVscyA9IGFyZ3NbaV07CiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJnc1tpICsgMV07CiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpIHsKICAgICAgICAgICAgICAgICAgbGFiZWxzID0gW2xhYmVsc107CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBsYWJlbENvbnRleHQgPSBjb250ZXh0LmNvbmNhdChpKTsKICAgICAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYnJhbmNoIGxhYmVsLicpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gbGFiZWxzOyBpJDEgPCBsaXN0Lmxlbmd0aDsgaSQxICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdOwogICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFiZWwgIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLicpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5hYnMobGFiZWwpID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0JyYW5jaCBsYWJlbHMgbXVzdCBiZSBpbnRlZ2VycyBubyBsYXJnZXIgdGhhbiAnICsgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKyAnLicpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihsYWJlbCkgIT09IGxhYmVsKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdOdW1lcmljIGJyYW5jaCBsYWJlbHMgbXVzdCBiZSBpbnRlZ2VyIHZhbHVlcy4nKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5wdXRUeXBlKSB7CiAgICAgICAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPSB0eXBlT2YobGFiZWwpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsQ29udGV4dC5jaGVja1N1YnR5cGUoaW5wdXRUeXBlLCB0eXBlT2YobGFiZWwpKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXNlc1tTdHJpbmcobGFiZWwpXSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0JyYW5jaCBsYWJlbHMgbXVzdCBiZSB1bmlxdWUuJyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZXNbU3RyaW5nKGxhYmVsKV0gPSBvdXRwdXRzLmxlbmd0aDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UodmFsdWUsIGksIG91dHB1dFR5cGUpOwogICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCByZXN1bHQudHlwZTsKICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocmVzdWx0KTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTsKICAgICAgICAgIGlmICghaW5wdXQpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBvdGhlcndpc2UgPSBjb250ZXh0LnBhcnNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgYXJncy5sZW5ndGggLSAxLCBvdXRwdXRUeXBlKTsKICAgICAgICAgIGlmICghb3RoZXJ3aXNlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5wdXQudHlwZS5raW5kICE9PSAndmFsdWUnICYmIGNvbnRleHQuY29uY2F0KDEpLmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIGlucHV0LnR5cGUpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpOwogICAgICB9OwogICAgICBNYXRjaC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIHZhciBvdXRwdXQgPSB0eXBlT2YoaW5wdXQpID09PSB0aGlzLmlucHV0VHlwZSAmJiB0aGlzLm91dHB1dHNbdGhpcy5jYXNlc1tpbnB1dF1dIHx8IHRoaXMub3RoZXJ3aXNlOwogICAgICAgICAgcmV0dXJuIG91dHB1dC5ldmFsdWF0ZShjdHgpOwogICAgICB9OwogICAgICBNYXRjaC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgICAgIHRoaXMub3V0cHV0cy5mb3JFYWNoKGZuKTsKICAgICAgICAgIGZuKHRoaXMub3RoZXJ3aXNlKTsKICAgICAgfTsKICAgICAgTWF0Y2gucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAob3V0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7CiAgICAgICAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7CiAgICAgIH07CiAgICAgIE1hdGNoLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7CiAgICAgICAgICB2YXIgdGhpcyQxJDEgPSB0aGlzOwogICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbCiAgICAgICAgICAgICAgJ21hdGNoJywKICAgICAgICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpCiAgICAgICAgICBdOwogICAgICAgICAgdmFyIHNvcnRlZExhYmVscyA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTsKICAgICAgICAgIHZhciBncm91cGVkQnlPdXRwdXQgPSBbXTsKICAgICAgICAgIHZhciBvdXRwdXRMb29rdXAgPSB7fTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc29ydGVkTGFiZWxzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciBsYWJlbCA9IGxpc3RbaV07CiAgICAgICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gb3V0cHV0TG9va3VwW3RoaXMuY2FzZXNbbGFiZWxdXTsKICAgICAgICAgICAgICBpZiAob3V0cHV0SW5kZXggPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICBvdXRwdXRMb29rdXBbdGhpcy5jYXNlc1tsYWJlbF1dID0gZ3JvdXBlZEJ5T3V0cHV0Lmxlbmd0aDsKICAgICAgICAgICAgICAgICAgZ3JvdXBlZEJ5T3V0cHV0LnB1c2goWwogICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXNlc1tsYWJlbF0sCiAgICAgICAgICAgICAgICAgICAgICBbbGFiZWxdCiAgICAgICAgICAgICAgICAgIF0pOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGdyb3VwZWRCeU91dHB1dFtvdXRwdXRJbmRleF1bMV0ucHVzaChsYWJlbCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgdmFyIGNvZXJjZUxhYmVsID0gZnVuY3Rpb24gKGxhYmVsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMkMSQxLmlucHV0VHlwZS5raW5kID09PSAnbnVtYmVyJyA/IE51bWJlcihsYWJlbCkgOiBsYWJlbDsKICAgICAgICAgIH07CiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBncm91cGVkQnlPdXRwdXQ7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7CiAgICAgICAgICAgICAgdmFyIHJlZiA9IGxpc3QkMVtpJDFdOwogICAgICAgICAgICAgIHZhciBvdXRwdXRJbmRleCA9IHJlZlswXTsKICAgICAgICAgICAgICB2YXIgbGFiZWxzID0gcmVmWzFdOwogICAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjb2VyY2VMYWJlbChsYWJlbHNbMF0pKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2gobGFiZWxzLm1hcChjb2VyY2VMYWJlbCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdXRwdXRzW291dHB1dEluZGV4JDFdLnNlcmlhbGl6ZSgpKTsKICAgICAgICAgIH0KICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm90aGVyd2lzZS5zZXJpYWxpemUoKSk7CiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDsKICAgICAgfTsKCiAgICAgIHZhciBDYXNlID0gZnVuY3Rpb24gQ2FzZSh0eXBlLCBicmFuY2hlcywgb3RoZXJ3aXNlKSB7CiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgICAgICAgdGhpcy5icmFuY2hlcyA9IGJyYW5jaGVzOwogICAgICAgICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7CiAgICAgIH07CiAgICAgIENhc2UucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCA0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICUgMiAhPT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cy4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBvdXRwdXRUeXBlOwogICAgICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHsKICAgICAgICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgYnJhbmNoZXMgPSBbXTsKICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHsKICAgICAgICAgICAgICB2YXIgdGVzdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgQm9vbGVhblR5cGUpOwogICAgICAgICAgICAgIGlmICghdGVzdCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpICsgMV0sIGkgKyAxLCBvdXRwdXRUeXBlKTsKICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJhbmNoZXMucHVzaChbCiAgICAgICAgICAgICAgICAgIHRlc3QsCiAgICAgICAgICAgICAgICAgIHJlc3VsdAogICAgICAgICAgICAgIF0pOwogICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlOwogICAgICAgICAgfQogICAgICAgICAgdmFyIG90aGVyd2lzZSA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIG91dHB1dFR5cGUpOwogICAgICAgICAgaWYgKCFvdGhlcndpc2UpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgQ2FzZShvdXRwdXRUeXBlLCBicmFuY2hlcywgb3RoZXJ3aXNlKTsKICAgICAgfTsKICAgICAgQ2FzZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5icmFuY2hlczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTsKICAgICAgICAgICAgICB2YXIgdGVzdCA9IHJlZlswXTsKICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZlsxXTsKICAgICAgICAgICAgICBpZiAodGVzdC5ldmFsdWF0ZShjdHgpKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMub3RoZXJ3aXNlLmV2YWx1YXRlKGN0eCk7CiAgICAgIH07CiAgICAgIENhc2UucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmJyYW5jaGVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciByZWYgPSBsaXN0W2ldOwogICAgICAgICAgICAgIHZhciB0ZXN0ID0gcmVmWzBdOwogICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdOwogICAgICAgICAgICAgIGZuKHRlc3QpOwogICAgICAgICAgICAgIGZuKGV4cHJlc3Npb24pOwogICAgICAgICAgfQogICAgICAgICAgZm4odGhpcy5vdGhlcndpc2UpOwogICAgICB9OwogICAgICBDYXNlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmJyYW5jaGVzLmV2ZXJ5KGZ1bmN0aW9uIChyZWYpIHsKICAgICAgICAgICAgICByZWZbMF07CiAgICAgICAgICAgICAgdmFyIG91dCA9IHJlZlsxXTsKICAgICAgICAgICAgICByZXR1cm4gb3V0Lm91dHB1dERlZmluZWQoKTsKICAgICAgICAgIH0pICYmIHRoaXMub3RoZXJ3aXNlLm91dHB1dERlZmluZWQoKTsKICAgICAgfTsKICAgICAgQ2FzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Nhc2UnXTsKICAgICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkgewogICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICB9OwoKICAgICAgdmFyIFNsaWNlID0gZnVuY3Rpb24gU2xpY2UodHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgsIGVuZEluZGV4KSB7CiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0OwogICAgICAgICAgdGhpcy5iZWdpbkluZGV4ID0gYmVnaW5JbmRleDsKICAgICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDsKICAgICAgfTsKICAgICAgU2xpY2UucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMiB8fCBhcmdzLmxlbmd0aCA+PSA1KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7CiAgICAgICAgICB2YXIgYmVnaW5JbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgTnVtYmVyVHlwZSk7CiAgICAgICAgICBpZiAoIWlucHV0IHx8ICFiZWdpbkluZGV4KSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGlucHV0LnR5cGUsIFsKICAgICAgICAgICAgICAgICAgYXJyYXkoVmFsdWVUeXBlKSwKICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgVmFsdWVUeXBlCiAgICAgICAgICAgICAgXSkpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcoaW5wdXQudHlwZSkgKyAnIGluc3RlYWQnKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkgewogICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgTnVtYmVyVHlwZSk7CiAgICAgICAgICAgICAgaWYgKCFlbmRJbmRleCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbGljZShpbnB1dC50eXBlLCBpbnB1dCwgYmVnaW5JbmRleCwgZW5kSW5kZXgpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGlucHV0LnR5cGUsIGlucHV0LCBiZWdpbkluZGV4KTsKICAgICAgICAgIH0KICAgICAgfTsKICAgICAgU2xpY2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICB2YXIgYmVnaW5JbmRleCA9IHRoaXMuYmVnaW5JbmRleC5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShpbnB1dCwgWwogICAgICAgICAgICAgICAgICAnc3RyaW5nJywKICAgICAgICAgICAgICAgICAgJ2FycmF5JwogICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKGlucHV0KSkgKyAnIGluc3RlYWQuJyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5lbmRJbmRleCkgewogICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXguZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoYmVnaW5JbmRleCwgZW5kSW5kZXgpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgpOwogICAgICB9OwogICAgICBTbGljZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgICAgIGZuKHRoaXMuYmVnaW5JbmRleCk7CiAgICAgICAgICBpZiAodGhpcy5lbmRJbmRleCkgewogICAgICAgICAgICAgIGZuKHRoaXMuZW5kSW5kZXgpOwogICAgICAgICAgfQogICAgICB9OwogICAgICBTbGljZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07CiAgICAgIFNsaWNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7CiAgICAgICAgICBpZiAodGhpcy5lbmRJbmRleCAhPSBudWxsICYmIHRoaXMuZW5kSW5kZXggIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXguc2VyaWFsaXplKCk7CiAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgJ3NsaWNlJywKICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSwKICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgICAgICBlbmRJbmRleAogICAgICAgICAgICAgIF07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICdzbGljZScsCiAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSwKICAgICAgICAgICAgICB0aGlzLmJlZ2luSW5kZXguc2VyaWFsaXplKCkKICAgICAgICAgIF07CiAgICAgIH07CgogICAgICBmdW5jdGlvbiBpc0NvbXBhcmFibGVUeXBlKG9wLCB0eXBlKSB7CiAgICAgICAgICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScpIHsKICAgICAgICAgICAgICByZXR1cm4gdHlwZS5raW5kID09PSAnYm9vbGVhbicgfHwgdHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCB0eXBlLmtpbmQgPT09ICdudW1iZXInIHx8IHR5cGUua2luZCA9PT0gJ251bGwnIHx8IHR5cGUua2luZCA9PT0gJ3ZhbHVlJzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIHR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgdHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCB0eXBlLmtpbmQgPT09ICd2YWx1ZSc7CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZXEoY3R4LCBhLCBiKSB7CiAgICAgICAgICByZXR1cm4gYSA9PT0gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBuZXEoY3R4LCBhLCBiKSB7CiAgICAgICAgICByZXR1cm4gYSAhPT0gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBsdChjdHgsIGEsIGIpIHsKICAgICAgICAgIHJldHVybiBhIDwgYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBndChjdHgsIGEsIGIpIHsKICAgICAgICAgIHJldHVybiBhID4gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBsdGVxKGN0eCwgYSwgYikgewogICAgICAgICAgcmV0dXJuIGEgPD0gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBndGVxKGN0eCwgYSwgYikgewogICAgICAgICAgcmV0dXJuIGEgPj0gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7CiAgICAgICAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID09PSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG5lcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7CiAgICAgICAgICByZXR1cm4gIWVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGx0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHsKICAgICAgICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPCAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGd0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHsKICAgICAgICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPiAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGx0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykgewogICAgICAgICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA8PSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGd0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykgewogICAgICAgICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA+PSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG1ha2VDb21wYXJpc29uKG9wLCBjb21wYXJlQmFzaWMsIGNvbXBhcmVXaXRoQ29sbGF0b3IpIHsKICAgICAgICAgIHZhciBpc09yZGVyQ29tcGFyaXNvbiA9IG9wICE9PSAnPT0nICYmIG9wICE9PSAnIT0nOwogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICBmdW5jdGlvbiBDb21wYXJpc29uKGxocywgcmhzLCBjb2xsYXRvcikgewogICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBCb29sZWFuVHlwZTsKICAgICAgICAgICAgICAgICAgdGhpcy5saHMgPSBsaHM7CiAgICAgICAgICAgICAgICAgIHRoaXMucmhzID0gcmhzOwogICAgICAgICAgICAgICAgICB0aGlzLmNvbGxhdG9yID0gY29sbGF0b3I7CiAgICAgICAgICAgICAgICAgIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50ID0gbGhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCByaHMudHlwZS5raW5kID09PSAndmFsdWUnOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBDb21wYXJpc29uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkgewogICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDMgJiYgYXJncy5sZW5ndGggIT09IDQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCB0d28gb3IgdGhyZWUgYXJndW1lbnRzLicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGFyZ3NbMF07CiAgICAgICAgICAgICAgICAgIHZhciBsaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7CiAgICAgICAgICAgICAgICAgIGlmICghbGhzKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcGFyYWJsZVR5cGUob3AsIGxocy50eXBlKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KDEpLmVycm9yKCciJyArIG9wICsgJyIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgXCcnICsgdG9TdHJpbmcobGhzLnR5cGUpICsgJ1wnLicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHZhciByaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7CiAgICAgICAgICAgICAgICAgIGlmICghcmhzKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcGFyYWJsZVR5cGUob3AsIHJocy50eXBlKSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KDIpLmVycm9yKCciJyArIG9wICsgJyIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgXCcnICsgdG9TdHJpbmcocmhzLnR5cGUpICsgJ1wnLicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChsaHMudHlwZS5raW5kICE9PSByaHMudHlwZS5raW5kICYmIGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHR5cGVzIFwnJyArIHRvU3RyaW5nKGxocy50eXBlKSArICdcJyBhbmQgXCcnICsgdG9TdHJpbmcocmhzLnR5cGUpICsgJ1wnLicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChpc09yZGVyQ29tcGFyaXNvbikgewogICAgICAgICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgPT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgICAgICAgICAgIGxocyA9IG5ldyBBc3NlcnRpb24ocmhzLnR5cGUsIFtsaHNdKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kID09PSAndmFsdWUnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmhzID0gbmV3IEFzc2VydGlvbihsaHMudHlwZSwgW3Joc10pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHZhciBjb2xsYXRvciA9IG51bGw7CiAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIHJocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdDYW5ub3QgdXNlIGNvbGxhdG9yIHRvIGNvbXBhcmUgbm9uLXN0cmluZyB0eXBlcy4nKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGNvbGxhdG9yID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBDb2xsYXRvclR5cGUpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsYXRvcikgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGFyaXNvbihsaHMsIHJocywgY29sbGF0b3IpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgQ29tcGFyaXNvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgICAgICAgICAgdmFyIGxocyA9IHRoaXMubGhzLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgICAgIHZhciByaHMgPSB0aGlzLnJocy5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgICBpZiAoaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBsdCA9IHR5cGVPZihsaHMpOwogICAgICAgICAgICAgICAgICAgICAgdmFyIHJ0ID0gdHlwZU9mKHJocyk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAobHQua2luZCAhPT0gcnQua2luZCB8fCAhKGx0LmtpbmQgPT09ICdzdHJpbmcnIHx8IGx0LmtpbmQgPT09ICdudW1iZXInKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIGFyZ3VtZW50cyBmb3IgIicgKyBvcCArICciIHRvIGJlIChzdHJpbmcsIHN0cmluZykgb3IgKG51bWJlciwgbnVtYmVyKSwgYnV0IGZvdW5kICgnICsgbHQua2luZCArICcsICcgKyBydC5raW5kICsgJykgaW5zdGVhZC4nKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXRvciAmJiAhaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBsdCQxID0gdHlwZU9mKGxocyk7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgcnQkMSA9IHR5cGVPZihyaHMpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGx0JDEua2luZCAhPT0gJ3N0cmluZycgfHwgcnQkMS5raW5kICE9PSAnc3RyaW5nJykgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlQmFzaWMoY3R4LCBsaHMsIHJocyk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGF0b3IgPyBjb21wYXJlV2l0aENvbGxhdG9yKGN0eCwgbGhzLCByaHMsIHRoaXMuY29sbGF0b3IuZXZhbHVhdGUoY3R4KSkgOiBjb21wYXJlQmFzaWMoY3R4LCBsaHMsIHJocyk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBDb21wYXJpc29uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHsKICAgICAgICAgICAgICAgICAgZm4odGhpcy5saHMpOwogICAgICAgICAgICAgICAgICBmbih0aGlzLnJocyk7CiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxhdG9yKSB7CiAgICAgICAgICAgICAgICAgICAgICBmbih0aGlzLmNvbGxhdG9yKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgQ29tcGFyaXNvbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgQ29tcGFyaXNvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkgewogICAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFtvcF07CiAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkgewogICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTsKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgcmV0dXJuIENvbXBhcmlzb247CiAgICAgICAgICB9KCk7CiAgICAgIH0KICAgICAgdmFyIEVxdWFscyA9IG1ha2VDb21wYXJpc29uKCc9PScsIGVxLCBlcUNvbGxhdGUpOwogICAgICB2YXIgTm90RXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJyE9JywgbmVxLCBuZXFDb2xsYXRlKTsKICAgICAgdmFyIExlc3NUaGFuID0gbWFrZUNvbXBhcmlzb24oJzwnLCBsdCwgbHRDb2xsYXRlKTsKICAgICAgdmFyIEdyZWF0ZXJUaGFuID0gbWFrZUNvbXBhcmlzb24oJz4nLCBndCwgZ3RDb2xsYXRlKTsKICAgICAgdmFyIExlc3NUaGFuT3JFcXVhbCA9IG1ha2VDb21wYXJpc29uKCc8PScsIGx0ZXEsIGx0ZXFDb2xsYXRlKTsKICAgICAgdmFyIEdyZWF0ZXJUaGFuT3JFcXVhbCA9IG1ha2VDb21wYXJpc29uKCc+PScsIGd0ZXEsIGd0ZXFDb2xsYXRlKTsKCiAgICAgIHZhciBOdW1iZXJGb3JtYXQgPSBmdW5jdGlvbiBOdW1iZXJGb3JtYXQobnVtYmVyLCBsb2NhbGUsIGN1cnJlbmN5LCBtaW5GcmFjdGlvbkRpZ2l0cywgbWF4RnJhY3Rpb25EaWdpdHMpIHsKICAgICAgICAgIHRoaXMudHlwZSA9IFN0cmluZ1R5cGU7CiAgICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjsKICAgICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlOwogICAgICAgICAgdGhpcy5jdXJyZW5jeSA9IGN1cnJlbmN5OwogICAgICAgICAgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA9IG1pbkZyYWN0aW9uRGlnaXRzOwogICAgICAgICAgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA9IG1heEZyYWN0aW9uRGlnaXRzOwogICAgICB9OwogICAgICBOdW1iZXJGb3JtYXQucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDMpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cy4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBudW1iZXIgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpOwogICAgICAgICAgaWYgKCFudW1iZXIpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBvcHRpb25zID0gYXJnc1syXTsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkgewogICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdOdW1iZXJGb3JtYXQgb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBsb2NhbGUgPSBudWxsOwogICAgICAgICAgaWYgKG9wdGlvbnNbJ2xvY2FsZSddKSB7CiAgICAgICAgICAgICAgbG9jYWxlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydsb2NhbGUnXSwgMSwgU3RyaW5nVHlwZSk7CiAgICAgICAgICAgICAgaWYgKCFsb2NhbGUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgdmFyIGN1cnJlbmN5ID0gbnVsbDsKICAgICAgICAgIGlmIChvcHRpb25zWydjdXJyZW5jeSddKSB7CiAgICAgICAgICAgICAgY3VycmVuY3kgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2N1cnJlbmN5J10sIDEsIFN0cmluZ1R5cGUpOwogICAgICAgICAgICAgIGlmICghY3VycmVuY3kpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgdmFyIG1pbkZyYWN0aW9uRGlnaXRzID0gbnVsbDsKICAgICAgICAgIGlmIChvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10pIHsKICAgICAgICAgICAgICBtaW5GcmFjdGlvbkRpZ2l0cyA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbWluLWZyYWN0aW9uLWRpZ2l0cyddLCAxLCBOdW1iZXJUeXBlKTsKICAgICAgICAgICAgICBpZiAoIW1pbkZyYWN0aW9uRGlnaXRzKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHZhciBtYXhGcmFjdGlvbkRpZ2l0cyA9IG51bGw7CiAgICAgICAgICBpZiAob3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddKSB7CiAgICAgICAgICAgICAgbWF4RnJhY3Rpb25EaWdpdHMgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSwgMSwgTnVtYmVyVHlwZSk7CiAgICAgICAgICAgICAgaWYgKCFtYXhGcmFjdGlvbkRpZ2l0cykgewogICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckZvcm1hdChudW1iZXIsIGxvY2FsZSwgY3VycmVuY3ksIG1pbkZyYWN0aW9uRGlnaXRzLCBtYXhGcmFjdGlvbkRpZ2l0cyk7CiAgICAgIH07CiAgICAgIE51bWJlckZvcm1hdC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHsKICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShjdHgpIDogW10sIHsKICAgICAgICAgICAgICBzdHlsZTogdGhpcy5jdXJyZW5jeSA/ICdjdXJyZW5jeScgOiAnZGVjaW1hbCcsCiAgICAgICAgICAgICAgY3VycmVuY3k6IHRoaXMuY3VycmVuY3kgPyB0aGlzLmN1cnJlbmN5LmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWQsCiAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID8gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShjdHgpIDogdW5kZWZpbmVkLAogICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZAogICAgICAgICAgfSkuZm9ybWF0KHRoaXMubnVtYmVyLmV2YWx1YXRlKGN0eCkpOwogICAgICB9OwogICAgICBOdW1iZXJGb3JtYXQucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikgewogICAgICAgICAgZm4odGhpcy5udW1iZXIpOwogICAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7CiAgICAgICAgICAgICAgZm4odGhpcy5sb2NhbGUpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMuY3VycmVuY3kpIHsKICAgICAgICAgICAgICBmbih0aGlzLmN1cnJlbmN5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7CiAgICAgICAgICAgICAgZm4odGhpcy5taW5GcmFjdGlvbkRpZ2l0cyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cykgewogICAgICAgICAgICAgIGZuKHRoaXMubWF4RnJhY3Rpb25EaWdpdHMpOwogICAgICAgICAgfQogICAgICB9OwogICAgICBOdW1iZXJGb3JtYXQucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgICBOdW1iZXJGb3JtYXQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHsKICAgICAgICAgIHZhciBvcHRpb25zID0ge307CiAgICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHsKICAgICAgICAgICAgICBvcHRpb25zWydsb2NhbGUnXSA9IHRoaXMubG9jYWxlLnNlcmlhbGl6ZSgpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMuY3VycmVuY3kpIHsKICAgICAgICAgICAgICBvcHRpb25zWydjdXJyZW5jeSddID0gdGhpcy5jdXJyZW5jeS5zZXJpYWxpemUoKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7CiAgICAgICAgICAgICAgb3B0aW9uc1snbWluLWZyYWN0aW9uLWRpZ2l0cyddID0gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5zZXJpYWxpemUoKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKSB7CiAgICAgICAgICAgICAgb3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddID0gdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cy5zZXJpYWxpemUoKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgJ251bWJlci1mb3JtYXQnLAogICAgICAgICAgICAgIHRoaXMubnVtYmVyLnNlcmlhbGl6ZSgpLAogICAgICAgICAgICAgIG9wdGlvbnMKICAgICAgICAgIF07CiAgICAgIH07CgogICAgICB2YXIgTGVuZ3RoID0gZnVuY3Rpb24gTGVuZ3RoKGlucHV0KSB7CiAgICAgICAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlOwogICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0OwogICAgICB9OwogICAgICBMZW5ndGgucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7CiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMSBhcmd1bWVudCwgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSk7CiAgICAgICAgICBpZiAoIWlucHV0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5wdXQudHlwZS5raW5kICE9PSAnYXJyYXknICYmIGlucHV0LnR5cGUua2luZCAhPT0gJ3N0cmluZycgJiYgaW5wdXQudHlwZS5raW5kICE9PSAndmFsdWUnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgJyArIHRvU3RyaW5nKGlucHV0LnR5cGUpICsgJyBpbnN0ZWFkLicpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5ldyBMZW5ndGgoaW5wdXQpOwogICAgICB9OwogICAgICBMZW5ndGgucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7CiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgewogICAgICAgICAgICAgIHJldHVybiBpbnB1dC5sZW5ndGg7CiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKGlucHV0KSkgKyAnIGluc3RlYWQuJyk7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIExlbmd0aC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7CiAgICAgICAgICBmbih0aGlzLmlucHV0KTsKICAgICAgfTsKICAgICAgTGVuZ3RoLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfTsKICAgICAgTGVuZ3RoLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7CiAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFsnbGVuZ3RoJ107CiAgICAgICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHsKICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpOwogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDsKICAgICAgfTsKCiAgICAgIHZhciBleHByZXNzaW9ucyA9IHsKICAgICAgICAgICc9PSc6IEVxdWFscywKICAgICAgICAgICchPSc6IE5vdEVxdWFscywKICAgICAgICAgICc+JzogR3JlYXRlclRoYW4sCiAgICAgICAgICAnPCc6IExlc3NUaGFuLAogICAgICAgICAgJz49JzogR3JlYXRlclRoYW5PckVxdWFsLAogICAgICAgICAgJzw9JzogTGVzc1RoYW5PckVxdWFsLAogICAgICAgICAgJ2FycmF5JzogQXNzZXJ0aW9uLAogICAgICAgICAgJ2F0JzogQXQsCiAgICAgICAgICAnYm9vbGVhbic6IEFzc2VydGlvbiwKICAgICAgICAgICdjYXNlJzogQ2FzZSwKICAgICAgICAgICdjb2FsZXNjZSc6IENvYWxlc2NlLAogICAgICAgICAgJ2NvbGxhdG9yJzogQ29sbGF0b3JFeHByZXNzaW9uLAogICAgICAgICAgJ2Zvcm1hdCc6IEZvcm1hdEV4cHJlc3Npb24sCiAgICAgICAgICAnaW1hZ2UnOiBJbWFnZUV4cHJlc3Npb24sCiAgICAgICAgICAnaW4nOiBJbiwKICAgICAgICAgICdpbmRleC1vZic6IEluZGV4T2YsCiAgICAgICAgICAnaW50ZXJwb2xhdGUnOiBJbnRlcnBvbGF0ZSwKICAgICAgICAgICdpbnRlcnBvbGF0ZS1oY2wnOiBJbnRlcnBvbGF0ZSwKICAgICAgICAgICdpbnRlcnBvbGF0ZS1sYWInOiBJbnRlcnBvbGF0ZSwKICAgICAgICAgICdsZW5ndGgnOiBMZW5ndGgsCiAgICAgICAgICAnbGV0JzogTGV0LAogICAgICAgICAgJ2xpdGVyYWwnOiBMaXRlcmFsLAogICAgICAgICAgJ21hdGNoJzogTWF0Y2gsCiAgICAgICAgICAnbnVtYmVyJzogQXNzZXJ0aW9uLAogICAgICAgICAgJ251bWJlci1mb3JtYXQnOiBOdW1iZXJGb3JtYXQsCiAgICAgICAgICAnb2JqZWN0JzogQXNzZXJ0aW9uLAogICAgICAgICAgJ3NsaWNlJzogU2xpY2UsCiAgICAgICAgICAnc3RlcCc6IFN0ZXAsCiAgICAgICAgICAnc3RyaW5nJzogQXNzZXJ0aW9uLAogICAgICAgICAgJ3RvLWJvb2xlYW4nOiBDb2VyY2lvbiwKICAgICAgICAgICd0by1jb2xvcic6IENvZXJjaW9uLAogICAgICAgICAgJ3RvLW51bWJlcic6IENvZXJjaW9uLAogICAgICAgICAgJ3RvLXN0cmluZyc6IENvZXJjaW9uLAogICAgICAgICAgJ3Zhcic6IFZhciwKICAgICAgICAgICd3aXRoaW4nOiBXaXRoaW4KICAgICAgfTsKICAgICAgZnVuY3Rpb24gcmdiYShjdHgsIHJlZikgewogICAgICAgICAgdmFyIHIgPSByZWZbMF07CiAgICAgICAgICB2YXIgZyA9IHJlZlsxXTsKICAgICAgICAgIHZhciBiID0gcmVmWzJdOwogICAgICAgICAgdmFyIGEgPSByZWZbM107CiAgICAgICAgICByID0gci5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgZyA9IGcuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgIGIgPSBiLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICB2YXIgYWxwaGEgPSBhID8gYS5ldmFsdWF0ZShjdHgpIDogMTsKICAgICAgICAgIHZhciBlcnJvciA9IHZhbGlkYXRlUkdCQShyLCBnLCBiLCBhbHBoYSk7CiAgICAgICAgICBpZiAoZXJyb3IpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSAqIGFscGhhLCBnIC8gMjU1ICogYWxwaGEsIGIgLyAyNTUgKiBhbHBoYSwgYWxwaGEpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGhhcyhrZXksIG9iaikgewogICAgICAgICAgcmV0dXJuIGtleSBpbiBvYmo7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0KGtleSwgb2JqKSB7CiAgICAgICAgICB2YXIgdiA9IG9ialtrZXldOwogICAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB2OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpbmFyeVNlYXJjaCh2LCBhLCBpLCBqKSB7CiAgICAgICAgICB3aGlsZSAoaSA8PSBqKSB7CiAgICAgICAgICAgICAgdmFyIG0gPSBpICsgaiA+PiAxOwogICAgICAgICAgICAgIGlmIChhW21dID09PSB2KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoYVttXSA+IHYpIHsKICAgICAgICAgICAgICAgICAgaiA9IG0gLSAxOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGkgPSBtICsgMTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdmFyYXJncyh0eXBlKSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlIH07CiAgICAgIH0KICAgICAgQ29tcG91bmRFeHByZXNzaW9uLnJlZ2lzdGVyKGV4cHJlc3Npb25zLCB7CiAgICAgICAgICAnZXJyb3InOiBbCiAgICAgICAgICAgICAgRXJyb3JUeXBlLAogICAgICAgICAgICAgIFtTdHJpbmdUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3Iodi5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ3R5cGVvZic6IFsKICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgIFtWYWx1ZVR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHR5cGVPZih2LmV2YWx1YXRlKGN0eCkpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ3RvLXJnYmEnOiBbCiAgICAgICAgICAgICAgYXJyYXkoTnVtYmVyVHlwZSwgNCksCiAgICAgICAgICAgICAgW0NvbG9yVHlwZV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gdi5ldmFsdWF0ZShjdHgpLnRvQXJyYXkoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ3JnYic6IFsKICAgICAgICAgICAgICBDb2xvclR5cGUsCiAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlCiAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICByZ2JhCiAgICAgICAgICBdLAogICAgICAgICAgJ3JnYmEnOiBbCiAgICAgICAgICAgICAgQ29sb3JUeXBlLAogICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZQogICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgcmdiYQogICAgICAgICAgXSwKICAgICAgICAgICdoYXMnOiB7CiAgICAgICAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgb3ZlcmxvYWRzOiBbCiAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgIFtTdHJpbmdUeXBlXSwKICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhcyhrZXkuZXZhbHVhdGUoY3R4KSwgY3R4LnByb3BlcnRpZXMoKSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdFR5cGUKICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSByZWZbMV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhcyhrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgXQogICAgICAgICAgfSwKICAgICAgICAgICdnZXQnOiB7CiAgICAgICAgICAgICAgdHlwZTogVmFsdWVUeXBlLAogICAgICAgICAgICAgIG92ZXJsb2FkczogWwogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sCiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlCiAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gcmVmWzFdOwogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIG9iai5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgIF0KICAgICAgICAgIH0sCiAgICAgICAgICAnZmVhdHVyZS1zdGF0ZSc6IFsKICAgICAgICAgICAgICBWYWx1ZVR5cGUsCiAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBjdHguZmVhdHVyZVN0YXRlIHx8IHt9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ3Byb3BlcnRpZXMnOiBbCiAgICAgICAgICAgICAgT2JqZWN0VHlwZSwKICAgICAgICAgICAgICBbXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgucHJvcGVydGllcygpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZ2VvbWV0cnktdHlwZSc6IFsKICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgIFtdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5nZW9tZXRyeVR5cGUoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2lkJzogWwogICAgICAgICAgICAgIFZhbHVlVHlwZSwKICAgICAgICAgICAgICBbXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaWQoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ3pvb20nOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguZ2xvYmFscy56b29tOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnaGVhdG1hcC1kZW5zaXR5JzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgW10sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbHMuaGVhdG1hcERlbnNpdHkgfHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2xpbmUtcHJvZ3Jlc3MnOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2FjY3VtdWxhdGVkJzogWwogICAgICAgICAgICAgIFZhbHVlVHlwZSwKICAgICAgICAgICAgICBbXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4KSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguZ2xvYmFscy5hY2N1bXVsYXRlZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN0eC5nbG9iYWxzLmFjY3VtdWxhdGVkOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnKyc6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgYXJncykgewogICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gMDsKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07CiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYXJnLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJyonOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHsKICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDE7CiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldOwogICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICo9IGFyZy5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICctJzogewogICAgICAgICAgICAgIHR5cGU6IE51bWJlclR5cGUsCiAgICAgICAgICAgICAgb3ZlcmxvYWRzOiBbCiAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlclR5cGUKICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIC0gYi5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWEuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgIF0KICAgICAgICAgIH0sCiAgICAgICAgICAnLyc6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZQogICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBhID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSAvIGIuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJyUnOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgICAgIE51bWJlclR5cGUKICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgYSA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgdmFyIGIgPSByZWZbMV07CiAgICAgICAgICAgICAgICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgJSBiLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdsbjInOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLkxOMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ3BpJzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgW10sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5QSTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2UnOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLkU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdeJzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlCiAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIGIgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHZhciBlID0gcmVmWzFdOwogICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coYi5ldmFsdWF0ZShjdHgpLCBlLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnc3FydCc6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIHggPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoeC5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2xvZzEwJzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgbiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSkgLyBNYXRoLkxOMTA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdsbic6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnbG9nMic6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpIC8gTWF0aC5MTjI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdzaW4nOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBuID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4obi5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2Nvcyc6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNvcyhuLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAndGFuJzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgbiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgudGFuKG4uZXZhbHVhdGUoY3R4KSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdhc2luJzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgbiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXNpbihuLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnYWNvcyc6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3Mobi5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2F0YW4nOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBuID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuKG4uZXZhbHVhdGUoY3R4KSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdtaW4nOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnbWF4JzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2Ficyc6IFsKICAgICAgICAgICAgICBOdW1iZXJUeXBlLAogICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhuLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAncm91bmQnOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBuID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICB2YXIgdiA9IG4uZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgPCAwID8gLU1hdGgucm91bmQoLXYpIDogTWF0aC5yb3VuZCh2KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2Zsb29yJzogWwogICAgICAgICAgICAgIE51bWJlclR5cGUsCiAgICAgICAgICAgICAgW051bWJlclR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgbiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iobi5ldmFsdWF0ZShjdHgpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2NlaWwnOiBbCiAgICAgICAgICAgICAgTnVtYmVyVHlwZSwKICAgICAgICAgICAgICBbTnVtYmVyVHlwZV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBuID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG4uZXZhbHVhdGUoY3R4KSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdmaWx0ZXItPT0nOiBbCiAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgayA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07CiAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgucHJvcGVydGllcygpW2sudmFsdWVdID09PSB2LnZhbHVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZmlsdGVyLWlkLT09JzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFtWYWx1ZVR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5pZCgpID09PSB2LnZhbHVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZmlsdGVyLXR5cGUtPT0nOiBbCiAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gdi52YWx1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2ZpbHRlci08JzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgVmFsdWVUeXBlCiAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVmWzFdOwogICAgICAgICAgICAgICAgICB2YXIgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07CiAgICAgICAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDwgYjsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2ZpbHRlci1pZC08JzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFtWYWx1ZVR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgdmFyIGEgPSBjdHguaWQoKTsKICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPCBiOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZmlsdGVyLT4nOiBbCiAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgayA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07CiAgICAgICAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTsKICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPiBiOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZmlsdGVyLWlkLT4nOiBbCiAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgW1ZhbHVlVHlwZV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICB2YXIgYSA9IGN0eC5pZCgpOwogICAgICAgICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+IGI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdmaWx0ZXItPD0nOiBbCiAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgayA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07CiAgICAgICAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTsKICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPD0gYjsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2ZpbHRlci1pZC08PSc6IFsKICAgICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICBbVmFsdWVUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHZhciBhID0gY3R4LmlkKCk7CiAgICAgICAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDw9IGI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdmaWx0ZXItPj0nOiBbCiAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgICAgICBWYWx1ZVR5cGUKICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgayA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07CiAgICAgICAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTsKICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlOwogICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPj0gYjsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2ZpbHRlci1pZC0+PSc6IFsKICAgICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICBbVmFsdWVUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHZhciBhID0gY3R4LmlkKCk7CiAgICAgICAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID49IGI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdmaWx0ZXItaGFzJzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFtWYWx1ZVR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgayA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGsudmFsdWUgaW4gY3R4LnByb3BlcnRpZXMoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2ZpbHRlci1oYXMtaWQnOiBbCiAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgW10sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmlkKCkgIT09IG51bGwgJiYgY3R4LmlkKCkgIT09IHVuZGVmaW5lZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2ZpbHRlci10eXBlLWluJzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFthcnJheShTdHJpbmdUeXBlKV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gdi52YWx1ZS5pbmRleE9mKGN0eC5nZW9tZXRyeVR5cGUoKSkgPj0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ2ZpbHRlci1pZC1pbic6IFsKICAgICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICBbYXJyYXkoVmFsdWVUeXBlKV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gdi52YWx1ZS5pbmRleE9mKGN0eC5pZCgpKSA+PSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZmlsdGVyLWluLXNtYWxsJzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgYXJyYXkoVmFsdWVUeXBlKQogICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBrID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHYudmFsdWUuaW5kZXhPZihjdHgucHJvcGVydGllcygpW2sudmFsdWVdKSA+PSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZmlsdGVyLWluLWxhcmdlJzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICAgICAgYXJyYXkoVmFsdWVUeXBlKQogICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBrID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaChjdHgucHJvcGVydGllcygpW2sudmFsdWVdLCB2LnZhbHVlLCAwLCB2LnZhbHVlLmxlbmd0aCAtIDEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnYWxsJzogewogICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIG92ZXJsb2FkczogWwogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUKICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpICYmIGIuZXZhbHVhdGUoY3R4KTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgICAgdmFyYXJncyhCb29sZWFuVHlwZSksCiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcuZXZhbHVhdGUoY3R4KSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgXQogICAgICAgICAgfSwKICAgICAgICAgICdhbnknOiB7CiAgICAgICAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsCiAgICAgICAgICAgICAgb3ZlcmxvYWRzOiBbCiAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZQogICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gcmVmWzFdOwogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgfHwgYi5ldmFsdWF0ZShjdHgpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICB2YXJhcmdzKEJvb2xlYW5UeXBlKSwKICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGFyZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmV2YWx1YXRlKGN0eCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgIF0KICAgICAgICAgIH0sCiAgICAgICAgICAnISc6IFsKICAgICAgICAgICAgICBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICBbQm9vbGVhblR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgYiA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuICFiLmV2YWx1YXRlKGN0eCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdpcy1zdXBwb3J0ZWQtc2NyaXB0JzogWwogICAgICAgICAgICAgIEJvb2xlYW5UeXBlLAogICAgICAgICAgICAgIFtTdHJpbmdUeXBlXSwKICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHsKICAgICAgICAgICAgICAgICAgdmFyIHMgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHZhciBpc1N1cHBvcnRlZFNjcmlwdCA9IGN0eC5nbG9iYWxzICYmIGN0eC5nbG9iYWxzLmlzU3VwcG9ydGVkU2NyaXB0OwogICAgICAgICAgICAgICAgICBpZiAoaXNTdXBwb3J0ZWRTY3JpcHQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZFNjcmlwdChzLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAndXBjYXNlJzogWwogICAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgcyA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuZXZhbHVhdGUoY3R4KS50b1VwcGVyQ2FzZSgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAnZG93bmNhc2UnOiBbCiAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7CiAgICAgICAgICAgICAgICAgIHZhciBzID0gcmVmWzBdOwogICAgICAgICAgICAgICAgICByZXR1cm4gcy5ldmFsdWF0ZShjdHgpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICdjb25jYXQnOiBbCiAgICAgICAgICAgICAgU3RyaW5nVHlwZSwKICAgICAgICAgICAgICB2YXJhcmdzKFZhbHVlVHlwZSksCiAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgYXJncykgewogICAgICAgICAgICAgICAgICByZXR1cm4gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nJDEoYXJnLmV2YWx1YXRlKGN0eCkpOwogICAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgJ3Jlc29sdmVkLWxvY2FsZSc6IFsKICAgICAgICAgICAgICBTdHJpbmdUeXBlLAogICAgICAgICAgICAgIFtDb2xsYXRvclR5cGVdLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikgewogICAgICAgICAgICAgICAgICB2YXIgY29sbGF0b3IgPSByZWZbMF07CiAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsYXRvci5ldmFsdWF0ZShjdHgpLnJlc29sdmVkTG9jYWxlKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICB9KTsKCiAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3ModmFsdWUpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgcmVzdWx0OiAnc3VjY2VzcycsCiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlCiAgICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgIHJlc3VsdDogJ2Vycm9yJywKICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUKICAgICAgICAgIH07CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHNwZWMpIHsKICAgICAgICAgIHJldHVybiBzcGVjWydwcm9wZXJ0eS10eXBlJ10gPT09ICdkYXRhLWRyaXZlbicgfHwgc3BlY1sncHJvcGVydHktdHlwZSddID09PSAnY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW4nOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHN1cHBvcnRzWm9vbUV4cHJlc3Npb24oc3BlYykgewogICAgICAgICAgcmV0dXJuICEhc3BlYy5leHByZXNzaW9uICYmIHNwZWMuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzLmluZGV4T2YoJ3pvb20nKSA+IC0xOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJwb2xhdGlvbihzcGVjKSB7CiAgICAgICAgICByZXR1cm4gISFzcGVjLmV4cHJlc3Npb24gJiYgc3BlYy5leHByZXNzaW9uLmludGVycG9sYXRlZDsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gZ2V0VHlwZSh2YWwpIHsKICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHsKICAgICAgICAgICAgICByZXR1cm4gJ251bWJlcic7CiAgICAgICAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFN0cmluZykgewogICAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJzsKICAgICAgICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm9vbGVhbikgewogICAgICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7CiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgewogICAgICAgICAgICAgIHJldHVybiAnYXJyYXknOwogICAgICAgICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHsKICAgICAgICAgICAgICByZXR1cm4gJ251bGwnOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbDsKICAgICAgICAgIH0KICAgICAgfQoKICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbiQxKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbih4KSB7CiAgICAgICAgICByZXR1cm4geDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHsKICAgICAgICAgIHZhciBpc0NvbG9yID0gcHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcic7CiAgICAgICAgICB2YXIgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSBwYXJhbWV0ZXJzLnN0b3BzICYmIHR5cGVvZiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdID09PSAnb2JqZWN0JzsKICAgICAgICAgIHZhciBmZWF0dXJlRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgcGFyYW1ldGVycy5wcm9wZXJ0eSAhPT0gdW5kZWZpbmVkOwogICAgICAgICAgdmFyIHpvb21EZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCAhZmVhdHVyZURlcGVuZGVudDsKICAgICAgICAgIHZhciB0eXBlID0gcGFyYW1ldGVycy50eXBlIHx8IChzdXBwb3J0c0ludGVycG9sYXRpb24ocHJvcGVydHlTcGVjKSA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnKTsKICAgICAgICAgIGlmIChpc0NvbG9yKSB7CiAgICAgICAgICAgICAgcGFyYW1ldGVycyA9IGV4dGVuZCh7fSwgcGFyYW1ldGVycyk7CiAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuc3RvcHMpIHsKICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zdG9wcyA9IHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BbMF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgQ29sb3IucGFyc2Uoc3RvcFsxXSkKICAgICAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kZWZhdWx0KSB7CiAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdCA9IENvbG9yLnBhcnNlKHBhcmFtZXRlcnMuZGVmYXVsdCk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0ID0gQ29sb3IucGFyc2UocHJvcGVydHlTcGVjLmRlZmF1bHQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgJiYgcGFyYW1ldGVycy5jb2xvclNwYWNlICE9PSAncmdiJyAmJiAhY29sb3JTcGFjZXNbcGFyYW1ldGVycy5jb2xvclNwYWNlXSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2xvciBzcGFjZTogJyArIHBhcmFtZXRlcnMuY29sb3JTcGFjZSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgaW5uZXJGdW47CiAgICAgICAgICB2YXIgaGFzaGVkU3RvcHM7CiAgICAgICAgICB2YXIgY2F0ZWdvcmljYWxLZXlUeXBlOwogICAgICAgICAgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHsKICAgICAgICAgICAgICBpbm5lckZ1biA9IGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbjsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykgewogICAgICAgICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7CiAgICAgICAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb247CiAgICAgICAgICAgICAgaGFzaGVkU3RvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1ldGVycy5zdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBsaXN0W2ldOwogICAgICAgICAgICAgICAgICBoYXNoZWRTdG9wc1tzdG9wWzBdXSA9IHN0b3BbMV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhdGVnb3JpY2FsS2V5VHlwZSA9IHR5cGVvZiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaWRlbnRpdHknKSB7CiAgICAgICAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb247CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmdW5jdGlvbiB0eXBlICInICsgdHlwZSArICciJyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQpIHsKICAgICAgICAgICAgICB2YXIgZmVhdHVyZUZ1bmN0aW9ucyA9IHt9OwogICAgICAgICAgICAgIHZhciB6b29tU3RvcHMgPSBbXTsKICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoOyBzKyspIHsKICAgICAgICAgICAgICAgICAgdmFyIHN0b3AkMSA9IHBhcmFtZXRlcnMuc3RvcHNbc107CiAgICAgICAgICAgICAgICAgIHZhciB6b29tID0gc3RvcCQxWzBdLnpvb207CiAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlRnVuY3Rpb25zW3pvb21dID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbTogem9vbSwKICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbWV0ZXJzLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcmFtZXRlcnMucHJvcGVydHksCiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0LAogICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BzOiBbXQogICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgIHpvb21TdG9wcy5wdXNoKHpvb20pOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0uc3RvcHMucHVzaChbCiAgICAgICAgICAgICAgICAgICAgICBzdG9wJDFbMF0udmFsdWUsCiAgICAgICAgICAgICAgICAgICAgICBzdG9wJDFbMV0KICAgICAgICAgICAgICAgICAgXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBmZWF0dXJlRnVuY3Rpb25TdG9wcyA9IFtdOwogICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHpvb21TdG9wczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIHogPSBsaXN0JDFbaSQxXTsKICAgICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHMucHVzaChbCiAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25zW3pdLnpvb20sCiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25zW3pdLCBwcm9wZXJ0eVNwZWMpCiAgICAgICAgICAgICAgICAgIF0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGlvblR5cGUgPSB7IG5hbWU6ICdsaW5lYXInIH07CiAgICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgICAga2luZDogJ2NvbXBvc2l0ZScsCiAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25UeXBlOiBpbnRlcnBvbGF0aW9uVHlwZSwKICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHVuZGVmaW5lZCwgaW50ZXJwb2xhdGlvblR5cGUpLAogICAgICAgICAgICAgICAgICB6b29tU3RvcHM6IGZlYXR1cmVGdW5jdGlvblN0b3BzLm1hcChmdW5jdGlvbiAocykgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNbMF07CiAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUocmVmLCBwcm9wZXJ0aWVzKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgem9vbSA9IHJlZi56b29tOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbih7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHM6IGZlYXR1cmVGdW5jdGlvblN0b3BzLAogICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZQogICAgICAgICAgICAgICAgICAgICAgfSwgcHJvcGVydHlTcGVjLCB6b29tKS5ldmFsdWF0ZSh6b29tLCBwcm9wZXJ0aWVzKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH07CiAgICAgICAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHsKICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGlvblR5cGUkMSA9IHR5cGUgPT09ICdleHBvbmVudGlhbCcgPyB7CiAgICAgICAgICAgICAgICAgIG5hbWU6ICdleHBvbmVudGlhbCcsCiAgICAgICAgICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMQogICAgICAgICAgICAgIH0gOiBudWxsOwogICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICAgIGtpbmQ6ICdjYW1lcmEnLAogICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZTogaW50ZXJwb2xhdGlvblR5cGUkMSwKICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHVuZGVmaW5lZCwgaW50ZXJwb2xhdGlvblR5cGUkMSksCiAgICAgICAgICAgICAgICAgIHpvb21TdG9wczogcGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHMpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzWzBdOwogICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZWYpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciB6b29tID0gcmVmLnpvb207CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJGdW4ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCB6b29tLCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzb3VyY2UnLAogICAgICAgICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoXywgZmVhdHVyZSkgewogICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZmVhdHVyZSAmJiBmZWF0dXJlLnByb3BlcnRpZXMgPyBmZWF0dXJlLnByb3BlcnRpZXNbcGFyYW1ldGVycy5wcm9wZXJ0eV0gOiB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckZ1bihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHZhbHVlLCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH07CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29hbGVzY2UoYSwgYiwgYykgewogICAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBhOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGIgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBiOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGMgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBjOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlQ2F0ZWdvcmljYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0LCBoYXNoZWRTdG9wcywga2V5VHlwZSkgewogICAgICAgICAgdmFyIGV2YWx1YXRlZCA9IHR5cGVvZiBpbnB1dCA9PT0ga2V5VHlwZSA/IGhhc2hlZFN0b3BzW2lucHV0XSA6IHVuZGVmaW5lZDsKICAgICAgICAgIHJldHVybiBjb2FsZXNjZShldmFsdWF0ZWQsIHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7CiAgICAgICAgICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDsKICAgICAgICAgIGlmIChuID09PSAxKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5wdXQgPD0gcGFyYW1ldGVycy5zdG9wc1swXVswXSkgewogICAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGlucHV0ID49IHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzBdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkgewogICAgICAgICAgICAgIHJldHVybiBzdG9wWzBdOwogICAgICAgICAgfSksIGlucHV0KTsKICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBldmFsdWF0ZUV4cG9uZW50aWFsRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCkgewogICAgICAgICAgdmFyIGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7CiAgICAgICAgICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDsKICAgICAgICAgIGlmIChuID09PSAxKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5wdXQgPD0gcGFyYW1ldGVycy5zdG9wc1swXVswXSkgewogICAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGlucHV0ID49IHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzBdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkgewogICAgICAgICAgICAgIHJldHVybiBzdG9wWzBdOwogICAgICAgICAgfSksIGlucHV0KTsKICAgICAgICAgIHZhciB0ID0gaW50ZXJwb2xhdGlvbkZhY3RvcihpbnB1dCwgYmFzZSwgcGFyYW1ldGVycy5zdG9wc1tpbmRleF1bMF0sIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXggKyAxXVswXSk7CiAgICAgICAgICB2YXIgb3V0cHV0TG93ZXIgPSBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTsKICAgICAgICAgIHZhciBvdXRwdXRVcHBlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXggKyAxXVsxXTsKICAgICAgICAgIHZhciBpbnRlcnAgPSBpbnRlcnBvbGF0ZVtwcm9wZXJ0eVNwZWMudHlwZV0gfHwgaWRlbnRpdHlGdW5jdGlvbjsKICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgJiYgcGFyYW1ldGVycy5jb2xvclNwYWNlICE9PSAncmdiJykgewogICAgICAgICAgICAgIHZhciBjb2xvcnNwYWNlID0gY29sb3JTcGFjZXNbcGFyYW1ldGVycy5jb2xvclNwYWNlXTsKICAgICAgICAgICAgICBpbnRlcnAgPSBmdW5jdGlvbiAoYSwgYikgewogICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzcGFjZS5yZXZlcnNlKGNvbG9yc3BhY2UuaW50ZXJwb2xhdGUoY29sb3JzcGFjZS5mb3J3YXJkKGEpLCBjb2xvcnNwYWNlLmZvcndhcmQoYiksIHQpKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXRMb3dlci5ldmFsdWF0ZSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZSgpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuLS0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07CiAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZhbHVhdGVkTG93ZXIgPSBvdXRwdXRMb3dlci5ldmFsdWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOwogICAgICAgICAgICAgICAgICAgICAgdmFyIGV2YWx1YXRlZFVwcGVyID0gb3V0cHV0VXBwZXIuZXZhbHVhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChldmFsdWF0ZWRMb3dlciA9PT0gdW5kZWZpbmVkIHx8IGV2YWx1YXRlZFVwcGVyID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycChldmFsdWF0ZWRMb3dlciwgZXZhbHVhdGVkVXBwZXIsIHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBpbnRlcnAob3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyLCB0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCkgewogICAgICAgICAgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnY29sb3InKSB7CiAgICAgICAgICAgICAgaW5wdXQgPSBDb2xvci5wYXJzZShpbnB1dCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnZm9ybWF0dGVkJykgewogICAgICAgICAgICAgIGlucHV0ID0gRm9ybWF0dGVkLmZyb21TdHJpbmcoaW5wdXQudG9TdHJpbmcoKSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAncmVzb2x2ZWRJbWFnZScpIHsKICAgICAgICAgICAgICBpbnB1dCA9IFJlc29sdmVkSW1hZ2UuZnJvbVN0cmluZyhpbnB1dC50b1N0cmluZygpKTsKICAgICAgICAgIH0gZWxzZSBpZiAoZ2V0VHlwZShpbnB1dCkgIT09IHByb3BlcnR5U3BlYy50eXBlICYmIChwcm9wZXJ0eVNwZWMudHlwZSAhPT0gJ2VudW0nIHx8ICFwcm9wZXJ0eVNwZWMudmFsdWVzW2lucHV0XSkpIHsKICAgICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBjb2FsZXNjZShpbnB1dCwgcGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGlvbkZhY3RvcihpbnB1dCwgYmFzZSwgbG93ZXJWYWx1ZSwgdXBwZXJWYWx1ZSkgewogICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSB1cHBlclZhbHVlIC0gbG93ZXJWYWx1ZTsKICAgICAgICAgIHZhciBwcm9ncmVzcyA9IGlucHV0IC0gbG93ZXJWYWx1ZTsKICAgICAgICAgIGlmIChkaWZmZXJlbmNlID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICB9IGVsc2UgaWYgKGJhc2UgPT09IDEpIHsKICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3MgLyBkaWZmZXJlbmNlOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gKE1hdGgucG93KGJhc2UsIHByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRpZmZlcmVuY2UpIC0gMSk7CiAgICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBTdHlsZUV4cHJlc3Npb24gPSBmdW5jdGlvbiBTdHlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7CiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uOwogICAgICAgICAgdGhpcy5fd2FybmluZ0hpc3RvcnkgPSB7fTsKICAgICAgICAgIHRoaXMuX2V2YWx1YXRvciA9IG5ldyBFdmFsdWF0aW9uQ29udGV4dCgpOwogICAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gcHJvcGVydHlTcGVjID8gZ2V0RGVmYXVsdFZhbHVlKHByb3BlcnR5U3BlYykgOiBudWxsOwogICAgICAgICAgdGhpcy5fZW51bVZhbHVlcyA9IHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2VudW0nID8gcHJvcGVydHlTcGVjLnZhbHVlcyA6IG51bGw7CiAgICAgIH07CiAgICAgIFN0eWxlRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikgewogICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBnbG9iYWxzOwogICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlOwogICAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IGZlYXR1cmVTdGF0ZTsKICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWw7CiAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuYXZhaWxhYmxlSW1hZ2VzID0gYXZhaWxhYmxlSW1hZ2VzIHx8IG51bGw7CiAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb247CiAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7CiAgICAgIH07CiAgICAgIFN0eWxlRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7CiAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGdsb2JhbHM7CiAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZSA9IGZlYXR1cmUgfHwgbnVsbDsKICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlU3RhdGUgPSBmZWF0dXJlU3RhdGUgfHwgbnVsbDsKICAgICAgICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWw7CiAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuYXZhaWxhYmxlSW1hZ2VzID0gYXZhaWxhYmxlSW1hZ2VzIHx8IG51bGw7CiAgICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb24gfHwgbnVsbDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpOwogICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgdmFsICE9PSB2YWwpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHRoaXMuX2VudW1WYWx1ZXMgJiYgISh2YWwgaW4gdGhpcy5fZW51bVZhbHVlcykpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyh0aGlzLl9lbnVtVmFsdWVzKS5tYXAoZnVuY3Rpb24gKHYpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTsKICAgICAgICAgICAgICAgICAgfSkuam9pbignLCAnKSArICcsIGJ1dCBmb3VuZCAnICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICcgaW5zdGVhZC4nKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0pIHsKICAgICAgICAgICAgICAgICAgdGhpcy5fd2FybmluZ0hpc3RvcnlbZS5tZXNzYWdlXSA9IHRydWU7CiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlLm1lc3NhZ2UpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7CiAgICAgICAgICB9CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbihleHByZXNzaW9uKSB7CiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShleHByZXNzaW9uKSAmJiBleHByZXNzaW9uLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGV4cHJlc3Npb25bMF0gPT09ICdzdHJpbmcnICYmIGV4cHJlc3Npb25bMF0gaW4gZXhwcmVzc2lvbnM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHsKICAgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2luZ0NvbnRleHQoZXhwcmVzc2lvbnMsIFtdLCBwcm9wZXJ0eVNwZWMgPyBnZXRFeHBlY3RlZFR5cGUocHJvcGVydHlTcGVjKSA6IHVuZGVmaW5lZCk7CiAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKGV4cHJlc3Npb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyB7IHR5cGVBbm5vdGF0aW9uOiAnY29lcmNlJyB9IDogdW5kZWZpbmVkKTsKICAgICAgICAgIGlmICghcGFyc2VkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKHBhcnNlci5lcnJvcnMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MobmV3IFN0eWxlRXhwcmVzc2lvbihwYXJzZWQsIHByb3BlcnR5U3BlYykpOwogICAgICB9CiAgICAgIHZhciBab29tQ29uc3RhbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gWm9vbUNvbnN0YW50RXhwcmVzc2lvbihraW5kLCBleHByZXNzaW9uKSB7CiAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kOwogICAgICAgICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjsKICAgICAgICAgIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGtpbmQgIT09ICdjb25zdGFudCcgJiYgIWlzU3RhdGVDb25zdGFudChleHByZXNzaW9uLmV4cHJlc3Npb24pOwogICAgICB9OwogICAgICBab29tQ29uc3RhbnRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nID0gZnVuY3Rpb24gZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7CiAgICAgIH07CiAgICAgIFpvb21Db25zdGFudEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTsKICAgICAgfTsKICAgICAgdmFyIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gWm9vbURlcGVuZGVudEV4cHJlc3Npb24oa2luZCwgZXhwcmVzc2lvbiwgem9vbVN0b3BzLCBpbnRlcnBvbGF0aW9uVHlwZSkgewogICAgICAgICAgdGhpcy5raW5kID0ga2luZDsKICAgICAgICAgIHRoaXMuem9vbVN0b3BzID0gem9vbVN0b3BzOwogICAgICAgICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjsKICAgICAgICAgIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGtpbmQgIT09ICdjYW1lcmEnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbi5leHByZXNzaW9uKTsKICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBpbnRlcnBvbGF0aW9uVHlwZTsKICAgICAgfTsKICAgICAgWm9vbURlcGVuZGVudEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcgPSBmdW5jdGlvbiBldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTsKICAgICAgfTsKICAgICAgWm9vbURlcGVuZGVudEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTsKICAgICAgfTsKICAgICAgWm9vbURlcGVuZGVudEV4cHJlc3Npb24ucHJvdG90eXBlLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBsb3dlciwgdXBwZXIpIHsKICAgICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb25UeXBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uVHlwZSwgaW5wdXQsIGxvd2VyLCB1cHBlcik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgfQogICAgICB9OwogICAgICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7CiAgICAgICAgICBleHByZXNzaW9uID0gY3JlYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpOwogICAgICAgICAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcGFyc2VkID0gZXhwcmVzc2lvbi52YWx1ZS5leHByZXNzaW9uOwogICAgICAgICAgdmFyIGlzRmVhdHVyZUNvbnN0YW50JDEgPSBpc0ZlYXR1cmVDb25zdGFudChwYXJzZWQpOwogICAgICAgICAgaWYgKCFpc0ZlYXR1cmVDb25zdGFudCQxICYmICFzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihwcm9wZXJ0eVNwZWMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnZGF0YSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkJyldKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpc1pvb21Db25zdGFudCA9IGlzR2xvYmFsUHJvcGVydHlDb25zdGFudChwYXJzZWQsIFsnem9vbSddKTsKICAgICAgICAgIGlmICghaXNab29tQ29uc3RhbnQgJiYgIXN1cHBvcnRzWm9vbUV4cHJlc3Npb24ocHJvcGVydHlTcGVjKSkgewogICAgICAgICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ3pvb20gZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZCcpXSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgem9vbUN1cnZlID0gZmluZFpvb21DdXJ2ZShwYXJzZWQpOwogICAgICAgICAgaWYgKCF6b29tQ3VydmUgJiYgIWlzWm9vbUNvbnN0YW50KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnInpvb20iIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCAic3RlcCIgb3IgImludGVycG9sYXRlIiBleHByZXNzaW9uLicpXSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHpvb21DdXJ2ZSBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvcikgewogICAgICAgICAgICAgIHJldHVybiBlcnJvcihbem9vbUN1cnZlXSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlICYmICFzdXBwb3J0c0ludGVycG9sYXRpb24ocHJvcGVydHlTcGVjKSkgewogICAgICAgICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJyJpbnRlcnBvbGF0ZSIgZXhwcmVzc2lvbnMgY2Fubm90IGJlIHVzZWQgd2l0aCB0aGlzIHByb3BlcnR5JyldKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghem9vbUN1cnZlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MoaXNGZWF0dXJlQ29uc3RhbnQkMSA/IG5ldyBab29tQ29uc3RhbnRFeHByZXNzaW9uKCdjb25zdGFudCcsIGV4cHJlc3Npb24udmFsdWUpIDogbmV3IFpvb21Db25zdGFudEV4cHJlc3Npb24oJ3NvdXJjZScsIGV4cHJlc3Npb24udmFsdWUpKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpbnRlcnBvbGF0aW9uVHlwZSA9IHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlID8gem9vbUN1cnZlLmludGVycG9sYXRpb24gOiB1bmRlZmluZWQ7CiAgICAgICAgICByZXR1cm4gc3VjY2Vzcyhpc0ZlYXR1cmVDb25zdGFudCQxID8gbmV3IFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKCdjYW1lcmEnLCBleHByZXNzaW9uLnZhbHVlLCB6b29tQ3VydmUubGFiZWxzLCBpbnRlcnBvbGF0aW9uVHlwZSkgOiBuZXcgWm9vbURlcGVuZGVudEV4cHJlc3Npb24oJ2NvbXBvc2l0ZScsIGV4cHJlc3Npb24udmFsdWUsIHpvb21DdXJ2ZS5sYWJlbHMsIGludGVycG9sYXRpb25UeXBlKSk7CiAgICAgIH0KICAgICAgdmFyIFN0eWxlUHJvcGVydHlGdW5jdGlvbiA9IGZ1bmN0aW9uIFN0eWxlUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBzcGVjaWZpY2F0aW9uKSB7CiAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzID0gcGFyYW1ldGVyczsKICAgICAgICAgIHRoaXMuX3NwZWNpZmljYXRpb24gPSBzcGVjaWZpY2F0aW9uOwogICAgICAgICAgZXh0ZW5kKHRoaXMsIGNyZWF0ZUZ1bmN0aW9uKHRoaXMuX3BhcmFtZXRlcnMsIHRoaXMuX3NwZWNpZmljYXRpb24pKTsKICAgICAgfTsKICAgICAgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkgewogICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZVByb3BlcnR5RnVuY3Rpb24oc2VyaWFsaXplZC5fcGFyYW1ldGVycywgc2VyaWFsaXplZC5fc3BlY2lmaWNhdGlvbik7CiAgICAgIH07CiAgICAgIFN0eWxlUHJvcGVydHlGdW5jdGlvbi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgX3BhcmFtZXRlcnM6IGlucHV0Ll9wYXJhbWV0ZXJzLAogICAgICAgICAgICAgIF9zcGVjaWZpY2F0aW9uOiBpbnB1dC5fc3BlY2lmaWNhdGlvbgogICAgICAgICAgfTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKSB7CiAgICAgICAgICBpZiAoaXNGdW5jdGlvbiQxKHZhbHVlKSkgewogICAgICAgICAgICAgIHJldHVybiBuZXcgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTsKICAgICAgICAgIH0gZWxzZSBpZiAoaXNFeHByZXNzaW9uKHZhbHVlKSkgewogICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTsKICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cHJlc3Npb24udmFsdWUubWFwKGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIua2V5ICsgJzogJyArIGVyci5tZXNzYWdlOwogICAgICAgICAgICAgICAgICB9KS5qb2luKCcsICcpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciBjb25zdGFudCA9IHZhbHVlOwogICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHNwZWNpZmljYXRpb24udHlwZSA9PT0gJ2NvbG9yJykgewogICAgICAgICAgICAgICAgICBjb25zdGFudCA9IENvbG9yLnBhcnNlKHZhbHVlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgICAga2luZDogJ2NvbnN0YW50JywKICAgICAgICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH07CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmluZFpvb21DdXJ2ZShleHByZXNzaW9uKSB7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDsKICAgICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgTGV0KSB7CiAgICAgICAgICAgICAgcmVzdWx0ID0gZmluZFpvb21DdXJ2ZShleHByZXNzaW9uLnJlc3VsdCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2FsZXNjZSkgewogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwcmVzc2lvbi5hcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTsKICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmluZFpvb21DdXJ2ZShhcmcpOwogICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBTdGVwIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSkgJiYgZXhwcmVzc2lvbi5pbnB1dCBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBleHByZXNzaW9uLmlucHV0Lm5hbWUgPT09ICd6b29tJykgewogICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHJlc3Npb247CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICAgIGV4cHJlc3Npb24uZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkgewogICAgICAgICAgICAgIHZhciBjaGlsZFJlc3VsdCA9IGZpbmRab29tQ3VydmUoY2hpbGQpOwogICAgICAgICAgICAgIGlmIChjaGlsZFJlc3VsdCBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvcikgewogICAgICAgICAgICAgICAgICByZXN1bHQgPSBjaGlsZFJlc3VsdDsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHQgJiYgY2hpbGRSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFBhcnNpbmdFcnJvcignJywgJyJ6b29tIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgInN0ZXAiIG9yICJpbnRlcnBvbGF0ZSIgZXhwcmVzc2lvbi4nKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiBjaGlsZFJlc3VsdCAmJiByZXN1bHQgIT09IGNoaWxkUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBQYXJzaW5nRXJyb3IoJycsICdPbmx5IG9uZSB6b29tLWJhc2VkICJzdGVwIiBvciAiaW50ZXJwb2xhdGUiIHN1YmV4cHJlc3Npb24gbWF5IGJlIHVzZWQgaW4gYW4gZXhwcmVzc2lvbi4nKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0RXhwZWN0ZWRUeXBlKHNwZWMpIHsKICAgICAgICAgIHZhciB0eXBlcyA9IHsKICAgICAgICAgICAgICBjb2xvcjogQ29sb3JUeXBlLAogICAgICAgICAgICAgIHN0cmluZzogU3RyaW5nVHlwZSwKICAgICAgICAgICAgICBudW1iZXI6IE51bWJlclR5cGUsCiAgICAgICAgICAgICAgZW51bTogU3RyaW5nVHlwZSwKICAgICAgICAgICAgICBib29sZWFuOiBCb29sZWFuVHlwZSwKICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IEZvcm1hdHRlZFR5cGUsCiAgICAgICAgICAgICAgcmVzb2x2ZWRJbWFnZTogUmVzb2x2ZWRJbWFnZVR5cGUKICAgICAgICAgIH07CiAgICAgICAgICBpZiAoc3BlYy50eXBlID09PSAnYXJyYXknKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5KHR5cGVzW3NwZWMudmFsdWVdIHx8IFZhbHVlVHlwZSwgc3BlYy5sZW5ndGgpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHR5cGVzW3NwZWMudHlwZV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKHNwZWMpIHsKICAgICAgICAgIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicgJiYgaXNGdW5jdGlvbiQxKHNwZWMuZGVmYXVsdCkpIHsKICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDApOwogICAgICAgICAgfSBlbHNlIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicpIHsKICAgICAgICAgICAgICByZXR1cm4gQ29sb3IucGFyc2Uoc3BlYy5kZWZhdWx0KSB8fCBudWxsOwogICAgICAgICAgfSBlbHNlIGlmIChzcGVjLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gc3BlYy5kZWZhdWx0OwogICAgICAgICAgfQogICAgICB9CgogICAgICBmdW5jdGlvbiBjb252ZXJ0TGl0ZXJhbCh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBbCiAgICAgICAgICAgICAgJ2xpdGVyYWwnLAogICAgICAgICAgICAgIHZhbHVlCiAgICAgICAgICBdIDogdmFsdWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29udmVydEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykgewogICAgICAgICAgdmFyIHN0b3BzID0gcGFyYW1ldGVycy5zdG9wczsKICAgICAgICAgIGlmICghc3RvcHMpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udmVydElkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB6b29tQW5kRmVhdHVyZURlcGVuZGVudCA9IHN0b3BzICYmIHR5cGVvZiBzdG9wc1swXVswXSA9PT0gJ29iamVjdCc7CiAgICAgICAgICB2YXIgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDsKICAgICAgICAgIHZhciB6b29tRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgIWZlYXR1cmVEZXBlbmRlbnQ7CiAgICAgICAgICBzdG9wcyA9IHN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkgewogICAgICAgICAgICAgIGlmICghZmVhdHVyZURlcGVuZGVudCAmJiBwcm9wZXJ0eVNwZWMudG9rZW5zICYmIHR5cGVvZiBzdG9wWzFdID09PSAnc3RyaW5nJykgewogICAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgICAgc3RvcFswXSwKICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRUb2tlblN0cmluZyhzdG9wWzFdKQogICAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICBzdG9wWzBdLAogICAgICAgICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChzdG9wWzFdKQogICAgICAgICAgICAgIF07CiAgICAgICAgICB9KTsKICAgICAgICAgIGlmICh6b29tQW5kRmVhdHVyZURlcGVuZGVudCkgewogICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcyk7CiAgICAgICAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHsKICAgICAgICAgICAgICByZXR1cm4gY29udmVydFpvb21GdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykgewogICAgICAgICAgdmFyIGdldCA9IFsKICAgICAgICAgICAgICAnZ2V0JywKICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnByb3BlcnR5CiAgICAgICAgICBdOwogICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5U3BlYy50eXBlID09PSAnc3RyaW5nJyA/IFsKICAgICAgICAgICAgICAgICAgJ3N0cmluZycsCiAgICAgICAgICAgICAgICAgIGdldAogICAgICAgICAgICAgIF0gOiBnZXQ7CiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnZW51bScpIHsKICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAnbWF0Y2gnLAogICAgICAgICAgICAgICAgICBnZXQsCiAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5U3BlYy52YWx1ZXMpLAogICAgICAgICAgICAgICAgICBnZXQsCiAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdAogICAgICAgICAgICAgIF07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gWwogICAgICAgICAgICAgICAgICBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJyA/ICd0by1jb2xvcicgOiBwcm9wZXJ0eVNwZWMudHlwZSwKICAgICAgICAgICAgICAgICAgZ2V0LAogICAgICAgICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpCiAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdhcnJheScpIHsKICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5zcGxpY2UoMSwgMCwgcHJvcGVydHlTcGVjLnZhbHVlLCBwcm9wZXJ0eVNwZWMubGVuZ3RoIHx8IG51bGwpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yKHBhcmFtZXRlcnMpIHsKICAgICAgICAgIHN3aXRjaCAocGFyYW1ldGVycy5jb2xvclNwYWNlKSB7CiAgICAgICAgICBjYXNlICdoY2wnOgogICAgICAgICAgICAgIHJldHVybiAnaW50ZXJwb2xhdGUtaGNsJzsKICAgICAgICAgIGNhc2UgJ2xhYic6CiAgICAgICAgICAgICAgcmV0dXJuICdpbnRlcnBvbGF0ZS1sYWInOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICByZXR1cm4gJ2ludGVycG9sYXRlJzsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcykgewogICAgICAgICAgdmFyIGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnMgPSB7fTsKICAgICAgICAgIHZhciBmZWF0dXJlRnVuY3Rpb25TdG9wcyA9IHt9OwogICAgICAgICAgdmFyIHpvb21TdG9wcyA9IFtdOwogICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdG9wcy5sZW5ndGg7IHMrKykgewogICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbc107CiAgICAgICAgICAgICAgdmFyIHpvb20gPSBzdG9wWzBdLnpvb207CiAgICAgICAgICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbem9vbV0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pvb21dID0gewogICAgICAgICAgICAgICAgICAgICAgem9vbTogem9vbSwKICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtZXRlcnMudHlwZSwKICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwYXJhbWV0ZXJzLnByb3BlcnR5LAogICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0CiAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pvb21dID0gW107CiAgICAgICAgICAgICAgICAgIHpvb21TdG9wcy5wdXNoKHpvb20pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6b29tXS5wdXNoKFsKICAgICAgICAgICAgICAgICAgc3RvcFswXS52YWx1ZSwKICAgICAgICAgICAgICAgICAgc3RvcFsxXQogICAgICAgICAgICAgIF0pOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGZ1bmN0aW9uVHlwZSA9IGdldEZ1bmN0aW9uVHlwZSh7fSwgcHJvcGVydHlTcGVjKTsKICAgICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcpIHsKICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IFsKICAgICAgICAgICAgICAgICAgZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSwKICAgICAgICAgICAgICAgICAgWydsaW5lYXInXSwKICAgICAgICAgICAgICAgICAgWyd6b29tJ10KICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gem9vbVN0b3BzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgICAgICB2YXIgeiA9IGxpc3RbaV07CiAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pdKTsKICAgICAgICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiwgeiwgb3V0cHV0LCBmYWxzZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiQxID0gWwogICAgICAgICAgICAgICAgICAnc3RlcCcsCiAgICAgICAgICAgICAgICAgIFsnem9vbSddCiAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSB6b29tU3RvcHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7CiAgICAgICAgICAgICAgICAgIHZhciB6JDEgPSBsaXN0JDFbaSQxXTsKICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCQxID0gY29udmVydFByb3BlcnR5RnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6JDFdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW3okMV0pOwogICAgICAgICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uJDEsIHokMSwgb3V0cHV0JDEsIHRydWUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbiQxKTsKICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbiQxOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvYWxlc2NlJDEoYSwgYikgewogICAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBhOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGIgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBiOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdldEZhbGxiYWNrKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykgewogICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGNvbnZlcnRMaXRlcmFsKGNvYWxlc2NlJDEocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCkpOwogICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnR5U3BlYy50eXBlID09PSAncmVzb2x2ZWRJbWFnZScpIHsKICAgICAgICAgICAgICByZXR1cm4gJyc7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpIHsKICAgICAgICAgIHZhciB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7CiAgICAgICAgICB2YXIgZ2V0ID0gWwogICAgICAgICAgICAgICdnZXQnLAogICAgICAgICAgICAgIHBhcmFtZXRlcnMucHJvcGVydHkKICAgICAgICAgIF07CiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlb2Ygc3RvcHNbMF1bMF0gPT09ICdib29sZWFuJykgewogICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gWydjYXNlJ107CiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBsaXN0W2ldOwogICAgICAgICAgICAgICAgICBleHByZXNzaW9uLnB1c2goWwogICAgICAgICAgICAgICAgICAgICAgJz09JywKICAgICAgICAgICAgICAgICAgICAgIGdldCwKICAgICAgICAgICAgICAgICAgICAgIHN0b3BbMF0KICAgICAgICAgICAgICAgICAgXSwgc3RvcFsxXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGV4cHJlc3Npb24ucHVzaChnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpKTsKICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJykgewogICAgICAgICAgICAgIHZhciBleHByZXNzaW9uJDEgPSBbCiAgICAgICAgICAgICAgICAgICdtYXRjaCcsCiAgICAgICAgICAgICAgICAgIGdldAogICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gc3RvcHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7CiAgICAgICAgICAgICAgICAgIHZhciBzdG9wJDEgPSBsaXN0JDFbaSQxXTsKICAgICAgICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiQxLCBzdG9wJDFbMF0sIHN0b3AkMVsxXSwgZmFsc2UpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBleHByZXNzaW9uJDEucHVzaChnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpKTsKICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbiQxOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7CiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24kMiA9IFsKICAgICAgICAgICAgICAgICAgJ3N0ZXAnLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJywKICAgICAgICAgICAgICAgICAgICAgIGdldAogICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwLCBsaXN0JDIgPSBzdG9wczsgaSQyIDwgbGlzdCQyLmxlbmd0aDsgaSQyICs9IDEpIHsKICAgICAgICAgICAgICAgICAgdmFyIHN0b3AkMiA9IGxpc3QkMltpJDJdOwogICAgICAgICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uJDIsIHN0b3AkMlswXSwgc3RvcCQyWzFdLCB0cnVlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24kMik7CiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkID8gZXhwcmVzc2lvbiQyIDogWwogICAgICAgICAgICAgICAgICAnY2FzZScsCiAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICc9PScsCiAgICAgICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGVvZicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0CiAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgJ251bWJlcicKICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiQyLAogICAgICAgICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpCiAgICAgICAgICAgICAgXTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykgewogICAgICAgICAgICAgIHZhciBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxOwogICAgICAgICAgICAgIHZhciBleHByZXNzaW9uJDMgPSBbCiAgICAgICAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksCiAgICAgICAgICAgICAgICAgIGJhc2UgPT09IDEgPyBbJ2xpbmVhciddIDogWwogICAgICAgICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJywKICAgICAgICAgICAgICAgICAgICAgIGJhc2UKICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgICAgJ251bWJlcicsCiAgICAgICAgICAgICAgICAgICAgICBnZXQKICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMCwgbGlzdCQzID0gc3RvcHM7IGkkMyA8IGxpc3QkMy5sZW5ndGg7IGkkMyArPSAxKSB7CiAgICAgICAgICAgICAgICAgIHZhciBzdG9wJDMgPSBsaXN0JDNbaSQzXTsKICAgICAgICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiQzLCBzdG9wJDNbMF0sIHN0b3AkM1sxXSwgZmFsc2UpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBleHByZXNzaW9uJDMgOiBbCiAgICAgICAgICAgICAgICAgICdjYXNlJywKICAgICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgICAgJz09JywKICAgICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZW9mJywKICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQKICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJwogICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICBleHByZXNzaW9uJDMsCiAgICAgICAgICAgICAgICAgIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdCkKICAgICAgICAgICAgICBdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvcGVydHkgZnVuY3Rpb24gdHlwZSAnICsgdHlwZSk7CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29udmVydFpvb21GdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzLCBpbnB1dCkgewogICAgICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApCiAgICAgICAgICAgICAgaW5wdXQgPSBbJ3pvb20nXTsKICAgICAgICAgIHZhciB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7CiAgICAgICAgICB2YXIgZXhwcmVzc2lvbjsKICAgICAgICAgIHZhciBpc1N0ZXAgPSBmYWxzZTsKICAgICAgICAgIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7CiAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IFsKICAgICAgICAgICAgICAgICAgJ3N0ZXAnLAogICAgICAgICAgICAgICAgICBpbnB1dAogICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgaXNTdGVwID0gdHJ1ZTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykgewogICAgICAgICAgICAgIHZhciBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxOwogICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBbCiAgICAgICAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksCiAgICAgICAgICAgICAgICAgIGJhc2UgPT09IDEgPyBbJ2xpbmVhciddIDogWwogICAgICAgICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJywKICAgICAgICAgICAgICAgICAgICAgIGJhc2UKICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgaW5wdXQKICAgICAgICAgICAgICBdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gem9vbSBmdW5jdGlvbiB0eXBlICInICsgdHlwZSArICciJyk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0b3BzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciBzdG9wID0gbGlzdFtpXTsKICAgICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uLCBzdG9wWzBdLCBzdG9wWzFdLCBpc1N0ZXApOwogICAgICAgICAgfQogICAgICAgICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24pOwogICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24pIHsKICAgICAgICAgIGlmIChleHByZXNzaW9uWzBdID09PSAnc3RlcCcgJiYgZXhwcmVzc2lvbi5sZW5ndGggPT09IDMpIHsKICAgICAgICAgICAgICBleHByZXNzaW9uLnB1c2goMCk7CiAgICAgICAgICAgICAgZXhwcmVzc2lvbi5wdXNoKGV4cHJlc3Npb25bM10pOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFwcGVuZFN0b3BQYWlyKGN1cnZlLCBpbnB1dCwgb3V0cHV0LCBpc1N0ZXApIHsKICAgICAgICAgIGlmIChjdXJ2ZS5sZW5ndGggPiAzICYmIGlucHV0ID09PSBjdXJ2ZVtjdXJ2ZS5sZW5ndGggLSAyXSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghKGlzU3RlcCAmJiBjdXJ2ZS5sZW5ndGggPT09IDIpKSB7CiAgICAgICAgICAgICAgY3VydmUucHVzaChpbnB1dCk7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJ2ZS5wdXNoKG91dHB1dCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykgewogICAgICAgICAgaWYgKHBhcmFtZXRlcnMudHlwZSkgewogICAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnR5cGU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eVNwZWMuZXhwcmVzc2lvbi5pbnRlcnBvbGF0ZWQgPyAnZXhwb25lbnRpYWwnIDogJ2ludGVydmFsJzsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjb252ZXJ0VG9rZW5TdHJpbmcocykgewogICAgICAgICAgdmFyIHJlc3VsdCA9IFsnY29uY2F0J107CiAgICAgICAgICB2YXIgcmUgPSAveyhbXnt9XSspfS9nOwogICAgICAgICAgdmFyIHBvcyA9IDA7CiAgICAgICAgICBmb3IgKHZhciBtYXRjaCA9IHJlLmV4ZWMocyk7IG1hdGNoICE9PSBudWxsOyBtYXRjaCA9IHJlLmV4ZWMocykpIHsKICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHMuc2xpY2UocG9zLCByZS5sYXN0SW5kZXggLSBtYXRjaFswXS5sZW5ndGgpOwogICAgICAgICAgICAgIHBvcyA9IHJlLmxhc3RJbmRleDsKICAgICAgICAgICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpdGVyYWwpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXN1bHQucHVzaChbCiAgICAgICAgICAgICAgICAgICdnZXQnLAogICAgICAgICAgICAgICAgICBtYXRjaFsxXQogICAgICAgICAgICAgIF0pOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgICByZXR1cm4gczsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChwb3MgPCBzLmxlbmd0aCkgewogICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHMuc2xpY2UocG9zKSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAndG8tc3RyaW5nJywKICAgICAgICAgICAgICAgICAgcmVzdWx0WzFdCiAgICAgICAgICAgICAgXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbkZpbHRlcihmaWx0ZXIpIHsKICAgICAgICAgIGlmIChmaWx0ZXIgPT09IHRydWUgfHwgZmlsdGVyID09PSBmYWxzZSkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcikgfHwgZmlsdGVyLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHN3aXRjaCAoZmlsdGVyWzBdKSB7CiAgICAgICAgICBjYXNlICdoYXMnOgogICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubGVuZ3RoID49IDIgJiYgZmlsdGVyWzFdICE9PSAnJGlkJyAmJiBmaWx0ZXJbMV0gIT09ICckdHlwZSc7CiAgICAgICAgICBjYXNlICdpbic6CiAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMyAmJiAodHlwZW9mIGZpbHRlclsxXSAhPT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pKTsKICAgICAgICAgIGNhc2UgJyFpbic6CiAgICAgICAgICBjYXNlICchaGFzJzoKICAgICAgICAgIGNhc2UgJ25vbmUnOgogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIGNhc2UgJz09JzoKICAgICAgICAgIGNhc2UgJyE9JzoKICAgICAgICAgIGNhc2UgJz4nOgogICAgICAgICAgY2FzZSAnPj0nOgogICAgICAgICAgY2FzZSAnPCc6CiAgICAgICAgICBjYXNlICc8PSc6CiAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggIT09IDMgfHwgKEFycmF5LmlzQXJyYXkoZmlsdGVyWzFdKSB8fCBBcnJheS5pc0FycmF5KGZpbHRlclsyXSkpOwogICAgICAgICAgY2FzZSAnYW55JzoKICAgICAgICAgIGNhc2UgJ2FsbCc6CiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBmaWx0ZXIuc2xpY2UoMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgICAgICAgIHZhciBmID0gbGlzdFtpXTsKICAgICAgICAgICAgICAgICAgaWYgKCFpc0V4cHJlc3Npb25GaWx0ZXIoZikgJiYgdHlwZW9mIGYgIT09ICdib29sZWFuJykgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgfQogICAgICB2YXIgZmlsdGVyU3BlYyA9IHsKICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLAogICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZSwKICAgICAgICAgICd0cmFuc2l0aW9uJzogZmFsc2UsCiAgICAgICAgICAncHJvcGVydHktdHlwZSc6ICdkYXRhLWRyaXZlbicsCiAgICAgICAgICAnZXhwcmVzc2lvbic6IHsKICAgICAgICAgICAgICAnaW50ZXJwb2xhdGVkJzogZmFsc2UsCiAgICAgICAgICAgICAgJ3BhcmFtZXRlcnMnOiBbCiAgICAgICAgICAgICAgICAgICd6b29tJywKICAgICAgICAgICAgICAgICAgJ2ZlYXR1cmUnCiAgICAgICAgICAgICAgXQogICAgICAgICAgfQogICAgICB9OwogICAgICBmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZmlsdGVyKSB7CiAgICAgICAgICBpZiAoZmlsdGVyID09PSBudWxsIHx8IGZpbHRlciA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgbmVlZEdlb21ldHJ5OiBmYWxzZQogICAgICAgICAgICAgIH07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIWlzRXhwcmVzc2lvbkZpbHRlcihmaWx0ZXIpKSB7CiAgICAgICAgICAgICAgZmlsdGVyID0gY29udmVydEZpbHRlcihmaWx0ZXIpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGNvbXBpbGVkID0gY3JlYXRlRXhwcmVzc2lvbihmaWx0ZXIsIGZpbHRlclNwZWMpOwogICAgICAgICAgaWYgKGNvbXBpbGVkLnJlc3VsdCA9PT0gJ2Vycm9yJykgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjb21waWxlZC52YWx1ZS5tYXAoZnVuY3Rpb24gKGVycikgewogICAgICAgICAgICAgICAgICByZXR1cm4gZXJyLmtleSArICc6ICcgKyBlcnIubWVzc2FnZTsKICAgICAgICAgICAgICB9KS5qb2luKCcsICcpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdmFyIG5lZWRHZW9tZXRyeSA9IGdlb21ldHJ5TmVlZGVkKGZpbHRlcik7CiAgICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZSwgY2Fub25pY2FsKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZWQudmFsdWUuZXZhbHVhdGUoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZSwge30sIGNhbm9uaWNhbCk7CiAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgIG5lZWRHZW9tZXRyeTogbmVlZEdlb21ldHJ5CiAgICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHsKICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBnZW9tZXRyeU5lZWRlZChmaWx0ZXIpIHsKICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGZpbHRlclswXSA9PT0gJ3dpdGhpbicpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBmaWx0ZXIubGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5TmVlZGVkKGZpbHRlcltpbmRleF0pKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb252ZXJ0RmlsdGVyKGZpbHRlcikgewogICAgICAgICAgaWYgKCFmaWx0ZXIpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBvcCA9IGZpbHRlclswXTsKICAgICAgICAgIGlmIChmaWx0ZXIubGVuZ3RoIDw9IDEpIHsKICAgICAgICAgICAgICByZXR1cm4gb3AgIT09ICdhbnknOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IG9wID09PSAnPT0nID8gY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJz09JykgOiBvcCA9PT0gJyE9JyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0Q29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCAnPT0nKSkgOiBvcCA9PT0gJzwnIHx8IG9wID09PSAnPicgfHwgb3AgPT09ICc8PScgfHwgb3AgPT09ICc+PScgPyBjb252ZXJ0Q29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCBvcCkgOiBvcCA9PT0gJ2FueScgPyBjb252ZXJ0RGlzanVuY3Rpb25PcChmaWx0ZXIuc2xpY2UoMSkpIDogb3AgPT09ICdhbGwnID8gWydhbGwnXS5jb25jYXQoZmlsdGVyLnNsaWNlKDEpLm1hcChjb252ZXJ0RmlsdGVyKSkgOiBvcCA9PT0gJ25vbmUnID8gWydhbGwnXS5jb25jYXQoZmlsdGVyLnNsaWNlKDEpLm1hcChjb252ZXJ0RmlsdGVyKS5tYXAoY29udmVydE5lZ2F0aW9uKSkgOiBvcCA9PT0gJ2luJyA/IGNvbnZlcnRJbk9wKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKSA6IG9wID09PSAnIWluJyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0SW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkpIDogb3AgPT09ICdoYXMnID8gY29udmVydEhhc09wKGZpbHRlclsxXSkgOiBvcCA9PT0gJyFoYXMnID8gY29udmVydE5lZ2F0aW9uKGNvbnZlcnRIYXNPcChmaWx0ZXJbMV0pKSA6IG9wID09PSAnd2l0aGluJyA/IGZpbHRlciA6IHRydWU7CiAgICAgICAgICByZXR1cm4gY29udmVydGVkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRDb21wYXJpc29uT3AocHJvcGVydHksIHZhbHVlLCBvcCkgewogICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkgewogICAgICAgICAgY2FzZSAnJHR5cGUnOgogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICdmaWx0ZXItdHlwZS0nICsgb3AsCiAgICAgICAgICAgICAgICAgIHZhbHVlCiAgICAgICAgICAgICAgXTsKICAgICAgICAgIGNhc2UgJyRpZCc6CiAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgJ2ZpbHRlci1pZC0nICsgb3AsCiAgICAgICAgICAgICAgICAgIHZhbHVlCiAgICAgICAgICAgICAgXTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgJ2ZpbHRlci0nICsgb3AsCiAgICAgICAgICAgICAgICAgIHByb3BlcnR5LAogICAgICAgICAgICAgICAgICB2YWx1ZQogICAgICAgICAgICAgIF07CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVycykgewogICAgICAgICAgcmV0dXJuIFsnYW55J10uY29uY2F0KGZpbHRlcnMubWFwKGNvbnZlcnRGaWx0ZXIpKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb252ZXJ0SW5PcChwcm9wZXJ0eSwgdmFsdWVzKSB7CiAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHsKICAgICAgICAgIGNhc2UgJyR0eXBlJzoKICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAnZmlsdGVyLXR5cGUtaW4nLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMKICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgIF07CiAgICAgICAgICBjYXNlICckaWQnOgogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICdmaWx0ZXItaWQtaW4nLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMKICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgIF07CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMjAwICYmICF2YWx1ZXMuc29tZShmdW5jdGlvbiAodikgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9PSB0eXBlb2YgdmFsdWVzWzBdOwogICAgICAgICAgICAgICAgICB9KSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgICAgJ2ZpbHRlci1pbi1sYXJnZScsCiAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSwKICAgICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNvcnQoY29tcGFyZSkKICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgICAgJ2ZpbHRlci1pbi1zbWFsbCcsCiAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSwKICAgICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzCiAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRIYXNPcChwcm9wZXJ0eSkgewogICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkgewogICAgICAgICAgY2FzZSAnJHR5cGUnOgogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgY2FzZSAnJGlkJzoKICAgICAgICAgICAgICByZXR1cm4gWydmaWx0ZXItaGFzLWlkJ107CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICdmaWx0ZXItaGFzJywKICAgICAgICAgICAgICAgICAgcHJvcGVydHkKICAgICAgICAgICAgICBdOwogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbnZlcnROZWdhdGlvbihmaWx0ZXIpIHsKICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgJyEnLAogICAgICAgICAgICAgIGZpbHRlcgogICAgICAgICAgXTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gY29udmVydEZpbHRlciQxKGZpbHRlcikgewogICAgICAgICAgcmV0dXJuIF9jb252ZXJ0RmlsdGVyKGZpbHRlciwge30pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jb252ZXJ0RmlsdGVyKGZpbHRlciwgZXhwZWN0ZWRUeXBlcykgewogICAgICAgICAgdmFyIHJlZiQxOwogICAgICAgICAgaWYgKGlzRXhwcmVzc2lvbkZpbHRlcihmaWx0ZXIpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghZmlsdGVyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgb3AgPSBmaWx0ZXJbMF07CiAgICAgICAgICBpZiAoZmlsdGVyLmxlbmd0aCA8PSAxKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG9wICE9PSAnYW55JzsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBjb252ZXJ0ZWQ7CiAgICAgICAgICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScgfHwgb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nKSB7CiAgICAgICAgICAgICAgdmFyIHJlZiA9IGZpbHRlcjsKICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSByZWZbMV07CiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVmWzJdOwogICAgICAgICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRDb21wYXJpc29uT3AkMShwcm9wZXJ0eSwgdmFsdWUsIG9wLCBleHBlY3RlZFR5cGVzKTsKICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT09ICdhbnknKSB7CiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZmlsdGVyLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoZikgewogICAgICAgICAgICAgICAgICB2YXIgdHlwZXMgPSB7fTsKICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2NvbnZlcnRGaWx0ZXIoZiwgdHlwZXMpOwogICAgICAgICAgICAgICAgICB2YXIgdHlwZWNoZWNrcyA9IHJ1bnRpbWVUeXBlQ2hlY2tzKHR5cGVzKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVjaGVja3MgPT09IHRydWUgPyBjaGlsZCA6IFsKICAgICAgICAgICAgICAgICAgICAgICdjYXNlJywKICAgICAgICAgICAgICAgICAgICAgIHR5cGVjaGVja3MsCiAgICAgICAgICAgICAgICAgICAgICBjaGlsZCwKICAgICAgICAgICAgICAgICAgICAgIGZhbHNlCiAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgcmV0dXJuIFsnYW55J10uY29uY2F0KGNoaWxkcmVuKTsKICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT09ICdhbGwnKSB7CiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuJDEgPSBmaWx0ZXIuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChmKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydEZpbHRlcihmLCBleHBlY3RlZFR5cGVzKTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kMS5sZW5ndGggPiAxID8gWydhbGwnXS5jb25jYXQoY2hpbGRyZW4kMSkgOiAocmVmJDEgPSBbXSkuY29uY2F0LmFwcGx5KHJlZiQxLCBjaGlsZHJlbiQxKTsKICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT09ICdub25lJykgewogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICchJywKICAgICAgICAgICAgICAgICAgX2NvbnZlcnRGaWx0ZXIoWydhbnknXS5jb25jYXQoZmlsdGVyLnNsaWNlKDEpKSwge30pCiAgICAgICAgICAgICAgXTsKICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT09ICdpbicpIHsKICAgICAgICAgICAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0SW5PcCQxKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKTsKICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT09ICchaW4nKSB7CiAgICAgICAgICAgICAgY29udmVydGVkID0gY29udmVydEluT3AkMShmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSwgdHJ1ZSk7CiAgICAgICAgICB9IGVsc2UgaWYgKG9wID09PSAnaGFzJykgewogICAgICAgICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRIYXNPcCQxKGZpbHRlclsxXSk7CiAgICAgICAgICB9IGVsc2UgaWYgKG9wID09PSAnIWhhcycpIHsKICAgICAgICAgICAgICBjb252ZXJ0ZWQgPSBbCiAgICAgICAgICAgICAgICAgICchJywKICAgICAgICAgICAgICAgICAgY29udmVydEhhc09wJDEoZmlsdGVyWzFdKQogICAgICAgICAgICAgIF07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGNvbnZlcnRlZCA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gY29udmVydGVkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJ1bnRpbWVUeXBlQ2hlY2tzKGV4cGVjdGVkVHlwZXMpIHsKICAgICAgICAgIHZhciBjb25kaXRpb25zID0gW107CiAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBleHBlY3RlZFR5cGVzKSB7CiAgICAgICAgICAgICAgdmFyIGdldCA9IHByb3BlcnR5ID09PSAnJGlkJyA/IFsnaWQnXSA6IFsKICAgICAgICAgICAgICAgICAgJ2dldCcsCiAgICAgICAgICAgICAgICAgIHByb3BlcnR5CiAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goWwogICAgICAgICAgICAgICAgICAnPT0nLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAndHlwZW9mJywKICAgICAgICAgICAgICAgICAgICAgIGdldAogICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICBleHBlY3RlZFR5cGVzW3Byb3BlcnR5XQogICAgICAgICAgICAgIF0pOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uc1swXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBbJ2FsbCddLmNvbmNhdChjb25kaXRpb25zKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb252ZXJ0Q29tcGFyaXNvbk9wJDEocHJvcGVydHksIHZhbHVlLCBvcCwgZXhwZWN0ZWRUeXBlcykgewogICAgICAgICAgdmFyIGdldDsKICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykgewogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgIG9wLAogICAgICAgICAgICAgICAgICBbJ2dlb21ldHJ5LXR5cGUnXSwKICAgICAgICAgICAgICAgICAgdmFsdWUKICAgICAgICAgICAgICBdOwogICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHsKICAgICAgICAgICAgICBnZXQgPSBbJ2lkJ107CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGdldCA9IFsKICAgICAgICAgICAgICAgICAgJ2dldCcsCiAgICAgICAgICAgICAgICAgIHByb3BlcnR5CiAgICAgICAgICAgICAgXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChleHBlY3RlZFR5cGVzICYmIHZhbHVlICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICAgICAgICAgICAgZXhwZWN0ZWRUeXBlc1twcm9wZXJ0eV0gPSB0eXBlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG9wID09PSAnPT0nICYmIHByb3BlcnR5ICE9PSAnJGlkJyAmJiB2YWx1ZSA9PT0gbnVsbCkgewogICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICdhbGwnLAogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAnaGFzJywKICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5CiAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICc9PScsCiAgICAgICAgICAgICAgICAgICAgICBnZXQsCiAgICAgICAgICAgICAgICAgICAgICBudWxsCiAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICBdOwogICAgICAgICAgfSBlbHNlIGlmIChvcCA9PT0gJyE9JyAmJiBwcm9wZXJ0eSAhPT0gJyRpZCcgJiYgdmFsdWUgPT09IG51bGwpIHsKICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAnYW55JywKICAgICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgICAgJyEnLAogICAgICAgICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgICAgICAgICdoYXMnLAogICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5CiAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgICchPScsCiAgICAgICAgICAgICAgICAgICAgICBnZXQsCiAgICAgICAgICAgICAgICAgICAgICBudWxsCiAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICBdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICBvcCwKICAgICAgICAgICAgICBnZXQsCiAgICAgICAgICAgICAgdmFsdWUKICAgICAgICAgIF07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29udmVydEluT3AkMShwcm9wZXJ0eSwgdmFsdWVzLCBuZWdhdGUpIHsKICAgICAgICAgIGlmIChuZWdhdGUgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBuZWdhdGUgPSBmYWxzZTsKICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0ZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBnZXQ7CiAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHsKICAgICAgICAgICAgICBnZXQgPSBbJ2dlb21ldHJ5LXR5cGUnXTsKICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICckaWQnKSB7CiAgICAgICAgICAgICAgZ2V0ID0gWydpZCddOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBnZXQgPSBbCiAgICAgICAgICAgICAgICAgICdnZXQnLAogICAgICAgICAgICAgICAgICBwcm9wZXJ0eQogICAgICAgICAgICAgIF07CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdW5pZm9ybVR5cGVzID0gdHJ1ZTsKICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlc1swXTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdmFsdWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpc3RbaV07CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkgewogICAgICAgICAgICAgICAgICB1bmlmb3JtVHlwZXMgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHVuaWZvcm1UeXBlcyAmJiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicpKSB7CiAgICAgICAgICAgICAgdmFyIHVuaXF1ZVZhbHVlcyA9IHZhbHVlcy5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBpID09PSAwIHx8IHZhbHVlc1tpIC0gMV0gIT09IHY7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgJ21hdGNoJywKICAgICAgICAgICAgICAgICAgZ2V0LAogICAgICAgICAgICAgICAgICB1bmlxdWVWYWx1ZXMsCiAgICAgICAgICAgICAgICAgICFuZWdhdGUsCiAgICAgICAgICAgICAgICAgIG5lZ2F0ZQogICAgICAgICAgICAgIF07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gW25lZ2F0ZSA/ICdhbGwnIDogJ2FueSddLmNvbmNhdCh2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7CiAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgbmVnYXRlID8gJyE9JyA6ICc9PScsCiAgICAgICAgICAgICAgICAgIGdldCwKICAgICAgICAgICAgICAgICAgdgogICAgICAgICAgICAgIF07CiAgICAgICAgICB9KSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29udmVydEhhc09wJDEocHJvcGVydHkpIHsKICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHsKICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAnIT0nLAogICAgICAgICAgICAgICAgICBbJ2lkJ10sCiAgICAgICAgICAgICAgICAgIG51bGwKICAgICAgICAgICAgICBdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAnaGFzJywKICAgICAgICAgICAgICAgICAgcHJvcGVydHkKICAgICAgICAgICAgICBdOwogICAgICAgICAgfQogICAgICB9CgogICAgICBmdW5jdGlvbiBtaWdyYXRlVG9FeHByZXNzaW9ucyAoc3R5bGUpIHsKICAgICAgICAgIHZhciBjb252ZXJ0ZWQgPSBbXTsKICAgICAgICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7CiAgICAgICAgICAgICAgaWYgKGxheWVyLmZpbHRlcikgewogICAgICAgICAgICAgICAgICBsYXllci5maWx0ZXIgPSBjb252ZXJ0RmlsdGVyJDEobGF5ZXIuZmlsdGVyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGVhY2hQcm9wZXJ0eShzdHlsZSwgewogICAgICAgICAgICAgIHBhaW50OiB0cnVlLAogICAgICAgICAgICAgIGxheW91dDogdHJ1ZQogICAgICAgICAgfSwgZnVuY3Rpb24gKHJlZikgewogICAgICAgICAgICAgIHZhciBwYXRoID0gcmVmLnBhdGg7CiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlOwogICAgICAgICAgICAgIHZhciByZWZlcmVuY2UgPSByZWYucmVmZXJlbmNlOwogICAgICAgICAgICAgIHZhciBzZXQgPSByZWYuc2V0OwogICAgICAgICAgICAgIGlmIChpc0V4cHJlc3Npb24odmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgIHNldChjb252ZXJ0RnVuY3Rpb24odmFsdWUsIHJlZmVyZW5jZSkpOwogICAgICAgICAgICAgICAgICBjb252ZXJ0ZWQucHVzaChwYXRoLmpvaW4oJy4nKSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWZlcmVuY2UudG9rZW5zICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgc2V0KGNvbnZlcnRUb2tlblN0cmluZyh2YWx1ZSkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICB9CgogICAgICBmdW5jdGlvbiBtaWdyYXRlIChzdHlsZSkgewogICAgICAgICAgdmFyIG1pZ3JhdGVkID0gZmFsc2U7CiAgICAgICAgICBpZiAoc3R5bGUudmVyc2lvbiA9PT0gNykgewogICAgICAgICAgICAgIHN0eWxlID0gbWlncmF0ZVRvVjgoc3R5bGUpOwogICAgICAgICAgICAgIG1pZ3JhdGVkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHlsZS52ZXJzaW9uID09PSA4KSB7CiAgICAgICAgICAgICAgbWlncmF0ZWQgPSBtaWdyYXRlVG9FeHByZXNzaW9ucyhzdHlsZSk7CiAgICAgICAgICAgICAgbWlncmF0ZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCFtaWdyYXRlZCkgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IG1pZ3JhdGUgZnJvbScsIHN0eWxlLnZlcnNpb24pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICB9CgogICAgICBmdW5jdGlvbiBjb21wb3NpdGUgKHN0eWxlKSB7CiAgICAgICAgICB2YXIgc3R5bGVJRHMgPSBbXTsKICAgICAgICAgIHZhciBzb3VyY2VJRHMgPSBbXTsKICAgICAgICAgIHZhciBjb21wb3NpdGVkU291cmNlTGF5ZXJzID0gW107CiAgICAgICAgICBmb3IgKHZhciBpZCBpbiBzdHlsZS5zb3VyY2VzKSB7CiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXNbaWRdOwogICAgICAgICAgICAgIGlmIChzb3VyY2UudHlwZSAhPT0gJ3ZlY3RvcicpIHsKICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBtYXRjaCA9IC9ebWFwYm94OlwvXC8oLiopLy5leGVjKHNvdXJjZS51cmwpOwogICAgICAgICAgICAgIGlmICghbWF0Y2gpIHsKICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHN0eWxlSURzLnB1c2goaWQpOwogICAgICAgICAgICAgIHNvdXJjZUlEcy5wdXNoKG1hdGNoWzFdKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHlsZUlEcy5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgfQogICAgICAgICAgc3R5bGVJRHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsKICAgICAgICAgICAgICBkZWxldGUgc3R5bGUuc291cmNlc1tpZF07CiAgICAgICAgICB9KTsKICAgICAgICAgIHZhciBjb21wb3NpdGVJRCA9IHNvdXJjZUlEcy5qb2luKCcsJyk7CiAgICAgICAgICBzdHlsZS5zb3VyY2VzW2NvbXBvc2l0ZUlEXSA9IHsKICAgICAgICAgICAgICAndHlwZSc6ICd2ZWN0b3InLAogICAgICAgICAgICAgICd1cmwnOiAnbWFwYm94Oi8vJyArIGNvbXBvc2l0ZUlECiAgICAgICAgICB9OwogICAgICAgICAgc3R5bGUubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7CiAgICAgICAgICAgICAgaWYgKHN0eWxlSURzLmluZGV4T2YobGF5ZXIuc291cmNlKSA+PSAwKSB7CiAgICAgICAgICAgICAgICAgIGxheWVyLnNvdXJjZSA9IGNvbXBvc2l0ZUlEOwogICAgICAgICAgICAgICAgICBpZiAoJ3NvdXJjZS1sYXllcicgaW4gbGF5ZXIpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGVkU291cmNlTGF5ZXJzLmluZGV4T2YobGF5ZXJbJ3NvdXJjZS1sYXllciddKSA+PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25mbGljdGluZyBzb3VyY2UgbGF5ZXIgbmFtZXMnKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlZFNvdXJjZUxheWVycy5wdXNoKGxheWVyWydzb3VyY2UtbGF5ZXInXSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBzdHlsZTsKICAgICAgfQoKICAgICAgdmFyIHJlZlByb3BlcnRpZXMgPSBbCiAgICAgICAgICAndHlwZScsCiAgICAgICAgICAnc291cmNlJywKICAgICAgICAgICdzb3VyY2UtbGF5ZXInLAogICAgICAgICAgJ21pbnpvb20nLAogICAgICAgICAgJ21heHpvb20nLAogICAgICAgICAgJ2ZpbHRlcicsCiAgICAgICAgICAnbGF5b3V0JwogICAgICBdOwoKICAgICAgZnVuY3Rpb24gZGVyZWYobGF5ZXIsIHBhcmVudCkgewogICAgICAgICAgdmFyIHJlc3VsdCA9IHt9OwogICAgICAgICAgZm9yICh2YXIgayBpbiBsYXllcikgewogICAgICAgICAgICAgIGlmIChrICE9PSAncmVmJykgewogICAgICAgICAgICAgICAgICByZXN1bHRba10gPSBsYXllcltrXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZWZQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKGspIHsKICAgICAgICAgICAgICBpZiAoayBpbiBwYXJlbnQpIHsKICAgICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gcGFyZW50W2tdOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZXJlZkxheWVycyhsYXllcnMpIHsKICAgICAgICAgIGxheWVycyA9IGxheWVycy5zbGljZSgpOwogICAgICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIG1hcFtsYXllcnNbaV0uaWRdID0gbGF5ZXJzW2ldOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGF5ZXJzLmxlbmd0aDsgaSQxKyspIHsKICAgICAgICAgICAgICBpZiAoJ3JlZicgaW4gbGF5ZXJzW2kkMV0pIHsKICAgICAgICAgICAgICAgICAgbGF5ZXJzW2kkMV0gPSBkZXJlZihsYXllcnNbaSQxXSwgbWFwW2xheWVyc1tpJDFdLnJlZl0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBsYXllcnM7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7CiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkgewogICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGIgPT09ICdvYmplY3QnKSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7CiAgICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkgewogICAgICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhID09PSBiOwogICAgICB9CgogICAgICB2YXIgb3BlcmF0aW9ucyA9IHsKICAgICAgICAgIHNldFN0eWxlOiAnc2V0U3R5bGUnLAogICAgICAgICAgYWRkTGF5ZXI6ICdhZGRMYXllcicsCiAgICAgICAgICByZW1vdmVMYXllcjogJ3JlbW92ZUxheWVyJywKICAgICAgICAgIHNldFBhaW50UHJvcGVydHk6ICdzZXRQYWludFByb3BlcnR5JywKICAgICAgICAgIHNldExheW91dFByb3BlcnR5OiAnc2V0TGF5b3V0UHJvcGVydHknLAogICAgICAgICAgc2V0RmlsdGVyOiAnc2V0RmlsdGVyJywKICAgICAgICAgIGFkZFNvdXJjZTogJ2FkZFNvdXJjZScsCiAgICAgICAgICByZW1vdmVTb3VyY2U6ICdyZW1vdmVTb3VyY2UnLAogICAgICAgICAgc2V0R2VvSlNPTlNvdXJjZURhdGE6ICdzZXRHZW9KU09OU291cmNlRGF0YScsCiAgICAgICAgICBzZXRMYXllclpvb21SYW5nZTogJ3NldExheWVyWm9vbVJhbmdlJywKICAgICAgICAgIHNldExheWVyUHJvcGVydHk6ICdzZXRMYXllclByb3BlcnR5JywKICAgICAgICAgIHNldENlbnRlcjogJ3NldENlbnRlcicsCiAgICAgICAgICBzZXRab29tOiAnc2V0Wm9vbScsCiAgICAgICAgICBzZXRCZWFyaW5nOiAnc2V0QmVhcmluZycsCiAgICAgICAgICBzZXRQaXRjaDogJ3NldFBpdGNoJywKICAgICAgICAgIHNldFNwcml0ZTogJ3NldFNwcml0ZScsCiAgICAgICAgICBzZXRHbHlwaHM6ICdzZXRHbHlwaHMnLAogICAgICAgICAgc2V0VHJhbnNpdGlvbjogJ3NldFRyYW5zaXRpb24nLAogICAgICAgICAgc2V0TGlnaHQ6ICdzZXRMaWdodCcKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMpIHsKICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkU291cmNlLAogICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgc291cmNlSWQsCiAgICAgICAgICAgICAgICAgIGFmdGVyW3NvdXJjZUlkXQogICAgICAgICAgICAgIF0KICAgICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJlbW92ZVNvdXJjZShzb3VyY2VJZCwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7CiAgICAgICAgICBjb21tYW5kcy5wdXNoKHsKICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZVNvdXJjZSwKICAgICAgICAgICAgICBhcmdzOiBbc291cmNlSWRdCiAgICAgICAgICB9KTsKICAgICAgICAgIHNvdXJjZXNSZW1vdmVkW3NvdXJjZUlkXSA9IHRydWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXBkYXRlU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7CiAgICAgICAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7CiAgICAgICAgICBhZGRTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2FuVXBkYXRlR2VvSlNPTihiZWZvcmUsIGFmdGVyLCBzb3VyY2VJZCkgewogICAgICAgICAgdmFyIHByb3A7CiAgICAgICAgICBmb3IgKHByb3AgaW4gYmVmb3JlW3NvdXJjZUlkXSkgewogICAgICAgICAgICAgIGlmICghYmVmb3JlW3NvdXJjZUlkXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZvciAocHJvcCBpbiBhZnRlcltzb3VyY2VJZF0pIHsKICAgICAgICAgICAgICBpZiAoIWFmdGVyW3NvdXJjZUlkXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRpZmZTb3VyY2VzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCkgewogICAgICAgICAgYmVmb3JlID0gYmVmb3JlIHx8IHt9OwogICAgICAgICAgYWZ0ZXIgPSBhZnRlciB8fCB7fTsKICAgICAgICAgIHZhciBzb3VyY2VJZDsKICAgICAgICAgIGZvciAoc291cmNlSWQgaW4gYmVmb3JlKSB7CiAgICAgICAgICAgICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkgewogICAgICAgICAgICAgICAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZm9yIChzb3VyY2VJZCBpbiBhZnRlcikgewogICAgICAgICAgICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHsKICAgICAgICAgICAgICAgICAgYWRkU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVbc291cmNlSWRdLCBhZnRlcltzb3VyY2VJZF0pKSB7CiAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBhZnRlcltzb3VyY2VJZF0udHlwZSA9PT0gJ2dlb2pzb24nICYmIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpKSB7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEdlb0pTT05Tb3VyY2VEYXRhLAogICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyW3NvdXJjZUlkXS5kYXRhCiAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcywgbGF5ZXJJZCwga2xhc3MsIGNvbW1hbmQpIHsKICAgICAgICAgIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTsKICAgICAgICAgIGFmdGVyID0gYWZ0ZXIgfHwge307CiAgICAgICAgICB2YXIgcHJvcDsKICAgICAgICAgIGZvciAocHJvcCBpbiBiZWZvcmUpIHsKICAgICAgICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlW3Byb3BdLCBhZnRlcltwcm9wXSkpIHsKICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLAogICAgICAgICAgICAgICAgICAgICAgYXJnczogWwogICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCwKICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlcltwcm9wXSwKICAgICAgICAgICAgICAgICAgICAgICAgICBrbGFzcwogICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHByb3AgaW4gYWZ0ZXIpIHsKICAgICAgICAgICAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHByb3ApIHx8IGJlZm9yZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlW3Byb3BdLCBhZnRlcltwcm9wXSkpIHsKICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLAogICAgICAgICAgICAgICAgICAgICAgYXJnczogWwogICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCwKICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlcltwcm9wXSwKICAgICAgICAgICAgICAgICAgICAgICAgICBrbGFzcwogICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcGx1Y2tJZChsYXllcikgewogICAgICAgICAgcmV0dXJuIGxheWVyLmlkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZGV4QnlJZChncm91cCwgbGF5ZXIpIHsKICAgICAgICAgIGdyb3VwW2xheWVyLmlkXSA9IGxheWVyOwogICAgICAgICAgcmV0dXJuIGdyb3VwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRpZmZMYXllcnMoYmVmb3JlLCBhZnRlciwgY29tbWFuZHMpIHsKICAgICAgICAgIGJlZm9yZSA9IGJlZm9yZSB8fCBbXTsKICAgICAgICAgIGFmdGVyID0gYWZ0ZXIgfHwgW107CiAgICAgICAgICB2YXIgYmVmb3JlT3JkZXIgPSBiZWZvcmUubWFwKHBsdWNrSWQpOwogICAgICAgICAgdmFyIGFmdGVyT3JkZXIgPSBhZnRlci5tYXAocGx1Y2tJZCk7CiAgICAgICAgICB2YXIgYmVmb3JlSW5kZXggPSBiZWZvcmUucmVkdWNlKGluZGV4QnlJZCwge30pOwogICAgICAgICAgdmFyIGFmdGVySW5kZXggPSBhZnRlci5yZWR1Y2UoaW5kZXhCeUlkLCB7fSk7CiAgICAgICAgICB2YXIgdHJhY2tlciA9IGJlZm9yZU9yZGVyLnNsaWNlKCk7CiAgICAgICAgICB2YXIgY2xlYW4gPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgICAgdmFyIGksIGQsIGxheWVySWQsIGJlZm9yZUxheWVyLCBhZnRlckxheWVyLCBpbnNlcnRCZWZvcmVMYXllcklkLCBwcm9wOwogICAgICAgICAgZm9yIChpID0gMCwgZCA9IDA7IGkgPCBiZWZvcmVPcmRlci5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGxheWVySWQgPSBiZWZvcmVPcmRlcltpXTsKICAgICAgICAgICAgICBpZiAoIWFmdGVySW5kZXguaGFzT3duUHJvcGVydHkobGF5ZXJJZCkpIHsKICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLAogICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xheWVySWRdCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmluZGV4T2YobGF5ZXJJZCwgZCksIDEpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGQrKzsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGkgPSAwLCBkID0gMDsgaSA8IGFmdGVyT3JkZXIubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICBsYXllcklkID0gYWZ0ZXJPcmRlclthZnRlck9yZGVyLmxlbmd0aCAtIDEgLSBpXTsKICAgICAgICAgICAgICBpZiAodHJhY2tlclt0cmFja2VyLmxlbmd0aCAtIDEgLSBpXSA9PT0gbGF5ZXJJZCkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGJlZm9yZUluZGV4Lmhhc093blByb3BlcnR5KGxheWVySWQpKSB7CiAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllciwKICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtsYXllcklkXQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkLCB0cmFja2VyLmxlbmd0aCAtIGQpLCAxKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBkKys7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGluc2VydEJlZm9yZUxheWVySWQgPSB0cmFja2VyW3RyYWNrZXIubGVuZ3RoIC0gaV07CiAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkTGF5ZXIsCiAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgIGFmdGVySW5kZXhbbGF5ZXJJZF0sCiAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkCiAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmxlbmd0aCAtIGksIDAsIGxheWVySWQpOwogICAgICAgICAgICAgIGNsZWFuW2xheWVySWRdID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhZnRlck9yZGVyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgbGF5ZXJJZCA9IGFmdGVyT3JkZXJbaV07CiAgICAgICAgICAgICAgYmVmb3JlTGF5ZXIgPSBiZWZvcmVJbmRleFtsYXllcklkXTsKICAgICAgICAgICAgICBhZnRlckxheWVyID0gYWZ0ZXJJbmRleFtsYXllcklkXTsKICAgICAgICAgICAgICBpZiAoY2xlYW5bbGF5ZXJJZF0gfHwgZGVlcEVxdWFsKGJlZm9yZUxheWVyLCBhZnRlckxheWVyKSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIuc291cmNlLCBhZnRlckxheWVyLnNvdXJjZSkgfHwgIWRlZXBFcXVhbChiZWZvcmVMYXllclsnc291cmNlLWxheWVyJ10sIGFmdGVyTGF5ZXJbJ3NvdXJjZS1sYXllciddKSB8fCAhZGVlcEVxdWFsKGJlZm9yZUxheWVyLnR5cGUsIGFmdGVyTGF5ZXIudHlwZSkpIHsKICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLAogICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xheWVySWRdCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxhc3RJbmRleE9mKGxheWVySWQpICsgMV07CiAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5hZGRMYXllciwKICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyLAogICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZUxheWVySWQKICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXIubGF5b3V0LCBhZnRlckxheWVyLmxheW91dCwgY29tbWFuZHMsIGxheWVySWQsIG51bGwsIG9wZXJhdGlvbnMuc2V0TGF5b3V0UHJvcGVydHkpOwogICAgICAgICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllci5wYWludCwgYWZ0ZXJMYXllci5wYWludCwgY29tbWFuZHMsIGxheWVySWQsIG51bGwsIG9wZXJhdGlvbnMuc2V0UGFpbnRQcm9wZXJ0eSk7CiAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIuZmlsdGVyLCBhZnRlckxheWVyLmZpbHRlcikpIHsKICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEZpbHRlciwKICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcklkLAogICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXIuZmlsdGVyCiAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllci5taW56b29tLCBhZnRlckxheWVyLm1pbnpvb20pIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIubWF4em9vbSwgYWZ0ZXJMYXllci5tYXh6b29tKSkgewogICAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGF5ZXJab29tUmFuZ2UsCiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCwKICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyLm1pbnpvb20sCiAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllci5tYXh6b29tCiAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gYmVmb3JlTGF5ZXIpIHsKICAgICAgICAgICAgICAgICAgaWYgKCFiZWZvcmVMYXllci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgewogICAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdsYXlvdXQnIHx8IHByb3AgPT09ICdwYWludCcgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHwgcHJvcCA9PT0gJ21ldGFkYXRhJyB8fCBwcm9wID09PSAnbWluem9vbScgfHwgcHJvcCA9PT0gJ21heHpvb20nKSB7CiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAocHJvcC5pbmRleE9mKCdwYWludC4nKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdKSkgewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LAogICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllcltwcm9wXQogICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGZvciAocHJvcCBpbiBhZnRlckxheWVyKSB7CiAgICAgICAgICAgICAgICAgIGlmICghYWZ0ZXJMYXllci5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBiZWZvcmVMYXllci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgewogICAgICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdsYXlvdXQnIHx8IHByb3AgPT09ICdwYWludCcgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHwgcHJvcCA9PT0gJ21ldGFkYXRhJyB8fCBwcm9wID09PSAnbWluem9vbScgfHwgcHJvcCA9PT0gJ21heHpvb20nKSB7CiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAocHJvcC5pbmRleE9mKCdwYWludC4nKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdKSkgewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LAogICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllcltwcm9wXQogICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRpZmZTdHlsZXMoYmVmb3JlLCBhZnRlcikgewogICAgICAgICAgaWYgKCFiZWZvcmUpIHsKICAgICAgICAgICAgICByZXR1cm4gW3sKICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0U3R5bGUsCiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdCiAgICAgICAgICAgICAgICAgIH1dOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGNvbW1hbmRzID0gW107CiAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS52ZXJzaW9uLCBhZnRlci52ZXJzaW9uKSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gW3sKICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLAogICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlcl0KICAgICAgICAgICAgICAgICAgICAgIH1dOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuY2VudGVyLCBhZnRlci5jZW50ZXIpKSB7CiAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRDZW50ZXIsCiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIuY2VudGVyXQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnpvb20sIGFmdGVyLnpvb20pKSB7CiAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRab29tLAogICAgICAgICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLnpvb21dCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuYmVhcmluZywgYWZ0ZXIuYmVhcmluZykpIHsKICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEJlYXJpbmcsCiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIuYmVhcmluZ10KICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5waXRjaCwgYWZ0ZXIucGl0Y2gpKSB7CiAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRQaXRjaCwKICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci5waXRjaF0KICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5zcHJpdGUsIGFmdGVyLnNwcml0ZSkpIHsKICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFNwcml0ZSwKICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci5zcHJpdGVdCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuZ2x5cGhzLCBhZnRlci5nbHlwaHMpKSB7CiAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRHbHlwaHMsCiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIuZ2x5cGhzXQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnRyYW5zaXRpb24sIGFmdGVyLnRyYW5zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRUcmFuc2l0aW9uLAogICAgICAgICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLnRyYW5zaXRpb25dCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUubGlnaHQsIGFmdGVyLmxpZ2h0KSkgewogICAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGlnaHQsCiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIubGlnaHRdCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgc291cmNlc1JlbW92ZWQgPSB7fTsKICAgICAgICAgICAgICB2YXIgcmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyA9IFtdOwogICAgICAgICAgICAgIGRpZmZTb3VyY2VzKGJlZm9yZS5zb3VyY2VzLCBhZnRlci5zb3VyY2VzLCByZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7CiAgICAgICAgICAgICAgdmFyIGJlZm9yZUxheWVycyA9IFtdOwogICAgICAgICAgICAgIGlmIChiZWZvcmUubGF5ZXJzKSB7CiAgICAgICAgICAgICAgICAgIGJlZm9yZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VzUmVtb3ZlZFtsYXllci5zb3VyY2VdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtsYXllci5pZF0KICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlTGF5ZXJzLnB1c2gobGF5ZXIpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY29tbWFuZHMgPSBjb21tYW5kcy5jb25jYXQocmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyk7CiAgICAgICAgICAgICAgZGlmZkxheWVycyhiZWZvcmVMYXllcnMsIGFmdGVyLmxheWVycywgY29tbWFuZHMpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGNvbXB1dGUgc3R5bGUgZGlmZjonLCBlKTsKICAgICAgICAgICAgICBjb21tYW5kcyA9IFt7CiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLAogICAgICAgICAgICAgICAgICAgICAgYXJnczogW2FmdGVyXQogICAgICAgICAgICAgICAgICB9XTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBjb21tYW5kczsKICAgICAgfQoKICAgICAgdmFyIFZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBtZXNzYWdlLCBpZGVudGlmaWVyKSB7CiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAoa2V5ID8ga2V5ICsgJzogJyA6ICcnKSArIG1lc3NhZ2U7CiAgICAgICAgICBpZiAoaWRlbnRpZmllcikgewogICAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5fX2xpbmVfXykgewogICAgICAgICAgICAgIHRoaXMubGluZSA9IHZhbHVlLl9fbGluZV9fOwogICAgICAgICAgfQogICAgICB9OwoKICAgICAgdmFyIFBhcnNpbmdFcnJvciQxID0gZnVuY3Rpb24gUGFyc2luZ0Vycm9yKGVycm9yKSB7CiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7CiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlOwogICAgICAgICAgdmFyIG1hdGNoID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvbGluZSAoXGQrKS8pOwogICAgICAgICAgdGhpcy5saW5lID0gbWF0Y2ggPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogMDsKICAgICAgfTsKCiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RhbnRzKG9wdGlvbnMpIHsKICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTsKICAgICAgICAgIHZhciBjb25zdGFudHMgPSBvcHRpb25zLnZhbHVlOwogICAgICAgICAgaWYgKGNvbnN0YW50cykgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGNvbnN0YW50cywgJ2NvbnN0YW50cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2OCcpXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgfQogICAgICB9CgogICAgICBmdW5jdGlvbiB1bmJ1bmRsZSh2YWx1ZSkgewogICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgewogICAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZU9mKCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBkZWVwVW5idW5kbGUodmFsdWUpIHsKICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgewogICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZGVlcFVuYnVuZGxlKTsKICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7CiAgICAgICAgICAgICAgdmFyIHVuYnVuZGxlZFZhbHVlID0ge307CiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7CiAgICAgICAgICAgICAgICAgIHVuYnVuZGxlZFZhbHVlW2tleV0gPSBkZWVwVW5idW5kbGUodmFsdWVba2V5XSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB1bmJ1bmRsZWRWYWx1ZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB1bmJ1bmRsZSh2YWx1ZSk7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMpIHsKICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTsKICAgICAgICAgIHZhciBvYmplY3QgPSBvcHRpb25zLnZhbHVlOwogICAgICAgICAgdmFyIGVsZW1lbnRTcGVjcyA9IG9wdGlvbnMudmFsdWVTcGVjIHx8IHt9OwogICAgICAgICAgdmFyIGVsZW1lbnRWYWxpZGF0b3JzID0gb3B0aW9ucy5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fTsKICAgICAgICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7CiAgICAgICAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7CiAgICAgICAgICB2YXIgZXJyb3JzID0gW107CiAgICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUob2JqZWN0KTsKICAgICAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0JykgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdCwgJ29iamVjdCBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgb2JqZWN0S2V5IGluIG9iamVjdCkgewogICAgICAgICAgICAgIHZhciBlbGVtZW50U3BlY0tleSA9IG9iamVjdEtleS5zcGxpdCgnLicpWzBdOwogICAgICAgICAgICAgIHZhciBlbGVtZW50U3BlYyA9IGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0gfHwgZWxlbWVudFNwZWNzWycqJ107CiAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlRWxlbWVudCA9IHZvaWQgMDsKICAgICAgICAgICAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXldKSB7CiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRWxlbWVudCA9IGVsZW1lbnRWYWxpZGF0b3JzW2VsZW1lbnRTcGVjS2V5XTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0pIHsKICAgICAgICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50VmFsaWRhdG9yc1snKiddKSB7CiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRWxlbWVudCA9IGVsZW1lbnRWYWxpZGF0b3JzWycqJ107CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50U3BlY3NbJyonXSkgewogICAgICAgICAgICAgICAgICB2YWxpZGF0ZUVsZW1lbnQgPSB2YWxpZGF0ZTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0W29iamVjdEtleV0sICd1bmtub3duIHByb3BlcnR5ICInICsgb2JqZWN0S2V5ICsgJyInKSk7CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRWxlbWVudCh7CiAgICAgICAgICAgICAgICAgIGtleTogKGtleSA/IGtleSArICcuJyA6IGtleSkgKyBvYmplY3RLZXksCiAgICAgICAgICAgICAgICAgIHZhbHVlOiBvYmplY3Rbb2JqZWN0S2V5XSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBlbGVtZW50U3BlYywKICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLAogICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYywKICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsCiAgICAgICAgICAgICAgICAgIG9iamVjdEtleTogb2JqZWN0S2V5CiAgICAgICAgICAgICAgfSwgb2JqZWN0KSk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBlbGVtZW50U3BlY0tleSQxIGluIGVsZW1lbnRTcGVjcykgewogICAgICAgICAgICAgIGlmIChlbGVtZW50VmFsaWRhdG9yc1tlbGVtZW50U3BlY0tleSQxXSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleSQxXS5yZXF1aXJlZCAmJiBlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXkkMV1bJ2RlZmF1bHQnXSA9PT0gdW5kZWZpbmVkICYmIG9iamVjdFtlbGVtZW50U3BlY0tleSQxXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5ICInICsgZWxlbWVudFNwZWNLZXkkMSArICciJykpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBlcnJvcnM7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkob3B0aW9ucykgewogICAgICAgICAgdmFyIGFycmF5ID0gb3B0aW9ucy52YWx1ZTsKICAgICAgICAgIHZhciBhcnJheVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYzsKICAgICAgICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7CiAgICAgICAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7CiAgICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7CiAgICAgICAgICB2YXIgdmFsaWRhdGVBcnJheUVsZW1lbnQgPSBvcHRpb25zLmFycmF5RWxlbWVudFZhbGlkYXRvciB8fCB2YWxpZGF0ZTsKICAgICAgICAgIGlmIChnZXRUeXBlKGFycmF5KSAhPT0gJ2FycmF5JykgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKGFycmF5KSArICcgZm91bmQnKV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYXJyYXlTcGVjLmxlbmd0aCAmJiBhcnJheS5sZW5ndGggIT09IGFycmF5U3BlYy5sZW5ndGgpIHsKICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGxlbmd0aCAnICsgYXJyYXlTcGVjLmxlbmd0aCArICcgZXhwZWN0ZWQsIGxlbmd0aCAnICsgYXJyYXkubGVuZ3RoICsgJyBmb3VuZCcpXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSAmJiBhcnJheS5sZW5ndGggPCBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSkgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgbGVuZ3RoIGF0IGxlYXN0ICcgKyBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSArICcgZXhwZWN0ZWQsIGxlbmd0aCAnICsgYXJyYXkubGVuZ3RoICsgJyBmb3VuZCcpXTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBhcnJheUVsZW1lbnRTcGVjID0gewogICAgICAgICAgICAgICd0eXBlJzogYXJyYXlTcGVjLnZhbHVlLAogICAgICAgICAgICAgICd2YWx1ZXMnOiBhcnJheVNwZWMudmFsdWVzCiAgICAgICAgICB9OwogICAgICAgICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA8IDcpIHsKICAgICAgICAgICAgICBhcnJheUVsZW1lbnRTcGVjLmZ1bmN0aW9uID0gYXJyYXlTcGVjLmZ1bmN0aW9uOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGdldFR5cGUoYXJyYXlTcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgICBhcnJheUVsZW1lbnRTcGVjID0gYXJyYXlTcGVjLnZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGVycm9ycyA9IFtdOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVBcnJheUVsZW1lbnQoewogICAgICAgICAgICAgICAgICBhcnJheTogYXJyYXksCiAgICAgICAgICAgICAgICAgIGFycmF5SW5kZXg6IGksCiAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcnJheVtpXSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBhcnJheUVsZW1lbnRTcGVjLAogICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsCiAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLAogICAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkgKyAnXScKICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZXJyb3JzOwogICAgICB9CgogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihvcHRpb25zKSB7CiAgICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7CiAgICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlOwogICAgICAgICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjOwogICAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTsKICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWUpIHsKICAgICAgICAgICAgICB0eXBlID0gJ05hTic7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ251bWJlciBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCdtaW5pbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPCB2YWx1ZVNwZWMubWluaW11bSkgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCB2YWx1ZSArICcgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlICcgKyB2YWx1ZVNwZWMubWluaW11bSldOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCdtYXhpbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPiB2YWx1ZVNwZWMubWF4aW11bSkgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCB2YWx1ZSArICcgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlICcgKyB2YWx1ZVNwZWMubWF4aW11bSldOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKG9wdGlvbnMpIHsKICAgICAgICAgIHZhciBmdW5jdGlvblZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjOwogICAgICAgICAgdmFyIGZ1bmN0aW9uVHlwZSA9IHVuYnVuZGxlKG9wdGlvbnMudmFsdWUudHlwZSk7CiAgICAgICAgICB2YXIgc3RvcEtleVR5cGU7CiAgICAgICAgICB2YXIgc3RvcERvbWFpblZhbHVlcyA9IHt9OwogICAgICAgICAgdmFyIHByZXZpb3VzU3RvcERvbWFpblZhbHVlOwogICAgICAgICAgdmFyIHByZXZpb3VzU3RvcERvbWFpblpvb207CiAgICAgICAgICB2YXIgaXNab29tRnVuY3Rpb24gPSBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkOwogICAgICAgICAgdmFyIGlzUHJvcGVydHlGdW5jdGlvbiA9ICFpc1pvb21GdW5jdGlvbjsKICAgICAgICAgIHZhciBpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uID0gZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzKSA9PT0gJ2FycmF5JyAmJiBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHNbMF0pID09PSAnYXJyYXknICYmIGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wc1swXVswXSkgPT09ICdvYmplY3QnOwogICAgICAgICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHsKICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LAogICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLAogICAgICAgICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMuZnVuY3Rpb24sCiAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsCiAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYywKICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogewogICAgICAgICAgICAgICAgICBzdG9wczogdmFsaWRhdGVGdW5jdGlvblN0b3BzLAogICAgICAgICAgICAgICAgICBkZWZhdWx0OiB2YWxpZGF0ZUZ1bmN0aW9uRGVmYXVsdAogICAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2lkZW50aXR5JyAmJiBpc1pvb21GdW5jdGlvbikgewogICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5ICJwcm9wZXJ0eSInKSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZnVuY3Rpb25UeXBlICE9PSAnaWRlbnRpdHknICYmICFvcHRpb25zLnZhbHVlLnN0b3BzKSB7CiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgInN0b3BzIicpKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcgJiYgb3B0aW9ucy52YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKG9wdGlvbnMudmFsdWVTcGVjKSkgewogICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdleHBvbmVudGlhbCBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHRpb25zLnN0eWxlU3BlYy4kdmVyc2lvbiA+PSA4KSB7CiAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlGdW5jdGlvbiAmJiAhc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24ob3B0aW9ucy52YWx1ZVNwZWMpKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdwcm9wZXJ0eSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzWm9vbUZ1bmN0aW9uICYmICFzdXBwb3J0c1pvb21FeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkgewogICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnem9vbSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoKGZ1bmN0aW9uVHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyB8fCBpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uKSAmJiBvcHRpb25zLnZhbHVlLnByb3BlcnR5ID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnInByb3BlcnR5IiBwcm9wZXJ0eSBpcyByZXF1aXJlZCcpKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBlcnJvcnM7CiAgICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcHMob3B0aW9ucykgewogICAgICAgICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdpZGVudGl0eScpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnaWRlbnRpdHkgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGEgInN0b3BzIiBwcm9wZXJ0eScpXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdOwogICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7CiAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5KHsKICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSwKICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAogICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMudmFsdWVTcGVjLAogICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSwKICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYywKICAgICAgICAgICAgICAgICAgYXJyYXlFbGVtZW50VmFsaWRhdG9yOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcAogICAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdhcnJheScgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHZhbHVlLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJykpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3Aob3B0aW9ucykgewogICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTsKICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlOwogICAgICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTsKICAgICAgICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdhcnJheScpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdhcnJheSBleHBlY3RlZCwgJyArIGdldFR5cGUodmFsdWUpICsgJyBmb3VuZCcpXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikgewogICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGxlbmd0aCAyIGV4cGVjdGVkLCBsZW5ndGggJyArIHZhbHVlLmxlbmd0aCArICcgZm91bmQnKV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uKSB7CiAgICAgICAgICAgICAgICAgIGlmIChnZXRUeXBlKHZhbHVlWzBdKSAhPT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IGV4cGVjdGVkLCAnICsgZ2V0VHlwZSh2YWx1ZVswXSkgKyAnIGZvdW5kJyldOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXS56b29tID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB6b29tJyldOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgdmFsdWUnKV07CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RvcERvbWFpblpvb20gJiYgcHJldmlvdXNTdG9wRG9tYWluWm9vbSA+IHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZVswXS56b29tLCAnc3RvcCB6b29tIHZhbHVlcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXInKV07CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pICE9PSBwcmV2aW91c1N0b3BEb21haW5ab29tKSB7CiAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5ab29tID0gdW5idW5kbGUodmFsdWVbMF0uem9vbSk7CiAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgICAgICAgICAgIHN0b3BEb21haW5WYWx1ZXMgPSB7fTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHsKICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbMF0sCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHsgem9vbToge30gfSwKICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLAogICAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYywKICAgICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbTogdmFsaWRhdGVOdW1iZXIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbGlkYXRlU3RvcERvbWFpblZhbHVlCiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKHsKICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbMF0sCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHt9LAogICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsCiAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjCiAgICAgICAgICAgICAgICAgIH0sIHZhbHVlKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChpc0V4cHJlc3Npb24oZGVlcFVuYnVuZGxlKHZhbHVlWzFdKSkpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1sxXScsIHZhbHVlWzFdLCAnZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGZ1bmN0aW9uIHN0b3BzLicpXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHsKICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnWzFdJywKICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzFdLAogICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IGZ1bmN0aW9uVmFsdWVTcGVjLAogICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSwKICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYwogICAgICAgICAgICAgIH0pKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKG9wdGlvbnMsIHN0b3ApIHsKICAgICAgICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUob3B0aW9ucy52YWx1ZSk7CiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5idW5kbGUob3B0aW9ucy52YWx1ZSk7CiAgICAgICAgICAgICAgdmFyIHJlcG9ydFZhbHVlID0gb3B0aW9ucy52YWx1ZSAhPT0gbnVsbCA/IG9wdGlvbnMudmFsdWUgOiBzdG9wOwogICAgICAgICAgICAgIGlmICghc3RvcEtleVR5cGUpIHsKICAgICAgICAgICAgICAgICAgc3RvcEtleVR5cGUgPSB0eXBlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gc3RvcEtleVR5cGUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgdHlwZSArICcgc3RvcCBkb21haW4gdHlwZSBtdXN0IG1hdGNoIHByZXZpb3VzIHN0b3AgZG9tYWluIHR5cGUgJyArIHN0b3BLZXlUeXBlKV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIHN0cmluZywgb3IgYm9vbGVhbicpXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIGZ1bmN0aW9uVHlwZSAhPT0gJ2NhdGVnb3JpY2FsJykgewogICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdudW1iZXIgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCc7CiAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihmdW5jdGlvblZhbHVlU3BlYykgJiYgZnVuY3Rpb25UeXBlID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJ1xuSWYgeW91IGludGVuZGVkIHRvIHVzZSBhIGNhdGVnb3JpY2FsIGZ1bmN0aW9uLCBzcGVjaWZ5IGAidHlwZSI6ICJjYXRlZ29yaWNhbCJgLic7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgbWVzc2FnZSldOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmICghaXNGaW5pdGUodmFsdWUpIHx8IE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ2ludGVnZXIgZXhwZWN0ZWQsIGZvdW5kICcgKyB2YWx1ZSldOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmIHByZXZpb3VzU3RvcERvbWFpblZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnc3RvcCBkb21haW4gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpXTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSA9IHZhbHVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHZhbHVlIGluIHN0b3BEb21haW5WYWx1ZXMpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZScpXTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzdG9wRG9tYWluVmFsdWVzW3ZhbHVlXSA9IHRydWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0KG9wdGlvbnMpIHsKICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGUoewogICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LAogICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBmdW5jdGlvblZhbHVlU3BlYywKICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsCiAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMKICAgICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpIHsKICAgICAgICAgIHZhciBleHByZXNzaW9uID0gKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgPyBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24gOiBjcmVhdGVFeHByZXNzaW9uKShkZWVwVW5idW5kbGUob3B0aW9ucy52YWx1ZSksIG9wdGlvbnMudmFsdWVTcGVjKTsKICAgICAgICAgIGlmIChleHByZXNzaW9uLnJlc3VsdCA9PT0gJ2Vycm9yJykgewogICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLnZhbHVlLm1hcChmdW5jdGlvbiAoZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoJycgKyBvcHRpb25zLmtleSArIGVycm9yLmtleSwgb3B0aW9ucy52YWx1ZSwgZXJyb3IubWVzc2FnZSk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZXhwcmVzc2lvbk9iaiA9IGV4cHJlc3Npb24udmFsdWUuZXhwcmVzc2lvbiB8fCBleHByZXNzaW9uLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbjsKICAgICAgICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAncHJvcGVydHknICYmIG9wdGlvbnMucHJvcGVydHlLZXkgPT09ICd0ZXh0LWZvbnQnICYmICFleHByZXNzaW9uT2JqLm91dHB1dERlZmluZWQoKSkgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ0ludmFsaWQgZGF0YSBleHByZXNzaW9uIGZvciAiJyArIG9wdGlvbnMucHJvcGVydHlLZXkgKyAnIi4gT3V0cHV0IHZhbHVlcyBtdXN0IGJlIGNvbnRhaW5lZCBhcyBsaXRlcmFscyB3aXRoaW4gdGhlIGV4cHJlc3Npb24uJyldOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgJiYgb3B0aW9ucy5wcm9wZXJ0eVR5cGUgPT09ICdsYXlvdXQnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHsKICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICciZmVhdHVyZS1zdGF0ZSIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGxheW91dCBwcm9wZXJ0aWVzLicpXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAnZmlsdGVyJyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnImZlYXR1cmUtc3RhdGUiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBmaWx0ZXJzLicpXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ICYmIG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQuaW5kZXhPZignY2x1c3RlcicpID09PSAwKSB7CiAgICAgICAgICAgICAgaWYgKCFpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZXhwcmVzc2lvbk9iaiwgWwogICAgICAgICAgICAgICAgICAgICAgJ3pvb20nLAogICAgICAgICAgICAgICAgICAgICAgJ2ZlYXR1cmUtc3RhdGUnCiAgICAgICAgICAgICAgICAgIF0pKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJyJ6b29tIiBhbmQgImZlYXR1cmUtc3RhdGUiIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggY2x1c3RlciBwcm9wZXJ0aWVzLicpXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdjbHVzdGVyLWluaXRpYWwnICYmICFpc0ZlYXR1cmVDb25zdGFudChleHByZXNzaW9uT2JqKSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdGZWF0dXJlIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBpbml0aWFsIGV4cHJlc3Npb24gcGFydCBvZiBjbHVzdGVyIHByb3BlcnRpZXMuJyldOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBbXTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuKG9wdGlvbnMpIHsKICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7CiAgICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7CiAgICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpOwogICAgICAgICAgaWYgKHR5cGUgIT09ICdib29sZWFuJykgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYm9vbGVhbiBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbG9yKG9wdGlvbnMpIHsKICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTsKICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7CiAgICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpOwogICAgICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdjb2xvciBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNzc2NvbG9ycGFyc2VyXzEodmFsdWUpID09PSBudWxsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdjb2xvciBleHBlY3RlZCwgIicgKyB2YWx1ZSArICciIGZvdW5kJyldOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICBmdW5jdGlvbiB2YWxpZGF0ZUVudW0ob3B0aW9ucykgewogICAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5OwogICAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTsKICAgICAgICAgIHZhciB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYzsKICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTsKICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlU3BlYy52YWx1ZXMpKSB7CiAgICAgICAgICAgICAgaWYgKHZhbHVlU3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkgewogICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdleHBlY3RlZCBvbmUgb2YgWycgKyB2YWx1ZVNwZWMudmFsdWVzLmpvaW4oJywgJykgKyAnXSwgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgZm91bmQnKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkgewogICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdleHBlY3RlZCBvbmUgb2YgWycgKyBPYmplY3Qua2V5cyh2YWx1ZVNwZWMudmFsdWVzKS5qb2luKCcsICcpICsgJ10sICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnIGZvdW5kJykpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBlcnJvcnM7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRmlsdGVyKG9wdGlvbnMpIHsKICAgICAgICAgIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZGVlcFVuYnVuZGxlKG9wdGlvbnMudmFsdWUpKSkgewogICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24oZXh0ZW5kKHt9LCBvcHRpb25zLCB7CiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiAnZmlsdGVyJywKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiB7IHZhbHVlOiAnYm9vbGVhbicgfQogICAgICAgICAgICAgIH0pKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcihvcHRpb25zKTsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU5vbkV4cHJlc3Npb25GaWx0ZXIob3B0aW9ucykgewogICAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTsKICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTsKICAgICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5JykgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKHZhbHVlKSArICcgZm91bmQnKV07CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7CiAgICAgICAgICB2YXIgdHlwZTsKICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTsKICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCAxKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpXTsKICAgICAgICAgIH0KICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHsKICAgICAgICAgICAgICBrZXk6IGtleSArICdbMF0nLAogICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVswXSwKICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5maWx0ZXJfb3BlcmF0b3IsCiAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsCiAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYwogICAgICAgICAgfSkpOwogICAgICAgICAgc3dpdGNoICh1bmJ1bmRsZSh2YWx1ZVswXSkpIHsKICAgICAgICAgIGNhc2UgJzwnOgogICAgICAgICAgY2FzZSAnPD0nOgogICAgICAgICAgY2FzZSAnPic6CiAgICAgICAgICBjYXNlICc+PSc6CiAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHVuYnVuZGxlKHZhbHVlWzFdKSA9PT0gJyR0eXBlJykgewogICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICciJHR5cGUiIGNhbm5vdCBiZSB1c2Ugd2l0aCBvcGVyYXRvciAiJyArIHZhbHVlWzBdICsgJyInKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgY2FzZSAnPT0nOgogICAgICAgICAgY2FzZSAnIT0nOgogICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDMpIHsKICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IGZvciBvcGVyYXRvciAiJyArIHZhbHVlWzBdICsgJyIgbXVzdCBoYXZlIDMgZWxlbWVudHMnKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgY2FzZSAnaW4nOgogICAgICAgICAgY2FzZSAnIWluJzoKICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIpIHsKICAgICAgICAgICAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pOwogICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1sxXScsIHZhbHVlWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnKSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVtpXSk7CiAgICAgICAgICAgICAgICAgIGlmICh1bmJ1bmRsZSh2YWx1ZVsxXSkgPT09ICckdHlwZScpIHsKICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHsKICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkgKyAnXScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLAogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmdlb21ldHJ5X3R5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYwogICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdib29sZWFuJykgewogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWx1ZVtpXSwgJ3N0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnKSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICdhbnknOgogICAgICAgICAgY2FzZSAnYWxsJzoKICAgICAgICAgIGNhc2UgJ25vbmUnOgogICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHZhbHVlLmxlbmd0aDsgaSQxKyspIHsKICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU5vbkV4cHJlc3Npb25GaWx0ZXIoewogICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpJDEgKyAnXScsCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaSQxXSwKICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLAogICAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYwogICAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAnaGFzJzoKICAgICAgICAgIGNhc2UgJyFoYXMnOgogICAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTsKICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2ZpbHRlciBhcnJheSBmb3IgIicgKyB2YWx1ZVswXSArICciIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzJykpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdzdHJpbmcgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICd3aXRoaW4nOgogICAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTsKICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2ZpbHRlciBhcnJheSBmb3IgIicgKyB2YWx1ZVswXSArICciIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzJykpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdvYmplY3QgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZXJyb3JzOwogICAgICB9CgogICAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsIHByb3BlcnR5VHlwZSkgewogICAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5OwogICAgICAgICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTsKICAgICAgICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYzsKICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7CiAgICAgICAgICB2YXIgcHJvcGVydHlLZXkgPSBvcHRpb25zLm9iamVjdEtleTsKICAgICAgICAgIHZhciBsYXllclNwZWMgPSBzdHlsZVNwZWNbcHJvcGVydHlUeXBlICsgJ18nICsgb3B0aW9ucy5sYXllclR5cGVdOwogICAgICAgICAgaWYgKCFsYXllclNwZWMpIHsKICAgICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdHJhbnNpdGlvbk1hdGNoID0gcHJvcGVydHlLZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7CiAgICAgICAgICBpZiAocHJvcGVydHlUeXBlID09PSAncGFpbnQnICYmIHRyYW5zaXRpb25NYXRjaCAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHsKICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMudHJhbnNpdGlvbiwKICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLAogICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV07CiAgICAgICAgICBpZiAoIXZhbHVlU3BlYykgewogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAndW5rbm93biBwcm9wZXJ0eSAiJyArIHByb3BlcnR5S2V5ICsgJyInKV07CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdG9rZW5NYXRjaDsKICAgICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ3N0cmluZycgJiYgc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24odmFsdWVTcGVjKSAmJiAhdmFsdWVTcGVjLnRva2VucyAmJiAodG9rZW5NYXRjaCA9IC9eeyhbXn1dKyl9JC8uZXhlYyh2YWx1ZSkpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICciJyArIHByb3BlcnR5S2V5ICsgJyIgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnBvbGF0aW9uIHN5bnRheFxuJyArICdVc2UgYW4gaWRlbnRpdHkgcHJvcGVydHkgZnVuY3Rpb24gaW5zdGVhZDogYHsgInR5cGUiOiAiaWRlbnRpdHkiLCAicHJvcGVydHkiOiAnICsgSlNPTi5zdHJpbmdpZnkodG9rZW5NYXRjaFsxXSkgKyAnIH1gLicpXTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTsKICAgICAgICAgIGlmIChvcHRpb25zLmxheWVyVHlwZSA9PT0gJ3N5bWJvbCcpIHsKICAgICAgICAgICAgICBpZiAocHJvcGVydHlLZXkgPT09ICd0ZXh0LWZpZWxkJyAmJiBzdHlsZSAmJiAhc3R5bGUuZ2x5cGhzKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3VzZSBvZiAidGV4dC1maWVsZCIgcmVxdWlyZXMgYSBzdHlsZSAiZ2x5cGhzIiBwcm9wZXJ0eScpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHByb3BlcnR5S2V5ID09PSAndGV4dC1mb250JyAmJiBpc0Z1bmN0aW9uJDEoZGVlcFVuYnVuZGxlKHZhbHVlKSkgJiYgdW5idW5kbGUodmFsdWUudHlwZSkgPT09ICdpZGVudGl0eScpIHsKICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnInRleHQtZm9udCIgZG9lcyBub3Qgc3VwcG9ydCBpZGVudGl0eSBmdW5jdGlvbnMnKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQodmFsaWRhdGUoewogICAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksCiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAogICAgICAgICAgICAgIHZhbHVlU3BlYzogdmFsdWVTcGVjLAogICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSwKICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYywKICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ3Byb3BlcnR5JywKICAgICAgICAgICAgICBwcm9wZXJ0eVR5cGU6IHByb3BlcnR5VHlwZSwKICAgICAgICAgICAgICBwcm9wZXJ0eUtleTogcHJvcGVydHlLZXkKICAgICAgICAgIH0pKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYWludFByb3BlcnR5KG9wdGlvbnMpIHsKICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsICdwYWludCcpOwogICAgICB9CgogICAgICBmdW5jdGlvbiB2YWxpZGF0ZUxheW91dFByb3BlcnR5KG9wdGlvbnMpIHsKICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsICdsYXlvdXQnKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVMYXllcihvcHRpb25zKSB7CiAgICAgICAgICB2YXIgZXJyb3JzID0gW107CiAgICAgICAgICB2YXIgbGF5ZXIgPSBvcHRpb25zLnZhbHVlOwogICAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5OwogICAgICAgICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTsKICAgICAgICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYzsKICAgICAgICAgIGlmICghbGF5ZXIudHlwZSAmJiAhbGF5ZXIucmVmKSB7CiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnZWl0aGVyICJ0eXBlIiBvciAicmVmIiBpcyByZXF1aXJlZCcpKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB0eXBlID0gdW5idW5kbGUobGF5ZXIudHlwZSk7CiAgICAgICAgICB2YXIgcmVmID0gdW5idW5kbGUobGF5ZXIucmVmKTsKICAgICAgICAgIGlmIChsYXllci5pZCkgewogICAgICAgICAgICAgIHZhciBsYXllcklkID0gdW5idW5kbGUobGF5ZXIuaWQpOwogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5hcnJheUluZGV4OyBpKyspIHsKICAgICAgICAgICAgICAgICAgdmFyIG90aGVyTGF5ZXIgPSBzdHlsZS5sYXllcnNbaV07CiAgICAgICAgICAgICAgICAgIGlmICh1bmJ1bmRsZShvdGhlckxheWVyLmlkKSA9PT0gbGF5ZXJJZCkgewogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLmlkLCAnZHVwbGljYXRlIGxheWVyIGlkICInICsgbGF5ZXIuaWQgKyAnIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJyArIG90aGVyTGF5ZXIuaWQuX19saW5lX18pKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmICgncmVmJyBpbiBsYXllcikgewogICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgJ3R5cGUnLAogICAgICAgICAgICAgICAgICAnc291cmNlJywKICAgICAgICAgICAgICAgICAgJ3NvdXJjZS1sYXllcicsCiAgICAgICAgICAgICAgICAgICdmaWx0ZXInLAogICAgICAgICAgICAgICAgICAnbGF5b3V0JwogICAgICAgICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAocCkgewogICAgICAgICAgICAgICAgICBpZiAocCBpbiBsYXllcikgewogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyW3BdLCAnIicgKyBwICsgJyIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVycycpKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIHZhciBwYXJlbnQ7CiAgICAgICAgICAgICAgc3R5bGUubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7CiAgICAgICAgICAgICAgICAgIGlmICh1bmJ1bmRsZShsYXllci5pZCkgPT09IHJlZikgewogICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gbGF5ZXI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBpZiAoIXBhcmVudCkgewogICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIucmVmLCAncmVmIGxheWVyICInICsgcmVmICsgJyIgbm90IGZvdW5kJykpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJlZikgewogICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIucmVmLCAncmVmIGNhbm5vdCByZWZlcmVuY2UgYW5vdGhlciByZWYgbGF5ZXInKSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdHlwZSA9IHVuYnVuZGxlKHBhcmVudC50eXBlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykgewogICAgICAgICAgICAgIGlmICghbGF5ZXIuc291cmNlKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgInNvdXJjZSInKSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXMgJiYgc3R5bGUuc291cmNlc1tsYXllci5zb3VyY2VdOwogICAgICAgICAgICAgICAgICB2YXIgc291cmNlVHlwZSA9IHNvdXJjZSAmJiB1bmJ1bmRsZShzb3VyY2UudHlwZSk7CiAgICAgICAgICAgICAgICAgIGlmICghc291cmNlKSB7CiAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnc291cmNlICInICsgbGF5ZXIuc291cmNlICsgJyIgbm90IGZvdW5kJykpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICd2ZWN0b3InICYmIHR5cGUgPT09ICdyYXN0ZXInKSB7CiAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnbGF5ZXIgIicgKyBsYXllci5pZCArICciIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScpKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAncmFzdGVyJyAmJiB0eXBlICE9PSAncmFzdGVyJykgewogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ2xheWVyICInICsgbGF5ZXIuaWQgKyAnIiByZXF1aXJlcyBhIHZlY3RvciBzb3VyY2UnKSk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3ZlY3RvcicgJiYgIWxheWVyWydzb3VyY2UtbGF5ZXInXSkgewogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbGF5ZXIgIicgKyBsYXllci5pZCArICciIG11c3Qgc3BlY2lmeSBhICJzb3VyY2UtbGF5ZXIiJykpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICdyYXN0ZXItZGVtJyAmJiB0eXBlICE9PSAnaGlsbHNoYWRlJykgewogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3Jhc3Rlci1kZW0gc291cmNlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBsYXllciB0eXBlIFwnaGlsbHNoYWRlXCcuJykpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lJyAmJiBsYXllci5wYWludCAmJiBsYXllci5wYWludFsnbGluZS1ncmFkaWVudCddICYmIChzb3VyY2VUeXBlICE9PSAnZ2VvanNvbicgfHwgIXNvdXJjZS5saW5lTWV0cmljcykpIHsKICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2xheWVyICInICsgbGF5ZXIuaWQgKyAnIiBzcGVjaWZpZXMgYSBsaW5lLWdyYWRpZW50LCB3aGljaCByZXF1aXJlcyBhIEdlb0pTT04gc291cmNlIHdpdGggYGxpbmVNZXRyaWNzYCBlbmFibGVkLicpKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3QoewogICAgICAgICAgICAgIGtleToga2V5LAogICAgICAgICAgICAgIHZhbHVlOiBsYXllciwKICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5sYXllciwKICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSwKICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLAogICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7CiAgICAgICAgICAgICAgICAgICcqJzogZnVuY3Rpb24gXygpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gdHlwZSgpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZSh7CiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnLnR5cGUnLAogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsYXllci50eXBlLAogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmxheWVyLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYywKICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGxheWVyLAogICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdEtleTogJ3R5cGUnCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgZmlsdGVyOiB2YWxpZGF0ZUZpbHRlciwKICAgICAgICAgICAgICAgICAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHsKICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogbGF5ZXIsCiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSwKICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSwKICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLAogICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcqJzogZnVuY3Rpb24gXyhvcHRpb25zKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShleHRlbmQoeyBsYXllclR5cGU6IHR5cGUgfSwgb3B0aW9ucykpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgIHBhaW50OiBmdW5jdGlvbiBwYWludChvcHRpb25zKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoewogICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllciwKICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LAogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLAogICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLAogICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKG9wdGlvbnMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVBhaW50UHJvcGVydHkoZXh0ZW5kKHsgbGF5ZXJUeXBlOiB0eXBlIH0sIG9wdGlvbnMpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIGVycm9yczsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcob3B0aW9ucykgewogICAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTsKICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTsKICAgICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7CiAgICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3N0cmluZyBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICB2YXIgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgPSB7IHByb21vdGVJZDogdmFsaWRhdGVQcm9tb3RlSWQgfTsKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVTb3VyY2Uob3B0aW9ucykgewogICAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTsKICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTsKICAgICAgICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYzsKICAgICAgICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7CiAgICAgICAgICBpZiAoIXZhbHVlLnR5cGUpIHsKICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJyJ0eXBlIiBpcyByZXF1aXJlZCcpXTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB0eXBlID0gdW5idW5kbGUodmFsdWUudHlwZSk7CiAgICAgICAgICB2YXIgZXJyb3JzOwogICAgICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgICBjYXNlICd2ZWN0b3InOgogICAgICAgICAgY2FzZSAncmFzdGVyJzoKICAgICAgICAgIGNhc2UgJ3Jhc3Rlci1kZW0nOgogICAgICAgICAgICAgIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHsKICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWNbJ3NvdXJjZV8nICsgdHlwZS5yZXBsYWNlKCctJywgJ18nKV0sCiAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLAogICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYywKICAgICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yczsKICAgICAgICAgIGNhc2UgJ2dlb2pzb24nOgogICAgICAgICAgICAgIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHsKICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2dlb2pzb24sCiAgICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSwKICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsCiAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiBvYmplY3RFbGVtZW50VmFsaWRhdG9ycwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGlmICh2YWx1ZS5jbHVzdGVyKSB7CiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUuY2x1c3RlclByb3BlcnRpZXMpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSB2YWx1ZS5jbHVzdGVyUHJvcGVydGllc1twcm9wXTsKICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHJlZlswXTsKICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBFeHByID0gcmVmWzFdOwogICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZHVjZUV4cHIgPSB0eXBlb2Ygb3BlcmF0b3IgPT09ICdzdHJpbmcnID8gWwogICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLAogICAgICAgICAgICAgICAgICAgICAgICAgIFsnYWNjdW11bGF0ZWQnXSwKICAgICAgICAgICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnZXQnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wCiAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgXSA6IG9wZXJhdG9yOwogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCB2YWxpZGF0ZUV4cHJlc3Npb24oewogICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJy4nICsgcHJvcCArICcubWFwJywKICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFwRXhwciwKICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItbWFwJwogICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCB2YWxpZGF0ZUV4cHJlc3Npb24oewogICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJy4nICsgcHJvcCArICcucmVkdWNlJywKICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVkdWNlRXhwciwKICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItcmVkdWNlJwogICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7CiAgICAgICAgICBjYXNlICd2aWRlbyc6CiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHsKICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX3ZpZGVvLAogICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsCiAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICBjYXNlICdpbWFnZSc6CiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHsKICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2ltYWdlLAogICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsCiAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICBjYXNlICdjYW52YXMnOgogICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG51bGwsICdQbGVhc2UgdXNlIHJ1bnRpbWUgQVBJcyB0byBhZGQgY2FudmFzIHNvdXJjZXMsIHJhdGhlciB0aGFuIGluY2x1ZGluZyB0aGVtIGluIHN0eWxlc2hlZXRzLicsICdzb3VyY2UuY2FudmFzJyldOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVFbnVtKHsKICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnLnR5cGUnLAogICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudHlwZSwKICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiB7CiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAndmVjdG9yJywKICAgICAgICAgICAgICAgICAgICAgICAgICAncmFzdGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAncmFzdGVyLWRlbScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dlb2pzb24nLAogICAgICAgICAgICAgICAgICAgICAgICAgICd2aWRlbycsCiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlJwogICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsCiAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9tb3RlSWQocmVmKSB7CiAgICAgICAgICB2YXIga2V5ID0gcmVmLmtleTsKICAgICAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTsKICAgICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHJpbmcoewogICAgICAgICAgICAgICAgICBrZXk6IGtleSwKICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTsKICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgdmFsaWRhdGVTdHJpbmcoewogICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnLicgKyBwcm9wLAogICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW3Byb3BdCiAgICAgICAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yczsKICAgICAgICAgIH0KICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVMaWdodChvcHRpb25zKSB7CiAgICAgICAgICB2YXIgbGlnaHQgPSBvcHRpb25zLnZhbHVlOwogICAgICAgICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjOwogICAgICAgICAgdmFyIGxpZ2h0U3BlYyA9IHN0eWxlU3BlYy5saWdodDsKICAgICAgICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7CiAgICAgICAgICB2YXIgZXJyb3JzID0gW107CiAgICAgICAgICB2YXIgcm9vdFR5cGUgPSBnZXRUeXBlKGxpZ2h0KTsKICAgICAgICAgIGlmIChsaWdodCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yczsKICAgICAgICAgIH0gZWxzZSBpZiAocm9vdFR5cGUgIT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcignbGlnaHQnLCBsaWdodCwgJ29iamVjdCBleHBlY3RlZCwgJyArIHJvb3RUeXBlICsgJyBmb3VuZCcpXSk7CiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yczsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGtleSBpbiBsaWdodCkgewogICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBrZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7CiAgICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25NYXRjaCAmJiBsaWdodFNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsaWdodFNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoewogICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGlnaHRba2V5XSwKICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sCiAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsCiAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYwogICAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaWdodFNwZWNba2V5XSkgewogICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHsKICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LAogICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpZ2h0W2tleV0sCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IGxpZ2h0U3BlY1trZXldLAogICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLAogICAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMKICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsaWdodFtrZXldLCAndW5rbm93biBwcm9wZXJ0eSAiJyArIGtleSArICciJyldKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZXJyb3JzOwogICAgICB9CgogICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdHRlZChvcHRpb25zKSB7CiAgICAgICAgICBpZiAodmFsaWRhdGVTdHJpbmcob3B0aW9ucykubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJbWFnZShvcHRpb25zKSB7CiAgICAgICAgICBpZiAodmFsaWRhdGVTdHJpbmcob3B0aW9ucykubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTsKICAgICAgfQoKICAgICAgdmFyIFZBTElEQVRPUlMgPSB7CiAgICAgICAgICAnKic6IGZ1bmN0aW9uIF8oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgfSwKICAgICAgICAgICdhcnJheSc6IHZhbGlkYXRlQXJyYXksCiAgICAgICAgICAnYm9vbGVhbic6IHZhbGlkYXRlQm9vbGVhbiwKICAgICAgICAgICdudW1iZXInOiB2YWxpZGF0ZU51bWJlciwKICAgICAgICAgICdjb2xvcic6IHZhbGlkYXRlQ29sb3IsCiAgICAgICAgICAnY29uc3RhbnRzJzogdmFsaWRhdGVDb25zdGFudHMsCiAgICAgICAgICAnZW51bSc6IHZhbGlkYXRlRW51bSwKICAgICAgICAgICdmaWx0ZXInOiB2YWxpZGF0ZUZpbHRlciwKICAgICAgICAgICdmdW5jdGlvbic6IHZhbGlkYXRlRnVuY3Rpb24sCiAgICAgICAgICAnbGF5ZXInOiB2YWxpZGF0ZUxheWVyLAogICAgICAgICAgJ29iamVjdCc6IHZhbGlkYXRlT2JqZWN0LAogICAgICAgICAgJ3NvdXJjZSc6IHZhbGlkYXRlU291cmNlLAogICAgICAgICAgJ2xpZ2h0JzogdmFsaWRhdGVMaWdodCwKICAgICAgICAgICdzdHJpbmcnOiB2YWxpZGF0ZVN0cmluZywKICAgICAgICAgICdmb3JtYXR0ZWQnOiB2YWxpZGF0ZUZvcm1hdHRlZCwKICAgICAgICAgICdyZXNvbHZlZEltYWdlJzogdmFsaWRhdGVJbWFnZQogICAgICB9OwogICAgICBmdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7CiAgICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlOwogICAgICAgICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjOwogICAgICAgICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjOwogICAgICAgICAgaWYgKHZhbHVlU3BlYy5leHByZXNzaW9uICYmIGlzRnVuY3Rpb24kMSh1bmJ1bmRsZSh2YWx1ZSkpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucyk7CiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU3BlYy5leHByZXNzaW9uICYmIGlzRXhwcmVzc2lvbihkZWVwVW5idW5kbGUodmFsdWUpKSkgewogICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucyk7CiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU3BlYy50eXBlICYmIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKG9wdGlvbnMpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB2YXIgdmFsaWQgPSB2YWxpZGF0ZU9iamVjdChleHRlbmQoe30sIG9wdGlvbnMsIHsgdmFsdWVTcGVjOiB2YWx1ZVNwZWMudHlwZSA/IHN0eWxlU3BlY1t2YWx1ZVNwZWMudHlwZV0gOiB2YWx1ZVNwZWMgfSkpOwogICAgICAgICAgICAgIHJldHVybiB2YWxpZDsKICAgICAgICAgIH0KICAgICAgfQoKICAgICAgZnVuY3Rpb24gdmFsaWRhdGVHbHlwaHNVUkwgKG9wdGlvbnMpIHsKICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7CiAgICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7CiAgICAgICAgICB2YXIgZXJyb3JzID0gdmFsaWRhdGVTdHJpbmcob3B0aW9ucyk7CiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkgewogICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZigne2ZvbnRzdGFja30nKSA9PT0gLTEpIHsKICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICciZ2x5cGhzIiB1cmwgbXVzdCBpbmNsdWRlIGEgIntmb250c3RhY2t9IiB0b2tlbicpKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7cmFuZ2V9JykgPT09IC0xKSB7CiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnImdseXBocyIgdXJsIG11c3QgaW5jbHVkZSBhICJ7cmFuZ2V9IiB0b2tlbicpKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBlcnJvcnM7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3R5bGVNaW4oc3R5bGUsIHN0eWxlU3BlYykgewogICAgICAgICAgaWYgKHN0eWxlU3BlYyA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIHN0eWxlU3BlYyA9IHY4OwogICAgICAgICAgdmFyIGVycm9ycyA9IFtdOwogICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7CiAgICAgICAgICAgICAga2V5OiAnJywKICAgICAgICAgICAgICB2YWx1ZTogc3R5bGUsCiAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuJHJvb3QsCiAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsCiAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLAogICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7CiAgICAgICAgICAgICAgICAgIGdseXBoczogdmFsaWRhdGVHbHlwaHNVUkwsCiAgICAgICAgICAgICAgICAgICcqJzogZnVuY3Rpb24gXygpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0pKTsKICAgICAgICAgIGlmIChzdHlsZS5jb25zdGFudHMpIHsKICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQ29uc3RhbnRzKHsKICAgICAgICAgICAgICAgICAga2V5OiAnY29uc3RhbnRzJywKICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0eWxlLmNvbnN0YW50cywKICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLAogICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYwogICAgICAgICAgICAgIH0pKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzb3J0RXJyb3JzKGVycm9ycyk7CiAgICAgIH0KICAgICAgdmFsaWRhdGVTdHlsZU1pbi5zb3VyY2UgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVTb3VyY2UpOwogICAgICB2YWxpZGF0ZVN0eWxlTWluLmxpZ2h0ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGlnaHQpOwogICAgICB2YWxpZGF0ZVN0eWxlTWluLmxheWVyID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5ZXIpOwogICAgICB2YWxpZGF0ZVN0eWxlTWluLmZpbHRlciA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUZpbHRlcik7CiAgICAgIHZhbGlkYXRlU3R5bGVNaW4ucGFpbnRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZVBhaW50UHJvcGVydHkpOwogICAgICB2YWxpZGF0ZVN0eWxlTWluLmxheW91dFByb3BlcnR5ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5b3V0UHJvcGVydHkpOwogICAgICBmdW5jdGlvbiBzb3J0RXJyb3JzKGVycm9ycykgewogICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChlcnJvcnMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICAgICAgICByZXR1cm4gYS5saW5lIC0gYi5saW5lOwogICAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3JhcENsZWFuRXJyb3JzKGlubmVyKSB7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgICAgICAgICAgICAgd2hpbGUgKGxlbi0tKQogICAgICAgICAgICAgICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTsKICAgICAgICAgICAgICByZXR1cm4gc29ydEVycm9ycyhpbm5lci5hcHBseSh0aGlzLCBhcmdzKSk7CiAgICAgICAgICB9OwogICAgICB9CgogICAgICB2YXIganNvbmxpbnQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7CiAgICAgIC8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC40LjE1ICovCiAgICAgIC8qCiAgICAgICAgUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6CgogICAgICAgIFBhcnNlcjogewogICAgICAgICAgeXk6IHt9CiAgICAgICAgfQoKICAgICAgICBQYXJzZXIucHJvdG90eXBlOiB7CiAgICAgICAgICB5eToge30sCiAgICAgICAgICB0cmFjZTogZnVuY3Rpb24oKSwKICAgICAgICAgIHN5bWJvbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gbnVtYmVyfSwKICAgICAgICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LAogICAgICAgICAgcHJvZHVjdGlvbnNfOiBbLi4uXSwKICAgICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlLCAkJCwgXyQpLAogICAgICAgICAgdGFibGU6IFsuLi5dLAogICAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LAogICAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSwKICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksCgogICAgICAgICAgbGV4ZXI6IHsKICAgICAgICAgICAgICBFT0Y6IDEsCiAgICAgICAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSwKICAgICAgICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQpLAogICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigpLAogICAgICAgICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLAogICAgICAgICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksCiAgICAgICAgICAgICAgbGVzczogZnVuY3Rpb24obiksCiAgICAgICAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLAogICAgICAgICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCksCiAgICAgICAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLAogICAgICAgICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSwKICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpLAogICAgICAgICAgICAgIGxleDogZnVuY3Rpb24oKSwKICAgICAgICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSwKICAgICAgICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSwKICAgICAgICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLAogICAgICAgICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLAogICAgICAgICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSwKCiAgICAgICAgICAgICAgb3B0aW9uczogewogICAgICAgICAgICAgICAgICByYW5nZXM6IGJvb2xlYW4gICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIpCiAgICAgICAgICAgICAgICAgIGZsZXg6IGJvb2xlYW4gICAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZCBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaCkKICAgICAgICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpCiAgICAgICAgICAgICAgfSwKCiAgICAgICAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLAogICAgICAgICAgICAgIHJ1bGVzOiBbLi4uXSwKICAgICAgICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSwKICAgICAgICAgIH0KICAgICAgICB9CgoKICAgICAgICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7CiAgICAgICAgICBmaXJzdF9saW5lOiBuLAogICAgICAgICAgbGFzdF9saW5lOiBuLAogICAgICAgICAgZmlyc3RfY29sdW1uOiBuLAogICAgICAgICAgbGFzdF9jb2x1bW46IG4sCiAgICAgICAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKQogICAgICAgIH0KCgogICAgICAgIHRoZSBwYXJzZUVycm9yIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZCBwYXJzZXIgZXJyb3JzOiB7CiAgICAgICAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dCkKICAgICAgICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpCiAgICAgICAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKQogICAgICAgIH0KICAgICAgICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHsKICAgICAgICAgIGxvYzogICAgICAgICAoeXlsbG9jKQogICAgICAgICAgZXhwZWN0ZWQ6ICAgIChzdHJpbmcgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucykKICAgICAgICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcikKICAgICAgICB9CiAgICAgICovCiAgICAgIHZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXsKICAgICAgdmFyIG89ZnVuY3Rpb24oayx2LG8sbCl7Zm9yKG89b3x8e30sbD1rLmxlbmd0aDtsLS07b1trW2xdXT12KXsgfXJldHVybiBvfSwkVjA9WzEsMTJdLCRWMT1bMSwxM10sJFYyPVsxLDldLCRWMz1bMSwxMF0sJFY0PVsxLDExXSwkVjU9WzEsMTRdLCRWNj1bMSwxNV0sJFY3PVsxNCwxOCwyMiwyNF0sJFY4PVsxOCwyMl0sJFY5PVsyMiwyNF07CiAgICAgIHZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LAogICAgICB5eToge30sCiAgICAgIHN5bWJvbHNfOiB7ImVycm9yIjoyLCJKU09OU3RyaW5nIjozLCJTVFJJTkciOjQsIkpTT05OdW1iZXIiOjUsIk5VTUJFUiI6NiwiSlNPTk51bGxMaXRlcmFsIjo3LCJOVUxMIjo4LCJKU09OQm9vbGVhbkxpdGVyYWwiOjksIlRSVUUiOjEwLCJGQUxTRSI6MTEsIkpTT05UZXh0IjoxMiwiSlNPTlZhbHVlIjoxMywiRU9GIjoxNCwiSlNPTk9iamVjdCI6MTUsIkpTT05BcnJheSI6MTYsInsiOjE3LCJ9IjoxOCwiSlNPTk1lbWJlckxpc3QiOjE5LCJKU09OTWVtYmVyIjoyMCwiOiI6MjEsIiwiOjIyLCJbIjoyMywiXSI6MjQsIkpTT05FbGVtZW50TGlzdCI6MjUsIiRhY2NlcHQiOjAsIiRlbmQiOjF9LAogICAgICB0ZXJtaW5hbHNfOiB7MjoiZXJyb3IiLDQ6IlNUUklORyIsNjoiTlVNQkVSIiw4OiJOVUxMIiwxMDoiVFJVRSIsMTE6IkZBTFNFIiwxNDoiRU9GIiwxNzoieyIsMTg6In0iLDIxOiI6IiwyMjoiLCIsMjM6IlsiLDI0OiJdIn0sCiAgICAgIHByb2R1Y3Rpb25zXzogWzAsWzMsMV0sWzUsMV0sWzcsMV0sWzksMV0sWzksMV0sWzEyLDJdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxNSwyXSxbMTUsM10sWzIwLDNdLFsxOSwxXSxbMTksM10sWzE2LDJdLFsxNiwzXSxbMjUsMV0sWzI1LDNdXSwKICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCAkJCAvKiB2c3RhY2sgKi8sIF8kIC8qIGxzdGFjayAqLykgewogICAgICAvKiB0aGlzID09IHl5dmFsICovCgogICAgICB2YXIgJDAgPSAkJC5sZW5ndGggLSAxOwogICAgICBzd2l0Y2ggKHl5c3RhdGUpIHsKICAgICAgY2FzZSAxOgogICAgICAgLy8gcmVwbGFjZSBlc2NhcGVkIGNoYXJhY3RlcnMgd2l0aCBhY3R1YWwgY2hhcmFjdGVyCiAgICAgICAgICAgICAgICB0aGlzLiQgPSBuZXcgU3RyaW5nKHl5dGV4dC5yZXBsYWNlKC9cXChcXHwiKS9nLCAiJCIrIjEiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csJ1xuJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCdccicpCiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywnXHQnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx2L2csJ1x2JykKICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCdcZicpCiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXGIvZywnXGInKSk7CiAgICAgICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSAgdGhpcy5fJC5maXJzdF9saW5lOwogICAgICAgICAgICAgIAogICAgICBicmVhazsKICAgICAgY2FzZSAyOgoKICAgICAgICAgICAgICAgICAgdGhpcy4kID0gbmV3IE51bWJlcih5eXRleHQpOwogICAgICAgICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSAgdGhpcy5fJC5maXJzdF9saW5lOwogICAgICAgICAgICAgIAogICAgICBicmVhazsKICAgICAgY2FzZSAzOgoKICAgICAgICAgICAgICAgICAgdGhpcy4kID0gbnVsbDsKICAgICAgICAgICAgICAKICAgICAgYnJlYWs7CiAgICAgIGNhc2UgNDoKCiAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBCb29sZWFuKHRydWUpOwogICAgICAgICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7CiAgICAgICAgICAgICAgCiAgICAgIGJyZWFrOwogICAgICBjYXNlIDU6CgogICAgICAgICAgICAgICAgICB0aGlzLiQgPSBuZXcgQm9vbGVhbihmYWxzZSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9IHRoaXMuXyQuZmlyc3RfbGluZTsKICAgICAgICAgICAgICAKICAgICAgYnJlYWs7CiAgICAgIGNhc2UgNjoKICAgICAgcmV0dXJuIHRoaXMuJCA9ICQkWyQwLTFdOwogICAgICBjYXNlIDEzOgogICAgICB0aGlzLiQgPSB7fTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuJCwgJ19fbGluZV9fJywgewogICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLAogICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgICAgICAgICAgIH0pOwogICAgICBicmVhazsKICAgICAgY2FzZSAxNDogY2FzZSAxOToKICAgICAgdGhpcy4kID0gJCRbJDAtMV07IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHsKICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuXyQuZmlyc3RfbGluZSwKICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgICAgICAgICAgICB9KTsKICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMTU6CiAgICAgIHRoaXMuJCA9IFskJFskMC0yXSwgJCRbJDBdXTsKICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMTY6CiAgICAgIHRoaXMuJCA9IHt9OyB0aGlzLiRbJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTsKICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMTc6CiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXVskJFskMF1bMF1dID0gJCRbJDBdWzFdOwogICAgICBicmVhazsKICAgICAgY2FzZSAxODoKICAgICAgdGhpcy4kID0gW107IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHsKICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuXyQuZmlyc3RfbGluZSwKICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgICAgICAgICAgICB9KTsKICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMjA6CiAgICAgIHRoaXMuJCA9IFskJFskMF1dOwogICAgICBicmVhazsKICAgICAgY2FzZSAyMToKICAgICAgdGhpcy4kID0gJCRbJDAtMl07ICQkWyQwLTJdLnB1c2goJCRbJDBdKTsKICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgfSwKICAgICAgdGFibGU6IFt7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTI6MSwxMzoyLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSx7MTpbM119LHsxNDpbMSwxNl19LG8oJFY3LFsyLDddKSxvKCRWNyxbMiw4XSksbygkVjcsWzIsOV0pLG8oJFY3LFsyLDEwXSksbygkVjcsWzIsMTFdKSxvKCRWNyxbMiwxMl0pLG8oJFY3LFsyLDNdKSxvKCRWNyxbMiw0XSksbygkVjcsWzIsNV0pLG8oWzE0LDE4LDIxLDIyLDI0XSxbMiwxXSksbygkVjcsWzIsMl0pLHszOjIwLDQ6JFYwLDE4OlsxLDE3XSwxOToxOCwyMDoxOX0sezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjIzLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2LDI0OlsxLDIxXSwyNToyMn0sezE6WzIsNl19LG8oJFY3LFsyLDEzXSksezE4OlsxLDI0XSwyMjpbMSwyNV19LG8oJFY4LFsyLDE2XSksezIxOlsxLDI2XX0sbygkVjcsWzIsMThdKSx7MjI6WzEsMjhdLDI0OlsxLDI3XX0sbygkVjksWzIsMjBdKSxvKCRWNyxbMiwxNF0pLHszOjIwLDQ6JFYwLDIwOjI5fSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MzAsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LG8oJFY3LFsyLDE5XSksezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjMxLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSxvKCRWOCxbMiwxN10pLG8oJFY4LFsyLDE1XSksbygkVjksWzIsMjFdKV0sCiAgICAgIGRlZmF1bHRBY3Rpb25zOiB7MTY6WzIsNl19LAogICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkgewogICAgICAgICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHsKICAgICAgICAgICAgICB0aGlzLnRyYWNlKHN0cik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpOwogICAgICAgICAgfQogICAgICB9LAogICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHsKICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gJycsIHl5bGluZW5vID0gMCwgeXlsZW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTsKICAgICAgICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICAgIHZhciBsZXhlciA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7CiAgICAgICAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9OwogICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLnl5KSB7CiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkgewogICAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTsKICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXI7CiAgICAgICAgICBzaGFyZWRTdGF0ZS55eS5wYXJzZXIgPSB0aGlzOwogICAgICAgICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICBsZXhlci55eWxsb2MgPSB7fTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYzsKICAgICAgICAgIGxzdGFjay5wdXNoKHl5bG9jKTsKICAgICAgICAgIHZhciByYW5nZXMgPSBsZXhlci5vcHRpb25zICYmIGxleGVyLm9wdGlvbnMucmFuZ2VzOwogICAgICAgICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvcjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7CiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgICAgICBmdW5jdGlvbiBsZXgoKSB7CiAgICAgICAgICAgICAgICAgIHZhciB0b2tlbjsKICAgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5sZXgoKSB8fCBFT0Y7CiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgICAgICAgICB9CiAgICAgICAgICB2YXIgc3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDsKICAgICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTsKICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHsKICAgICAgICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyU3RyID0gJyc7CiAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IFRFUlJPUikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcJycgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyAnXCcnKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzpcbicgKyBsZXhlci5zaG93UG9zaXRpb24oKSArICdcbkV4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCBcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcJyc7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXCcnKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCwKICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLAogICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLAogICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsCiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkgewogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnICsgc3RhdGUgKyAnLCB0b2tlbjogJyArIHN5bWJvbCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7CiAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7CiAgICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7CiAgICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7CiAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTsKICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbnVsbDsKICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nOwogICAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0OwogICAgICAgICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubzsKICAgICAgICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTsKICAgICAgICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTsKICAgICAgICAgICAgICAgICAgeXl2YWwuXyQgPSB7CiAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsCiAgICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9saW5lLAogICAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbiwKICAgICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uCiAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMpIHsKICAgICAgICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gWwogICAgICAgICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXQogICAgICAgICAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmFwcGx5KHl5dmFsLCBbCiAgICAgICAgICAgICAgICAgICAgICB5eXRleHQsCiAgICAgICAgICAgICAgICAgICAgICB5eWxlbmcsCiAgICAgICAgICAgICAgICAgICAgICB5eWxpbmVubywKICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LAogICAgICAgICAgICAgICAgICAgICAgYWN0aW9uWzFdLAogICAgICAgICAgICAgICAgICAgICAgdnN0YWNrLAogICAgICAgICAgICAgICAgICAgICAgbHN0YWNrCiAgICAgICAgICAgICAgICAgIF0uY29uY2F0KGFyZ3MpKTsKICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpOwogICAgICAgICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTsKICAgICAgICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTsKICAgICAgICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7CiAgICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTsKICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGggLSAyXV1bc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dOwogICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfX07CiAgICAgIC8qIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC4zLjQgKi8KICAgICAgdmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7CiAgICAgIHZhciBsZXhlciA9ICh7CgogICAgICBFT0Y6MSwKCiAgICAgIHBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHsKICAgICAgICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHsKICAgICAgICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0sCgogICAgICAvLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dAogICAgICBzZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQsIHl5KSB7CiAgICAgICAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307CiAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDsKICAgICAgICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fYmFja3RyYWNrID0gdGhpcy5kb25lID0gZmFsc2U7CiAgICAgICAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDsKICAgICAgICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJzsKICAgICAgICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107CiAgICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7CiAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsCiAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogMCwKICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiAxLAogICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogMAogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHsKICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwOwogICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfSwKCiAgICAgIC8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0CiAgICAgIGlucHV0OmZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTsKICAgICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDsKICAgICAgICAgICAgICB0aGlzLnl5bGVuZysrOwogICAgICAgICAgICAgIHRoaXMub2Zmc2V0Kys7CiAgICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDsKICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7CiAgICAgICAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/OlxyXG4/fFxuKS4qL2cpOwogICAgICAgICAgICAgIGlmIChsaW5lcykgewogICAgICAgICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7CiAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpOwogICAgICAgICAgICAgIHJldHVybiBjaDsKICAgICAgICAgIH0sCgogICAgICAvLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0CiAgICAgIHVucHV0OmZ1bmN0aW9uIChjaCkgewogICAgICAgICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7CiAgICAgICAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/OlxyXG4/fFxuKS9nKTsKCiAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0OwogICAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7CiAgICAgICAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47CiAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuOwogICAgICAgICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/OlxyXG4/fFxuKS9nKTsKICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTsKICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTsKCiAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHsKICAgICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlOwoKICAgICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHsKICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSwKICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSwKICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sCiAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/CiAgICAgICAgICAgICAgICAgICAgICAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKQogICAgICAgICAgICAgICAgICAgICAgICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOgogICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlbgogICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoOwogICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfSwKCiAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uCiAgICAgIG1vcmU6ZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIHRoaXMuX21vcmUgPSB0cnVlOwogICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfSwKCiAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBzaWduYWxzIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZSBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuCiAgICAgIHJlamVjdDpmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwgewogICAgICAgICAgICAgICAgICAgICAgdGV4dDogIiIsCiAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCwKICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm8KICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0sCgogICAgICAvLyByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaAogICAgICBsZXNzOmZ1bmN0aW9uIChuKSB7CiAgICAgICAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTsKICAgICAgICAgIH0sCgogICAgICAvLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzCiAgICAgIHBhc3RJbnB1dDpmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7CiAgICAgICAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cbi9nLCAiIik7CiAgICAgICAgICB9LAoKICAgICAgLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzCiAgICAgIHVwY29taW5nSW5wdXQ6ZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDsKICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkgewogICAgICAgICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMC1uZXh0Lmxlbmd0aCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cbi9nLCAiIik7CiAgICAgICAgICB9LAoKICAgICAgLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlcwogICAgICBzaG93UG9zaXRpb246ZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpOwogICAgICAgICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKCItIik7CiAgICAgICAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgIlxuIiArIGMgKyAiXiI7CiAgICAgICAgICB9LAoKICAgICAgLy8gdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuCiAgICAgIHRlc3RfbWF0Y2g6ZnVuY3Rpb24gKG1hdGNoLCBpbmRleGVkX3J1bGUpIHsKICAgICAgICAgICAgICB2YXIgdG9rZW4sCiAgICAgICAgICAgICAgICAgIGxpbmVzLAogICAgICAgICAgICAgICAgICBiYWNrdXA7CgogICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7CiAgICAgICAgICAgICAgICAgIC8vIHNhdmUgY29udGV4dAogICAgICAgICAgICAgICAgICBiYWNrdXAgPSB7CiAgICAgICAgICAgICAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubywKICAgICAgICAgICAgICAgICAgICAgIHl5bGxvYzogewogICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLmxhc3RfbGluZSwKICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiwKICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4KICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LAogICAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsCiAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsCiAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsCiAgICAgICAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLAogICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCwKICAgICAgICAgICAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLAogICAgICAgICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCwKICAgICAgICAgICAgICAgICAgICAgIHl5OiB0aGlzLnl5LAogICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksCiAgICAgICAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmUKICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XHJcbj98XG4pLiovZyk7CiAgICAgICAgICAgICAgaWYgKGxpbmVzKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHsKICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLAogICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLAogICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLAogICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgPwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xyP1xuPy8pWzBdLmxlbmd0aCA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aAogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07CiAgICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTsKICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDsKICAgICAgICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDsKICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgewogICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7CiAgICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7CiAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpOwogICAgICAgICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTsKICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTsKICAgICAgICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAodG9rZW4pIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7CiAgICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dAogICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkgewogICAgICAgICAgICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC4KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfSwKCiAgICAgIC8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0CiAgICAgIG5leHQ6ZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB2YXIgdG9rZW4sCiAgICAgICAgICAgICAgICAgIG1hdGNoLAogICAgICAgICAgICAgICAgICB0ZW1wTWF0Y2gsCiAgICAgICAgICAgICAgICAgIGluZGV4OwogICAgICAgICAgICAgIGlmICghdGhpcy5fbW9yZSkgewogICAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnOwogICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpOwogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pOwogICAgICAgICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHsKICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoOwogICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC4KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChtYXRjaCkgewogICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZXNbaW5kZXhdKTsKICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09ICIiKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7CiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAiIiwKICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLAogICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVubwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9LAoKICAgICAgLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlbgogICAgICBsZXg6ZnVuY3Rpb24gbGV4KCkgewogICAgICAgICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7CiAgICAgICAgICAgICAgaWYgKHIpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV4KCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSwKCiAgICAgIC8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spCiAgICAgIGJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikgewogICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pOwogICAgICAgICAgfSwKCiAgICAgIC8vIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uIHN0YWNrCiAgICAgIHBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkgewogICAgICAgICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxOwogICAgICAgICAgICAgIGlmIChuID4gMCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9LAoKICAgICAgLy8gcHJvZHVjZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUKICAgICAgX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkgewogICAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbIklOSVRJQUwiXS5ydWxlczsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9LAoKICAgICAgLy8gcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleCBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsIGlmIGF2YWlsYWJsZQogICAgICB0b3BTdGF0ZTpmdW5jdGlvbiB0b3BTdGF0ZShuKSB7CiAgICAgICAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7CiAgICAgICAgICAgICAgaWYgKG4gPj0gMCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gIklOSVRJQUwiOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0sCgogICAgICAvLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKQogICAgICBwdXNoU3RhdGU6ZnVuY3Rpb24gcHVzaFN0YXRlKGNvbmRpdGlvbikgewogICAgICAgICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTsKICAgICAgICAgIH0sCgogICAgICAvLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFjawogICAgICBzdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7CiAgICAgICAgICB9LAogICAgICBvcHRpb25zOiB7fSwKICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7CiAgICAgIHN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7CiAgICAgIGNhc2UgMDovKiBza2lwIHdoaXRlc3BhY2UgKi8KICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMTpyZXR1cm4gNgogICAgICBjYXNlIDI6eXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDEseXlfLnl5bGVuZy0yKTsgcmV0dXJuIDQKICAgICAgY2FzZSAzOnJldHVybiAxNwogICAgICBjYXNlIDQ6cmV0dXJuIDE4CiAgICAgIGNhc2UgNTpyZXR1cm4gMjMKICAgICAgY2FzZSA2OnJldHVybiAyNAogICAgICBjYXNlIDc6cmV0dXJuIDIyCiAgICAgIGNhc2UgODpyZXR1cm4gMjEKICAgICAgY2FzZSA5OnJldHVybiAxMAogICAgICBjYXNlIDEwOnJldHVybiAxMQogICAgICBjYXNlIDExOnJldHVybiA4CiAgICAgIGNhc2UgMTI6cmV0dXJuIDE0CiAgICAgIGNhc2UgMTM6cmV0dXJuICdJTlZBTElEJwogICAgICB9CiAgICAgIH0sCiAgICAgIHJ1bGVzOiBbL14oPzpccyspLywvXig/OigtPyhbMC05XXxbMS05XVswLTldKykpKFwuWzAtOV0rKT8oW2VFXVstK10/WzAtOV0rKT9cYikvLC9eKD86Iig/OlxcW1xcImJmbnJ0L118XFx1W2EtZkEtRjAtOV17NH18W15cXFwwLVx4MDlceDBhLVx4MWYiXSkqIikvLC9eKD86XHspLywvXig/Olx9KS8sL14oPzpcWykvLC9eKD86XF0pLywvXig/OiwpLywvXig/OjopLywvXig/OnRydWVcYikvLC9eKD86ZmFsc2VcYikvLC9eKD86bnVsbFxiKS8sL14oPzokKS8sL14oPzouKS9dLAogICAgICBjb25kaXRpb25zOiB7IklOSVRJQUwiOnsicnVsZXMiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzXSwiaW5jbHVzaXZlIjp0cnVlfX0KICAgICAgfSk7CiAgICAgIHJldHVybiBsZXhlcjsKICAgICAgfSkoKTsKICAgICAgcGFyc2VyLmxleGVyID0gbGV4ZXI7CiAgICAgIGZ1bmN0aW9uIFBhcnNlciAoKSB7CiAgICAgICAgdGhpcy55eSA9IHt9OwogICAgICB9CiAgICAgIFBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjsKICAgICAgcmV0dXJuIG5ldyBQYXJzZXI7CiAgICAgIH0pKCk7CgoKICAgICAgaWYgKHR5cGVvZiBjb21tb25qc1JlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmICdvYmplY3QnICE9PSAndW5kZWZpbmVkJykgewogICAgICBleHBvcnRzLnBhcnNlciA9IHBhcnNlcjsKICAgICAgZXhwb3J0cy5QYXJzZXIgPSBwYXJzZXIuUGFyc2VyOwogICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTsgfTsKICAgICAgfQogICAgICB9KTsKICAgICAganNvbmxpbnQucGFyc2VyOwogICAgICBqc29ubGludC5QYXJzZXI7CiAgICAgIGpzb25saW50LnBhcnNlOwoKICAgICAgZnVuY3Rpb24gcmVhZFN0eWxlKHN0eWxlKSB7CiAgICAgICAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyB8fCBzdHlsZSBpbnN0YW5jZW9mIEJ1ZmZlcikgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBqc29ubGludC5wYXJzZShzdHlsZS50b1N0cmluZygpKTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IkMShlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc3R5bGU7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3R5bGUoc3R5bGUsIHN0eWxlU3BlYykgewogICAgICAgICAgaWYgKHN0eWxlU3BlYyA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIHN0eWxlU3BlYyA9IHY4OwogICAgICAgICAgdmFyIHMgPSBzdHlsZTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgcyA9IHJlYWRTdHlsZShzKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZXR1cm4gW2VdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHZhbGlkYXRlU3R5bGVNaW4ocywgc3R5bGVTcGVjKTsKICAgICAgfQoKICAgICAgdmFyIFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04gPSA4OwogICAgICB2YXIgTUFYX1NPVVJDRVNfSU5fU1RZTEUgPSAxNTsKICAgICAgZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSwgcmVnZXgpIHsKICAgICAgICAgIGlmICghdmFsdWUgfHwgZ2V0VHlwZSh2YWx1ZSkgIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gISF2YWx1ZS5tYXRjaChyZWdleCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0U291cmNlQ291bnQoc291cmNlKSB7CiAgICAgICAgICBpZiAoc291cmNlLnVybCkgewogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UudXJsLnNwbGl0KCcsJykubGVuZ3RoOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRBbGxvd2VkS2V5RXJyb3JzKG9iaiwga2V5cywgcGF0aCkgewogICAgICAgICAgdmFyIGFsbG93ZWQgPSBuZXcgU2V0KGtleXMpOwogICAgICAgICAgdmFyIGVycm9ycyA9IFtdOwogICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7CiAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkLmhhcyhrKSkgewogICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHBhdGggPyBwYXRoICsgJy4nICsgayA6IG51bGw7CiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IocHJvcCwgb2JqW2tdLCAnVW5zdXBwb3J0ZWQgcHJvcGVydHkgIicgKyBrICsgJyInKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gZXJyb3JzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdldFNvdXJjZUVycm9ycyhzb3VyY2UsIGkpIHsKICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTsKICAgICAgICAgIHZhciBzb3VyY2VLZXlzID0gWwogICAgICAgICAgICAgICd0eXBlJywKICAgICAgICAgICAgICAndXJsJywKICAgICAgICAgICAgICAndGlsZVNpemUnCiAgICAgICAgICBdOwogICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBnZXRBbGxvd2VkS2V5RXJyb3JzKHNvdXJjZSwgc291cmNlS2V5cywgJ3NvdXJjZScpKTsKICAgICAgICAgIHZhciBzb3VyY2VVcmxQYXR0ZXJuID0gL15tYXBib3g6XC9cLyhbXi9dKikkLzsKICAgICAgICAgIGlmICghaXNWYWxpZChzb3VyY2UudXJsLCBzb3VyY2VVcmxQYXR0ZXJuKSkgewogICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3NvdXJjZXNbJyArIGkgKyAnXScsIHNvdXJjZS51cmwsICdTb3VyY2UgdXJsIG11c3QgYmUgYSB2YWxpZCBNYXBib3ggdGlsZXNldCB1cmwnKSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZXJyb3JzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdldFNvdXJjZXNFcnJvcnMoc291cmNlcykgewogICAgICAgICAgdmFyIGVycm9ycyA9IFtdOwogICAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZXMpLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHsKICAgICAgICAgICAgICB2YXIgc291cmNlRXJyb3JzID0gZ2V0U291cmNlRXJyb3JzKHNvdXJjZXNbc10sIGkpOwogICAgICAgICAgICAgIGlmICghc291cmNlRXJyb3JzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICBjb3VudCA9IGNvdW50ICsgZ2V0U291cmNlQ291bnQoc291cmNlc1tzXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgc291cmNlRXJyb3JzKTsKICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKGNvdW50ID4gTUFYX1NPVVJDRVNfSU5fU1RZTEUpIHsKICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCdzb3VyY2VzJywgbnVsbCwgJ1N0eWxlcyBtdXN0IGNvbnRhaW4gJyArIE1BWF9TT1VSQ0VTX0lOX1NUWUxFICsgJyBvciBmZXdlciBzb3VyY2VzJykpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGVycm9yczsKICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRSb290RXJyb3JzKHN0eWxlLCBzcGVjS2V5cykgewogICAgICAgICAgdmFyIGVycm9ycyA9IFtdOwogICAgICAgICAgdmFyIG9wdGlvbmFsUm9vdFByb3BlcnRpZXMgPSBbCiAgICAgICAgICAgICAgJ293bmVyJywKICAgICAgICAgICAgICAnaWQnLAogICAgICAgICAgICAgICdjYWNoZUNvbnRyb2wnLAogICAgICAgICAgICAgICdkcmFmdCcsCiAgICAgICAgICAgICAgJ2NyZWF0ZWQnLAogICAgICAgICAgICAgICdtb2RpZmllZCcsCiAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknCiAgICAgICAgICBdOwogICAgICAgICAgdmFyIGFsbG93ZWRLZXlFcnJvcnMgPSBnZXRBbGxvd2VkS2V5RXJyb3JzKHN0eWxlLCBzcGVjS2V5cy5jb25jYXQob3B0aW9uYWxSb290UHJvcGVydGllcykpOwogICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBhbGxvd2VkS2V5RXJyb3JzKTsKICAgICAgICAgIGlmIChzdHlsZS52ZXJzaW9uID4gU1VQUE9SVEVEX1NQRUNfVkVSU0lPTiB8fCBzdHlsZS52ZXJzaW9uIDwgU1VQUE9SVEVEX1NQRUNfVkVSU0lPTikgewogICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3ZlcnNpb24nLCBzdHlsZS52ZXJzaW9uLCAnU3R5bGUgdmVyc2lvbiBtdXN0IGJlICcgKyBTVVBQT1JURURfU1BFQ19WRVJTSU9OKSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZ2x5cGhVcmxQYXR0ZXJuID0gL15tYXBib3g6XC9cL2ZvbnRzXC8oW14vXSopXC97Zm9udHN0YWNrfVwve3JhbmdlfS5wYmYkLzsKICAgICAgICAgIGlmICghaXNWYWxpZChzdHlsZS5nbHlwaHMsIGdseXBoVXJsUGF0dGVybikpIHsKICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCdnbHlwaHMnLCBzdHlsZS5nbHlwaHMsICdTdHlsZXMgbXVzdCByZWZlcmVuY2UgZ2x5cGhzIGhvc3RlZCBieSBNYXBib3gnKSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgc3ByaXRlVXJsUGF0dGVybiA9IC9ebWFwYm94OlwvXC9zcHJpdGVzXC8oW14vXSopXC8oW14vXSopXC8/KFteL10qKT8kLzsKICAgICAgICAgIGlmICghaXNWYWxpZChzdHlsZS5zcHJpdGUsIHNwcml0ZVVybFBhdHRlcm4pKSB7CiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignc3ByaXRlJywgc3R5bGUuc3ByaXRlLCAnU3R5bGVzIG11c3QgcmVmZXJlbmNlIHNwcml0ZXMgaG9zdGVkIGJ5IE1hcGJveCcpKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB2aXNpYmlsaXR5UGF0dGVybiA9IC9eKHB1YmxpY3xwcml2YXRlKSQvOwogICAgICAgICAgaWYgKCFpc1ZhbGlkKHN0eWxlLnZpc2liaWxpdHksIHZpc2liaWxpdHlQYXR0ZXJuKSkgewogICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Zpc2liaWxpdHknLCBzdHlsZS52aXNpYmlsaXR5LCAnU3R5bGUgdmlzaWJpbGl0eSBtdXN0IGJlIHB1YmxpYyBvciBwcml2YXRlJykpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGVycm9yczsKICAgICAgfQogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU1hcGJveEFwaVN1cHBvcnRlZChzdHlsZSkgewogICAgICAgICAgdmFyIHMgPSBzdHlsZTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgcyA9IHJlYWRTdHlsZShzKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZXR1cm4gW2VdOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlU3R5bGVNaW4ocywgdjgpLmNvbmNhdChnZXRSb290RXJyb3JzKHMsIE9iamVjdC5rZXlzKHY4LiRyb290KSkpOwogICAgICAgICAgaWYgKHMuc291cmNlcykgewogICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZ2V0U291cmNlc0Vycm9ycyhzLnNvdXJjZXMpKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBlcnJvcnM7CiAgICAgIH0KCiAgICAgIHZhciBleHByZXNzaW9uJDEgPSB7CiAgICAgICAgICBTdHlsZUV4cHJlc3Npb246IFN0eWxlRXhwcmVzc2lvbiwKICAgICAgICAgIGlzRXhwcmVzc2lvbjogaXNFeHByZXNzaW9uLAogICAgICAgICAgaXNFeHByZXNzaW9uRmlsdGVyOiBpc0V4cHJlc3Npb25GaWx0ZXIsCiAgICAgICAgICBjcmVhdGVFeHByZXNzaW9uOiBjcmVhdGVFeHByZXNzaW9uLAogICAgICAgICAgY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uOiBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24sCiAgICAgICAgICBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb246IG5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbiwKICAgICAgICAgIFpvb21Db25zdGFudEV4cHJlc3Npb246IFpvb21Db25zdGFudEV4cHJlc3Npb24sCiAgICAgICAgICBab29tRGVwZW5kZW50RXhwcmVzc2lvbjogWm9vbURlcGVuZGVudEV4cHJlc3Npb24sCiAgICAgICAgICBTdHlsZVByb3BlcnR5RnVuY3Rpb246IFN0eWxlUHJvcGVydHlGdW5jdGlvbgogICAgICB9OwogICAgICB2YXIgc3R5bGVGdW5jdGlvbiA9IHsKICAgICAgICAgIGNvbnZlcnRGdW5jdGlvbjogY29udmVydEZ1bmN0aW9uLAogICAgICAgICAgY3JlYXRlRnVuY3Rpb246IGNyZWF0ZUZ1bmN0aW9uLAogICAgICAgICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbiQxCiAgICAgIH07CiAgICAgIHZhciB2aXNpdCA9IHsKICAgICAgICAgIGVhY2hTb3VyY2U6IGVhY2hTb3VyY2UsCiAgICAgICAgICBlYWNoTGF5ZXI6IGVhY2hMYXllciwKICAgICAgICAgIGVhY2hQcm9wZXJ0eTogZWFjaFByb3BlcnR5CiAgICAgIH07CiAgICAgIHZhbGlkYXRlU3R5bGUucGFyc2VkID0gdmFsaWRhdGVTdHlsZTsKICAgICAgdmFsaWRhdGVTdHlsZS5sYXRlc3QgPSB2YWxpZGF0ZVN0eWxlOwoKICAgICAgZXhwb3J0cy5Db2xvciA9IENvbG9yOwogICAgICBleHBvcnRzLlBhcnNpbmdFcnJvciA9IFBhcnNpbmdFcnJvciQxOwogICAgICBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IFZhbGlkYXRpb25FcnJvcjsKICAgICAgZXhwb3J0cy5jb21wb3NpdGUgPSBjb21wb3NpdGU7CiAgICAgIGV4cG9ydHMuY29udmVydEZpbHRlciA9IGNvbnZlcnRGaWx0ZXIkMTsKICAgICAgZXhwb3J0cy5kZXJlZkxheWVycyA9IGRlcmVmTGF5ZXJzOwogICAgICBleHBvcnRzLmRpZmYgPSBkaWZmU3R5bGVzOwogICAgICBleHBvcnRzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uJDE7CiAgICAgIGV4cG9ydHMuZmVhdHVyZUZpbHRlciA9IGNyZWF0ZUZpbHRlcjsKICAgICAgZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7CiAgICAgIGV4cG9ydHMuZnVuY3Rpb24gPSBzdHlsZUZ1bmN0aW9uOwogICAgICBleHBvcnRzLmxhdGVzdCA9IHY4OwogICAgICBleHBvcnRzLm1pZ3JhdGUgPSBtaWdyYXRlOwogICAgICBleHBvcnRzLnY4ID0gdjg7CiAgICAgIGV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZVN0eWxlOwogICAgICBleHBvcnRzLnZhbGlkYXRlTWFwYm94QXBpU3VwcG9ydGVkID0gdmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQ7CiAgICAgIGV4cG9ydHMudmlzaXQgPSB2aXNpdDsKCiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7CgogICAgfSkpKTsKCiAgICB9KTsKCiAgICAvKioKICAgICAqIENsYXNzIGZvciB3b3JraW5nIHdpdGggTWFwYm94IHN0eWxlIGV4cHJlc3Npb25zLgogICAgICoKICAgICAqIFNlZSBodHRwczovL2RvY3MubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvc3R5bGUtc3BlYy8jZXhwcmVzc2lvbnMKICAgICAqLwogICAgY2xhc3MgRXhwcmVzc2lvbiB7CiAgICAgICAgY29uc3RydWN0b3IocGFyc2VkRXhwcmVzc2lvbikgewogICAgICAgICAgICB0aGlzLnBhcnNlZEV4cHJlc3Npb24gPSBwYXJzZWRFeHByZXNzaW9uOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBQYXJzZSBhIE1hcGJveCBzdHlsZSBleHByZXNzaW9uLgogICAgICAgICAqCiAgICAgICAgICogUGFzcyBhbiBleHBlY3RlZCB0eXBlIHRvIGdldCB0aWdoZXIgZXJyb3IgY2hlY2tpbmcgYW5kIG1vcmUgcHJlY2lzZSB0eXBlcy4KICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgcGFyc2UoZXhwciwgZXhwZWN0ZWRUeXBlKSB7CiAgICAgICAgICAgIC8vIEZvciBkZXRhaWxzIG9uIHVzZSBvZiB0aGlzIHByaXZhdGUgQVBJIGFuZCBwbGFucyB0byBwdWJsaWNpemUgaXQsIHNlZQogICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvNzY3MAogICAgICAgICAgICBsZXQgcGFyc2VSZXN1bHQ7CiAgICAgICAgICAgIGlmIChleHBlY3RlZFR5cGUpIHsKICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0ID0gc3R5bGVTcGVjLmV4cHJlc3Npb24uY3JlYXRlRXhwcmVzc2lvbihleHByLCB7CiAgICAgICAgICAgICAgICAgICAgdHlwZTogZXhwZWN0ZWRUeXBlLAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQucmVzdWx0ID09PSAnc3VjY2VzcycpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24ocGFyc2VSZXN1bHQudmFsdWUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQgPSBzdHlsZVNwZWMuZXhwcmVzc2lvbi5jcmVhdGVFeHByZXNzaW9uKGV4cHIpOwogICAgICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0LnJlc3VsdCA9PT0gJ3N1Y2Nlc3MnKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHBhcnNlUmVzdWx0LnZhbHVlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aHJvdyBwYXJzZVJlc3VsdC52YWx1ZVswXTsKICAgICAgICB9CiAgICAgICAgZXZhbHVhdGUoZmVhdHVyZSwgY29udGV4dCA9IHsgem9vbTogMTQgfSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRFeHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQsIGZlYXR1cmUpOwogICAgICAgIH0KICAgIH0KCiAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL3RyZWUvYzM5MTBmODcwZGI0NmFiYTJhNTBkYjMxMTExNTgyNDQxMjZjYjE5YS9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2RlZmluaXRpb25zCiAgICBjb25zdCBzZXJpYWxpemVGb3JtYXR0ZWQgPSBmb3JtYXR0ZWQgPT4gewogICAgICBjb25zdCB7IHNlY3Rpb25zIH0gPSBmb3JtYXR0ZWQ7CiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddOwogICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHsKICAgICAgICBpZiAoc2VjdGlvbi5pbWFnZSkgewogICAgICAgICAgc2VyaWFsaXplZC5wdXNoKFsnaW1hZ2UnLCBzZWN0aW9uLmltYWdlLm5hbWVdKTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi50ZXh0KTsKICAgICAgICBjb25zdCBvcHRpb25zID0ge307CiAgICAgICAgaWYgKHNlY3Rpb24uZm9udFN0YWNrKSB7CiAgICAgICAgICBvcHRpb25zWyd0ZXh0LWZvbnQnXSA9IFsnbGl0ZXJhbCcsIHNlY3Rpb24uZm9udFN0YWNrLnNwbGl0KCcsJyldOwogICAgICAgIH0KICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkgewogICAgICAgICAgb3B0aW9uc1snZm9udC1zY2FsZSddID0gc2VjdGlvbi5zY2FsZTsKICAgICAgICB9CiAgICAgICAgaWYgKHNlY3Rpb24udGV4dENvbG9yKSB7CiAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBbJ3JnYmEnXS5jb25jYXQoc2VjdGlvbi50ZXh0Q29sb3IudG9BcnJheSgpKTsKICAgICAgICB9CiAgICAgICAgc2VyaWFsaXplZC5wdXNoKG9wdGlvbnMpOwogICAgICB9CiAgICAgIHJldHVybiBzZXJpYWxpemVkOwogICAgfTsKCiAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL3RyZWUvYzM5MTBmODcwZGI0NmFiYTJhNTBkYjMxMTExNTgyNDQxMjZjYjE5YS9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2RlZmluaXRpb25zCiAgICBjb25zdCBzZXJpYWxpemVJY29uSW1hZ2UgPSByZXNvbHZlZEltYWdlID0+IHsKICAgICAgcmV0dXJuIFsnaW1hZ2UnLCByZXNvbHZlZEltYWdlLm5hbWVdOwogICAgfTsKCiAgICBjb25zdCBldmFsdWF0ZUV4cHJlc3Npb24gPSAoewogICAgICBsYXllclR5cGUsCiAgICAgIHByb3BlcnR5VHlwZSwKICAgICAgcHJvcGVydHlJZCwKICAgICAgcHJvcGVydGllcywKICAgICAgdmFsdWUsCiAgICAgIHpvb20sCiAgICB9KSA9PiB7CiAgICAgIGNvbnN0IGluaXRpYWxLZXkgPSBgJHtwcm9wZXJ0eVR5cGV9XyR7bGF5ZXJUeXBlfWA7CiAgICAgIGNvbnN0IHByb3BlcnR5U3BlYyA9IHY4W2luaXRpYWxLZXldW3Byb3BlcnR5SWRdOwogICAgICBjb25zdCBmZWF0dXJlID0gewogICAgICAgIHR5cGU6ICdGZWF0dXJlJywKICAgICAgICBwcm9wZXJ0aWVzLAogICAgICAgIGdlb21ldHJ5OiBudWxsLAogICAgICB9OwoKICAgICAgbGV0IG5leHRWYWx1ZSA9IEV4cHJlc3Npb24ucGFyc2UodmFsdWUsIHByb3BlcnR5U3BlYy50eXBlKS5ldmFsdWF0ZSgKICAgICAgICBmZWF0dXJlLAogICAgICAgIHpvb20gJiYgewogICAgICAgICAgem9vbSwKICAgICAgICB9CiAgICAgICk7CgogICAgICBpZiAoCiAgICAgICAgcHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicgJiYKICAgICAgICBuZXh0VmFsdWUgJiYKICAgICAgICBuZXh0VmFsdWUuaGFzT3duUHJvcGVydHkoJ3InKQogICAgICApIHsKICAgICAgICBuZXh0VmFsdWUgPSBgcmdiYSgke01hdGgucm91bmQoMjU1ICogbmV4dFZhbHVlLnIpfSwgJHtNYXRoLnJvdW5kKAogICAgICAyNTUgKiBuZXh0VmFsdWUuZwogICAgKX0sICR7TWF0aC5yb3VuZCgyNTUgKiBuZXh0VmFsdWUuYil9LCAke25leHRWYWx1ZS5hfSlgOwogICAgICB9CgogICAgICBpZiAoCiAgICAgICAgcHJvcGVydHlJZCA9PT0gJ2ljb24taW1hZ2UnICYmCiAgICAgICAgbmV4dFZhbHVlICYmCiAgICAgICAgbmV4dFZhbHVlLmhhc093blByb3BlcnR5KCduYW1lJykKICAgICAgKSB7CiAgICAgICAgbmV4dFZhbHVlID0gc2VyaWFsaXplSWNvbkltYWdlKG5leHRWYWx1ZSk7CiAgICAgIH0KICAgICAgaWYgKAogICAgICAgIHByb3BlcnR5SWQgPT09ICd0ZXh0LWZpZWxkJyAmJgogICAgICAgIG5leHRWYWx1ZSAmJgogICAgICAgIG5leHRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnc2VjdGlvbnMnKQogICAgICApIHsKICAgICAgICBuZXh0VmFsdWUgPSBzZXJpYWxpemVGb3JtYXR0ZWQobmV4dFZhbHVlKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5leHRWYWx1ZTsKICAgIH07CgogICAgY29uc3QgeyBpc0V4cHJlc3Npb24gfSA9IGV4cHJlc3Npb247CgogICAgbGV0IGNvbWJvVmFsdWVMaW1pdDsKICAgIHByb3BlcnR5VmFsdWVDb21ib0xpbWl0U3RvcmUuc3Vic2NyaWJlKHZhbHVlID0+IHsKICAgICAgY29tYm9WYWx1ZUxpbWl0ID0gdmFsdWU7CiAgICB9KTsKCiAgICBjb25zdCBGQUxMQkFDS1MgPSB7CiAgICAgIHN0cmluZzogJ0ZBTExCQUNLJywKICAgICAgbnVtYmVyOiAtMTAwMCwKICAgICAgYXJyYXk6IFtdLAogICAgICBvYmplY3Q6IHt9LAogICAgICBib29sZWFuOiBmYWxzZSwKICAgIH07CgogICAgY29uc3QgbWVyZ2VXaXRoQ3VzdG9taXplciA9IChvYmpWYWx1ZSwgc3JjVmFsdWUpID0+IHsKICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqVmFsdWUpKSB7CiAgICAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7CiAgICAgIH0KICAgIH07CgogICAgLy8gTWF0aCBvcGVyYXRvcnMgZnJvbSB0aGUgc3R5bGUgc3BlYwogICAgY29uc3QgbWF0aE9wZXJhdG9ycyA9IE9iamVjdC5lbnRyaWVzKAogICAgICB2OD8uZXhwcmVzc2lvbl9uYW1lPy52YWx1ZXMgPz8ge30KICAgICk/LnJlZHVjZSgoYWNjLCBrdikgPT4gewogICAgICBjb25zdCBbaywgdl0gPSBrdjsKICAgICAgaWYgKHY/Lmdyb3VwID09PSAnTWF0aCcpIHsKICAgICAgICBhY2MucHVzaChrKTsKICAgICAgfQogICAgICByZXR1cm4gYWNjOwogICAgfSwgW10pOwoKICAgIGNvbnN0IGlzSGFuZGxlZENvbmRpdGlvbmFsID0gdmFsdWUgPT4gewogICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gZmFsc2U7CiAgICAgIGlmIChtYXRoT3BlcmF0b3JzLmluY2x1ZGVzKHZhbHVlWzBdKSkgewogICAgICAgIHJldHVybiB2YWx1ZS5zb21lKHYgPT4gaXNIYW5kbGVkQ29uZGl0aW9uYWwodikpOwogICAgICB9CiAgICAgIHJldHVybiB2YWx1ZVswXSA9PT0gJ21hdGNoJyB8fCB2YWx1ZVswXSA9PT0gJ2Nhc2UnOwogICAgfTsKCiAgICBjb25zdCBpc0hhbmRsZWRTY2FsZSA9IHZhbHVlID0+IHsKICAgICAgY29uc3QgaXNJbnRlcnBvbGF0ZSA9CiAgICAgICAgdmFsdWVbMF0gPT09ICdpbnRlcnBvbGF0ZScgJiYgdmFsdWU/LlsyXT8uWzBdID09PSAnem9vbSc7CiAgICAgIGNvbnN0IGlzU3RlcCA9IHZhbHVlWzBdID09PSAnc3RlcCcgJiYgdmFsdWU/LlsxXT8uWzBdID09PSAnem9vbSc7CiAgICAgIGNvbnN0IGlzU2NhbGUgPSBpc0ludGVycG9sYXRlIHx8IGlzU3RlcDsKICAgICAgcmV0dXJuIGlzU2NhbGUgJiYgdmFsdWUuc29tZSh2ID0+IGlzSGFuZGxlZENvbmRpdGlvbmFsKHYpKTsKICAgIH07CgogICAgLy8gUGFyc2VzIGEgc2NhbGUgZXhwcmVzc2lvbiBhbmQgcmV0dXJucyBhbGwgcHJvcGVydGllcyBpbiBuZXN0ZWQgY29uZGl0aW9uYWxzIGFsb25nIHdpdGggcmVsZXZhbnQgem9vbXMKICAgIGNvbnN0IHBhcnNlU2NhbGVFeHByZXNzaW9uID0gdmFsdWUgPT4gewogICAgICBjb25zdCBbc2NhbGVUeXBlXSA9IHZhbHVlOwogICAgICBsZXQgaW5wdXRPdXRwdXRzID0gW107CiAgICAgIGxldCB6b29tcyA9IFtdOwogICAgICBsZXQgc2NhbGVPdXRwdXRzID0gW107CiAgICAgIGxldCBvdXRwdXRzID0gW107CiAgICAgIGxldCBwcm9wZXJ0aWVzID0ge307CgogICAgICAvLyBQdWxsIG91dCBvdXRwdXRzIGFuZCB6b29tcyBmcm9tIGludGVycG9sYXRpb24KICAgICAgc3dpdGNoIChzY2FsZVR5cGUpIHsKICAgICAgICBjYXNlICdpbnRlcnBvbGF0ZSc6CiAgICAgICAgY2FzZSAnaW50ZXJwb2xhdGUtaGNsJzoKICAgICAgICBjYXNlICdpbnRlcnBvbGF0ZS1sYWInOiB7CiAgICAgICAgICBpbnB1dE91dHB1dHMgPSB2YWx1ZS5zbGljZSgzKTsKICAgICAgICAgIGlucHV0T3V0cHV0cy5mb3JFYWNoKCh2YWwsIGkpID0+CiAgICAgICAgICAgIGkgJSAyICE9PSAwID8gc2NhbGVPdXRwdXRzLnB1c2godmFsKSA6IHpvb21zLnB1c2godmFsKQogICAgICAgICAgKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBjYXNlICdzdGVwJzogewogICAgICAgICAgaW5wdXRPdXRwdXRzID0gdmFsdWUuc2xpY2UoMik7CiAgICAgICAgICBpbnB1dE91dHB1dHMuZm9yRWFjaCgodmFsLCBpKSA9PgogICAgICAgICAgICBpICUgMiA9PT0gMCA/IHNjYWxlT3V0cHV0cy5wdXNoKHZhbCkgOiB6b29tcy5wdXNoKHZhbCkKICAgICAgICAgICk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgICAgZm9yIChjb25zdCBzY2FsZU91dHB1dCBvZiBzY2FsZU91dHB1dHMpIHsKICAgICAgICBpZiAoaXNIYW5kbGVkQ29uZGl0aW9uYWwoc2NhbGVPdXRwdXQpKSB7CiAgICAgICAgICBjb25zdCB7IG91dHB1dHM6IHNjYWxlT3V0cHV0cywgcHJvcGVydGllczogc2NhbGVQcm9wZXJ0aWVzIH0gPQogICAgICAgICAgICBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihzY2FsZU91dHB1dCk7CiAgICAgICAgICBvdXRwdXRzID0gWy4uLm5ldyBTZXQob3V0cHV0cy5jb25jYXQoc2NhbGVPdXRwdXRzKSldOwogICAgICAgICAgcHJvcGVydGllcyA9IGxvZGFzaF9tZXJnZXdpdGgocHJvcGVydGllcywgc2NhbGVQcm9wZXJ0aWVzLCBtZXJnZVdpdGhDdXN0b21pemVyKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgem9vbXMsIG91dHB1dHMsIHByb3BlcnRpZXMgfTsKICAgIH07CgogICAgLy8gVE9ETyB0aGlzIG5lZWRzIHRvIGJlIGEgbGl0dGxlIG1vcmUgYWR2YW5jZWQKICAgIC8vIGFzc3VtZXMgb25lIHByb3BlcnR5IGZvciBub3cKICAgIGNvbnN0IHBhcnNlQ2FzZUNvbmRpdGlvbiA9IHZhbHVlID0+IHsKICAgICAgY29uc3QgZmxhdFZhbHVlID0gdmFsdWUuZmxhdChJbmZpbml0eSk7CiAgICAgIGNvbnN0IGxvb2t1cHMgPSBbJ2dldCcsICdoYXMnLCAnaW4nXTsKICAgICAgY29uc3QgcHJvcGVydGllcyA9IGZsYXRWYWx1ZS5maWx0ZXIoCiAgICAgICAgKGl0ZW0sIGkpID0+IGkgIT09IDAgJiYgbG9va3Vwcy5pbmNsdWRlcyhmbGF0VmFsdWVbaSAtIDFdKQogICAgICApOwogICAgICAvLyBKdXN0IGZpcnN0IG9uZSBmb3Igbm93IGFzc3VtaW5nIDEKICAgICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzWzBdOwogICAgICBsZXQgaW5wdXRzID0gZmxhdFZhbHVlLmZpbHRlcigKICAgICAgICBpdGVtID0+ICFwcm9wZXJ0aWVzLmluY2x1ZGVzKGl0ZW0pICYmICFpc0V4cHJlc3Npb24oW2l0ZW1dKQogICAgICApOwogICAgICAvLyBUaGlzIGlzIGEgaGFjayBmb3IgcmVmIGxlbmd0aCB3ZSBzaG91bGQgaGFuZGxlIGJldHRlcgogICAgICBpZiAoZmxhdFZhbHVlLmluY2x1ZGVzKCdsZW5ndGgnKSAmJiBwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkgewogICAgICAgIGlucHV0cyA9IGlucHV0cy5tYXAobnVtID0+IGAke251bX1gLnJlcGVhdChudW0pKTsKICAgICAgfQogICAgICByZXR1cm4geyBbcHJvcGVydHldOiBpbnB1dHMgfTsKICAgIH07CgogICAgLy8gUmV0dXJucyBwcm9wZXJ0aWVzIGFuZCBvdXRwdXRzIG9mIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24KICAgIGNvbnN0IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gdmFsdWUgPT4gewogICAgICBjb25zdCBleHByZXNzaW9uVHlwZSA9IHZhbHVlWzBdOwogICAgICBsZXQgaW5wdXRPdXRwdXRzID0gW107CiAgICAgIGxldCBpbnB1dHMgPSBbXTsKICAgICAgbGV0IG91dHB1dHMgPSBbXTsKICAgICAgbGV0IHByb3BlcnRpZXMgPSB7fTsKCiAgICAgIHN3aXRjaCAoZXhwcmVzc2lvblR5cGUpIHsKICAgICAgICBjYXNlICdjYXNlJzogewogICAgICAgICAgaW5wdXRPdXRwdXRzID0gdmFsdWUuc2xpY2UoMSk7CiAgICAgICAgICBsZXQgY2FzZUlucHV0cyA9IFtdOwogICAgICAgICAgY29uc3QgZmFsbGJhY2sgPSBpbnB1dE91dHB1dHMucG9wKCk7CiAgICAgICAgICBpbnB1dE91dHB1dHMuZm9yRWFjaCgodmFsLCBpKSA9PgogICAgICAgICAgICBpICUgMiAhPT0gMCA/IG91dHB1dHMucHVzaCh2YWwpIDogY2FzZUlucHV0cy5wdXNoKHZhbCkKICAgICAgICAgICk7CiAgICAgICAgICBvdXRwdXRzLnB1c2goZmFsbGJhY2spOwoKICAgICAgICAgIGNhc2VJbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7CiAgICAgICAgICAgIGNvbnN0IGNhc2VQcm9wZXJ0aWVzID0gcGFyc2VDYXNlQ29uZGl0aW9uKGlucHV0KTsKICAgICAgICAgICAgaW5wdXRzID0gaW5wdXRzLmNvbmNhdChjYXNlSW5wdXRzKTsKICAgICAgICAgICAgcHJvcGVydGllcyA9IGxvZGFzaF9tZXJnZXdpdGgocHJvcGVydGllcywgY2FzZVByb3BlcnRpZXMsIG1lcmdlV2l0aEN1c3RvbWl6ZXIpOwogICAgICAgICAgfSk7CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGNhc2UgJ21hdGNoJzogewogICAgICAgICAgaW5wdXRPdXRwdXRzID0gdmFsdWUuc2xpY2UoMik7CiAgICAgICAgICBjb25zdCBmYWxsYmFjayA9IGlucHV0T3V0cHV0cy5wb3AoKTsKICAgICAgICAgIGlucHV0T3V0cHV0cy5mb3JFYWNoKCh2YWwsIGkpID0+CiAgICAgICAgICAgIGkgJSAyICE9PSAwID8gb3V0cHV0cy5wdXNoKHZhbCkgOiBpbnB1dHMucHVzaCh2YWwpCiAgICAgICAgICApOwogICAgICAgICAgb3V0cHV0cy5wdXNoKGZhbGxiYWNrKTsKCiAgICAgICAgICBjb25zdCBmbGF0Q29uZGl0aW9uID0gdmFsdWVbMV0uZmxhdChJbmZpbml0eSk7CiAgICAgICAgICAvLyBUT0RPIHRoaXMgaXMgbmFpdmUgaGFuZGxpbmcgdG8gZ2V0IGEgcHJvcGVydHkgc2ltaWxhciB0byBvbiBjYXNlIGV4cHJlc3Npb25zCiAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGZsYXRDb25kaXRpb24uZmlsdGVyKHYgPT4gIWlzRXhwcmVzc2lvbihbdl0pKVswXTsKCiAgICAgICAgICAvLyBUaGlzIGlzIGEgaGFjayBmb3IgcmVmIGxlbmd0aCB3ZSBzaG91bGQgaGFuZGxlIGJldHRlcgogICAgICAgICAgaWYgKGZsYXRDb25kaXRpb24uaW5jbHVkZXMoJ2xlbmd0aCcpKSB7CiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0cy5tYXAobnVtID0+IGAke251bX1gLnJlcGVhdChudW0pKTsKICAgICAgICAgIH0KCiAgICAgICAgICBwcm9wZXJ0aWVzID0geyBbcHJvcGVydHldOiBpbnB1dHMuZmxhdChJbmZpbml0eSkgfTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQoKICAgICAgLy8gSWYgdGhlcmUncyBhIG1hdGggb3BlcmF0aW9uLCB0cmVhdCBhbGwgb3RoZXIgdmFsdWVzIGxpa2Ugb3V0cHV0cwogICAgICAvLyBmb3IgcHVsbGluZyBwcm9wZXJ0aWVzIG91dCBvZiByZWN1cnNpb24KICAgICAgaWYgKG1hdGhPcGVyYXRvcnMuaW5jbHVkZXMoZXhwcmVzc2lvblR5cGUpKSB7CiAgICAgICAgb3V0cHV0cyA9IHZhbHVlLmZpbHRlcihpc0hhbmRsZWRDb25kaXRpb25hbCk7CiAgICAgIH0KCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbaV07CiAgICAgICAgaWYgKGlzSGFuZGxlZENvbmRpdGlvbmFsKG91dHB1dCkpIHsKICAgICAgICAgIGNvbnN0IHsKICAgICAgICAgICAgaW5wdXRzOiBuZXN0ZWRJbnB1dHMsCiAgICAgICAgICAgIG91dHB1dHM6IG5lc3RlZE91dHB1dHMsCiAgICAgICAgICAgIHByb3BlcnRpZXM6IG5lc3RlZFByb3BlcnRpZXMsCiAgICAgICAgICB9ID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24ob3V0cHV0KTsKCiAgICAgICAgICBvdXRwdXRzLnNwbGljZShpLCAxLCAuLi5uZXN0ZWRPdXRwdXRzKTsKICAgICAgICAgIGlucHV0cyA9IGlucHV0cy5jb25jYXQobmVzdGVkSW5wdXRzKTsKICAgICAgICAgIHByb3BlcnRpZXMgPSBsb2Rhc2hfbWVyZ2V3aXRoKHByb3BlcnRpZXMsIG5lc3RlZFByb3BlcnRpZXMsIG1lcmdlV2l0aEN1c3RvbWl6ZXIpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBpbnB1dHMsCiAgICAgICAgb3V0cHV0czogWy4uLm5ldyBTZXQob3V0cHV0cyldLAogICAgICAgIHByb3BlcnRpZXMsCiAgICAgIH07CiAgICB9OwoKICAgIC8vIEdldHMgdGhlIHJlZmVyZW5jZWQgZGF0YSBwcm9wZXJ0aWVzIGFuZCByZWZlcmVuY2VkIHZhbHVlcyBmcm9tIGV4cHJlc3Npb25zCiAgICBjb25zdCBnZXRQcm9wZXJ0eVZhbHVlcyA9IHZhbHVlID0+IHsKICAgICAgbGV0IHpvb21zID0gW107CiAgICAgIGxldCBwcm9wZXJ0aWVzID0ge307CiAgICAgIGlmIChpc0hhbmRsZWRTY2FsZSh2YWx1ZSkpIHsKICAgICAgICAoeyB6b29tcywgcHJvcGVydGllcyB9ID0gcGFyc2VTY2FsZUV4cHJlc3Npb24odmFsdWUpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAoeyBwcm9wZXJ0aWVzIH0gPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2YWx1ZSkpOwogICAgICB9CgogICAgICAvLyBUT0RPIGNhbiB3ZSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZT8gU2V0cyBmYWxsYmFjayBiYXNlZCBvbiB0eXBlIG9mIHZhbHVlCiAgICAgIC8vIElmIHRoaXMgY2F1c2VzIHByb2JsZW1zLCB3ZSBtYXkgYmUgYmV0dGVyIHdpdGhvdXQgZmFsbGJhY2tzCiAgICAgIC8vIE5vdGU6IGZhbGxiYWNrcyBkZWZpbmVkIGFyZSBfbGlrZWx5XyBmYWxsYmFjayBwcm9wZXJ0eSB2YWx1ZXMsIGJ1dCBub3QgZ3VhcmFudGVlZCBiYXNlZCBvbiBleHByZXNzaW9uCiAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5yZWR1Y2UoKGFjYywgcHJvcCkgPT4gewogICAgICAgIGxldCB2YWx1ZVR5cGUgPSB0eXBlb2YgcHJvcGVydGllc1twcm9wXVswXTsKICAgICAgICBpZiAodmFsdWVUeXBlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHZhbHVlVHlwZSkpIHsKICAgICAgICAgIHZhbHVlVHlwZSA9ICdhcnJheSc7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbHVlcyA9CiAgICAgICAgICB2YWx1ZVR5cGUgIT09IHVuZGVmaW5lZAogICAgICAgICAgICA/IHByb3BlcnRpZXNbcHJvcF0uY29uY2F0KFtGQUxMQkFDS1NbdmFsdWVUeXBlXV0pCiAgICAgICAgICAgIDogcHJvcGVydGllc1twcm9wXTsKICAgICAgICBhY2NbcHJvcF0gPSBbLi4ubmV3IFNldCh2YWx1ZXMpXTsKICAgICAgICByZXR1cm4gYWNjOwogICAgICB9LCB7fSk7CgogICAgICByZXR1cm4gewogICAgICAgIHByb3BlcnR5VmFsdWVzOiBwcm9wZXJ0aWVzLAogICAgICAgIHpvb21zLAogICAgICB9OwogICAgfTsKCiAgICBjb25zdCBnZXRFeHBhbmRhYmxlUHJvcGVydGllcyA9IGxheWVyID0+IHsKICAgICAgcmV0dXJuIFsncGFpbnQnLCAnbGF5b3V0J10KICAgICAgICAubWFwKHR5cGUgPT4gewogICAgICAgICAgaWYgKCFsYXllclt0eXBlXSkgcmV0dXJuIFtdOwogICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGxheWVyW3R5cGVdKQogICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHsKICAgICAgICAgICAgICBpZiAoaXNIYW5kbGVkQ29uZGl0aW9uYWwodmFsdWUpKSByZXR1cm4geyB0eXBlLCBrZXksIHZhbHVlIH07CiAgICAgICAgICAgICAgaWYgKGlzSGFuZGxlZFNjYWxlKHZhbHVlKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZSwga2V5LCB2YWx1ZSB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYpOwogICAgICAgIH0pCiAgICAgICAgLmZpbHRlcih2ID0+IHYubGVuZ3RoKQogICAgICAgIC5yZWR1Y2UoKGFnZywgY3VycmVudCkgPT4gYWdnLmNvbmNhdChjdXJyZW50KSwgW10pCiAgICAgICAgLm1hcCh2ID0+IHsKICAgICAgICAgIGNvbnN0IHsgcHJvcGVydHlWYWx1ZXMsIHpvb21zIH0gPSBnZXRQcm9wZXJ0eVZhbHVlcyh2LnZhbHVlKTsKICAgICAgICAgIHJldHVybiB7IC4uLnYsIHByb3BlcnRpZXM6IHByb3BlcnR5VmFsdWVzLCB6b29tcyB9OwogICAgICAgIH0pOwogICAgfTsKCiAgICAvLyBSZXR1cm5zIGFuIGV4cHJlc3Npb24gd2l0aCBub24tY29uZGl0aW9uYWwgYGdldGAgZXhwcmVzc2lvbnMgcmVwbGFjZWQgYnkgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGFzIGEgc3RyaW5nCiAgICAvLyBUaGUgcHJvcGVydHkgbGlzdCBjb250YWlucyBhbGwgZ2V0IGV4cHJlc3Npb25zIHRoYXQgYXJlIHJlbGV2YW50IHRvIHRoZSBjb25kaXRpb25zCiAgICBjb25zdCByZXBsYWNlSW50ZXJuYWxHZXRzID0gKHZhbHVlLCBwcm9wZXJ0eUxpc3QpID0+IHsKICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlOwogICAgICBpZiAodmFsdWVbMF0gPT09ICdnZXQnICYmICFwcm9wZXJ0eUxpc3QuaW5jbHVkZXModmFsdWVbMV0pKSByZXR1cm4gdmFsdWVbMV07CiAgICAgIHJldHVybiB2YWx1ZS5tYXAodiA9PiByZXBsYWNlSW50ZXJuYWxHZXRzKHYsIHByb3BlcnR5TGlzdCkpOwogICAgfTsKCiAgICAvLyBDcmVhdGVzIG5ldyBleHByZXNzaW9uIGZvciBleHBhbmRlZCBsYXllciBiYXNlZCBvbiB0aGUgcHJvcGVydGllcyBnaXZlbgogICAgY29uc3QgZXZhbHVhdGVFeHByZXNzaW9uRm9yUHJvcGVydGllcyA9ICh7CiAgICAgIGxheWVyVHlwZSwKICAgICAgcGFpbnRPckxheW91dCwKICAgICAgcHJvcGVydHlJZCwKICAgICAgdmFsdWUsCiAgICAgIHByb3BlcnRpZXMsCiAgICAgIHpvb20sCiAgICB9KSA9PiB7CiAgICAgIGlmIChwcm9wZXJ0eUlkID09PSAndGV4dC1maWVsZCcpIHsKICAgICAgICB2YWx1ZSA9IHJlcGxhY2VJbnRlcm5hbEdldHModmFsdWUsIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKTsKICAgICAgfQogICAgICBjb25zdCBldmFsdWF0ZWQgPSBldmFsdWF0ZUV4cHJlc3Npb24oewogICAgICAgIGxheWVyVHlwZSwKICAgICAgICBwcm9wZXJ0eVR5cGU6IHBhaW50T3JMYXlvdXQsCiAgICAgICAgcHJvcGVydHlJZCwKICAgICAgICBwcm9wZXJ0aWVzLAogICAgICAgIHZhbHVlLAogICAgICAgIHpvb20sCiAgICAgIH0pOwogICAgICByZXR1cm4gZXZhbHVhdGVkOwogICAgfTsKCiAgICAvLyBDcmVhdGVzIG5ldyB6b29tIGJhc2VkIGV4cHJlc3Npb24gZm9yIGV4cGFuZGVkIGxheWVyIGJhc2VkIG9uIHRoZSBwcm9wZXJ0aWVzIGdpdmVuCiAgICAvLyBTY2FsZSBleHByZXNzaW9ucyBhcmUgYWx3YXlzIG9uIHRoZSBvdXRlcm1vc3QgZXhwcmVzc2lvbgogICAgY29uc3QgY3JlYXRlRXZhbHVhdGVkWm9vbUV4cHJlc3Npb24gPSAoCiAgICAgIHpvb21zLAogICAgICB7IGxheWVyVHlwZSwgcGFpbnRPckxheW91dCwgcHJvcGVydHlJZCwgdmFsdWUsIHByb3BlcnRpZXMgfQogICAgKSA9PiB7CiAgICAgIGNvbnN0IGluaXRpYWxLZXkgPSBgJHtwYWludE9yTGF5b3V0fV8ke2xheWVyVHlwZX1gOwogICAgICBjb25zdCBwcm9wZXJ0eVNwZWMgPSB2OFtpbml0aWFsS2V5XVtwcm9wZXJ0eUlkXTsKICAgICAgY29uc3QgYWxsb3dzSW50ZXJwb2xhdGUgPSBwcm9wZXJ0eVNwZWM/LmV4cHJlc3Npb24/LmludGVycG9sYXRlZDsKCiAgICAgIGxldCBleHByZXNzaW9uID0gW107CgogICAgICBpZiAoYWxsb3dzSW50ZXJwb2xhdGUpIHsKICAgICAgICBleHByZXNzaW9uLnB1c2goJ2ludGVycG9sYXRlJywgWydsaW5lYXInXSwgWyd6b29tJ10pOwogICAgICB9IGVsc2UgewogICAgICAgIGV4cHJlc3Npb24ucHVzaCgnc3RlcCcsIFsnem9vbSddKTsKICAgICAgICB6b29tcyA9IFswLCAuLi56b29tc107CiAgICAgIH0KCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgem9vbXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB6b29tID0gem9vbXNbaV07CiAgICAgICAgbGV0IGV2YWx1YXRlZEV4cHJlc3Npb24gPSBldmFsdWF0ZUV4cHJlc3Npb25Gb3JQcm9wZXJ0aWVzKHsKICAgICAgICAgIGxheWVyVHlwZSwKICAgICAgICAgIHBhaW50T3JMYXlvdXQsCiAgICAgICAgICBwcm9wZXJ0eUlkLAogICAgICAgICAgdmFsdWUsCiAgICAgICAgICBwcm9wZXJ0aWVzLAogICAgICAgICAgLy8gRm9yIGV2YWx1YXRpb24sIGEgem9vbSBvZiB6ZXJvIHJldHVybnMgbnVsbAogICAgICAgICAgLy8gVW5jbGVhciB3aHkgdGhpcyBpcwogICAgICAgICAgem9vbTogem9vbSA9PT0gMCA/IDAuMSA6IHpvb20sCiAgICAgICAgfSk7CgogICAgICAgIC8vIFRoZSBldmFsdWF0ZWQgZXhwcmVzc2lvbiBtYXkgY29udGFpbiBhbiBhcnJheSwgYnV0IGl0J3Mgc2FmZXIgdG8gYWx3YXlzCiAgICAgICAgLy8gd3JhcCBpbiAibGl0ZXJhbCIgc2luY2Ugd2UgYXJlIGJ1aWxkaW5nIGl0IGludG8gYSBzY2FsZSBleHByZXNzaW9uCiAgICAgICAgaWYgKAogICAgICAgICAgcHJvcGVydHlJZCA9PT0gJ3RleHQtZm9udCcgJiYKICAgICAgICAgIEFycmF5LmlzQXJyYXkoZXZhbHVhdGVkRXhwcmVzc2lvbikgJiYKICAgICAgICAgIGV2YWx1YXRlZEV4cHJlc3Npb25bMF0gIT09ICdsaXRlcmFsJwogICAgICAgICkgewogICAgICAgICAgZXZhbHVhdGVkRXhwcmVzc2lvbiA9IFsnbGl0ZXJhbCcsIGV2YWx1YXRlZEV4cHJlc3Npb25dOwogICAgICAgIH0KCiAgICAgICAgaWYgKCFhbGxvd3NJbnRlcnBvbGF0ZSAmJiB6b29tID09PSAwICYmIGkgPT09IDApIHsKICAgICAgICAgIGV4cHJlc3Npb24ucHVzaChldmFsdWF0ZWRFeHByZXNzaW9uKTsKICAgICAgICB9CiAgICAgICAgZXhwcmVzc2lvbi5wdXNoKHpvb20sIGV2YWx1YXRlZEV4cHJlc3Npb24pOwogICAgICB9CgogICAgICByZXR1cm4gZXhwcmVzc2lvbjsKICAgIH07CgogICAgLy8gQ3JlYXRlcyBhIGxheWVyIGZvciBlYWNoIGNvbWJpbmF0aW9uIG9mIHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiBwcmV2aW91cyBleGlzdGluZyBsYXllcgogICAgY29uc3QgZXhwYW5kTGF5ZXIgPSBsYXllciA9PiB7CiAgICAgIGNvbnN0IGV4cGFuZGVkUHJvcGVydGllcyA9IGdldEV4cGFuZGFibGVQcm9wZXJ0aWVzKGxheWVyKTsKICAgICAgaWYgKCFleHBhbmRlZFByb3BlcnRpZXMubGVuZ3RoKQogICAgICAgIHJldHVybiB7IGV4cGFuZGVkTGF5ZXJzOiBbbGF5ZXJdLCBjb21ib0xpbWl0SGl0OiBmYWxzZSB9OwogICAgICBsZXQgem9vbXMgPSBbXTsKICAgICAgbGV0IHByb3BlcnR5UGF0aHMgPSBbXTsKICAgICAgbGV0IHByb3BlcnRpZXMgPSB7fTsKCiAgICAgIGV4cGFuZGVkUHJvcGVydGllcy5mb3JFYWNoKHByb3BlcnR5ID0+IHsKICAgICAgICBsZXQgewogICAgICAgICAgdHlwZTogcHJvcGVydHlUeXBlLAogICAgICAgICAga2V5OiBwcm9wZXJ0eUlkLAogICAgICAgICAgcHJvcGVydGllczogcHJvcGVydHlEYXRhLAogICAgICAgICAgdmFsdWU6IHByb3BlcnR5VmFsdWUsCiAgICAgICAgICB6b29tczogcHJvcGVydHlab29tcywKICAgICAgICB9ID0gcHJvcGVydHk7CgogICAgICAgIHByb3BlcnR5UGF0aHMucHVzaChbcHJvcGVydHlUeXBlLCBwcm9wZXJ0eUlkXSk7CiAgICAgICAgcHJvcGVydGllcyA9IGxvZGFzaF9tZXJnZXdpdGgocHJvcGVydGllcywgcHJvcGVydHlEYXRhLCBtZXJnZVdpdGhDdXN0b21pemVyKTsKCiAgICAgICAgLy8gQWRkIHpvb21zIDAuMSBhZnRlciBhY3R1YWwgem9vbXMgZm9yIHN0ZXAgZnVuY3Rpb25zIHNvIHRoYXQKICAgICAgICAvLyB3ZSBjYW4gc2FmZWx5IGNyZWF0ZSBpbnRlcnBvbGF0ZSBmdW5jdGlvbnMgdGhhdCBsb29rIGxpa2Ugc3RlcCBmdW5jdGlvbnMKICAgICAgICAvLyBUT0RPIHRoaXMgaXMgbmFpdmUgaGFuZGxpbmcgYW5kIGRvZXNuJ3QgYWNjb3VudCBmb3IgZXhwb25lbnRpYWwgZnVuY3Rpb25zCiAgICAgICAgaWYgKHByb3BlcnR5Wm9vbXMubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBzY2FsZVR5cGUgPSBwcm9wZXJ0eVZhbHVlWzBdOwogICAgICAgICAgaWYgKHNjYWxlVHlwZSA9PT0gJ3N0ZXAnKSB7CiAgICAgICAgICAgIHByb3BlcnR5Wm9vbXMgPSBwcm9wZXJ0eVpvb21zLnJlZHVjZSgoYWNjLCB6KSA9PiB7CiAgICAgICAgICAgICAgYWNjLnB1c2goeiwgeiArIDAuMSk7CiAgICAgICAgICAgICAgcmV0dXJuIGFjYzsKICAgICAgICAgICAgfSwgW10pOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgem9vbXMgPSBbLi4ubmV3IFNldCh6b29tcy5jb25jYXQocHJvcGVydHlab29tcykpXTsKICAgICAgfSk7CgogICAgICBsZXQgcHJvcGVydHlDb21ib3MgPSBjYXJ0ZXNpYW5fMShwcm9wZXJ0aWVzKTsKCiAgICAgIC8vIERlZHVwZSB0aGUgY29tYm9zCiAgICAgIHByb3BlcnR5Q29tYm9zID0gcHJvcGVydHlDb21ib3MucmVkdWNlKChhY2MsIGNvbWJvKSA9PiB7CiAgICAgICAgY29uc3QgaGFzQ29tYm8gPSBhY2MuZmluZChpdGVtID0+CiAgICAgICAgICBPYmplY3Qua2V5cyhpdGVtKS5ldmVyeShrID0+IGNvbWJvW2tdID09PSBpdGVtW2tdKQogICAgICAgICk7CiAgICAgICAgaWYgKCFoYXNDb21ibykgewogICAgICAgICAgYWNjLnB1c2goY29tYm8pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYWNjOwogICAgICB9LCBbXSk7CgogICAgICBjb25zdCBmdWxsQ29tYm9BbXQgPSBwcm9wZXJ0eUNvbWJvcy5sZW5ndGg7CiAgICAgIHByb3BlcnR5Q29tYm9zID0gcHJvcGVydHlDb21ib3Muc2xpY2UoMCwgY29tYm9WYWx1ZUxpbWl0KTsKICAgICAgY29uc3Qgc2xpY2VkQ29tYm9BbXQgPSBwcm9wZXJ0eUNvbWJvcy5sZW5ndGg7CgogICAgICBsZXQgbmV4dExheWVycyA9IFtdOwoKICAgICAgZm9yIChjb25zdCBjb21ibyBvZiBwcm9wZXJ0eUNvbWJvcykgewogICAgICAgIGNvbnN0IG5leHRMYXllciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGF5ZXIpKTsKCiAgICAgICAgbGV0IG5leHRJZCA9IE9iamVjdC5rZXlzKGNvbWJvKS5yZWR1Y2UoKGFjYywgcHJvcCkgPT4gewogICAgICAgICAgY29uc3QgcHJvcFZhbHVlID0KICAgICAgICAgICAgRkFMTEJBQ0tTW2NvbWJvW3Byb3BdXSAhPT0gdW5kZWZpbmVkID8gJ0ZBTExCQUNLJyA6IGNvbWJvW3Byb3BdOwogICAgICAgICAgYWNjLnB1c2goW3Byb3AsICc6ICcsIEpTT04uc3RyaW5naWZ5KHByb3BWYWx1ZSldLmpvaW4oJycpKTsKICAgICAgICAgIHJldHVybiBhY2M7CiAgICAgICAgfSwgW10pOwogICAgICAgIG5leHRJZCA9IGAke25leHRMYXllci5pZH0vJHtuZXh0SWQuam9pbignLycpfWA7CiAgICAgICAgbmV4dExheWVyLmlkID0gbmV4dElkOwogICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwcm9wZXJ0eVBhdGhzKSB7CiAgICAgICAgICBjb25zdCBbcGFpbnRPckxheW91dCwgcHJvcGVydHlJZF0gPSBwYXRoOwogICAgICAgICAgbGV0IG5leHRWYWx1ZSA9IG5leHRMYXllcltwYWludE9yTGF5b3V0XVtwcm9wZXJ0eUlkXTsKICAgICAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgICAgIGxheWVyVHlwZTogbGF5ZXIudHlwZSwKICAgICAgICAgICAgcGFpbnRPckxheW91dCwKICAgICAgICAgICAgcHJvcGVydHlJZCwKICAgICAgICAgICAgdmFsdWU6IG5leHRWYWx1ZSwKICAgICAgICAgICAgcHJvcGVydGllczogY29tYm8sCiAgICAgICAgICB9OwoKICAgICAgICAgIGlmICh6b29tcy5sZW5ndGgpIHsKICAgICAgICAgICAgbmV4dFZhbHVlID0gY3JlYXRlRXZhbHVhdGVkWm9vbUV4cHJlc3Npb24oem9vbXMsIGFyZ3MpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbmV4dFZhbHVlID0gZXZhbHVhdGVFeHByZXNzaW9uRm9yUHJvcGVydGllcyhhcmdzKTsKICAgICAgICAgIH0KICAgICAgICAgIC8vIElmIG5leHQgdmFsdWUgaXMgaW52YWxpZCwgdGhlbiByZW1vdmUgdGhlIHByb3BlcnR5CiAgICAgICAgICBpZiAobmV4dFZhbHVlID09PSBudWxsKSB7CiAgICAgICAgICAgIGRlbGV0ZSBuZXh0TGF5ZXJbcGFpbnRPckxheW91dF1bcHJvcGVydHlJZF07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBuZXh0TGF5ZXJbcGFpbnRPckxheW91dF1bcHJvcGVydHlJZF0gPSBuZXh0VmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBuZXh0TGF5ZXJzLnB1c2gobmV4dExheWVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBleHBhbmRlZExheWVyczogbmV4dExheWVycywKICAgICAgICBjb21ib0xpbWl0SGl0OiBmdWxsQ29tYm9BbXQgPiBzbGljZWRDb21ib0FtdCwKICAgICAgfTsKICAgIH07CgogICAgLyoqCiAgICAgKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+CiAgICAgKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9Im5wbSIgLW8gLi9gCiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz4KICAgICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT4KICAgICAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+CiAgICAgKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnMKICAgICAqLwoKICAgIC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciAiRnVuY3Rpb25zIiBtZXRob2RzLiAqLwogICAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJzsKCiAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi8KICAgIHZhciBOQU4gPSAwIC8gMDsKCiAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCiAgICB2YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7CgogICAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi8KICAgIHZhciByZVRyaW0gPSAvXlxzK3xccyskL2c7CgogICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi8KICAgIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7CgogICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqLwogICAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7CgogICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovCiAgICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTsKCiAgICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqLwogICAgdmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50OwoKICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovCiAgICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCQxID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsJDEgJiYgY29tbW9uanNHbG9iYWwkMS5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbCQxOwoKICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovCiAgICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjsKCiAgICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi8KICAgIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOwoKICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7CgogICAgLyoqCiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlCiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZykKICAgICAqIG9mIHZhbHVlcy4KICAgICAqLwogICAgdmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7CgogICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqLwogICAgdmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LAogICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluOwoKICAgIC8qKgogICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlCiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDIuNC4wCiAgICAgKiBAY2F0ZWdvcnkgRGF0ZQogICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7CiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7CiAgICAgKiB9LCBfLm5vdygpKTsKICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uCiAgICAgKi8KICAgIHZhciBub3cgPSBmdW5jdGlvbigpIHsKICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTsKICAgIH07CgogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGAKICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhcwogICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbAogICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uCiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUKICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQKICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQKICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgCiAgICAgKiBpbnZvY2F0aW9uLgogICAgICoKICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMKICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uCiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuCiAgICAgKgogICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkCiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuCiAgICAgKgogICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pCiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgMC4xLjAKICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuCiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC4KICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0KICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuCiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0KICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC4KICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0KICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LgogICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LgogICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTsKICAgICAqCiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy4KICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHsKICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLAogICAgICogICAndHJhaWxpbmcnOiBmYWxzZQogICAgICogfSkpOwogICAgICoKICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuCiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTsKICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTsKICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTsKICAgICAqCiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLgogICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7CiAgICAgKi8KICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHsKICAgICAgdmFyIGxhc3RBcmdzLAogICAgICAgICAgbGFzdFRoaXMsCiAgICAgICAgICBtYXhXYWl0LAogICAgICAgICAgcmVzdWx0LAogICAgICAgICAgdGltZXJJZCwKICAgICAgICAgIGxhc3RDYWxsVGltZSwKICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCwKICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSwKICAgICAgICAgIG1heGluZyA9IGZhbHNlLAogICAgICAgICAgdHJhaWxpbmcgPSB0cnVlOwoKICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7CiAgICAgIH0KICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7CiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkgewogICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZzsKICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9uczsKICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0OwogICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkgewogICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsCiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpczsKCiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDsKICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7CiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CgogICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7CiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci4KICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7CiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS4KICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpOwogICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLgogICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7CiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSwKICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSwKICAgICAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsOwoKICAgICAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0OwogICAgICB9CgogICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkgewogICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsCiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7CgogICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlCiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmcKICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuCiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHwKICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHsKICAgICAgICB2YXIgdGltZSA9IG5vdygpOwogICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHsKICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7CiAgICAgICAgfQogICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLgogICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7CiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDsKCiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlbgogICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLgogICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykgewogICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7CiAgICAgICAgfQogICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gY2FuY2VsKCkgewogICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTsKICAgICAgICB9CiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwOwogICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkOwogICAgICB9CgogICAgICBmdW5jdGlvbiBmbHVzaCgpIHsKICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkgewogICAgICAgIHZhciB0aW1lID0gbm93KCksCiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7CgogICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzOwogICAgICAgIGxhc3RUaGlzID0gdGhpczsKICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lOwoKICAgICAgICBpZiAoaXNJbnZva2luZykgewogICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChtYXhpbmcpIHsKICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC4KICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTsKICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsOwogICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDsKICAgICAgcmV0dXJuIGRlYm91bmNlZDsKICAgIH0KCiAgICAvKioKICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXIKICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgCiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvCiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2AKICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAKICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUKICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGUKICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzCiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvbgogICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LgogICAgICoKICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZAogICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLgogICAgICoKICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKQogICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDAuMS4wCiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb24KICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLgogICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuCiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0KICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuCiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdCiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC4KICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy4KICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTsKICAgICAqCiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy4KICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTsKICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpOwogICAgICoKICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uCiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTsKICAgICAqLwogICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykgewogICAgICB2YXIgbGVhZGluZyA9IHRydWUsCiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7CgogICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTsKICAgICAgfQogICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHsKICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7CiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZzsKICAgICAgfQogICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgewogICAgICAgICdsZWFkaW5nJzogbGVhZGluZywKICAgICAgICAnbWF4V2FpdCc6IHdhaXQsCiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmcKICAgICAgfSk7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUKICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcykKICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYCkKICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAbWVtYmVyT2YgXwogICAgICogQHNpbmNlIDAuMS4wCiAgICAgKiBAY2F0ZWdvcnkgTGFuZwogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogXy5pc09iamVjdCh7fSk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc09iamVjdChbMSwgMiwgM10pOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTsKICAgICAqIC8vID0+IHRydWUKICAgICAqCiAgICAgKiBfLmlzT2JqZWN0KG51bGwpOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqLwogICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7CiAgICB9CgogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGAKICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgIm9iamVjdCIuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSA0LjAuMAogICAgICogQGNhdGVnb3J5IExhbmcKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogXy5pc09iamVjdExpa2Uoe30pOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7CiAgICAgKiAvLyA9PiB0cnVlCiAgICAgKgogICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTsKICAgICAqIC8vID0+IGZhbHNlCiAgICAgKgogICAgICogXy5pc09iamVjdExpa2UobnVsbCk7CiAgICAgKiAvLyA9PiBmYWxzZQogICAgICovCiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHsKICAgICAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnOwogICAgfQoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQG1lbWJlck9mIF8KICAgICAqIEBzaW5jZSA0LjAuMAogICAgICogQGNhdGVnb3J5IExhbmcKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC4KICAgICAqIEBleGFtcGxlCiAgICAgKgogICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpOwogICAgICogLy8gPT4gdHJ1ZQogICAgICoKICAgICAqIF8uaXNTeW1ib2woJ2FiYycpOwogICAgICogLy8gPT4gZmFsc2UKICAgICAqLwogICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHsKICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fAogICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7CiAgICB9CgogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLgogICAgICoKICAgICAqIEBzdGF0aWMKICAgICAqIEBtZW1iZXJPZiBfCiAgICAgKiBAc2luY2UgNC4wLjAKICAgICAqIEBjYXRlZ29yeSBMYW5nCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLgogICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLgogICAgICogQGV4YW1wbGUKICAgICAqCiAgICAgKiBfLnRvTnVtYmVyKDMuMik7CiAgICAgKiAvLyA9PiAzLjIKICAgICAqCiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpOwogICAgICogLy8gPT4gNWUtMzI0CiAgICAgKgogICAgICogXy50b051bWJlcihJbmZpbml0eSk7CiAgICAgKiAvLyA9PiBJbmZpbml0eQogICAgICoKICAgICAqIF8udG9OdW1iZXIoJzMuMicpOwogICAgICogLy8gPT4gMy4yCiAgICAgKi8KICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7CiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHsKICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgIH0KICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkgewogICAgICAgIHJldHVybiBOQU47CiAgICAgIH0KICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkgewogICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTsKICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHsKICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTsKICAgICAgfQogICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7CiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7CiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKQogICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KQogICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpOwogICAgfQoKICAgIHZhciBsb2Rhc2hfdGhyb3R0bGUgPSB0aHJvdHRsZTsKCiAgICBjb25zdCB0aHJvdHRsZVRpbWUgPSAyNTA7CgogICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKAogICAgICAnbWVzc2FnZScsCiAgICAgIGUgPT4gewogICAgICAgIGNvbnN0IGxheWVycyA9IGUuZGF0YTsKICAgICAgICBsZXQgbGltaXRlZEV4cGFuZGVkTGF5ZXJJZHMgPSBbXTsKCiAgICAgICAgbGV0IHByb2dyZXNzID0gMDsKICAgICAgICBjb25zdCB0aHJvdHRsZWRQcm9ncmVzc1VwZGF0ZSA9IGxvZGFzaF90aHJvdHRsZSgoKSA9PiB7CiAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgcHJvZ3Jlc3MgfSk7CiAgICAgICAgfSwgdGhyb3R0bGVUaW1lKTsKCiAgICAgICAgY29uc3QgZXhwYW5kTGF5ZXJzID0gbGF5ZXJzID0+IHsKICAgICAgICAgIGxldCBuZXh0TGF5ZXJzID0gbGF5ZXJzOwogICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHByb2dyZXNzIH0pOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgbmV4dExheWVycyA9IGxheWVycy5yZWR1Y2UoKGFjYywgbCwgaSkgPT4gewogICAgICAgICAgICAgIGNvbnN0IHsgZXhwYW5kZWRMYXllcnMsIGNvbWJvTGltaXRIaXQgfSA9IGV4cGFuZExheWVyKGwpOwogICAgICAgICAgICAgIGlmIChjb21ib0xpbWl0SGl0KSBsaW1pdGVkRXhwYW5kZWRMYXllcklkcy5wdXNoKGwuaWQpOwogICAgICAgICAgICAgIGFjYyA9IGFjYy5jb25jYXQoZXhwYW5kZWRMYXllcnMpOwogICAgICAgICAgICAgIHByb2dyZXNzID0gaSAvIGxheWVycy5sZW5ndGg7CiAgICAgICAgICAgICAgdGhyb3R0bGVkUHJvZ3Jlc3NVcGRhdGUoKTsKICAgICAgICAgICAgICByZXR1cm4gYWNjOwogICAgICAgICAgICB9LCBbXSk7CiAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpOwogICAgICAgICAgfQogICAgICAgICAgc2V0VGltZW91dCgKICAgICAgICAgICAgKCkgPT4KICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgICAgICAgICAgIHByb2dyZXNzLAogICAgICAgICAgICAgICAgZXhwYW5kZWRMYXllcnM6IG5leHRMYXllcnMsCiAgICAgICAgICAgICAgICBsaW1pdGVkRXhwYW5kZWRMYXllcklkcywKICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgdGhyb3R0bGVUaW1lCiAgICAgICAgICApOwogICAgICAgIH07CgogICAgICAgIGV4cGFuZExheWVycyhsYXllcnMpOwogICAgICB9LAogICAgICBmYWxzZQogICAgKTsKCn0pKCk7Cgo=', null, false);
    /* eslint-enable */

    var css = "main.svelte-1majwbb{width:100%;height:100%}button.svelte-1majwbb{margin:0px;font-size:0.9em;border-radius:4px;cursor:pointer;font-weight:bold}.drop.svelte-1majwbb{font-size:5em;display:flex;flex-direction:column;align-items:center;height:100%;justify-content:center}.download-button.svelte-1majwbb{display:flex;align-self:center}.clear-style-button.svelte-1majwbb{position:fixed;bottom:12px;right:12px;display:flex;align-items:center}.icon.svelte-1majwbb{margin-left:6px}.top-bar.svelte-1majwbb{position:fixed;background-color:white;padding:var(--app-padding);width:calc(100% - (var(--app-padding) * 2));height:36px;top:0;display:flex;align-items:center;justify-content:space-between}.loading-screen.svelte-1majwbb{position:fixed;height:100%;width:100%;top:0;bottom:0;right:0;left:0}";
    n(css,{});

    /* src/App.svelte generated by Svelte v3.48.0 */
    const file = "src/App.svelte";

    // (175:23) 
    function create_if_block_3(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Drop a style here";
    			add_location(div0, file, 176, 6, 4846);
    			attr_dev(div1, "class", "drop svelte-1majwbb");
    			add_location(div1, file, 175, 4, 4821);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(175:23) ",
    		ctx
    	});

    	return block;
    }

    // (157:2) {#if expandedLayers.length}
    function create_if_block_1(ctx) {
    	let div0;
    	let tabs;
    	let t0;
    	let t1;
    	let tabscontent;
    	let t2;
    	let button;
    	let t3;
    	let div1;
    	let fa;
    	let current;
    	let mounted;
    	let dispose;

    	tabs = new Tabs({
    			props: { selectedTab: /*selectedTab*/ ctx[1] },
    			$$inline: true
    		});

    	tabs.$on("tabchange", /*handleTabChange*/ ctx[6]);
    	let if_block = /*selectedTab*/ ctx[1] !== 'typography' && create_if_block_2(ctx);

    	tabscontent = new TabsContent({
    			props: {
    				selectedTab: /*selectedTab*/ ctx[1],
    				style: /*style*/ ctx[0],
    				updateBackgroundRect: /*updateBackgroundRect*/ ctx[9],
    				backgroundSvgData: /*backgroundSvgData*/ ctx[2]
    			},
    			$$inline: true
    		});

    	fa = new Fa$1({ props: { icon: faTrash }, $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(tabs.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(tabscontent.$$.fragment);
    			t2 = space();
    			button = element("button");
    			t3 = text$1("Clear style ");
    			div1 = element("div");
    			create_component(fa.$$.fragment);
    			attr_dev(div0, "class", "top-bar svelte-1majwbb");
    			add_location(div0, file, 157, 4, 4240);
    			attr_dev(div1, "class", "icon svelte-1majwbb");
    			add_location(div1, file, 172, 19, 4733);
    			attr_dev(button, "class", "clear-style-button svelte-1majwbb");
    			add_location(button, file, 171, 4, 4657);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(tabs, div0, null);
    			append_dev(div0, t0);
    			if (if_block) if_block.m(div0, null);
    			insert_dev(target, t1, anchor);
    			mount_component(tabscontent, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, button, anchor);
    			append_dev(button, t3);
    			append_dev(button, div1);
    			mount_component(fa, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*clearStyle*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const tabs_changes = {};
    			if (dirty & /*selectedTab*/ 2) tabs_changes.selectedTab = /*selectedTab*/ ctx[1];
    			tabs.$set(tabs_changes);

    			if (/*selectedTab*/ ctx[1] !== 'typography') {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*selectedTab*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const tabscontent_changes = {};
    			if (dirty & /*selectedTab*/ 2) tabscontent_changes.selectedTab = /*selectedTab*/ ctx[1];
    			if (dirty & /*style*/ 1) tabscontent_changes.style = /*style*/ ctx[0];
    			if (dirty & /*backgroundSvgData*/ 4) tabscontent_changes.backgroundSvgData = /*backgroundSvgData*/ ctx[2];
    			tabscontent.$set(tabscontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(tabscontent.$$.fragment, local);
    			transition_in(fa.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(tabscontent.$$.fragment, local);
    			transition_out(fa.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(tabs);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t1);
    			destroy_component(tabscontent, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(button);
    			destroy_component(fa);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(157:2) {#if expandedLayers.length}",
    		ctx
    	});

    	return block;
    }

    // (160:6) {#if selectedTab !== 'typography'}
    function create_if_block_2(ctx) {
    	let button;
    	let t;
    	let div;
    	let fa;
    	let current;
    	let mounted;
    	let dispose;

    	fa = new Fa$1({
    			props: { icon: faDownload },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text$1("Download SVG ");
    			div = element("div");
    			create_component(fa.$$.fragment);
    			attr_dev(div, "class", "icon svelte-1majwbb");
    			add_location(div, file, 161, 24, 4450);
    			attr_dev(button, "class", "download-button svelte-1majwbb");
    			add_location(button, file, 160, 8, 4371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    			append_dev(button, div);
    			mount_component(fa, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*downloadSvg*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fa.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fa.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(fa);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(160:6) {#if selectedTab !== 'typography'}",
    		ctx
    	});

    	return block;
    }

    // (180:2) {#if isLoading}
    function create_if_block(ctx) {
    	let div;
    	let progressbar;
    	let current;

    	progressbar = new ProgressBar({
    			props: { progress: /*loadingProgress*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(progressbar.$$.fragment);
    			attr_dev(div, "class", "loading-screen svelte-1majwbb");
    			add_location(div, file, 180, 4, 4916);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(progressbar, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const progressbar_changes = {};
    			if (dirty & /*loadingProgress*/ 32) progressbar_changes.progress = /*loadingProgress*/ ctx[5];
    			progressbar.$set(progressbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(progressbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(progressbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(progressbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(180:2) {#if isLoading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1, create_if_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*expandedLayers*/ ctx[3].length) return 0;
    		if (!/*isLoading*/ ctx[4]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let if_block1 = /*isLoading*/ ctx[4] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(main, "class", "svelte-1majwbb");
    			add_location(main, file, 151, 0, 4112);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(main, null);
    			}

    			append_dev(main, t);
    			if (if_block1) if_block1.m(main, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(main, "dragover", handleDragOver, false, false, false),
    					listen_dev(main, "dragover", handleDragEnter, false, false, false),
    					listen_dev(main, "drop", /*handleDrop*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(main, t);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if (/*isLoading*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isLoading*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(main, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function handleDragOver(e) {
    	e.preventDefault();
    }

    function handleDragEnter(e) {
    	e.preventDefault();
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let { selectedTab } = $$props;
    	let { style } = $$props;
    	let { backgroundSvgData = {} } = $$props;
    	let { loadDefaultStyle = false } = $$props;
    	let isLoading;
    	let loadingProgress;

    	loadingStore.subscribe(value => {
    		$$invalidate(4, isLoading = value.loading);
    		$$invalidate(5, loadingProgress = value.progress);
    	});

    	let expandedLayers = [];

    	displayLayersStore.subscribe(value => {
    		$$invalidate(3, expandedLayers = value.layers);
    	});

    	onMount(() => {
    		const query = readQuery();

    		if (query.selectedTab) {
    			$$invalidate(1, selectedTab = query.selectedTab);
    		} else {
    			$$invalidate(1, selectedTab = 'fill');
    		}

    		if (loadDefaultStyle) {
    			loadStyleUrl('./style.json');
    		}
    	});

    	const setExpandedLayers = style => {
    		const { layers } = style;
    		const worker = new WorkerFactory();
    		worker.postMessage(layers);

    		worker.addEventListener('message', event => {
    			const { progress, expandedLayers, limitedExpandedLayerIds } = event.data;
    			loadingStore.update(v => ({ ...v, progress }));

    			if (expandedLayers) {
    				displayLayersStore.set({
    					style,
    					layers: expandedLayers,
    					limitHit: limitedExpandedLayerIds
    				});
    			}
    		});
    	};

    	function getState() {
    		let state = {};
    		if (selectedTab) state.selectedTab = selectedTab;
    		return state;
    	}

    	function updateQuery() {
    		writeQuery(getState());
    	}

    	async function loadStyleUrl(url) {
    		$$invalidate(0, style = await json(url));
    	}

    	function handleStyleLoad(e) {
    		$$invalidate(0, style = e.detail.style);
    	}

    	function handleTabChange(e) {
    		$$invalidate(1, selectedTab = e.detail.tab);
    		updateQuery();
    	}

    	async function handleDrop(e) {
    		e.stopPropagation();
    		e.preventDefault();
    		const { files } = e.dataTransfer;
    		const text = await files[0].text();
    		$$invalidate(0, style = migrate(JSON.parse(text)));
    		$$invalidate(0, style = convertStylesheetToRgb(style));

    		// On dropping in a style, switch to the fill tab to refresh background layer state
    		handleTabChange({ detail: { tab: 'fill' } });
    	}

    	function clearStyle() {
    		$$invalidate(0, style = undefined);
    	}

    	function updateBackgroundRect(backgroundRect, backgroundGradient) {
    		$$invalidate(2, backgroundSvgData = {
    			gradientDefs: backgroundGradient,
    			rect: backgroundRect
    		});
    	}

    	function downloadSvg() {
    		let svg = document.getElementById(selectedTab);

    		dist(svg, {
    			recursive: true,
    			// Limiting to these properties for now since the function runs much faster
    			properties: ['font-size', 'font-family', 'text-anchor']
    		});

    		svg = new XMLSerializer().serializeToString(svg);
    		const blob = new Blob([svg]);
    		const element = document.createElement('a');
    		element.download = `${style.id}-${selectedTab}-chart.svg`;
    		element.href = window.URL.createObjectURL(blob);
    		element.click();
    		element.remove();
    	}

    	const writable_props = ['selectedTab', 'style', 'backgroundSvgData', 'loadDefaultStyle'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('selectedTab' in $$props) $$invalidate(1, selectedTab = $$props.selectedTab);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('backgroundSvgData' in $$props) $$invalidate(2, backgroundSvgData = $$props.backgroundSvgData);
    		if ('loadDefaultStyle' in $$props) $$invalidate(11, loadDefaultStyle = $$props.loadDefaultStyle);
    	};

    	$$self.$capture_state = () => ({
    		d3,
    		migrate,
    		onMount,
    		Fa: Fa$1,
    		faTrash,
    		faDownload,
    		readQuery,
    		writeQuery,
    		Tabs,
    		TabsContent,
    		ProgressBar,
    		computedStyleToInlineStyle: dist,
    		convertStylesheetToRgb,
    		loadingStore,
    		displayLayersStore,
    		ExpandLayersWorker: WorkerFactory,
    		selectedTab,
    		style,
    		backgroundSvgData,
    		loadDefaultStyle,
    		isLoading,
    		loadingProgress,
    		expandedLayers,
    		setExpandedLayers,
    		getState,
    		updateQuery,
    		loadStyleUrl,
    		handleStyleLoad,
    		handleTabChange,
    		handleDragOver,
    		handleDragEnter,
    		handleDrop,
    		clearStyle,
    		updateBackgroundRect,
    		downloadSvg
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedTab' in $$props) $$invalidate(1, selectedTab = $$props.selectedTab);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('backgroundSvgData' in $$props) $$invalidate(2, backgroundSvgData = $$props.backgroundSvgData);
    		if ('loadDefaultStyle' in $$props) $$invalidate(11, loadDefaultStyle = $$props.loadDefaultStyle);
    		if ('isLoading' in $$props) $$invalidate(4, isLoading = $$props.isLoading);
    		if ('loadingProgress' in $$props) $$invalidate(5, loadingProgress = $$props.loadingProgress);
    		if ('expandedLayers' in $$props) $$invalidate(3, expandedLayers = $$props.expandedLayers);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*style*/ 1) {
    			if (style) {
    				displayLayersStore.set({ style: null, layers: [], limitHit: [] });
    				loadingStore.set({ loading: true, progress: 0 });
    				setExpandedLayers(style);
    			}
    		}

    		if ($$self.$$.dirty & /*expandedLayers*/ 8) {
    			if (expandedLayers.length) {
    				// Let progress hit 100%, then brief timeout before moving on
    				// This lets fast style loads feel smoother with loading
    				loadingStore.update(v => ({ ...v, progress: 1 }));

    				setTimeout(() => loadingStore.set({ loading: false, progress: null }), 250);
    			}
    		}
    	};

    	return [
    		style,
    		selectedTab,
    		backgroundSvgData,
    		expandedLayers,
    		isLoading,
    		loadingProgress,
    		handleTabChange,
    		handleDrop,
    		clearStyle,
    		updateBackgroundRect,
    		downloadSvg,
    		loadDefaultStyle
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance, create_fragment, safe_not_equal, {
    			selectedTab: 1,
    			style: 0,
    			backgroundSvgData: 2,
    			loadDefaultStyle: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*selectedTab*/ ctx[1] === undefined && !('selectedTab' in props)) {
    			console.warn("<App> was created without expected prop 'selectedTab'");
    		}

    		if (/*style*/ ctx[0] === undefined && !('style' in props)) {
    			console.warn("<App> was created without expected prop 'style'");
    		}
    	}

    	get selectedTab() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedTab(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundSvgData() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundSvgData(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadDefaultStyle() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadDefaultStyle(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const app = new App({
      target: document.body,
      props: {
        loadDefaultStyle: "development" === 'development',
      },
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
